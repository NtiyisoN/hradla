{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/babel-polyfill/lib/index.js","node_modules/babel-polyfill/node_modules/regenerator-runtime/runtime.js","node_modules/core-js/fn/regexp/escape.js","node_modules/core-js/modules/_a-function.js","node_modules/core-js/modules/_a-number-value.js","node_modules/core-js/modules/_add-to-unscopables.js","node_modules/core-js/modules/_an-instance.js","node_modules/core-js/modules/_an-object.js","node_modules/core-js/modules/_array-copy-within.js","node_modules/core-js/modules/_array-fill.js","node_modules/core-js/modules/_array-from-iterable.js","node_modules/core-js/modules/_array-includes.js","node_modules/core-js/modules/_array-methods.js","node_modules/core-js/modules/_array-reduce.js","node_modules/core-js/modules/_array-species-constructor.js","node_modules/core-js/modules/_array-species-create.js","node_modules/core-js/modules/_bind.js","node_modules/core-js/modules/_classof.js","node_modules/core-js/modules/_cof.js","node_modules/core-js/modules/_collection-strong.js","node_modules/core-js/modules/_collection-to-json.js","node_modules/core-js/modules/_collection-weak.js","node_modules/core-js/modules/_collection.js","node_modules/core-js/modules/_core.js","node_modules/core-js/modules/_create-property.js","node_modules/core-js/modules/_ctx.js","node_modules/core-js/modules/_date-to-iso-string.js","node_modules/core-js/modules/_date-to-primitive.js","node_modules/core-js/modules/_defined.js","node_modules/core-js/modules/_descriptors.js","node_modules/core-js/modules/_dom-create.js","node_modules/core-js/modules/_enum-bug-keys.js","node_modules/core-js/modules/_enum-keys.js","node_modules/core-js/modules/_export.js","node_modules/core-js/modules/_fails-is-regexp.js","node_modules/core-js/modules/_fails.js","node_modules/core-js/modules/_fix-re-wks.js","node_modules/core-js/modules/_flags.js","node_modules/core-js/modules/_flatten-into-array.js","node_modules/core-js/modules/_for-of.js","node_modules/core-js/modules/_global.js","node_modules/core-js/modules/_has.js","node_modules/core-js/modules/_hide.js","node_modules/core-js/modules/_html.js","node_modules/core-js/modules/_ie8-dom-define.js","node_modules/core-js/modules/_inherit-if-required.js","node_modules/core-js/modules/_invoke.js","node_modules/core-js/modules/_iobject.js","node_modules/core-js/modules/_is-array-iter.js","node_modules/core-js/modules/_is-array.js","node_modules/core-js/modules/_is-integer.js","node_modules/core-js/modules/_is-object.js","node_modules/core-js/modules/_is-regexp.js","node_modules/core-js/modules/_iter-call.js","node_modules/core-js/modules/_iter-create.js","node_modules/core-js/modules/_iter-define.js","node_modules/core-js/modules/_iter-detect.js","node_modules/core-js/modules/_iter-step.js","node_modules/core-js/modules/_iterators.js","node_modules/core-js/modules/_library.js","node_modules/core-js/modules/_math-expm1.js","node_modules/core-js/modules/_math-fround.js","node_modules/core-js/modules/_math-log1p.js","node_modules/core-js/modules/_math-scale.js","node_modules/core-js/modules/_math-sign.js","node_modules/core-js/modules/_meta.js","node_modules/core-js/modules/_metadata.js","node_modules/core-js/modules/_microtask.js","node_modules/core-js/modules/_new-promise-capability.js","node_modules/core-js/modules/_object-assign.js","node_modules/core-js/modules/_object-create.js","node_modules/core-js/modules/_object-dp.js","node_modules/core-js/modules/_object-dps.js","node_modules/core-js/modules/_object-forced-pam.js","node_modules/core-js/modules/_object-gopd.js","node_modules/core-js/modules/_object-gopn-ext.js","node_modules/core-js/modules/_object-gopn.js","node_modules/core-js/modules/_object-gops.js","node_modules/core-js/modules/_object-gpo.js","node_modules/core-js/modules/_object-keys-internal.js","node_modules/core-js/modules/_object-keys.js","node_modules/core-js/modules/_object-pie.js","node_modules/core-js/modules/_object-sap.js","node_modules/core-js/modules/_object-to-array.js","node_modules/core-js/modules/_own-keys.js","node_modules/core-js/modules/_parse-float.js","node_modules/core-js/modules/_parse-int.js","node_modules/core-js/modules/_perform.js","node_modules/core-js/modules/_promise-resolve.js","node_modules/core-js/modules/_property-desc.js","node_modules/core-js/modules/_redefine-all.js","node_modules/core-js/modules/_redefine.js","node_modules/core-js/modules/_replacer.js","node_modules/core-js/modules/_same-value.js","node_modules/core-js/modules/_set-collection-from.js","node_modules/core-js/modules/_set-collection-of.js","node_modules/core-js/modules/_set-proto.js","node_modules/core-js/modules/_set-species.js","node_modules/core-js/modules/_set-to-string-tag.js","node_modules/core-js/modules/_shared-key.js","node_modules/core-js/modules/_shared.js","node_modules/core-js/modules/_species-constructor.js","node_modules/core-js/modules/_strict-method.js","node_modules/core-js/modules/_string-at.js","node_modules/core-js/modules/_string-context.js","node_modules/core-js/modules/_string-html.js","node_modules/core-js/modules/_string-pad.js","node_modules/core-js/modules/_string-repeat.js","node_modules/core-js/modules/_string-trim.js","node_modules/core-js/modules/_string-ws.js","node_modules/core-js/modules/_task.js","node_modules/core-js/modules/_to-absolute-index.js","node_modules/core-js/modules/_to-index.js","node_modules/core-js/modules/_to-integer.js","node_modules/core-js/modules/_to-iobject.js","node_modules/core-js/modules/_to-length.js","node_modules/core-js/modules/_to-object.js","node_modules/core-js/modules/_to-primitive.js","node_modules/core-js/modules/_typed-array.js","node_modules/core-js/modules/_typed-buffer.js","node_modules/core-js/modules/_typed.js","node_modules/core-js/modules/_uid.js","node_modules/core-js/modules/_user-agent.js","node_modules/core-js/modules/_validate-collection.js","node_modules/core-js/modules/_wks-define.js","node_modules/core-js/modules/_wks-ext.js","node_modules/core-js/modules/_wks.js","node_modules/core-js/modules/core.get-iterator-method.js","node_modules/core-js/modules/core.regexp.escape.js","node_modules/core-js/modules/es6.array.copy-within.js","node_modules/core-js/modules/es6.array.every.js","node_modules/core-js/modules/es6.array.fill.js","node_modules/core-js/modules/es6.array.filter.js","node_modules/core-js/modules/es6.array.find-index.js","node_modules/core-js/modules/es6.array.find.js","node_modules/core-js/modules/es6.array.for-each.js","node_modules/core-js/modules/es6.array.from.js","node_modules/core-js/modules/es6.array.index-of.js","node_modules/core-js/modules/es6.array.is-array.js","node_modules/core-js/modules/es6.array.iterator.js","node_modules/core-js/modules/es6.array.join.js","node_modules/core-js/modules/es6.array.last-index-of.js","node_modules/core-js/modules/es6.array.map.js","node_modules/core-js/modules/es6.array.of.js","node_modules/core-js/modules/es6.array.reduce-right.js","node_modules/core-js/modules/es6.array.reduce.js","node_modules/core-js/modules/es6.array.slice.js","node_modules/core-js/modules/es6.array.some.js","node_modules/core-js/modules/es6.array.sort.js","node_modules/core-js/modules/es6.array.species.js","node_modules/core-js/modules/es6.date.now.js","node_modules/core-js/modules/es6.date.to-iso-string.js","node_modules/core-js/modules/es6.date.to-json.js","node_modules/core-js/modules/es6.date.to-primitive.js","node_modules/core-js/modules/es6.date.to-string.js","node_modules/core-js/modules/es6.function.bind.js","node_modules/core-js/modules/es6.function.has-instance.js","node_modules/core-js/modules/es6.function.name.js","node_modules/core-js/modules/es6.map.js","node_modules/core-js/modules/es6.math.acosh.js","node_modules/core-js/modules/es6.math.asinh.js","node_modules/core-js/modules/es6.math.atanh.js","node_modules/core-js/modules/es6.math.cbrt.js","node_modules/core-js/modules/es6.math.clz32.js","node_modules/core-js/modules/es6.math.cosh.js","node_modules/core-js/modules/es6.math.expm1.js","node_modules/core-js/modules/es6.math.fround.js","node_modules/core-js/modules/es6.math.hypot.js","node_modules/core-js/modules/es6.math.imul.js","node_modules/core-js/modules/es6.math.log10.js","node_modules/core-js/modules/es6.math.log1p.js","node_modules/core-js/modules/es6.math.log2.js","node_modules/core-js/modules/es6.math.sign.js","node_modules/core-js/modules/es6.math.sinh.js","node_modules/core-js/modules/es6.math.tanh.js","node_modules/core-js/modules/es6.math.trunc.js","node_modules/core-js/modules/es6.number.constructor.js","node_modules/core-js/modules/es6.number.epsilon.js","node_modules/core-js/modules/es6.number.is-finite.js","node_modules/core-js/modules/es6.number.is-integer.js","node_modules/core-js/modules/es6.number.is-nan.js","node_modules/core-js/modules/es6.number.is-safe-integer.js","node_modules/core-js/modules/es6.number.max-safe-integer.js","node_modules/core-js/modules/es6.number.min-safe-integer.js","node_modules/core-js/modules/es6.number.parse-float.js","node_modules/core-js/modules/es6.number.parse-int.js","node_modules/core-js/modules/es6.number.to-fixed.js","node_modules/core-js/modules/es6.number.to-precision.js","node_modules/core-js/modules/es6.object.assign.js","node_modules/core-js/modules/es6.object.create.js","node_modules/core-js/modules/es6.object.define-properties.js","node_modules/core-js/modules/es6.object.define-property.js","node_modules/core-js/modules/es6.object.freeze.js","node_modules/core-js/modules/es6.object.get-own-property-descriptor.js","node_modules/core-js/modules/es6.object.get-own-property-names.js","node_modules/core-js/modules/es6.object.get-prototype-of.js","node_modules/core-js/modules/es6.object.is-extensible.js","node_modules/core-js/modules/es6.object.is-frozen.js","node_modules/core-js/modules/es6.object.is-sealed.js","node_modules/core-js/modules/es6.object.is.js","node_modules/core-js/modules/es6.object.keys.js","node_modules/core-js/modules/es6.object.prevent-extensions.js","node_modules/core-js/modules/es6.object.seal.js","node_modules/core-js/modules/es6.object.set-prototype-of.js","node_modules/core-js/modules/es6.object.to-string.js","node_modules/core-js/modules/es6.parse-float.js","node_modules/core-js/modules/es6.parse-int.js","node_modules/core-js/modules/es6.promise.js","node_modules/core-js/modules/es6.reflect.apply.js","node_modules/core-js/modules/es6.reflect.construct.js","node_modules/core-js/modules/es6.reflect.define-property.js","node_modules/core-js/modules/es6.reflect.delete-property.js","node_modules/core-js/modules/es6.reflect.enumerate.js","node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js","node_modules/core-js/modules/es6.reflect.get-prototype-of.js","node_modules/core-js/modules/es6.reflect.get.js","node_modules/core-js/modules/es6.reflect.has.js","node_modules/core-js/modules/es6.reflect.is-extensible.js","node_modules/core-js/modules/es6.reflect.own-keys.js","node_modules/core-js/modules/es6.reflect.prevent-extensions.js","node_modules/core-js/modules/es6.reflect.set-prototype-of.js","node_modules/core-js/modules/es6.reflect.set.js","node_modules/core-js/modules/es6.regexp.constructor.js","node_modules/core-js/modules/es6.regexp.flags.js","node_modules/core-js/modules/es6.regexp.match.js","node_modules/core-js/modules/es6.regexp.replace.js","node_modules/core-js/modules/es6.regexp.search.js","node_modules/core-js/modules/es6.regexp.split.js","node_modules/core-js/modules/es6.regexp.to-string.js","node_modules/core-js/modules/es6.set.js","node_modules/core-js/modules/es6.string.anchor.js","node_modules/core-js/modules/es6.string.big.js","node_modules/core-js/modules/es6.string.blink.js","node_modules/core-js/modules/es6.string.bold.js","node_modules/core-js/modules/es6.string.code-point-at.js","node_modules/core-js/modules/es6.string.ends-with.js","node_modules/core-js/modules/es6.string.fixed.js","node_modules/core-js/modules/es6.string.fontcolor.js","node_modules/core-js/modules/es6.string.fontsize.js","node_modules/core-js/modules/es6.string.from-code-point.js","node_modules/core-js/modules/es6.string.includes.js","node_modules/core-js/modules/es6.string.italics.js","node_modules/core-js/modules/es6.string.iterator.js","node_modules/core-js/modules/es6.string.link.js","node_modules/core-js/modules/es6.string.raw.js","node_modules/core-js/modules/es6.string.repeat.js","node_modules/core-js/modules/es6.string.small.js","node_modules/core-js/modules/es6.string.starts-with.js","node_modules/core-js/modules/es6.string.strike.js","node_modules/core-js/modules/es6.string.sub.js","node_modules/core-js/modules/es6.string.sup.js","node_modules/core-js/modules/es6.string.trim.js","node_modules/core-js/modules/es6.symbol.js","node_modules/core-js/modules/es6.typed.array-buffer.js","node_modules/core-js/modules/es6.typed.data-view.js","node_modules/core-js/modules/es6.typed.float32-array.js","node_modules/core-js/modules/es6.typed.float64-array.js","node_modules/core-js/modules/es6.typed.int16-array.js","node_modules/core-js/modules/es6.typed.int32-array.js","node_modules/core-js/modules/es6.typed.int8-array.js","node_modules/core-js/modules/es6.typed.uint16-array.js","node_modules/core-js/modules/es6.typed.uint32-array.js","node_modules/core-js/modules/es6.typed.uint8-array.js","node_modules/core-js/modules/es6.typed.uint8-clamped-array.js","node_modules/core-js/modules/es6.weak-map.js","node_modules/core-js/modules/es6.weak-set.js","node_modules/core-js/modules/es7.array.flat-map.js","node_modules/core-js/modules/es7.array.flatten.js","node_modules/core-js/modules/es7.array.includes.js","node_modules/core-js/modules/es7.asap.js","node_modules/core-js/modules/es7.error.is-error.js","node_modules/core-js/modules/es7.global.js","node_modules/core-js/modules/es7.map.from.js","node_modules/core-js/modules/es7.map.of.js","node_modules/core-js/modules/es7.map.to-json.js","node_modules/core-js/modules/es7.math.clamp.js","node_modules/core-js/modules/es7.math.deg-per-rad.js","node_modules/core-js/modules/es7.math.degrees.js","node_modules/core-js/modules/es7.math.fscale.js","node_modules/core-js/modules/es7.math.iaddh.js","node_modules/core-js/modules/es7.math.imulh.js","node_modules/core-js/modules/es7.math.isubh.js","node_modules/core-js/modules/es7.math.rad-per-deg.js","node_modules/core-js/modules/es7.math.radians.js","node_modules/core-js/modules/es7.math.scale.js","node_modules/core-js/modules/es7.math.signbit.js","node_modules/core-js/modules/es7.math.umulh.js","node_modules/core-js/modules/es7.object.define-getter.js","node_modules/core-js/modules/es7.object.define-setter.js","node_modules/core-js/modules/es7.object.entries.js","node_modules/core-js/modules/es7.object.get-own-property-descriptors.js","node_modules/core-js/modules/es7.object.lookup-getter.js","node_modules/core-js/modules/es7.object.lookup-setter.js","node_modules/core-js/modules/es7.object.values.js","node_modules/core-js/modules/es7.observable.js","node_modules/core-js/modules/es7.promise.finally.js","node_modules/core-js/modules/es7.promise.try.js","node_modules/core-js/modules/es7.reflect.define-metadata.js","node_modules/core-js/modules/es7.reflect.delete-metadata.js","node_modules/core-js/modules/es7.reflect.get-metadata-keys.js","node_modules/core-js/modules/es7.reflect.get-metadata.js","node_modules/core-js/modules/es7.reflect.get-own-metadata-keys.js","node_modules/core-js/modules/es7.reflect.get-own-metadata.js","node_modules/core-js/modules/es7.reflect.has-metadata.js","node_modules/core-js/modules/es7.reflect.has-own-metadata.js","node_modules/core-js/modules/es7.reflect.metadata.js","node_modules/core-js/modules/es7.set.from.js","node_modules/core-js/modules/es7.set.of.js","node_modules/core-js/modules/es7.set.to-json.js","node_modules/core-js/modules/es7.string.at.js","node_modules/core-js/modules/es7.string.match-all.js","node_modules/core-js/modules/es7.string.pad-end.js","node_modules/core-js/modules/es7.string.pad-start.js","node_modules/core-js/modules/es7.string.trim-left.js","node_modules/core-js/modules/es7.string.trim-right.js","node_modules/core-js/modules/es7.symbol.async-iterator.js","node_modules/core-js/modules/es7.symbol.observable.js","node_modules/core-js/modules/es7.system.global.js","node_modules/core-js/modules/es7.weak-map.from.js","node_modules/core-js/modules/es7.weak-map.of.js","node_modules/core-js/modules/es7.weak-set.from.js","node_modules/core-js/modules/es7.weak-set.of.js","node_modules/core-js/modules/web.dom.iterable.js","node_modules/core-js/modules/web.immediate.js","node_modules/core-js/modules/web.timers.js","node_modules/core-js/shim.js","node_modules/json-stringify-pretty-compact/index.js","node_modules/libstl/Datastructures/DoublyLinkedList.js","node_modules/libstl/Datastructures/Heap.js","node_modules/libstl/Datastructures/MaxHeap.js","node_modules/libstl/Datastructures/MinHeap.js","node_modules/libstl/Datastructures/PriorityQueue.js","node_modules/libstl/Datastructures/Queue.js","node_modules/libstl/Datastructures/Stack.js","node_modules/libstl/node-module.js","src/es6/main.js","src/es6/modules/Canvas.js","src/es6/modules/Logic.js","src/es6/modules/Simulation.js","src/es6/modules/editorElements.js","src/es6/modules/editorElements/Blackbox.js","src/es6/modules/editorElements/Box.js","src/es6/modules/editorElements/Connector.js","src/es6/modules/editorElements/Gate.js","src/es6/modules/editorElements/HelperWire.js","src/es6/modules/editorElements/InputBox.js","src/es6/modules/editorElements/InputConnector.js","src/es6/modules/editorElements/NetworkElement.js","src/es6/modules/editorElements/OutputBox.js","src/es6/modules/editorElements/OutputConnector.js","src/es6/modules/editorElements/Transform.js","src/es6/modules/editorElements/Wire.js","src/es6/modules/editorElements/WireAnchor.js","src/es6/modules/editorElements/pointTraveller.js","src/es6/modules/editorElements/stateClasses.js","src/es6/modules/findPath.js","src/es6/modules/other/helperFunctions.js","src/es6/modules/other/id.js","src/es6/modules/other/mapWithDefaultValue.js","src/es6/modules/svgObjects.js","src/es6/modules/svgObjects/Group.js","src/es6/modules/svgObjects/MultiLineText.js","src/es6/modules/svgObjects/Pattern.js","src/es6/modules/svgObjects/PolyLine.js","src/es6/modules/svgObjects/PolyLinePoint.js","src/es6/modules/svgObjects/PolyLinePoints.js","src/es6/modules/svgObjects/Rectangle.js","src/es6/modules/svgObjects/SvgElement.js","src/es6/modules/svgObjects/SvgImage.js","src/es6/modules/svgObjects/Tag.js","src/es6/modules/svgObjects/Text.js","src/es6/modules/ui/ContextMenu.js","src/es6/modules/ui/FloatingMenu.js","src/es6/modules/ui/Messages.js","src/es6/modules/ui/Tutorial.js","src/es6/modules/ui/ViewBox.js","src/es6/modules/ui/networkLibrary.js"],"names":[],"mappings":"AAAA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AChuBA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;;ACFA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;;ACHA;AACA;;ACDA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACheA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;;ACDA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;;ACFA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;;ACFA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;;ACDA;AACA;;ACDA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;;ACFA;AACA;AACA;;ACFA;AACA;AACA;;ACFA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;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","file":"main.js","sourcesContent":["(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()","\"use strict\";\n\nrequire(\"core-js/shim\");\n\nrequire(\"regenerator-runtime/runtime\");\n\nrequire(\"core-js/fn/regexp/escape\");\n\nif (global._babelPolyfill) {\n  throw new Error(\"only one instance of babel-polyfill is allowed\");\n}\nglobal._babelPolyfill = true;\n\nvar DEFINE_PROPERTY = \"defineProperty\";\nfunction define(O, key, value) {\n  O[key] || Object[DEFINE_PROPERTY](O, key, {\n    writable: true,\n    configurable: true,\n    value: value\n  });\n}\n\ndefine(String.prototype, \"padLeft\", \"\".padStart);\ndefine(String.prototype, \"padRight\", \"\".padEnd);\n\n\"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill\".split(\",\").forEach(function (key) {\n  [][key] && define(Array, key, Function.call.bind([][key]));\n});","/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    if (typeof global.process === \"object\" && global.process.domain) {\n      invoke = global.process.domain.bind(invoke);\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // Among the various tricks for obtaining a reference to the global\n  // object, this seems to be the most reliable technique that does not\n  // use indirect eval (which violates Content Security Policy).\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this\n);\n","require('../../modules/core.regexp.escape');\nmodule.exports = require('../../modules/_core').RegExp.escape;\n","module.exports = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n","var cof = require('./_cof');\nmodule.exports = function (it, msg) {\n  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);\n  return +it;\n};\n","// 22.1.3.31 Array.prototype[@@unscopables]\nvar UNSCOPABLES = require('./_wks')('unscopables');\nvar ArrayProto = Array.prototype;\nif (ArrayProto[UNSCOPABLES] == undefined) require('./_hide')(ArrayProto, UNSCOPABLES, {});\nmodule.exports = function (key) {\n  ArrayProto[UNSCOPABLES][key] = true;\n};\n","module.exports = function (it, Constructor, name, forbiddenField) {\n  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {\n    throw TypeError(name + ': incorrect invocation!');\n  } return it;\n};\n","var isObject = require('./_is-object');\nmodule.exports = function (it) {\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n","// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)\n'use strict';\nvar toObject = require('./_to-object');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nvar toLength = require('./_to-length');\n\nmodule.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {\n  var O = toObject(this);\n  var len = toLength(O.length);\n  var to = toAbsoluteIndex(target, len);\n  var from = toAbsoluteIndex(start, len);\n  var end = arguments.length > 2 ? arguments[2] : undefined;\n  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);\n  var inc = 1;\n  if (from < to && to < from + count) {\n    inc = -1;\n    from += count - 1;\n    to += count - 1;\n  }\n  while (count-- > 0) {\n    if (from in O) O[to] = O[from];\n    else delete O[to];\n    to += inc;\n    from += inc;\n  } return O;\n};\n","// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)\n'use strict';\nvar toObject = require('./_to-object');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nvar toLength = require('./_to-length');\nmodule.exports = function fill(value /* , start = 0, end = @length */) {\n  var O = toObject(this);\n  var length = toLength(O.length);\n  var aLen = arguments.length;\n  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);\n  var end = aLen > 2 ? arguments[2] : undefined;\n  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);\n  while (endPos > index) O[index++] = value;\n  return O;\n};\n","var forOf = require('./_for-of');\n\nmodule.exports = function (iter, ITERATOR) {\n  var result = [];\n  forOf(iter, false, result.push, result, ITERATOR);\n  return result;\n};\n","// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = require('./_to-iobject');\nvar toLength = require('./_to-length');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n","// 0 -> Array#forEach\n// 1 -> Array#map\n// 2 -> Array#filter\n// 3 -> Array#some\n// 4 -> Array#every\n// 5 -> Array#find\n// 6 -> Array#findIndex\nvar ctx = require('./_ctx');\nvar IObject = require('./_iobject');\nvar toObject = require('./_to-object');\nvar toLength = require('./_to-length');\nvar asc = require('./_array-species-create');\nmodule.exports = function (TYPE, $create) {\n  var IS_MAP = TYPE == 1;\n  var IS_FILTER = TYPE == 2;\n  var IS_SOME = TYPE == 3;\n  var IS_EVERY = TYPE == 4;\n  var IS_FIND_INDEX = TYPE == 6;\n  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n  var create = $create || asc;\n  return function ($this, callbackfn, that) {\n    var O = toObject($this);\n    var self = IObject(O);\n    var f = ctx(callbackfn, that, 3);\n    var length = toLength(self.length);\n    var index = 0;\n    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;\n    var val, res;\n    for (;length > index; index++) if (NO_HOLES || index in self) {\n      val = self[index];\n      res = f(val, index, O);\n      if (TYPE) {\n        if (IS_MAP) result[index] = res;   // map\n        else if (res) switch (TYPE) {\n          case 3: return true;             // some\n          case 5: return val;              // find\n          case 6: return index;            // findIndex\n          case 2: result.push(val);        // filter\n        } else if (IS_EVERY) return false; // every\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;\n  };\n};\n","var aFunction = require('./_a-function');\nvar toObject = require('./_to-object');\nvar IObject = require('./_iobject');\nvar toLength = require('./_to-length');\n\nmodule.exports = function (that, callbackfn, aLen, memo, isRight) {\n  aFunction(callbackfn);\n  var O = toObject(that);\n  var self = IObject(O);\n  var length = toLength(O.length);\n  var index = isRight ? length - 1 : 0;\n  var i = isRight ? -1 : 1;\n  if (aLen < 2) for (;;) {\n    if (index in self) {\n      memo = self[index];\n      index += i;\n      break;\n    }\n    index += i;\n    if (isRight ? index < 0 : length <= index) {\n      throw TypeError('Reduce of empty array with no initial value');\n    }\n  }\n  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {\n    memo = callbackfn(memo, self[index], index, O);\n  }\n  return memo;\n};\n","var isObject = require('./_is-object');\nvar isArray = require('./_is-array');\nvar SPECIES = require('./_wks')('species');\n\nmodule.exports = function (original) {\n  var C;\n  if (isArray(original)) {\n    C = original.constructor;\n    // cross-realm fallback\n    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;\n    if (isObject(C)) {\n      C = C[SPECIES];\n      if (C === null) C = undefined;\n    }\n  } return C === undefined ? Array : C;\n};\n","// 9.4.2.3 ArraySpeciesCreate(originalArray, length)\nvar speciesConstructor = require('./_array-species-constructor');\n\nmodule.exports = function (original, length) {\n  return new (speciesConstructor(original))(length);\n};\n","'use strict';\nvar aFunction = require('./_a-function');\nvar isObject = require('./_is-object');\nvar invoke = require('./_invoke');\nvar arraySlice = [].slice;\nvar factories = {};\n\nvar construct = function (F, len, args) {\n  if (!(len in factories)) {\n    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';\n    // eslint-disable-next-line no-new-func\n    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');\n  } return factories[len](F, args);\n};\n\nmodule.exports = Function.bind || function bind(that /* , ...args */) {\n  var fn = aFunction(this);\n  var partArgs = arraySlice.call(arguments, 1);\n  var bound = function (/* args... */) {\n    var args = partArgs.concat(arraySlice.call(arguments));\n    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);\n  };\n  if (isObject(fn.prototype)) bound.prototype = fn.prototype;\n  return bound;\n};\n","// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = require('./_cof');\nvar TAG = require('./_wks')('toStringTag');\n// ES3 wrong here\nvar ARG = cof(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (e) { /* empty */ }\n};\n\nmodule.exports = function (it) {\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n","var toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n","'use strict';\nvar dP = require('./_object-dp').f;\nvar create = require('./_object-create');\nvar redefineAll = require('./_redefine-all');\nvar ctx = require('./_ctx');\nvar anInstance = require('./_an-instance');\nvar forOf = require('./_for-of');\nvar $iterDefine = require('./_iter-define');\nvar step = require('./_iter-step');\nvar setSpecies = require('./_set-species');\nvar DESCRIPTORS = require('./_descriptors');\nvar fastKey = require('./_meta').fastKey;\nvar validate = require('./_validate-collection');\nvar SIZE = DESCRIPTORS ? '_s' : 'size';\n\nvar getEntry = function (that, key) {\n  // fast case\n  var index = fastKey(key);\n  var entry;\n  if (index !== 'F') return that._i[index];\n  // frozen object case\n  for (entry = that._f; entry; entry = entry.n) {\n    if (entry.k == key) return entry;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {\n    var C = wrapper(function (that, iterable) {\n      anInstance(that, C, NAME, '_i');\n      that._t = NAME;         // collection type\n      that._i = create(null); // index\n      that._f = undefined;    // first entry\n      that._l = undefined;    // last entry\n      that[SIZE] = 0;         // size\n      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    redefineAll(C.prototype, {\n      // 23.1.3.1 Map.prototype.clear()\n      // 23.2.3.2 Set.prototype.clear()\n      clear: function clear() {\n        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {\n          entry.r = true;\n          if (entry.p) entry.p = entry.p.n = undefined;\n          delete data[entry.i];\n        }\n        that._f = that._l = undefined;\n        that[SIZE] = 0;\n      },\n      // 23.1.3.3 Map.prototype.delete(key)\n      // 23.2.3.4 Set.prototype.delete(value)\n      'delete': function (key) {\n        var that = validate(this, NAME);\n        var entry = getEntry(that, key);\n        if (entry) {\n          var next = entry.n;\n          var prev = entry.p;\n          delete that._i[entry.i];\n          entry.r = true;\n          if (prev) prev.n = next;\n          if (next) next.p = prev;\n          if (that._f == entry) that._f = next;\n          if (that._l == entry) that._l = prev;\n          that[SIZE]--;\n        } return !!entry;\n      },\n      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)\n      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)\n      forEach: function forEach(callbackfn /* , that = undefined */) {\n        validate(this, NAME);\n        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\n        var entry;\n        while (entry = entry ? entry.n : this._f) {\n          f(entry.v, entry.k, this);\n          // revert to the last existing entry\n          while (entry && entry.r) entry = entry.p;\n        }\n      },\n      // 23.1.3.7 Map.prototype.has(key)\n      // 23.2.3.7 Set.prototype.has(value)\n      has: function has(key) {\n        return !!getEntry(validate(this, NAME), key);\n      }\n    });\n    if (DESCRIPTORS) dP(C.prototype, 'size', {\n      get: function () {\n        return validate(this, NAME)[SIZE];\n      }\n    });\n    return C;\n  },\n  def: function (that, key, value) {\n    var entry = getEntry(that, key);\n    var prev, index;\n    // change existing entry\n    if (entry) {\n      entry.v = value;\n    // create new entry\n    } else {\n      that._l = entry = {\n        i: index = fastKey(key, true), // <- index\n        k: key,                        // <- key\n        v: value,                      // <- value\n        p: prev = that._l,             // <- previous entry\n        n: undefined,                  // <- next entry\n        r: false                       // <- removed\n      };\n      if (!that._f) that._f = entry;\n      if (prev) prev.n = entry;\n      that[SIZE]++;\n      // add to index\n      if (index !== 'F') that._i[index] = entry;\n    } return that;\n  },\n  getEntry: getEntry,\n  setStrong: function (C, NAME, IS_MAP) {\n    // add .keys, .values, .entries, [@@iterator]\n    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11\n    $iterDefine(C, NAME, function (iterated, kind) {\n      this._t = validate(iterated, NAME); // target\n      this._k = kind;                     // kind\n      this._l = undefined;                // previous\n    }, function () {\n      var that = this;\n      var kind = that._k;\n      var entry = that._l;\n      // revert to the last existing entry\n      while (entry && entry.r) entry = entry.p;\n      // get next entry\n      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {\n        // or finish the iteration\n        that._t = undefined;\n        return step(1);\n      }\n      // return step by kind\n      if (kind == 'keys') return step(0, entry.k);\n      if (kind == 'values') return step(0, entry.v);\n      return step(0, [entry.k, entry.v]);\n    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);\n\n    // add [@@species], 23.1.2.2, 23.2.2.2\n    setSpecies(NAME);\n  }\n};\n","// https://github.com/DavidBruant/Map-Set.prototype.toJSON\nvar classof = require('./_classof');\nvar from = require('./_array-from-iterable');\nmodule.exports = function (NAME) {\n  return function toJSON() {\n    if (classof(this) != NAME) throw TypeError(NAME + \"#toJSON isn't generic\");\n    return from(this);\n  };\n};\n","'use strict';\nvar redefineAll = require('./_redefine-all');\nvar getWeak = require('./_meta').getWeak;\nvar anObject = require('./_an-object');\nvar isObject = require('./_is-object');\nvar anInstance = require('./_an-instance');\nvar forOf = require('./_for-of');\nvar createArrayMethod = require('./_array-methods');\nvar $has = require('./_has');\nvar validate = require('./_validate-collection');\nvar arrayFind = createArrayMethod(5);\nvar arrayFindIndex = createArrayMethod(6);\nvar id = 0;\n\n// fallback for uncaught frozen keys\nvar uncaughtFrozenStore = function (that) {\n  return that._l || (that._l = new UncaughtFrozenStore());\n};\nvar UncaughtFrozenStore = function () {\n  this.a = [];\n};\nvar findUncaughtFrozen = function (store, key) {\n  return arrayFind(store.a, function (it) {\n    return it[0] === key;\n  });\n};\nUncaughtFrozenStore.prototype = {\n  get: function (key) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) return entry[1];\n  },\n  has: function (key) {\n    return !!findUncaughtFrozen(this, key);\n  },\n  set: function (key, value) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) entry[1] = value;\n    else this.a.push([key, value]);\n  },\n  'delete': function (key) {\n    var index = arrayFindIndex(this.a, function (it) {\n      return it[0] === key;\n    });\n    if (~index) this.a.splice(index, 1);\n    return !!~index;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {\n    var C = wrapper(function (that, iterable) {\n      anInstance(that, C, NAME, '_i');\n      that._t = NAME;      // collection type\n      that._i = id++;      // collection id\n      that._l = undefined; // leak store for uncaught frozen objects\n      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    redefineAll(C.prototype, {\n      // 23.3.3.2 WeakMap.prototype.delete(key)\n      // 23.4.3.3 WeakSet.prototype.delete(value)\n      'delete': function (key) {\n        if (!isObject(key)) return false;\n        var data = getWeak(key);\n        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);\n        return data && $has(data, this._i) && delete data[this._i];\n      },\n      // 23.3.3.4 WeakMap.prototype.has(key)\n      // 23.4.3.4 WeakSet.prototype.has(value)\n      has: function has(key) {\n        if (!isObject(key)) return false;\n        var data = getWeak(key);\n        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);\n        return data && $has(data, this._i);\n      }\n    });\n    return C;\n  },\n  def: function (that, key, value) {\n    var data = getWeak(anObject(key), true);\n    if (data === true) uncaughtFrozenStore(that).set(key, value);\n    else data[that._i] = value;\n    return that;\n  },\n  ufstore: uncaughtFrozenStore\n};\n","'use strict';\nvar global = require('./_global');\nvar $export = require('./_export');\nvar redefine = require('./_redefine');\nvar redefineAll = require('./_redefine-all');\nvar meta = require('./_meta');\nvar forOf = require('./_for-of');\nvar anInstance = require('./_an-instance');\nvar isObject = require('./_is-object');\nvar fails = require('./_fails');\nvar $iterDetect = require('./_iter-detect');\nvar setToStringTag = require('./_set-to-string-tag');\nvar inheritIfRequired = require('./_inherit-if-required');\n\nmodule.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {\n  var Base = global[NAME];\n  var C = Base;\n  var ADDER = IS_MAP ? 'set' : 'add';\n  var proto = C && C.prototype;\n  var O = {};\n  var fixMethod = function (KEY) {\n    var fn = proto[KEY];\n    redefine(proto, KEY,\n      KEY == 'delete' ? function (a) {\n        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);\n      } : KEY == 'has' ? function has(a) {\n        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);\n      } : KEY == 'get' ? function get(a) {\n        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);\n      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }\n        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }\n    );\n  };\n  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {\n    new C().entries().next();\n  }))) {\n    // create collection constructor\n    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);\n    redefineAll(C.prototype, methods);\n    meta.NEED = true;\n  } else {\n    var instance = new C();\n    // early implementations not supports chaining\n    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;\n    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false\n    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });\n    // most early implementations doesn't supports iterables, most modern - not close it correctly\n    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new\n    // for early implementations -0 and +0 not the same\n    var BUGGY_ZERO = !IS_WEAK && fails(function () {\n      // V8 ~ Chromium 42- fails only with 5+ elements\n      var $instance = new C();\n      var index = 5;\n      while (index--) $instance[ADDER](index, index);\n      return !$instance.has(-0);\n    });\n    if (!ACCEPT_ITERABLES) {\n      C = wrapper(function (target, iterable) {\n        anInstance(target, C, NAME);\n        var that = inheritIfRequired(new Base(), target, C);\n        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);\n        return that;\n      });\n      C.prototype = proto;\n      proto.constructor = C;\n    }\n    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {\n      fixMethod('delete');\n      fixMethod('has');\n      IS_MAP && fixMethod('get');\n    }\n    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);\n    // weak collections should not contains .clear method\n    if (IS_WEAK && proto.clear) delete proto.clear;\n  }\n\n  setToStringTag(C, NAME);\n\n  O[NAME] = C;\n  $export($export.G + $export.W + $export.F * (C != Base), O);\n\n  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);\n\n  return C;\n};\n","var core = module.exports = { version: '2.5.3' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n","'use strict';\nvar $defineProperty = require('./_object-dp');\nvar createDesc = require('./_property-desc');\n\nmodule.exports = function (object, index, value) {\n  if (index in object) $defineProperty.f(object, index, createDesc(0, value));\n  else object[index] = value;\n};\n","// optional / simple context binding\nvar aFunction = require('./_a-function');\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n","'use strict';\n// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()\nvar fails = require('./_fails');\nvar getTime = Date.prototype.getTime;\nvar $toISOString = Date.prototype.toISOString;\n\nvar lz = function (num) {\n  return num > 9 ? num : '0' + num;\n};\n\n// PhantomJS / old WebKit has a broken implementations\nmodule.exports = (fails(function () {\n  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';\n}) || !fails(function () {\n  $toISOString.call(new Date(NaN));\n})) ? function toISOString() {\n  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');\n  var d = this;\n  var y = d.getUTCFullYear();\n  var m = d.getUTCMilliseconds();\n  var s = y < 0 ? '-' : y > 9999 ? '+' : '';\n  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +\n    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +\n    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +\n    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';\n} : $toISOString;\n","'use strict';\nvar anObject = require('./_an-object');\nvar toPrimitive = require('./_to-primitive');\nvar NUMBER = 'number';\n\nmodule.exports = function (hint) {\n  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');\n  return toPrimitive(anObject(this), hint != NUMBER);\n};\n","// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n","// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('./_fails')(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n","var isObject = require('./_is-object');\nvar document = require('./_global').document;\n// typeof document.createElement is 'object' in old IE\nvar is = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n  return is ? document.createElement(it) : {};\n};\n","// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n","// all enumerable object keys, includes symbols\nvar getKeys = require('./_object-keys');\nvar gOPS = require('./_object-gops');\nvar pIE = require('./_object-pie');\nmodule.exports = function (it) {\n  var result = getKeys(it);\n  var getSymbols = gOPS.f;\n  if (getSymbols) {\n    var symbols = getSymbols(it);\n    var isEnum = pIE.f;\n    var i = 0;\n    var key;\n    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);\n  } return result;\n};\n","var global = require('./_global');\nvar core = require('./_core');\nvar hide = require('./_hide');\nvar redefine = require('./_redefine');\nvar ctx = require('./_ctx');\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\n  var key, own, out, exp;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    // export native or passed\n    out = (own ? target : source)[key];\n    // bind timers to global for call from export context\n    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // extend global\n    if (target) redefine(target, key, out, type & $export.U);\n    // export\n    if (exports[key] != out) hide(exports, key, exp);\n    if (IS_PROTO && expProto[key] != out) expProto[key] = out;\n  }\n};\nglobal.core = core;\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nmodule.exports = $export;\n","var MATCH = require('./_wks')('match');\nmodule.exports = function (KEY) {\n  var re = /./;\n  try {\n    '/./'[KEY](re);\n  } catch (e) {\n    try {\n      re[MATCH] = false;\n      return !'/./'[KEY](re);\n    } catch (f) { /* empty */ }\n  } return true;\n};\n","module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n","'use strict';\nvar hide = require('./_hide');\nvar redefine = require('./_redefine');\nvar fails = require('./_fails');\nvar defined = require('./_defined');\nvar wks = require('./_wks');\n\nmodule.exports = function (KEY, length, exec) {\n  var SYMBOL = wks(KEY);\n  var fns = exec(defined, SYMBOL, ''[KEY]);\n  var strfn = fns[0];\n  var rxfn = fns[1];\n  if (fails(function () {\n    var O = {};\n    O[SYMBOL] = function () { return 7; };\n    return ''[KEY](O) != 7;\n  })) {\n    redefine(String.prototype, KEY, strfn);\n    hide(RegExp.prototype, SYMBOL, length == 2\n      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)\n      // 21.2.5.11 RegExp.prototype[@@split](string, limit)\n      ? function (string, arg) { return rxfn.call(string, this, arg); }\n      // 21.2.5.6 RegExp.prototype[@@match](string)\n      // 21.2.5.9 RegExp.prototype[@@search](string)\n      : function (string) { return rxfn.call(string, this); }\n    );\n  }\n};\n","'use strict';\n// 21.2.5.3 get RegExp.prototype.flags\nvar anObject = require('./_an-object');\nmodule.exports = function () {\n  var that = anObject(this);\n  var result = '';\n  if (that.global) result += 'g';\n  if (that.ignoreCase) result += 'i';\n  if (that.multiline) result += 'm';\n  if (that.unicode) result += 'u';\n  if (that.sticky) result += 'y';\n  return result;\n};\n","'use strict';\n// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray\nvar isArray = require('./_is-array');\nvar isObject = require('./_is-object');\nvar toLength = require('./_to-length');\nvar ctx = require('./_ctx');\nvar IS_CONCAT_SPREADABLE = require('./_wks')('isConcatSpreadable');\n\nfunction flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {\n  var targetIndex = start;\n  var sourceIndex = 0;\n  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;\n  var element, spreadable;\n\n  while (sourceIndex < sourceLen) {\n    if (sourceIndex in source) {\n      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];\n\n      spreadable = false;\n      if (isObject(element)) {\n        spreadable = element[IS_CONCAT_SPREADABLE];\n        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);\n      }\n\n      if (spreadable && depth > 0) {\n        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;\n      } else {\n        if (targetIndex >= 0x1fffffffffffff) throw TypeError();\n        target[targetIndex] = element;\n      }\n\n      targetIndex++;\n    }\n    sourceIndex++;\n  }\n  return targetIndex;\n}\n\nmodule.exports = flattenIntoArray;\n","var ctx = require('./_ctx');\nvar call = require('./_iter-call');\nvar isArrayIter = require('./_is-array-iter');\nvar anObject = require('./_an-object');\nvar toLength = require('./_to-length');\nvar getIterFn = require('./core.get-iterator-method');\nvar BREAK = {};\nvar RETURN = {};\nvar exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {\n  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);\n  var f = ctx(fn, that, entries ? 2 : 1);\n  var index = 0;\n  var length, step, iterator, result;\n  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');\n  // fast case for arrays with default iterator\n  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {\n    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n    if (result === BREAK || result === RETURN) return result;\n  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {\n    result = call(iterator, f, step.value, entries);\n    if (result === BREAK || result === RETURN) return result;\n  }\n};\nexports.BREAK = BREAK;\nexports.RETURN = RETURN;\n","// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n","var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n","var dP = require('./_object-dp');\nvar createDesc = require('./_property-desc');\nmodule.exports = require('./_descriptors') ? function (object, key, value) {\n  return dP.f(object, key, createDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n","var document = require('./_global').document;\nmodule.exports = document && document.documentElement;\n","module.exports = !require('./_descriptors') && !require('./_fails')(function () {\n  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n","var isObject = require('./_is-object');\nvar setPrototypeOf = require('./_set-proto').set;\nmodule.exports = function (that, target, C) {\n  var S = target.constructor;\n  var P;\n  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {\n    setPrototypeOf(that, P);\n  } return that;\n};\n","// fast apply, http://jsperf.lnkit.com/fast-apply/5\nmodule.exports = function (fn, args, that) {\n  var un = that === undefined;\n  switch (args.length) {\n    case 0: return un ? fn()\n                      : fn.call(that);\n    case 1: return un ? fn(args[0])\n                      : fn.call(that, args[0]);\n    case 2: return un ? fn(args[0], args[1])\n                      : fn.call(that, args[0], args[1]);\n    case 3: return un ? fn(args[0], args[1], args[2])\n                      : fn.call(that, args[0], args[1], args[2]);\n    case 4: return un ? fn(args[0], args[1], args[2], args[3])\n                      : fn.call(that, args[0], args[1], args[2], args[3]);\n  } return fn.apply(that, args);\n};\n","// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = require('./_cof');\n// eslint-disable-next-line no-prototype-builtins\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n","// check on default Array iterator\nvar Iterators = require('./_iterators');\nvar ITERATOR = require('./_wks')('iterator');\nvar ArrayProto = Array.prototype;\n\nmodule.exports = function (it) {\n  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n};\n","// 7.2.2 IsArray(argument)\nvar cof = require('./_cof');\nmodule.exports = Array.isArray || function isArray(arg) {\n  return cof(arg) == 'Array';\n};\n","// 20.1.2.3 Number.isInteger(number)\nvar isObject = require('./_is-object');\nvar floor = Math.floor;\nmodule.exports = function isInteger(it) {\n  return !isObject(it) && isFinite(it) && floor(it) === it;\n};\n","module.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n","// 7.2.8 IsRegExp(argument)\nvar isObject = require('./_is-object');\nvar cof = require('./_cof');\nvar MATCH = require('./_wks')('match');\nmodule.exports = function (it) {\n  var isRegExp;\n  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');\n};\n","// call something on iterator step with safe closing on error\nvar anObject = require('./_an-object');\nmodule.exports = function (iterator, fn, value, entries) {\n  try {\n    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch (e) {\n    var ret = iterator['return'];\n    if (ret !== undefined) anObject(ret.call(iterator));\n    throw e;\n  }\n};\n","'use strict';\nvar create = require('./_object-create');\nvar descriptor = require('./_property-desc');\nvar setToStringTag = require('./_set-to-string-tag');\nvar IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nrequire('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });\n\nmodule.exports = function (Constructor, NAME, next) {\n  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n","'use strict';\nvar LIBRARY = require('./_library');\nvar $export = require('./_export');\nvar redefine = require('./_redefine');\nvar hide = require('./_hide');\nvar has = require('./_has');\nvar Iterators = require('./_iterators');\nvar $iterCreate = require('./_iter-create');\nvar setToStringTag = require('./_set-to-string-tag');\nvar getPrototypeOf = require('./_object-gpo');\nvar ITERATOR = require('./_wks')('iterator');\nvar BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`\nvar FF_ITERATOR = '@@iterator';\nvar KEYS = 'keys';\nvar VALUES = 'values';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function (kind) {\n    if (!BUGGY && kind in proto) return proto[kind];\n    switch (kind) {\n      case KEYS: return function keys() { return new Constructor(this, kind); };\n      case VALUES: return function values() { return new Constructor(this, kind); };\n    } return function entries() { return new Constructor(this, kind); };\n  };\n  var TAG = NAME + ' Iterator';\n  var DEF_VALUES = DEFAULT == VALUES;\n  var VALUES_BUG = false;\n  var proto = Base.prototype;\n  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\n  var $default = (!BUGGY && $native) || getMethod(DEFAULT);\n  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;\n  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;\n  var methods, key, IteratorPrototype;\n  // Fix native\n  if ($anyNative) {\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));\n    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEF_VALUES && $native && $native.name !== VALUES) {\n    VALUES_BUG = true;\n    $default = function values() { return $native.call(this); };\n  }\n  // Define iterator\n  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG] = returnThis;\n  if (DEFAULT) {\n    methods = {\n      values: DEF_VALUES ? $default : getMethod(VALUES),\n      keys: IS_SET ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if (FORCED) for (key in methods) {\n      if (!(key in proto)) redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n","var ITERATOR = require('./_wks')('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var riter = [7][ITERATOR]();\n  riter['return'] = function () { SAFE_CLOSING = true; };\n  // eslint-disable-next-line no-throw-literal\n  Array.from(riter, function () { throw 2; });\n} catch (e) { /* empty */ }\n\nmodule.exports = function (exec, skipClosing) {\n  if (!skipClosing && !SAFE_CLOSING) return false;\n  var safe = false;\n  try {\n    var arr = [7];\n    var iter = arr[ITERATOR]();\n    iter.next = function () { return { done: safe = true }; };\n    arr[ITERATOR] = function () { return iter; };\n    exec(arr);\n  } catch (e) { /* empty */ }\n  return safe;\n};\n","module.exports = function (done, value) {\n  return { value: value, done: !!done };\n};\n","module.exports = {};\n","module.exports = false;\n","// 20.2.2.14 Math.expm1(x)\nvar $expm1 = Math.expm1;\nmodule.exports = (!$expm1\n  // Old FF bug\n  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168\n  // Tor Browser bug\n  || $expm1(-2e-17) != -2e-17\n) ? function expm1(x) {\n  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;\n} : $expm1;\n","// 20.2.2.16 Math.fround(x)\nvar sign = require('./_math-sign');\nvar pow = Math.pow;\nvar EPSILON = pow(2, -52);\nvar EPSILON32 = pow(2, -23);\nvar MAX32 = pow(2, 127) * (2 - EPSILON32);\nvar MIN32 = pow(2, -126);\n\nvar roundTiesToEven = function (n) {\n  return n + 1 / EPSILON - 1 / EPSILON;\n};\n\nmodule.exports = Math.fround || function fround(x) {\n  var $abs = Math.abs(x);\n  var $sign = sign(x);\n  var a, result;\n  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;\n  a = (1 + EPSILON32 / EPSILON) * $abs;\n  result = a - (a - $abs);\n  // eslint-disable-next-line no-self-compare\n  if (result > MAX32 || result != result) return $sign * Infinity;\n  return $sign * result;\n};\n","// 20.2.2.20 Math.log1p(x)\nmodule.exports = Math.log1p || function log1p(x) {\n  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);\n};\n","// https://rwaldron.github.io/proposal-math-extensions/\nmodule.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {\n  if (\n    arguments.length === 0\n      // eslint-disable-next-line no-self-compare\n      || x != x\n      // eslint-disable-next-line no-self-compare\n      || inLow != inLow\n      // eslint-disable-next-line no-self-compare\n      || inHigh != inHigh\n      // eslint-disable-next-line no-self-compare\n      || outLow != outLow\n      // eslint-disable-next-line no-self-compare\n      || outHigh != outHigh\n  ) return NaN;\n  if (x === Infinity || x === -Infinity) return x;\n  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;\n};\n","// 20.2.2.28 Math.sign(x)\nmodule.exports = Math.sign || function sign(x) {\n  // eslint-disable-next-line no-self-compare\n  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;\n};\n","var META = require('./_uid')('meta');\nvar isObject = require('./_is-object');\nvar has = require('./_has');\nvar setDesc = require('./_object-dp').f;\nvar id = 0;\nvar isExtensible = Object.isExtensible || function () {\n  return true;\n};\nvar FREEZE = !require('./_fails')(function () {\n  return isExtensible(Object.preventExtensions({}));\n});\nvar setMeta = function (it) {\n  setDesc(it, META, { value: {\n    i: 'O' + ++id, // object ID\n    w: {}          // weak collections IDs\n  } });\n};\nvar fastKey = function (it, create) {\n  // return primitive with prefix\n  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if (!has(it, META)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return 'F';\n    // not necessary to add metadata\n    if (!create) return 'E';\n    // add missing metadata\n    setMeta(it);\n  // return object ID\n  } return it[META].i;\n};\nvar getWeak = function (it, create) {\n  if (!has(it, META)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return true;\n    // not necessary to add metadata\n    if (!create) return false;\n    // add missing metadata\n    setMeta(it);\n  // return hash weak collections IDs\n  } return it[META].w;\n};\n// add metadata on freeze-family methods calling\nvar onFreeze = function (it) {\n  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);\n  return it;\n};\nvar meta = module.exports = {\n  KEY: META,\n  NEED: false,\n  fastKey: fastKey,\n  getWeak: getWeak,\n  onFreeze: onFreeze\n};\n","var Map = require('./es6.map');\nvar $export = require('./_export');\nvar shared = require('./_shared')('metadata');\nvar store = shared.store || (shared.store = new (require('./es6.weak-map'))());\n\nvar getOrCreateMetadataMap = function (target, targetKey, create) {\n  var targetMetadata = store.get(target);\n  if (!targetMetadata) {\n    if (!create) return undefined;\n    store.set(target, targetMetadata = new Map());\n  }\n  var keyMetadata = targetMetadata.get(targetKey);\n  if (!keyMetadata) {\n    if (!create) return undefined;\n    targetMetadata.set(targetKey, keyMetadata = new Map());\n  } return keyMetadata;\n};\nvar ordinaryHasOwnMetadata = function (MetadataKey, O, P) {\n  var metadataMap = getOrCreateMetadataMap(O, P, false);\n  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);\n};\nvar ordinaryGetOwnMetadata = function (MetadataKey, O, P) {\n  var metadataMap = getOrCreateMetadataMap(O, P, false);\n  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);\n};\nvar ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {\n  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);\n};\nvar ordinaryOwnMetadataKeys = function (target, targetKey) {\n  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);\n  var keys = [];\n  if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); });\n  return keys;\n};\nvar toMetaKey = function (it) {\n  return it === undefined || typeof it == 'symbol' ? it : String(it);\n};\nvar exp = function (O) {\n  $export($export.S, 'Reflect', O);\n};\n\nmodule.exports = {\n  store: store,\n  map: getOrCreateMetadataMap,\n  has: ordinaryHasOwnMetadata,\n  get: ordinaryGetOwnMetadata,\n  set: ordinaryDefineOwnMetadata,\n  keys: ordinaryOwnMetadataKeys,\n  key: toMetaKey,\n  exp: exp\n};\n","var global = require('./_global');\nvar macrotask = require('./_task').set;\nvar Observer = global.MutationObserver || global.WebKitMutationObserver;\nvar process = global.process;\nvar Promise = global.Promise;\nvar isNode = require('./_cof')(process) == 'process';\n\nmodule.exports = function () {\n  var head, last, notify;\n\n  var flush = function () {\n    var parent, fn;\n    if (isNode && (parent = process.domain)) parent.exit();\n    while (head) {\n      fn = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch (e) {\n        if (head) notify();\n        else last = undefined;\n        throw e;\n      }\n    } last = undefined;\n    if (parent) parent.enter();\n  };\n\n  // Node.js\n  if (isNode) {\n    notify = function () {\n      process.nextTick(flush);\n    };\n  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339\n  } else if (Observer && !(global.navigator && global.navigator.standalone)) {\n    var toggle = true;\n    var node = document.createTextNode('');\n    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new\n    notify = function () {\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if (Promise && Promise.resolve) {\n    var promise = Promise.resolve();\n    notify = function () {\n      promise.then(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessag\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    notify = function () {\n      // strange IE + webpack dev server bug - use .call(global)\n      macrotask.call(global, flush);\n    };\n  }\n\n  return function (fn) {\n    var task = { fn: fn, next: undefined };\n    if (last) last.next = task;\n    if (!head) {\n      head = task;\n      notify();\n    } last = task;\n  };\n};\n","'use strict';\n// 25.4.1.5 NewPromiseCapability(C)\nvar aFunction = require('./_a-function');\n\nfunction PromiseCapability(C) {\n  var resolve, reject;\n  this.promise = new C(function ($$resolve, $$reject) {\n    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject = $$reject;\n  });\n  this.resolve = aFunction(resolve);\n  this.reject = aFunction(reject);\n}\n\nmodule.exports.f = function (C) {\n  return new PromiseCapability(C);\n};\n","'use strict';\n// 19.1.2.1 Object.assign(target, source, ...)\nvar getKeys = require('./_object-keys');\nvar gOPS = require('./_object-gops');\nvar pIE = require('./_object-pie');\nvar toObject = require('./_to-object');\nvar IObject = require('./_iobject');\nvar $assign = Object.assign;\n\n// should work with symbols and should have deterministic property order (V8 bug)\nmodule.exports = !$assign || require('./_fails')(function () {\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line no-undef\n  var S = Symbol();\n  var K = 'abcdefghijklmnopqrst';\n  A[S] = 7;\n  K.split('').forEach(function (k) { B[k] = k; });\n  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars\n  var T = toObject(target);\n  var aLen = arguments.length;\n  var index = 1;\n  var getSymbols = gOPS.f;\n  var isEnum = pIE.f;\n  while (aLen > index) {\n    var S = IObject(arguments[index++]);\n    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];\n  } return T;\n} : $assign;\n","// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject = require('./_an-object');\nvar dPs = require('./_object-dps');\nvar enumBugKeys = require('./_enum-bug-keys');\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\nvar Empty = function () { /* empty */ };\nvar PROTOTYPE = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = require('./_dom-create')('iframe');\n  var i = enumBugKeys.length;\n  var lt = '<';\n  var gt = '>';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  require('./_html').appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n","var anObject = require('./_an-object');\nvar IE8_DOM_DEFINE = require('./_ie8-dom-define');\nvar toPrimitive = require('./_to-primitive');\nvar dP = Object.defineProperty;\n\nexports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n","var dP = require('./_object-dp');\nvar anObject = require('./_an-object');\nvar getKeys = require('./_object-keys');\n\nmodule.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = getKeys(Properties);\n  var length = keys.length;\n  var i = 0;\n  var P;\n  while (length > i) dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n","'use strict';\n// Forced replacement prototype accessors methods\nmodule.exports = require('./_library') || !require('./_fails')(function () {\n  var K = Math.random();\n  // In FF throws only define methods\n  // eslint-disable-next-line no-undef, no-useless-call\n  __defineSetter__.call(null, K, function () { /* empty */ });\n  delete require('./_global')[K];\n});\n","var pIE = require('./_object-pie');\nvar createDesc = require('./_property-desc');\nvar toIObject = require('./_to-iobject');\nvar toPrimitive = require('./_to-primitive');\nvar has = require('./_has');\nvar IE8_DOM_DEFINE = require('./_ie8-dom-define');\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nexports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {\n  O = toIObject(O);\n  P = toPrimitive(P, true);\n  if (IE8_DOM_DEFINE) try {\n    return gOPD(O, P);\n  } catch (e) { /* empty */ }\n  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);\n};\n","// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nvar toIObject = require('./_to-iobject');\nvar gOPN = require('./_object-gopn').f;\nvar toString = {}.toString;\n\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function (it) {\n  try {\n    return gOPN(it);\n  } catch (e) {\n    return windowNames.slice();\n  }\n};\n\nmodule.exports.f = function getOwnPropertyNames(it) {\n  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n};\n","// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\nvar $keys = require('./_object-keys-internal');\nvar hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');\n\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return $keys(O, hiddenKeys);\n};\n","exports.f = Object.getOwnPropertySymbols;\n","// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has = require('./_has');\nvar toObject = require('./_to-object');\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\nvar ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n","var has = require('./_has');\nvar toIObject = require('./_to-iobject');\nvar arrayIndexOf = require('./_array-includes')(false);\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\n\nmodule.exports = function (object, names) {\n  var O = toIObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n","// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys = require('./_object-keys-internal');\nvar enumBugKeys = require('./_enum-bug-keys');\n\nmodule.exports = Object.keys || function keys(O) {\n  return $keys(O, enumBugKeys);\n};\n","exports.f = {}.propertyIsEnumerable;\n","// most Object methods by ES6 should accept primitives\nvar $export = require('./_export');\nvar core = require('./_core');\nvar fails = require('./_fails');\nmodule.exports = function (KEY, exec) {\n  var fn = (core.Object || {})[KEY] || Object[KEY];\n  var exp = {};\n  exp[KEY] = exec(fn);\n  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);\n};\n","var getKeys = require('./_object-keys');\nvar toIObject = require('./_to-iobject');\nvar isEnum = require('./_object-pie').f;\nmodule.exports = function (isEntries) {\n  return function (it) {\n    var O = toIObject(it);\n    var keys = getKeys(O);\n    var length = keys.length;\n    var i = 0;\n    var result = [];\n    var key;\n    while (length > i) if (isEnum.call(O, key = keys[i++])) {\n      result.push(isEntries ? [key, O[key]] : O[key]);\n    } return result;\n  };\n};\n","// all object keys, includes non-enumerable and symbols\nvar gOPN = require('./_object-gopn');\nvar gOPS = require('./_object-gops');\nvar anObject = require('./_an-object');\nvar Reflect = require('./_global').Reflect;\nmodule.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {\n  var keys = gOPN.f(anObject(it));\n  var getSymbols = gOPS.f;\n  return getSymbols ? keys.concat(getSymbols(it)) : keys;\n};\n","var $parseFloat = require('./_global').parseFloat;\nvar $trim = require('./_string-trim').trim;\n\nmodule.exports = 1 / $parseFloat(require('./_string-ws') + '-0') !== -Infinity ? function parseFloat(str) {\n  var string = $trim(String(str), 3);\n  var result = $parseFloat(string);\n  return result === 0 && string.charAt(0) == '-' ? -0 : result;\n} : $parseFloat;\n","var $parseInt = require('./_global').parseInt;\nvar $trim = require('./_string-trim').trim;\nvar ws = require('./_string-ws');\nvar hex = /^[-+]?0[xX]/;\n\nmodule.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {\n  var string = $trim(String(str), 3);\n  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));\n} : $parseInt;\n","module.exports = function (exec) {\n  try {\n    return { e: false, v: exec() };\n  } catch (e) {\n    return { e: true, v: e };\n  }\n};\n","var anObject = require('./_an-object');\nvar isObject = require('./_is-object');\nvar newPromiseCapability = require('./_new-promise-capability');\n\nmodule.exports = function (C, x) {\n  anObject(C);\n  if (isObject(x) && x.constructor === C) return x;\n  var promiseCapability = newPromiseCapability.f(C);\n  var resolve = promiseCapability.resolve;\n  resolve(x);\n  return promiseCapability.promise;\n};\n","module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n","var redefine = require('./_redefine');\nmodule.exports = function (target, src, safe) {\n  for (var key in src) redefine(target, key, src[key], safe);\n  return target;\n};\n","var global = require('./_global');\nvar hide = require('./_hide');\nvar has = require('./_has');\nvar SRC = require('./_uid')('src');\nvar TO_STRING = 'toString';\nvar $toString = Function[TO_STRING];\nvar TPL = ('' + $toString).split(TO_STRING);\n\nrequire('./_core').inspectSource = function (it) {\n  return $toString.call(it);\n};\n\n(module.exports = function (O, key, val, safe) {\n  var isFunction = typeof val == 'function';\n  if (isFunction) has(val, 'name') || hide(val, 'name', key);\n  if (O[key] === val) return;\n  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\n  if (O === global) {\n    O[key] = val;\n  } else if (!safe) {\n    delete O[key];\n    hide(O, key, val);\n  } else if (O[key]) {\n    O[key] = val;\n  } else {\n    hide(O, key, val);\n  }\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, TO_STRING, function toString() {\n  return typeof this == 'function' && this[SRC] || $toString.call(this);\n});\n","module.exports = function (regExp, replace) {\n  var replacer = replace === Object(replace) ? function (part) {\n    return replace[part];\n  } : replace;\n  return function (it) {\n    return String(it).replace(regExp, replacer);\n  };\n};\n","// 7.2.9 SameValue(x, y)\nmodule.exports = Object.is || function is(x, y) {\n  // eslint-disable-next-line no-self-compare\n  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;\n};\n","'use strict';\n// https://tc39.github.io/proposal-setmap-offrom/\nvar $export = require('./_export');\nvar aFunction = require('./_a-function');\nvar ctx = require('./_ctx');\nvar forOf = require('./_for-of');\n\nmodule.exports = function (COLLECTION) {\n  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {\n    var mapFn = arguments[1];\n    var mapping, A, n, cb;\n    aFunction(this);\n    mapping = mapFn !== undefined;\n    if (mapping) aFunction(mapFn);\n    if (source == undefined) return new this();\n    A = [];\n    if (mapping) {\n      n = 0;\n      cb = ctx(mapFn, arguments[2], 2);\n      forOf(source, false, function (nextItem) {\n        A.push(cb(nextItem, n++));\n      });\n    } else {\n      forOf(source, false, A.push, A);\n    }\n    return new this(A);\n  } });\n};\n","'use strict';\n// https://tc39.github.io/proposal-setmap-offrom/\nvar $export = require('./_export');\n\nmodule.exports = function (COLLECTION) {\n  $export($export.S, COLLECTION, { of: function of() {\n    var length = arguments.length;\n    var A = new Array(length);\n    while (length--) A[length] = arguments[length];\n    return new this(A);\n  } });\n};\n","// Works with __proto__ only. Old v8 can't work with null proto objects.\n/* eslint-disable no-proto */\nvar isObject = require('./_is-object');\nvar anObject = require('./_an-object');\nvar check = function (O, proto) {\n  anObject(O);\n  if (!isObject(proto) && proto !== null) throw TypeError(proto + \": can't set as prototype!\");\n};\nmodule.exports = {\n  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n    function (test, buggy, set) {\n      try {\n        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);\n        set(test, []);\n        buggy = !(test instanceof Array);\n      } catch (e) { buggy = true; }\n      return function setPrototypeOf(O, proto) {\n        check(O, proto);\n        if (buggy) O.__proto__ = proto;\n        else set(O, proto);\n        return O;\n      };\n    }({}, false) : undefined),\n  check: check\n};\n","'use strict';\nvar global = require('./_global');\nvar dP = require('./_object-dp');\nvar DESCRIPTORS = require('./_descriptors');\nvar SPECIES = require('./_wks')('species');\n\nmodule.exports = function (KEY) {\n  var C = global[KEY];\n  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {\n    configurable: true,\n    get: function () { return this; }\n  });\n};\n","var def = require('./_object-dp').f;\nvar has = require('./_has');\nvar TAG = require('./_wks')('toStringTag');\n\nmodule.exports = function (it, tag, stat) {\n  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });\n};\n","var shared = require('./_shared')('keys');\nvar uid = require('./_uid');\nmodule.exports = function (key) {\n  return shared[key] || (shared[key] = uid(key));\n};\n","var global = require('./_global');\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || (global[SHARED] = {});\nmodule.exports = function (key) {\n  return store[key] || (store[key] = {});\n};\n","// 7.3.20 SpeciesConstructor(O, defaultConstructor)\nvar anObject = require('./_an-object');\nvar aFunction = require('./_a-function');\nvar SPECIES = require('./_wks')('species');\nmodule.exports = function (O, D) {\n  var C = anObject(O).constructor;\n  var S;\n  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);\n};\n","'use strict';\nvar fails = require('./_fails');\n\nmodule.exports = function (method, arg) {\n  return !!method && fails(function () {\n    // eslint-disable-next-line no-useless-call\n    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);\n  });\n};\n","var toInteger = require('./_to-integer');\nvar defined = require('./_defined');\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function (TO_STRING) {\n  return function (that, pos) {\n    var s = String(defined(that));\n    var i = toInteger(pos);\n    var l = s.length;\n    var a, b;\n    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n","// helper for String#{startsWith, endsWith, includes}\nvar isRegExp = require('./_is-regexp');\nvar defined = require('./_defined');\n\nmodule.exports = function (that, searchString, NAME) {\n  if (isRegExp(searchString)) throw TypeError('String#' + NAME + \" doesn't accept regex!\");\n  return String(defined(that));\n};\n","var $export = require('./_export');\nvar fails = require('./_fails');\nvar defined = require('./_defined');\nvar quot = /\"/g;\n// B.2.3.2.1 CreateHTML(string, tag, attribute, value)\nvar createHTML = function (string, tag, attribute, value) {\n  var S = String(defined(string));\n  var p1 = '<' + tag;\n  if (attribute !== '') p1 += ' ' + attribute + '=\"' + String(value).replace(quot, '&quot;') + '\"';\n  return p1 + '>' + S + '</' + tag + '>';\n};\nmodule.exports = function (NAME, exec) {\n  var O = {};\n  O[NAME] = exec(createHTML);\n  $export($export.P + $export.F * fails(function () {\n    var test = ''[NAME]('\"');\n    return test !== test.toLowerCase() || test.split('\"').length > 3;\n  }), 'String', O);\n};\n","// https://github.com/tc39/proposal-string-pad-start-end\nvar toLength = require('./_to-length');\nvar repeat = require('./_string-repeat');\nvar defined = require('./_defined');\n\nmodule.exports = function (that, maxLength, fillString, left) {\n  var S = String(defined(that));\n  var stringLength = S.length;\n  var fillStr = fillString === undefined ? ' ' : String(fillString);\n  var intMaxLength = toLength(maxLength);\n  if (intMaxLength <= stringLength || fillStr == '') return S;\n  var fillLen = intMaxLength - stringLength;\n  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));\n  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);\n  return left ? stringFiller + S : S + stringFiller;\n};\n","'use strict';\nvar toInteger = require('./_to-integer');\nvar defined = require('./_defined');\n\nmodule.exports = function repeat(count) {\n  var str = String(defined(this));\n  var res = '';\n  var n = toInteger(count);\n  if (n < 0 || n == Infinity) throw RangeError(\"Count can't be negative\");\n  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;\n  return res;\n};\n","var $export = require('./_export');\nvar defined = require('./_defined');\nvar fails = require('./_fails');\nvar spaces = require('./_string-ws');\nvar space = '[' + spaces + ']';\nvar non = '\\u200b\\u0085';\nvar ltrim = RegExp('^' + space + space + '*');\nvar rtrim = RegExp(space + space + '*$');\n\nvar exporter = function (KEY, exec, ALIAS) {\n  var exp = {};\n  var FORCE = fails(function () {\n    return !!spaces[KEY]() || non[KEY]() != non;\n  });\n  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];\n  if (ALIAS) exp[ALIAS] = fn;\n  $export($export.P + $export.F * FORCE, 'String', exp);\n};\n\n// 1 -> String#trimLeft\n// 2 -> String#trimRight\n// 3 -> String#trim\nvar trim = exporter.trim = function (string, TYPE) {\n  string = String(defined(string));\n  if (TYPE & 1) string = string.replace(ltrim, '');\n  if (TYPE & 2) string = string.replace(rtrim, '');\n  return string;\n};\n\nmodule.exports = exporter;\n","module.exports = '\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003' +\n  '\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n","var ctx = require('./_ctx');\nvar invoke = require('./_invoke');\nvar html = require('./_html');\nvar cel = require('./_dom-create');\nvar global = require('./_global');\nvar process = global.process;\nvar setTask = global.setImmediate;\nvar clearTask = global.clearImmediate;\nvar MessageChannel = global.MessageChannel;\nvar Dispatch = global.Dispatch;\nvar counter = 0;\nvar queue = {};\nvar ONREADYSTATECHANGE = 'onreadystatechange';\nvar defer, channel, port;\nvar run = function () {\n  var id = +this;\n  // eslint-disable-next-line no-prototype-builtins\n  if (queue.hasOwnProperty(id)) {\n    var fn = queue[id];\n    delete queue[id];\n    fn();\n  }\n};\nvar listener = function (event) {\n  run.call(event.data);\n};\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif (!setTask || !clearTask) {\n  setTask = function setImmediate(fn) {\n    var args = [];\n    var i = 1;\n    while (arguments.length > i) args.push(arguments[i++]);\n    queue[++counter] = function () {\n      // eslint-disable-next-line no-new-func\n      invoke(typeof fn == 'function' ? fn : Function(fn), args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clearTask = function clearImmediate(id) {\n    delete queue[id];\n  };\n  // Node.js 0.8-\n  if (require('./_cof')(process) == 'process') {\n    defer = function (id) {\n      process.nextTick(ctx(run, id, 1));\n    };\n  // Sphere (JS game engine) Dispatch API\n  } else if (Dispatch && Dispatch.now) {\n    defer = function (id) {\n      Dispatch.now(ctx(run, id, 1));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  } else if (MessageChannel) {\n    channel = new MessageChannel();\n    port = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = ctx(port.postMessage, port, 1);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {\n    defer = function (id) {\n      global.postMessage(id + '', '*');\n    };\n    global.addEventListener('message', listener, false);\n  // IE8-\n  } else if (ONREADYSTATECHANGE in cel('script')) {\n    defer = function (id) {\n      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {\n        html.removeChild(this);\n        run.call(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function (id) {\n      setTimeout(ctx(run, id, 1), 0);\n    };\n  }\n}\nmodule.exports = {\n  set: setTask,\n  clear: clearTask\n};\n","var toInteger = require('./_to-integer');\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n","// https://tc39.github.io/ecma262/#sec-toindex\nvar toInteger = require('./_to-integer');\nvar toLength = require('./_to-length');\nmodule.exports = function (it) {\n  if (it === undefined) return 0;\n  var number = toInteger(it);\n  var length = toLength(number);\n  if (number !== length) throw RangeError('Wrong length!');\n  return length;\n};\n","// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = function (it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n","// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = require('./_iobject');\nvar defined = require('./_defined');\nmodule.exports = function (it) {\n  return IObject(defined(it));\n};\n","// 7.1.15 ToLength\nvar toInteger = require('./_to-integer');\nvar min = Math.min;\nmodule.exports = function (it) {\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n","// 7.1.13 ToObject(argument)\nvar defined = require('./_defined');\nmodule.exports = function (it) {\n  return Object(defined(it));\n};\n","// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = require('./_is-object');\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n","'use strict';\nif (require('./_descriptors')) {\n  var LIBRARY = require('./_library');\n  var global = require('./_global');\n  var fails = require('./_fails');\n  var $export = require('./_export');\n  var $typed = require('./_typed');\n  var $buffer = require('./_typed-buffer');\n  var ctx = require('./_ctx');\n  var anInstance = require('./_an-instance');\n  var propertyDesc = require('./_property-desc');\n  var hide = require('./_hide');\n  var redefineAll = require('./_redefine-all');\n  var toInteger = require('./_to-integer');\n  var toLength = require('./_to-length');\n  var toIndex = require('./_to-index');\n  var toAbsoluteIndex = require('./_to-absolute-index');\n  var toPrimitive = require('./_to-primitive');\n  var has = require('./_has');\n  var classof = require('./_classof');\n  var isObject = require('./_is-object');\n  var toObject = require('./_to-object');\n  var isArrayIter = require('./_is-array-iter');\n  var create = require('./_object-create');\n  var getPrototypeOf = require('./_object-gpo');\n  var gOPN = require('./_object-gopn').f;\n  var getIterFn = require('./core.get-iterator-method');\n  var uid = require('./_uid');\n  var wks = require('./_wks');\n  var createArrayMethod = require('./_array-methods');\n  var createArrayIncludes = require('./_array-includes');\n  var speciesConstructor = require('./_species-constructor');\n  var ArrayIterators = require('./es6.array.iterator');\n  var Iterators = require('./_iterators');\n  var $iterDetect = require('./_iter-detect');\n  var setSpecies = require('./_set-species');\n  var arrayFill = require('./_array-fill');\n  var arrayCopyWithin = require('./_array-copy-within');\n  var $DP = require('./_object-dp');\n  var $GOPD = require('./_object-gopd');\n  var dP = $DP.f;\n  var gOPD = $GOPD.f;\n  var RangeError = global.RangeError;\n  var TypeError = global.TypeError;\n  var Uint8Array = global.Uint8Array;\n  var ARRAY_BUFFER = 'ArrayBuffer';\n  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;\n  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';\n  var PROTOTYPE = 'prototype';\n  var ArrayProto = Array[PROTOTYPE];\n  var $ArrayBuffer = $buffer.ArrayBuffer;\n  var $DataView = $buffer.DataView;\n  var arrayForEach = createArrayMethod(0);\n  var arrayFilter = createArrayMethod(2);\n  var arraySome = createArrayMethod(3);\n  var arrayEvery = createArrayMethod(4);\n  var arrayFind = createArrayMethod(5);\n  var arrayFindIndex = createArrayMethod(6);\n  var arrayIncludes = createArrayIncludes(true);\n  var arrayIndexOf = createArrayIncludes(false);\n  var arrayValues = ArrayIterators.values;\n  var arrayKeys = ArrayIterators.keys;\n  var arrayEntries = ArrayIterators.entries;\n  var arrayLastIndexOf = ArrayProto.lastIndexOf;\n  var arrayReduce = ArrayProto.reduce;\n  var arrayReduceRight = ArrayProto.reduceRight;\n  var arrayJoin = ArrayProto.join;\n  var arraySort = ArrayProto.sort;\n  var arraySlice = ArrayProto.slice;\n  var arrayToString = ArrayProto.toString;\n  var arrayToLocaleString = ArrayProto.toLocaleString;\n  var ITERATOR = wks('iterator');\n  var TAG = wks('toStringTag');\n  var TYPED_CONSTRUCTOR = uid('typed_constructor');\n  var DEF_CONSTRUCTOR = uid('def_constructor');\n  var ALL_CONSTRUCTORS = $typed.CONSTR;\n  var TYPED_ARRAY = $typed.TYPED;\n  var VIEW = $typed.VIEW;\n  var WRONG_LENGTH = 'Wrong length!';\n\n  var $map = createArrayMethod(1, function (O, length) {\n    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);\n  });\n\n  var LITTLE_ENDIAN = fails(function () {\n    // eslint-disable-next-line no-undef\n    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;\n  });\n\n  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {\n    new Uint8Array(1).set({});\n  });\n\n  var toOffset = function (it, BYTES) {\n    var offset = toInteger(it);\n    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');\n    return offset;\n  };\n\n  var validate = function (it) {\n    if (isObject(it) && TYPED_ARRAY in it) return it;\n    throw TypeError(it + ' is not a typed array!');\n  };\n\n  var allocate = function (C, length) {\n    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {\n      throw TypeError('It is not a typed array constructor!');\n    } return new C(length);\n  };\n\n  var speciesFromList = function (O, list) {\n    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);\n  };\n\n  var fromList = function (C, list) {\n    var index = 0;\n    var length = list.length;\n    var result = allocate(C, length);\n    while (length > index) result[index] = list[index++];\n    return result;\n  };\n\n  var addGetter = function (it, key, internal) {\n    dP(it, key, { get: function () { return this._d[internal]; } });\n  };\n\n  var $from = function from(source /* , mapfn, thisArg */) {\n    var O = toObject(source);\n    var aLen = arguments.length;\n    var mapfn = aLen > 1 ? arguments[1] : undefined;\n    var mapping = mapfn !== undefined;\n    var iterFn = getIterFn(O);\n    var i, length, values, result, step, iterator;\n    if (iterFn != undefined && !isArrayIter(iterFn)) {\n      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {\n        values.push(step.value);\n      } O = values;\n    }\n    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);\n    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {\n      result[i] = mapping ? mapfn(O[i], i) : O[i];\n    }\n    return result;\n  };\n\n  var $of = function of(/* ...items */) {\n    var index = 0;\n    var length = arguments.length;\n    var result = allocate(this, length);\n    while (length > index) result[index] = arguments[index++];\n    return result;\n  };\n\n  // iOS Safari 6.x fails here\n  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });\n\n  var $toLocaleString = function toLocaleString() {\n    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);\n  };\n\n  var proto = {\n    copyWithin: function copyWithin(target, start /* , end */) {\n      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    every: function every(callbackfn /* , thisArg */) {\n      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars\n      return arrayFill.apply(validate(this), arguments);\n    },\n    filter: function filter(callbackfn /* , thisArg */) {\n      return speciesFromList(this, arrayFilter(validate(this), callbackfn,\n        arguments.length > 1 ? arguments[1] : undefined));\n    },\n    find: function find(predicate /* , thisArg */) {\n      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    findIndex: function findIndex(predicate /* , thisArg */) {\n      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    forEach: function forEach(callbackfn /* , thisArg */) {\n      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    indexOf: function indexOf(searchElement /* , fromIndex */) {\n      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    includes: function includes(searchElement /* , fromIndex */) {\n      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    join: function join(separator) { // eslint-disable-line no-unused-vars\n      return arrayJoin.apply(validate(this), arguments);\n    },\n    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars\n      return arrayLastIndexOf.apply(validate(this), arguments);\n    },\n    map: function map(mapfn /* , thisArg */) {\n      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars\n      return arrayReduce.apply(validate(this), arguments);\n    },\n    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars\n      return arrayReduceRight.apply(validate(this), arguments);\n    },\n    reverse: function reverse() {\n      var that = this;\n      var length = validate(that).length;\n      var middle = Math.floor(length / 2);\n      var index = 0;\n      var value;\n      while (index < middle) {\n        value = that[index];\n        that[index++] = that[--length];\n        that[length] = value;\n      } return that;\n    },\n    some: function some(callbackfn /* , thisArg */) {\n      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    sort: function sort(comparefn) {\n      return arraySort.call(validate(this), comparefn);\n    },\n    subarray: function subarray(begin, end) {\n      var O = validate(this);\n      var length = O.length;\n      var $begin = toAbsoluteIndex(begin, length);\n      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(\n        O.buffer,\n        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,\n        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)\n      );\n    }\n  };\n\n  var $slice = function slice(start, end) {\n    return speciesFromList(this, arraySlice.call(validate(this), start, end));\n  };\n\n  var $set = function set(arrayLike /* , offset */) {\n    validate(this);\n    var offset = toOffset(arguments[1], 1);\n    var length = this.length;\n    var src = toObject(arrayLike);\n    var len = toLength(src.length);\n    var index = 0;\n    if (len + offset > length) throw RangeError(WRONG_LENGTH);\n    while (index < len) this[offset + index] = src[index++];\n  };\n\n  var $iterators = {\n    entries: function entries() {\n      return arrayEntries.call(validate(this));\n    },\n    keys: function keys() {\n      return arrayKeys.call(validate(this));\n    },\n    values: function values() {\n      return arrayValues.call(validate(this));\n    }\n  };\n\n  var isTAIndex = function (target, key) {\n    return isObject(target)\n      && target[TYPED_ARRAY]\n      && typeof key != 'symbol'\n      && key in target\n      && String(+key) == String(key);\n  };\n  var $getDesc = function getOwnPropertyDescriptor(target, key) {\n    return isTAIndex(target, key = toPrimitive(key, true))\n      ? propertyDesc(2, target[key])\n      : gOPD(target, key);\n  };\n  var $setDesc = function defineProperty(target, key, desc) {\n    if (isTAIndex(target, key = toPrimitive(key, true))\n      && isObject(desc)\n      && has(desc, 'value')\n      && !has(desc, 'get')\n      && !has(desc, 'set')\n      // TODO: add validation descriptor w/o calling accessors\n      && !desc.configurable\n      && (!has(desc, 'writable') || desc.writable)\n      && (!has(desc, 'enumerable') || desc.enumerable)\n    ) {\n      target[key] = desc.value;\n      return target;\n    } return dP(target, key, desc);\n  };\n\n  if (!ALL_CONSTRUCTORS) {\n    $GOPD.f = $getDesc;\n    $DP.f = $setDesc;\n  }\n\n  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {\n    getOwnPropertyDescriptor: $getDesc,\n    defineProperty: $setDesc\n  });\n\n  if (fails(function () { arrayToString.call({}); })) {\n    arrayToString = arrayToLocaleString = function toString() {\n      return arrayJoin.call(this);\n    };\n  }\n\n  var $TypedArrayPrototype$ = redefineAll({}, proto);\n  redefineAll($TypedArrayPrototype$, $iterators);\n  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);\n  redefineAll($TypedArrayPrototype$, {\n    slice: $slice,\n    set: $set,\n    constructor: function () { /* noop */ },\n    toString: arrayToString,\n    toLocaleString: $toLocaleString\n  });\n  addGetter($TypedArrayPrototype$, 'buffer', 'b');\n  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');\n  addGetter($TypedArrayPrototype$, 'byteLength', 'l');\n  addGetter($TypedArrayPrototype$, 'length', 'e');\n  dP($TypedArrayPrototype$, TAG, {\n    get: function () { return this[TYPED_ARRAY]; }\n  });\n\n  // eslint-disable-next-line max-statements\n  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {\n    CLAMPED = !!CLAMPED;\n    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';\n    var GETTER = 'get' + KEY;\n    var SETTER = 'set' + KEY;\n    var TypedArray = global[NAME];\n    var Base = TypedArray || {};\n    var TAC = TypedArray && getPrototypeOf(TypedArray);\n    var FORCED = !TypedArray || !$typed.ABV;\n    var O = {};\n    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];\n    var getter = function (that, index) {\n      var data = that._d;\n      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);\n    };\n    var setter = function (that, index, value) {\n      var data = that._d;\n      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;\n      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);\n    };\n    var addElement = function (that, index) {\n      dP(that, index, {\n        get: function () {\n          return getter(this, index);\n        },\n        set: function (value) {\n          return setter(this, index, value);\n        },\n        enumerable: true\n      });\n    };\n    if (FORCED) {\n      TypedArray = wrapper(function (that, data, $offset, $length) {\n        anInstance(that, TypedArray, NAME, '_d');\n        var index = 0;\n        var offset = 0;\n        var buffer, byteLength, length, klass;\n        if (!isObject(data)) {\n          length = toIndex(data);\n          byteLength = length * BYTES;\n          buffer = new $ArrayBuffer(byteLength);\n        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {\n          buffer = data;\n          offset = toOffset($offset, BYTES);\n          var $len = data.byteLength;\n          if ($length === undefined) {\n            if ($len % BYTES) throw RangeError(WRONG_LENGTH);\n            byteLength = $len - offset;\n            if (byteLength < 0) throw RangeError(WRONG_LENGTH);\n          } else {\n            byteLength = toLength($length) * BYTES;\n            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);\n          }\n          length = byteLength / BYTES;\n        } else if (TYPED_ARRAY in data) {\n          return fromList(TypedArray, data);\n        } else {\n          return $from.call(TypedArray, data);\n        }\n        hide(that, '_d', {\n          b: buffer,\n          o: offset,\n          l: byteLength,\n          e: length,\n          v: new $DataView(buffer)\n        });\n        while (index < length) addElement(that, index++);\n      });\n      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);\n      hide(TypedArrayPrototype, 'constructor', TypedArray);\n    } else if (!fails(function () {\n      TypedArray(1);\n    }) || !fails(function () {\n      new TypedArray(-1); // eslint-disable-line no-new\n    }) || !$iterDetect(function (iter) {\n      new TypedArray(); // eslint-disable-line no-new\n      new TypedArray(null); // eslint-disable-line no-new\n      new TypedArray(1.5); // eslint-disable-line no-new\n      new TypedArray(iter); // eslint-disable-line no-new\n    }, true)) {\n      TypedArray = wrapper(function (that, data, $offset, $length) {\n        anInstance(that, TypedArray, NAME);\n        var klass;\n        // `ws` module bug, temporarily remove validation length for Uint8Array\n        // https://github.com/websockets/ws/pull/645\n        if (!isObject(data)) return new Base(toIndex(data));\n        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {\n          return $length !== undefined\n            ? new Base(data, toOffset($offset, BYTES), $length)\n            : $offset !== undefined\n              ? new Base(data, toOffset($offset, BYTES))\n              : new Base(data);\n        }\n        if (TYPED_ARRAY in data) return fromList(TypedArray, data);\n        return $from.call(TypedArray, data);\n      });\n      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {\n        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);\n      });\n      TypedArray[PROTOTYPE] = TypedArrayPrototype;\n      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;\n    }\n    var $nativeIterator = TypedArrayPrototype[ITERATOR];\n    var CORRECT_ITER_NAME = !!$nativeIterator\n      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);\n    var $iterator = $iterators.values;\n    hide(TypedArray, TYPED_CONSTRUCTOR, true);\n    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);\n    hide(TypedArrayPrototype, VIEW, true);\n    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);\n\n    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {\n      dP(TypedArrayPrototype, TAG, {\n        get: function () { return NAME; }\n      });\n    }\n\n    O[NAME] = TypedArray;\n\n    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);\n\n    $export($export.S, NAME, {\n      BYTES_PER_ELEMENT: BYTES\n    });\n\n    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {\n      from: $from,\n      of: $of\n    });\n\n    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);\n\n    $export($export.P, NAME, proto);\n\n    setSpecies(NAME);\n\n    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });\n\n    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);\n\n    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;\n\n    $export($export.P + $export.F * fails(function () {\n      new TypedArray(1).slice();\n    }), NAME, { slice: $slice });\n\n    $export($export.P + $export.F * (fails(function () {\n      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();\n    }) || !fails(function () {\n      TypedArrayPrototype.toLocaleString.call([1, 2]);\n    })), NAME, { toLocaleString: $toLocaleString });\n\n    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;\n    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);\n  };\n} else module.exports = function () { /* empty */ };\n","'use strict';\nvar global = require('./_global');\nvar DESCRIPTORS = require('./_descriptors');\nvar LIBRARY = require('./_library');\nvar $typed = require('./_typed');\nvar hide = require('./_hide');\nvar redefineAll = require('./_redefine-all');\nvar fails = require('./_fails');\nvar anInstance = require('./_an-instance');\nvar toInteger = require('./_to-integer');\nvar toLength = require('./_to-length');\nvar toIndex = require('./_to-index');\nvar gOPN = require('./_object-gopn').f;\nvar dP = require('./_object-dp').f;\nvar arrayFill = require('./_array-fill');\nvar setToStringTag = require('./_set-to-string-tag');\nvar ARRAY_BUFFER = 'ArrayBuffer';\nvar DATA_VIEW = 'DataView';\nvar PROTOTYPE = 'prototype';\nvar WRONG_LENGTH = 'Wrong length!';\nvar WRONG_INDEX = 'Wrong index!';\nvar $ArrayBuffer = global[ARRAY_BUFFER];\nvar $DataView = global[DATA_VIEW];\nvar Math = global.Math;\nvar RangeError = global.RangeError;\n// eslint-disable-next-line no-shadow-restricted-names\nvar Infinity = global.Infinity;\nvar BaseBuffer = $ArrayBuffer;\nvar abs = Math.abs;\nvar pow = Math.pow;\nvar floor = Math.floor;\nvar log = Math.log;\nvar LN2 = Math.LN2;\nvar BUFFER = 'buffer';\nvar BYTE_LENGTH = 'byteLength';\nvar BYTE_OFFSET = 'byteOffset';\nvar $BUFFER = DESCRIPTORS ? '_b' : BUFFER;\nvar $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;\nvar $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;\n\n// IEEE754 conversions based on https://github.com/feross/ieee754\nfunction packIEEE754(value, mLen, nBytes) {\n  var buffer = new Array(nBytes);\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;\n  var i = 0;\n  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n  var e, m, c;\n  value = abs(value);\n  // eslint-disable-next-line no-self-compare\n  if (value != value || value === Infinity) {\n    // eslint-disable-next-line no-self-compare\n    m = value != value ? 1 : 0;\n    e = eMax;\n  } else {\n    e = floor(log(value) / LN2);\n    if (value * (c = pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * pow(2, eBias - 1) * pow(2, mLen);\n      e = 0;\n    }\n  }\n  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);\n  e = e << mLen | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);\n  buffer[--i] |= s * 128;\n  return buffer;\n}\nfunction unpackIEEE754(buffer, mLen, nBytes) {\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = eLen - 7;\n  var i = nBytes - 1;\n  var s = buffer[i--];\n  var e = s & 127;\n  var m;\n  s >>= 7;\n  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);\n  m = e & (1 << -nBits) - 1;\n  e >>= -nBits;\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : s ? -Infinity : Infinity;\n  } else {\n    m = m + pow(2, mLen);\n    e = e - eBias;\n  } return (s ? -1 : 1) * m * pow(2, e - mLen);\n}\n\nfunction unpackI32(bytes) {\n  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];\n}\nfunction packI8(it) {\n  return [it & 0xff];\n}\nfunction packI16(it) {\n  return [it & 0xff, it >> 8 & 0xff];\n}\nfunction packI32(it) {\n  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];\n}\nfunction packF64(it) {\n  return packIEEE754(it, 52, 8);\n}\nfunction packF32(it) {\n  return packIEEE754(it, 23, 4);\n}\n\nfunction addGetter(C, key, internal) {\n  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });\n}\n\nfunction get(view, bytes, index, isLittleEndian) {\n  var numIndex = +index;\n  var intIndex = toIndex(numIndex);\n  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);\n  var store = view[$BUFFER]._b;\n  var start = intIndex + view[$OFFSET];\n  var pack = store.slice(start, start + bytes);\n  return isLittleEndian ? pack : pack.reverse();\n}\nfunction set(view, bytes, index, conversion, value, isLittleEndian) {\n  var numIndex = +index;\n  var intIndex = toIndex(numIndex);\n  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);\n  var store = view[$BUFFER]._b;\n  var start = intIndex + view[$OFFSET];\n  var pack = conversion(+value);\n  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];\n}\n\nif (!$typed.ABV) {\n  $ArrayBuffer = function ArrayBuffer(length) {\n    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);\n    var byteLength = toIndex(length);\n    this._b = arrayFill.call(new Array(byteLength), 0);\n    this[$LENGTH] = byteLength;\n  };\n\n  $DataView = function DataView(buffer, byteOffset, byteLength) {\n    anInstance(this, $DataView, DATA_VIEW);\n    anInstance(buffer, $ArrayBuffer, DATA_VIEW);\n    var bufferLength = buffer[$LENGTH];\n    var offset = toInteger(byteOffset);\n    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');\n    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);\n    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);\n    this[$BUFFER] = buffer;\n    this[$OFFSET] = offset;\n    this[$LENGTH] = byteLength;\n  };\n\n  if (DESCRIPTORS) {\n    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');\n    addGetter($DataView, BUFFER, '_b');\n    addGetter($DataView, BYTE_LENGTH, '_l');\n    addGetter($DataView, BYTE_OFFSET, '_o');\n  }\n\n  redefineAll($DataView[PROTOTYPE], {\n    getInt8: function getInt8(byteOffset) {\n      return get(this, 1, byteOffset)[0] << 24 >> 24;\n    },\n    getUint8: function getUint8(byteOffset) {\n      return get(this, 1, byteOffset)[0];\n    },\n    getInt16: function getInt16(byteOffset /* , littleEndian */) {\n      var bytes = get(this, 2, byteOffset, arguments[1]);\n      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;\n    },\n    getUint16: function getUint16(byteOffset /* , littleEndian */) {\n      var bytes = get(this, 2, byteOffset, arguments[1]);\n      return bytes[1] << 8 | bytes[0];\n    },\n    getInt32: function getInt32(byteOffset /* , littleEndian */) {\n      return unpackI32(get(this, 4, byteOffset, arguments[1]));\n    },\n    getUint32: function getUint32(byteOffset /* , littleEndian */) {\n      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;\n    },\n    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {\n      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);\n    },\n    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {\n      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);\n    },\n    setInt8: function setInt8(byteOffset, value) {\n      set(this, 1, byteOffset, packI8, value);\n    },\n    setUint8: function setUint8(byteOffset, value) {\n      set(this, 1, byteOffset, packI8, value);\n    },\n    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {\n      set(this, 2, byteOffset, packI16, value, arguments[2]);\n    },\n    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {\n      set(this, 2, byteOffset, packI16, value, arguments[2]);\n    },\n    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packI32, value, arguments[2]);\n    },\n    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packI32, value, arguments[2]);\n    },\n    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packF32, value, arguments[2]);\n    },\n    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {\n      set(this, 8, byteOffset, packF64, value, arguments[2]);\n    }\n  });\n} else {\n  if (!fails(function () {\n    $ArrayBuffer(1);\n  }) || !fails(function () {\n    new $ArrayBuffer(-1); // eslint-disable-line no-new\n  }) || fails(function () {\n    new $ArrayBuffer(); // eslint-disable-line no-new\n    new $ArrayBuffer(1.5); // eslint-disable-line no-new\n    new $ArrayBuffer(NaN); // eslint-disable-line no-new\n    return $ArrayBuffer.name != ARRAY_BUFFER;\n  })) {\n    $ArrayBuffer = function ArrayBuffer(length) {\n      anInstance(this, $ArrayBuffer);\n      return new BaseBuffer(toIndex(length));\n    };\n    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];\n    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {\n      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);\n    }\n    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;\n  }\n  // iOS Safari 7.x bug\n  var view = new $DataView(new $ArrayBuffer(2));\n  var $setInt8 = $DataView[PROTOTYPE].setInt8;\n  view.setInt8(0, 2147483648);\n  view.setInt8(1, 2147483649);\n  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {\n    setInt8: function setInt8(byteOffset, value) {\n      $setInt8.call(this, byteOffset, value << 24 >> 24);\n    },\n    setUint8: function setUint8(byteOffset, value) {\n      $setInt8.call(this, byteOffset, value << 24 >> 24);\n    }\n  }, true);\n}\nsetToStringTag($ArrayBuffer, ARRAY_BUFFER);\nsetToStringTag($DataView, DATA_VIEW);\nhide($DataView[PROTOTYPE], $typed.VIEW, true);\nexports[ARRAY_BUFFER] = $ArrayBuffer;\nexports[DATA_VIEW] = $DataView;\n","var global = require('./_global');\nvar hide = require('./_hide');\nvar uid = require('./_uid');\nvar TYPED = uid('typed_array');\nvar VIEW = uid('view');\nvar ABV = !!(global.ArrayBuffer && global.DataView);\nvar CONSTR = ABV;\nvar i = 0;\nvar l = 9;\nvar Typed;\n\nvar TypedArrayConstructors = (\n  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'\n).split(',');\n\nwhile (i < l) {\n  if (Typed = global[TypedArrayConstructors[i++]]) {\n    hide(Typed.prototype, TYPED, true);\n    hide(Typed.prototype, VIEW, true);\n  } else CONSTR = false;\n}\n\nmodule.exports = {\n  ABV: ABV,\n  CONSTR: CONSTR,\n  TYPED: TYPED,\n  VIEW: VIEW\n};\n","var id = 0;\nvar px = Math.random();\nmodule.exports = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n","var global = require('./_global');\nvar navigator = global.navigator;\n\nmodule.exports = navigator && navigator.userAgent || '';\n","var isObject = require('./_is-object');\nmodule.exports = function (it, TYPE) {\n  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');\n  return it;\n};\n","var global = require('./_global');\nvar core = require('./_core');\nvar LIBRARY = require('./_library');\nvar wksExt = require('./_wks-ext');\nvar defineProperty = require('./_object-dp').f;\nmodule.exports = function (name) {\n  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\n  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });\n};\n","exports.f = require('./_wks');\n","var store = require('./_shared')('wks');\nvar uid = require('./_uid');\nvar Symbol = require('./_global').Symbol;\nvar USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function (name) {\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n","var classof = require('./_classof');\nvar ITERATOR = require('./_wks')('iterator');\nvar Iterators = require('./_iterators');\nmodule.exports = require('./_core').getIteratorMethod = function (it) {\n  if (it != undefined) return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n","// https://github.com/benjamingr/RexExp.escape\nvar $export = require('./_export');\nvar $re = require('./_replacer')(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n\n$export($export.S, 'RegExp', { escape: function escape(it) { return $re(it); } });\n","// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)\nvar $export = require('./_export');\n\n$export($export.P, 'Array', { copyWithin: require('./_array-copy-within') });\n\nrequire('./_add-to-unscopables')('copyWithin');\n","'use strict';\nvar $export = require('./_export');\nvar $every = require('./_array-methods')(4);\n\n$export($export.P + $export.F * !require('./_strict-method')([].every, true), 'Array', {\n  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])\n  every: function every(callbackfn /* , thisArg */) {\n    return $every(this, callbackfn, arguments[1]);\n  }\n});\n","// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)\nvar $export = require('./_export');\n\n$export($export.P, 'Array', { fill: require('./_array-fill') });\n\nrequire('./_add-to-unscopables')('fill');\n","'use strict';\nvar $export = require('./_export');\nvar $filter = require('./_array-methods')(2);\n\n$export($export.P + $export.F * !require('./_strict-method')([].filter, true), 'Array', {\n  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])\n  filter: function filter(callbackfn /* , thisArg */) {\n    return $filter(this, callbackfn, arguments[1]);\n  }\n});\n","'use strict';\n// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)\nvar $export = require('./_export');\nvar $find = require('./_array-methods')(6);\nvar KEY = 'findIndex';\nvar forced = true;\n// Shouldn't skip holes\nif (KEY in []) Array(1)[KEY](function () { forced = false; });\n$export($export.P + $export.F * forced, 'Array', {\n  findIndex: function findIndex(callbackfn /* , that = undefined */) {\n    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\nrequire('./_add-to-unscopables')(KEY);\n","'use strict';\n// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)\nvar $export = require('./_export');\nvar $find = require('./_array-methods')(5);\nvar KEY = 'find';\nvar forced = true;\n// Shouldn't skip holes\nif (KEY in []) Array(1)[KEY](function () { forced = false; });\n$export($export.P + $export.F * forced, 'Array', {\n  find: function find(callbackfn /* , that = undefined */) {\n    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\nrequire('./_add-to-unscopables')(KEY);\n","'use strict';\nvar $export = require('./_export');\nvar $forEach = require('./_array-methods')(0);\nvar STRICT = require('./_strict-method')([].forEach, true);\n\n$export($export.P + $export.F * !STRICT, 'Array', {\n  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])\n  forEach: function forEach(callbackfn /* , thisArg */) {\n    return $forEach(this, callbackfn, arguments[1]);\n  }\n});\n","'use strict';\nvar ctx = require('./_ctx');\nvar $export = require('./_export');\nvar toObject = require('./_to-object');\nvar call = require('./_iter-call');\nvar isArrayIter = require('./_is-array-iter');\nvar toLength = require('./_to-length');\nvar createProperty = require('./_create-property');\nvar getIterFn = require('./core.get-iterator-method');\n\n$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {\n  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\n  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n    var O = toObject(arrayLike);\n    var C = typeof this == 'function' ? this : Array;\n    var aLen = arguments.length;\n    var mapfn = aLen > 1 ? arguments[1] : undefined;\n    var mapping = mapfn !== undefined;\n    var index = 0;\n    var iterFn = getIterFn(O);\n    var length, result, step, iterator;\n    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);\n    // if object isn't iterable or it's array with default iterator - use simple case\n    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {\n      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {\n        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);\n      }\n    } else {\n      length = toLength(O.length);\n      for (result = new C(length); length > index; index++) {\n        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n      }\n    }\n    result.length = index;\n    return result;\n  }\n});\n","'use strict';\nvar $export = require('./_export');\nvar $indexOf = require('./_array-includes')(false);\nvar $native = [].indexOf;\nvar NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;\n\n$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {\n  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])\n  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {\n    return NEGATIVE_ZERO\n      // convert -0 to +0\n      ? $native.apply(this, arguments) || 0\n      : $indexOf(this, searchElement, arguments[1]);\n  }\n});\n","// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)\nvar $export = require('./_export');\n\n$export($export.S, 'Array', { isArray: require('./_is-array') });\n","'use strict';\nvar addToUnscopables = require('./_add-to-unscopables');\nvar step = require('./_iter-step');\nvar Iterators = require('./_iterators');\nvar toIObject = require('./_to-iobject');\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var kind = this._k;\n  var index = this._i++;\n  if (!O || index >= O.length) {\n    this._t = undefined;\n    return step(1);\n  }\n  if (kind == 'keys') return step(0, index);\n  if (kind == 'values') return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n","'use strict';\n// 22.1.3.13 Array.prototype.join(separator)\nvar $export = require('./_export');\nvar toIObject = require('./_to-iobject');\nvar arrayJoin = [].join;\n\n// fallback for not array-like strings\n$export($export.P + $export.F * (require('./_iobject') != Object || !require('./_strict-method')(arrayJoin)), 'Array', {\n  join: function join(separator) {\n    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);\n  }\n});\n","'use strict';\nvar $export = require('./_export');\nvar toIObject = require('./_to-iobject');\nvar toInteger = require('./_to-integer');\nvar toLength = require('./_to-length');\nvar $native = [].lastIndexOf;\nvar NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;\n\n$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {\n  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])\n  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {\n    // convert -0 to +0\n    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;\n    var O = toIObject(this);\n    var length = toLength(O.length);\n    var index = length - 1;\n    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));\n    if (index < 0) index = length + index;\n    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;\n    return -1;\n  }\n});\n","'use strict';\nvar $export = require('./_export');\nvar $map = require('./_array-methods')(1);\n\n$export($export.P + $export.F * !require('./_strict-method')([].map, true), 'Array', {\n  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])\n  map: function map(callbackfn /* , thisArg */) {\n    return $map(this, callbackfn, arguments[1]);\n  }\n});\n","'use strict';\nvar $export = require('./_export');\nvar createProperty = require('./_create-property');\n\n// WebKit Array.of isn't generic\n$export($export.S + $export.F * require('./_fails')(function () {\n  function F() { /* empty */ }\n  return !(Array.of.call(F) instanceof F);\n}), 'Array', {\n  // 22.1.2.3 Array.of( ...items)\n  of: function of(/* ...args */) {\n    var index = 0;\n    var aLen = arguments.length;\n    var result = new (typeof this == 'function' ? this : Array)(aLen);\n    while (aLen > index) createProperty(result, index, arguments[index++]);\n    result.length = aLen;\n    return result;\n  }\n});\n","'use strict';\nvar $export = require('./_export');\nvar $reduce = require('./_array-reduce');\n\n$export($export.P + $export.F * !require('./_strict-method')([].reduceRight, true), 'Array', {\n  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])\n  reduceRight: function reduceRight(callbackfn /* , initialValue */) {\n    return $reduce(this, callbackfn, arguments.length, arguments[1], true);\n  }\n});\n","'use strict';\nvar $export = require('./_export');\nvar $reduce = require('./_array-reduce');\n\n$export($export.P + $export.F * !require('./_strict-method')([].reduce, true), 'Array', {\n  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])\n  reduce: function reduce(callbackfn /* , initialValue */) {\n    return $reduce(this, callbackfn, arguments.length, arguments[1], false);\n  }\n});\n","'use strict';\nvar $export = require('./_export');\nvar html = require('./_html');\nvar cof = require('./_cof');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nvar toLength = require('./_to-length');\nvar arraySlice = [].slice;\n\n// fallback for not array-like ES3 strings and DOM objects\n$export($export.P + $export.F * require('./_fails')(function () {\n  if (html) arraySlice.call(html);\n}), 'Array', {\n  slice: function slice(begin, end) {\n    var len = toLength(this.length);\n    var klass = cof(this);\n    end = end === undefined ? len : end;\n    if (klass == 'Array') return arraySlice.call(this, begin, end);\n    var start = toAbsoluteIndex(begin, len);\n    var upTo = toAbsoluteIndex(end, len);\n    var size = toLength(upTo - start);\n    var cloned = new Array(size);\n    var i = 0;\n    for (; i < size; i++) cloned[i] = klass == 'String'\n      ? this.charAt(start + i)\n      : this[start + i];\n    return cloned;\n  }\n});\n","'use strict';\nvar $export = require('./_export');\nvar $some = require('./_array-methods')(3);\n\n$export($export.P + $export.F * !require('./_strict-method')([].some, true), 'Array', {\n  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])\n  some: function some(callbackfn /* , thisArg */) {\n    return $some(this, callbackfn, arguments[1]);\n  }\n});\n","'use strict';\nvar $export = require('./_export');\nvar aFunction = require('./_a-function');\nvar toObject = require('./_to-object');\nvar fails = require('./_fails');\nvar $sort = [].sort;\nvar test = [1, 2, 3];\n\n$export($export.P + $export.F * (fails(function () {\n  // IE8-\n  test.sort(undefined);\n}) || !fails(function () {\n  // V8 bug\n  test.sort(null);\n  // Old WebKit\n}) || !require('./_strict-method')($sort)), 'Array', {\n  // 22.1.3.25 Array.prototype.sort(comparefn)\n  sort: function sort(comparefn) {\n    return comparefn === undefined\n      ? $sort.call(toObject(this))\n      : $sort.call(toObject(this), aFunction(comparefn));\n  }\n});\n","require('./_set-species')('Array');\n","// 20.3.3.1 / 15.9.4.4 Date.now()\nvar $export = require('./_export');\n\n$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });\n","// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()\nvar $export = require('./_export');\nvar toISOString = require('./_date-to-iso-string');\n\n// PhantomJS / old WebKit has a broken implementations\n$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {\n  toISOString: toISOString\n});\n","'use strict';\nvar $export = require('./_export');\nvar toObject = require('./_to-object');\nvar toPrimitive = require('./_to-primitive');\n\n$export($export.P + $export.F * require('./_fails')(function () {\n  return new Date(NaN).toJSON() !== null\n    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;\n}), 'Date', {\n  // eslint-disable-next-line no-unused-vars\n  toJSON: function toJSON(key) {\n    var O = toObject(this);\n    var pv = toPrimitive(O);\n    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();\n  }\n});\n","var TO_PRIMITIVE = require('./_wks')('toPrimitive');\nvar proto = Date.prototype;\n\nif (!(TO_PRIMITIVE in proto)) require('./_hide')(proto, TO_PRIMITIVE, require('./_date-to-primitive'));\n","var DateProto = Date.prototype;\nvar INVALID_DATE = 'Invalid Date';\nvar TO_STRING = 'toString';\nvar $toString = DateProto[TO_STRING];\nvar getTime = DateProto.getTime;\nif (new Date(NaN) + '' != INVALID_DATE) {\n  require('./_redefine')(DateProto, TO_STRING, function toString() {\n    var value = getTime.call(this);\n    // eslint-disable-next-line no-self-compare\n    return value === value ? $toString.call(this) : INVALID_DATE;\n  });\n}\n","// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)\nvar $export = require('./_export');\n\n$export($export.P, 'Function', { bind: require('./_bind') });\n","'use strict';\nvar isObject = require('./_is-object');\nvar getPrototypeOf = require('./_object-gpo');\nvar HAS_INSTANCE = require('./_wks')('hasInstance');\nvar FunctionProto = Function.prototype;\n// 19.2.3.6 Function.prototype[@@hasInstance](V)\nif (!(HAS_INSTANCE in FunctionProto)) require('./_object-dp').f(FunctionProto, HAS_INSTANCE, { value: function (O) {\n  if (typeof this != 'function' || !isObject(O)) return false;\n  if (!isObject(this.prototype)) return O instanceof this;\n  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:\n  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;\n  return false;\n} });\n","var dP = require('./_object-dp').f;\nvar FProto = Function.prototype;\nvar nameRE = /^\\s*function ([^ (]*)/;\nvar NAME = 'name';\n\n// 19.2.4.2 name\nNAME in FProto || require('./_descriptors') && dP(FProto, NAME, {\n  configurable: true,\n  get: function () {\n    try {\n      return ('' + this).match(nameRE)[1];\n    } catch (e) {\n      return '';\n    }\n  }\n});\n","'use strict';\nvar strong = require('./_collection-strong');\nvar validate = require('./_validate-collection');\nvar MAP = 'Map';\n\n// 23.1 Map Objects\nmodule.exports = require('./_collection')(MAP, function (get) {\n  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.1.3.6 Map.prototype.get(key)\n  get: function get(key) {\n    var entry = strong.getEntry(validate(this, MAP), key);\n    return entry && entry.v;\n  },\n  // 23.1.3.9 Map.prototype.set(key, value)\n  set: function set(key, value) {\n    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);\n  }\n}, strong, true);\n","// 20.2.2.3 Math.acosh(x)\nvar $export = require('./_export');\nvar log1p = require('./_math-log1p');\nvar sqrt = Math.sqrt;\nvar $acosh = Math.acosh;\n\n$export($export.S + $export.F * !($acosh\n  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509\n  && Math.floor($acosh(Number.MAX_VALUE)) == 710\n  // Tor Browser bug: Math.acosh(Infinity) -> NaN\n  && $acosh(Infinity) == Infinity\n), 'Math', {\n  acosh: function acosh(x) {\n    return (x = +x) < 1 ? NaN : x > 94906265.62425156\n      ? Math.log(x) + Math.LN2\n      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));\n  }\n});\n","// 20.2.2.5 Math.asinh(x)\nvar $export = require('./_export');\nvar $asinh = Math.asinh;\n\nfunction asinh(x) {\n  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));\n}\n\n// Tor Browser bug: Math.asinh(0) -> -0\n$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });\n","// 20.2.2.7 Math.atanh(x)\nvar $export = require('./_export');\nvar $atanh = Math.atanh;\n\n// Tor Browser bug: Math.atanh(-0) -> 0\n$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {\n  atanh: function atanh(x) {\n    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;\n  }\n});\n","// 20.2.2.9 Math.cbrt(x)\nvar $export = require('./_export');\nvar sign = require('./_math-sign');\n\n$export($export.S, 'Math', {\n  cbrt: function cbrt(x) {\n    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);\n  }\n});\n","// 20.2.2.11 Math.clz32(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  clz32: function clz32(x) {\n    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;\n  }\n});\n","// 20.2.2.12 Math.cosh(x)\nvar $export = require('./_export');\nvar exp = Math.exp;\n\n$export($export.S, 'Math', {\n  cosh: function cosh(x) {\n    return (exp(x = +x) + exp(-x)) / 2;\n  }\n});\n","// 20.2.2.14 Math.expm1(x)\nvar $export = require('./_export');\nvar $expm1 = require('./_math-expm1');\n\n$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });\n","// 20.2.2.16 Math.fround(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', { fround: require('./_math-fround') });\n","// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])\nvar $export = require('./_export');\nvar abs = Math.abs;\n\n$export($export.S, 'Math', {\n  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars\n    var sum = 0;\n    var i = 0;\n    var aLen = arguments.length;\n    var larg = 0;\n    var arg, div;\n    while (i < aLen) {\n      arg = abs(arguments[i++]);\n      if (larg < arg) {\n        div = larg / arg;\n        sum = sum * div * div + 1;\n        larg = arg;\n      } else if (arg > 0) {\n        div = arg / larg;\n        sum += div * div;\n      } else sum += arg;\n    }\n    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);\n  }\n});\n","// 20.2.2.18 Math.imul(x, y)\nvar $export = require('./_export');\nvar $imul = Math.imul;\n\n// some WebKit versions fails with big numbers, some has wrong arity\n$export($export.S + $export.F * require('./_fails')(function () {\n  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;\n}), 'Math', {\n  imul: function imul(x, y) {\n    var UINT16 = 0xffff;\n    var xn = +x;\n    var yn = +y;\n    var xl = UINT16 & xn;\n    var yl = UINT16 & yn;\n    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);\n  }\n});\n","// 20.2.2.21 Math.log10(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  log10: function log10(x) {\n    return Math.log(x) * Math.LOG10E;\n  }\n});\n","// 20.2.2.20 Math.log1p(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', { log1p: require('./_math-log1p') });\n","// 20.2.2.22 Math.log2(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  log2: function log2(x) {\n    return Math.log(x) / Math.LN2;\n  }\n});\n","// 20.2.2.28 Math.sign(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', { sign: require('./_math-sign') });\n","// 20.2.2.30 Math.sinh(x)\nvar $export = require('./_export');\nvar expm1 = require('./_math-expm1');\nvar exp = Math.exp;\n\n// V8 near Chromium 38 has a problem with very small numbers\n$export($export.S + $export.F * require('./_fails')(function () {\n  return !Math.sinh(-2e-17) != -2e-17;\n}), 'Math', {\n  sinh: function sinh(x) {\n    return Math.abs(x = +x) < 1\n      ? (expm1(x) - expm1(-x)) / 2\n      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);\n  }\n});\n","// 20.2.2.33 Math.tanh(x)\nvar $export = require('./_export');\nvar expm1 = require('./_math-expm1');\nvar exp = Math.exp;\n\n$export($export.S, 'Math', {\n  tanh: function tanh(x) {\n    var a = expm1(x = +x);\n    var b = expm1(-x);\n    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));\n  }\n});\n","// 20.2.2.34 Math.trunc(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  trunc: function trunc(it) {\n    return (it > 0 ? Math.floor : Math.ceil)(it);\n  }\n});\n","'use strict';\nvar global = require('./_global');\nvar has = require('./_has');\nvar cof = require('./_cof');\nvar inheritIfRequired = require('./_inherit-if-required');\nvar toPrimitive = require('./_to-primitive');\nvar fails = require('./_fails');\nvar gOPN = require('./_object-gopn').f;\nvar gOPD = require('./_object-gopd').f;\nvar dP = require('./_object-dp').f;\nvar $trim = require('./_string-trim').trim;\nvar NUMBER = 'Number';\nvar $Number = global[NUMBER];\nvar Base = $Number;\nvar proto = $Number.prototype;\n// Opera ~12 has broken Object#toString\nvar BROKEN_COF = cof(require('./_object-create')(proto)) == NUMBER;\nvar TRIM = 'trim' in String.prototype;\n\n// 7.1.3 ToNumber(argument)\nvar toNumber = function (argument) {\n  var it = toPrimitive(argument, false);\n  if (typeof it == 'string' && it.length > 2) {\n    it = TRIM ? it.trim() : $trim(it, 3);\n    var first = it.charCodeAt(0);\n    var third, radix, maxCode;\n    if (first === 43 || first === 45) {\n      third = it.charCodeAt(2);\n      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix\n    } else if (first === 48) {\n      switch (it.charCodeAt(1)) {\n        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i\n        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i\n        default: return +it;\n      }\n      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {\n        code = digits.charCodeAt(i);\n        // parseInt parses a string to a first unavailable symbol\n        // but ToNumber should return NaN if a string contains unavailable symbols\n        if (code < 48 || code > maxCode) return NaN;\n      } return parseInt(digits, radix);\n    }\n  } return +it;\n};\n\nif (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {\n  $Number = function Number(value) {\n    var it = arguments.length < 1 ? 0 : value;\n    var that = this;\n    return that instanceof $Number\n      // check on 1..constructor(foo) case\n      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)\n        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);\n  };\n  for (var keys = require('./_descriptors') ? gOPN(Base) : (\n    // ES3:\n    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +\n    // ES6 (in case, if modules with ES6 Number statics required before):\n    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +\n    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'\n  ).split(','), j = 0, key; keys.length > j; j++) {\n    if (has(Base, key = keys[j]) && !has($Number, key)) {\n      dP($Number, key, gOPD(Base, key));\n    }\n  }\n  $Number.prototype = proto;\n  proto.constructor = $Number;\n  require('./_redefine')(global, NUMBER, $Number);\n}\n","// 20.1.2.1 Number.EPSILON\nvar $export = require('./_export');\n\n$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });\n","// 20.1.2.2 Number.isFinite(number)\nvar $export = require('./_export');\nvar _isFinite = require('./_global').isFinite;\n\n$export($export.S, 'Number', {\n  isFinite: function isFinite(it) {\n    return typeof it == 'number' && _isFinite(it);\n  }\n});\n","// 20.1.2.3 Number.isInteger(number)\nvar $export = require('./_export');\n\n$export($export.S, 'Number', { isInteger: require('./_is-integer') });\n","// 20.1.2.4 Number.isNaN(number)\nvar $export = require('./_export');\n\n$export($export.S, 'Number', {\n  isNaN: function isNaN(number) {\n    // eslint-disable-next-line no-self-compare\n    return number != number;\n  }\n});\n","// 20.1.2.5 Number.isSafeInteger(number)\nvar $export = require('./_export');\nvar isInteger = require('./_is-integer');\nvar abs = Math.abs;\n\n$export($export.S, 'Number', {\n  isSafeInteger: function isSafeInteger(number) {\n    return isInteger(number) && abs(number) <= 0x1fffffffffffff;\n  }\n});\n","// 20.1.2.6 Number.MAX_SAFE_INTEGER\nvar $export = require('./_export');\n\n$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });\n","// 20.1.2.10 Number.MIN_SAFE_INTEGER\nvar $export = require('./_export');\n\n$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });\n","var $export = require('./_export');\nvar $parseFloat = require('./_parse-float');\n// 20.1.2.12 Number.parseFloat(string)\n$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });\n","var $export = require('./_export');\nvar $parseInt = require('./_parse-int');\n// 20.1.2.13 Number.parseInt(string, radix)\n$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });\n","'use strict';\nvar $export = require('./_export');\nvar toInteger = require('./_to-integer');\nvar aNumberValue = require('./_a-number-value');\nvar repeat = require('./_string-repeat');\nvar $toFixed = 1.0.toFixed;\nvar floor = Math.floor;\nvar data = [0, 0, 0, 0, 0, 0];\nvar ERROR = 'Number.toFixed: incorrect invocation!';\nvar ZERO = '0';\n\nvar multiply = function (n, c) {\n  var i = -1;\n  var c2 = c;\n  while (++i < 6) {\n    c2 += n * data[i];\n    data[i] = c2 % 1e7;\n    c2 = floor(c2 / 1e7);\n  }\n};\nvar divide = function (n) {\n  var i = 6;\n  var c = 0;\n  while (--i >= 0) {\n    c += data[i];\n    data[i] = floor(c / n);\n    c = (c % n) * 1e7;\n  }\n};\nvar numToString = function () {\n  var i = 6;\n  var s = '';\n  while (--i >= 0) {\n    if (s !== '' || i === 0 || data[i] !== 0) {\n      var t = String(data[i]);\n      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;\n    }\n  } return s;\n};\nvar pow = function (x, n, acc) {\n  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);\n};\nvar log = function (x) {\n  var n = 0;\n  var x2 = x;\n  while (x2 >= 4096) {\n    n += 12;\n    x2 /= 4096;\n  }\n  while (x2 >= 2) {\n    n += 1;\n    x2 /= 2;\n  } return n;\n};\n\n$export($export.P + $export.F * (!!$toFixed && (\n  0.00008.toFixed(3) !== '0.000' ||\n  0.9.toFixed(0) !== '1' ||\n  1.255.toFixed(2) !== '1.25' ||\n  1000000000000000128.0.toFixed(0) !== '1000000000000000128'\n) || !require('./_fails')(function () {\n  // V8 ~ Android 4.3-\n  $toFixed.call({});\n})), 'Number', {\n  toFixed: function toFixed(fractionDigits) {\n    var x = aNumberValue(this, ERROR);\n    var f = toInteger(fractionDigits);\n    var s = '';\n    var m = ZERO;\n    var e, z, j, k;\n    if (f < 0 || f > 20) throw RangeError(ERROR);\n    // eslint-disable-next-line no-self-compare\n    if (x != x) return 'NaN';\n    if (x <= -1e21 || x >= 1e21) return String(x);\n    if (x < 0) {\n      s = '-';\n      x = -x;\n    }\n    if (x > 1e-21) {\n      e = log(x * pow(2, 69, 1)) - 69;\n      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);\n      z *= 0x10000000000000;\n      e = 52 - e;\n      if (e > 0) {\n        multiply(0, z);\n        j = f;\n        while (j >= 7) {\n          multiply(1e7, 0);\n          j -= 7;\n        }\n        multiply(pow(10, j, 1), 0);\n        j = e - 1;\n        while (j >= 23) {\n          divide(1 << 23);\n          j -= 23;\n        }\n        divide(1 << j);\n        multiply(1, 1);\n        divide(2);\n        m = numToString();\n      } else {\n        multiply(0, z);\n        multiply(1 << -e, 0);\n        m = numToString() + repeat.call(ZERO, f);\n      }\n    }\n    if (f > 0) {\n      k = m.length;\n      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));\n    } else {\n      m = s + m;\n    } return m;\n  }\n});\n","'use strict';\nvar $export = require('./_export');\nvar $fails = require('./_fails');\nvar aNumberValue = require('./_a-number-value');\nvar $toPrecision = 1.0.toPrecision;\n\n$export($export.P + $export.F * ($fails(function () {\n  // IE7-\n  return $toPrecision.call(1, undefined) !== '1';\n}) || !$fails(function () {\n  // V8 ~ Android 4.3-\n  $toPrecision.call({});\n})), 'Number', {\n  toPrecision: function toPrecision(precision) {\n    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');\n    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);\n  }\n});\n","// 19.1.3.1 Object.assign(target, source)\nvar $export = require('./_export');\n\n$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });\n","var $export = require('./_export');\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n$export($export.S, 'Object', { create: require('./_object-create') });\n","var $export = require('./_export');\n// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)\n$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperties: require('./_object-dps') });\n","var $export = require('./_export');\n// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)\n$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });\n","// 19.1.2.5 Object.freeze(O)\nvar isObject = require('./_is-object');\nvar meta = require('./_meta').onFreeze;\n\nrequire('./_object-sap')('freeze', function ($freeze) {\n  return function freeze(it) {\n    return $freeze && isObject(it) ? $freeze(meta(it)) : it;\n  };\n});\n","// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\nvar toIObject = require('./_to-iobject');\nvar $getOwnPropertyDescriptor = require('./_object-gopd').f;\n\nrequire('./_object-sap')('getOwnPropertyDescriptor', function () {\n  return function getOwnPropertyDescriptor(it, key) {\n    return $getOwnPropertyDescriptor(toIObject(it), key);\n  };\n});\n","// 19.1.2.7 Object.getOwnPropertyNames(O)\nrequire('./_object-sap')('getOwnPropertyNames', function () {\n  return require('./_object-gopn-ext').f;\n});\n","// 19.1.2.9 Object.getPrototypeOf(O)\nvar toObject = require('./_to-object');\nvar $getPrototypeOf = require('./_object-gpo');\n\nrequire('./_object-sap')('getPrototypeOf', function () {\n  return function getPrototypeOf(it) {\n    return $getPrototypeOf(toObject(it));\n  };\n});\n","// 19.1.2.11 Object.isExtensible(O)\nvar isObject = require('./_is-object');\n\nrequire('./_object-sap')('isExtensible', function ($isExtensible) {\n  return function isExtensible(it) {\n    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;\n  };\n});\n","// 19.1.2.12 Object.isFrozen(O)\nvar isObject = require('./_is-object');\n\nrequire('./_object-sap')('isFrozen', function ($isFrozen) {\n  return function isFrozen(it) {\n    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;\n  };\n});\n","// 19.1.2.13 Object.isSealed(O)\nvar isObject = require('./_is-object');\n\nrequire('./_object-sap')('isSealed', function ($isSealed) {\n  return function isSealed(it) {\n    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;\n  };\n});\n","// 19.1.3.10 Object.is(value1, value2)\nvar $export = require('./_export');\n$export($export.S, 'Object', { is: require('./_same-value') });\n","// 19.1.2.14 Object.keys(O)\nvar toObject = require('./_to-object');\nvar $keys = require('./_object-keys');\n\nrequire('./_object-sap')('keys', function () {\n  return function keys(it) {\n    return $keys(toObject(it));\n  };\n});\n","// 19.1.2.15 Object.preventExtensions(O)\nvar isObject = require('./_is-object');\nvar meta = require('./_meta').onFreeze;\n\nrequire('./_object-sap')('preventExtensions', function ($preventExtensions) {\n  return function preventExtensions(it) {\n    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;\n  };\n});\n","// 19.1.2.17 Object.seal(O)\nvar isObject = require('./_is-object');\nvar meta = require('./_meta').onFreeze;\n\nrequire('./_object-sap')('seal', function ($seal) {\n  return function seal(it) {\n    return $seal && isObject(it) ? $seal(meta(it)) : it;\n  };\n});\n","// 19.1.3.19 Object.setPrototypeOf(O, proto)\nvar $export = require('./_export');\n$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });\n","'use strict';\n// 19.1.3.6 Object.prototype.toString()\nvar classof = require('./_classof');\nvar test = {};\ntest[require('./_wks')('toStringTag')] = 'z';\nif (test + '' != '[object z]') {\n  require('./_redefine')(Object.prototype, 'toString', function toString() {\n    return '[object ' + classof(this) + ']';\n  }, true);\n}\n","var $export = require('./_export');\nvar $parseFloat = require('./_parse-float');\n// 18.2.4 parseFloat(string)\n$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });\n","var $export = require('./_export');\nvar $parseInt = require('./_parse-int');\n// 18.2.5 parseInt(string, radix)\n$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });\n","'use strict';\nvar LIBRARY = require('./_library');\nvar global = require('./_global');\nvar ctx = require('./_ctx');\nvar classof = require('./_classof');\nvar $export = require('./_export');\nvar isObject = require('./_is-object');\nvar aFunction = require('./_a-function');\nvar anInstance = require('./_an-instance');\nvar forOf = require('./_for-of');\nvar speciesConstructor = require('./_species-constructor');\nvar task = require('./_task').set;\nvar microtask = require('./_microtask')();\nvar newPromiseCapabilityModule = require('./_new-promise-capability');\nvar perform = require('./_perform');\nvar promiseResolve = require('./_promise-resolve');\nvar PROMISE = 'Promise';\nvar TypeError = global.TypeError;\nvar process = global.process;\nvar $Promise = global[PROMISE];\nvar isNode = classof(process) == 'process';\nvar empty = function () { /* empty */ };\nvar Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;\nvar newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;\n\nvar USE_NATIVE = !!function () {\n  try {\n    // correct subclassing with @@species support\n    var promise = $Promise.resolve(1);\n    var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {\n      exec(empty, empty);\n    };\n    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;\n  } catch (e) { /* empty */ }\n}();\n\n// helpers\nvar isThenable = function (it) {\n  var then;\n  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n};\nvar notify = function (promise, isReject) {\n  if (promise._n) return;\n  promise._n = true;\n  var chain = promise._c;\n  microtask(function () {\n    var value = promise._v;\n    var ok = promise._s == 1;\n    var i = 0;\n    var run = function (reaction) {\n      var handler = ok ? reaction.ok : reaction.fail;\n      var resolve = reaction.resolve;\n      var reject = reaction.reject;\n      var domain = reaction.domain;\n      var result, then;\n      try {\n        if (handler) {\n          if (!ok) {\n            if (promise._h == 2) onHandleUnhandled(promise);\n            promise._h = 1;\n          }\n          if (handler === true) result = value;\n          else {\n            if (domain) domain.enter();\n            result = handler(value);\n            if (domain) domain.exit();\n          }\n          if (result === reaction.promise) {\n            reject(TypeError('Promise-chain cycle'));\n          } else if (then = isThenable(result)) {\n            then.call(result, resolve, reject);\n          } else resolve(result);\n        } else reject(value);\n      } catch (e) {\n        reject(e);\n      }\n    };\n    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach\n    promise._c = [];\n    promise._n = false;\n    if (isReject && !promise._h) onUnhandled(promise);\n  });\n};\nvar onUnhandled = function (promise) {\n  task.call(global, function () {\n    var value = promise._v;\n    var unhandled = isUnhandled(promise);\n    var result, handler, console;\n    if (unhandled) {\n      result = perform(function () {\n        if (isNode) {\n          process.emit('unhandledRejection', value, promise);\n        } else if (handler = global.onunhandledrejection) {\n          handler({ promise: promise, reason: value });\n        } else if ((console = global.console) && console.error) {\n          console.error('Unhandled promise rejection', value);\n        }\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      promise._h = isNode || isUnhandled(promise) ? 2 : 1;\n    } promise._a = undefined;\n    if (unhandled && result.e) throw result.v;\n  });\n};\nvar isUnhandled = function (promise) {\n  return promise._h !== 1 && (promise._a || promise._c).length === 0;\n};\nvar onHandleUnhandled = function (promise) {\n  task.call(global, function () {\n    var handler;\n    if (isNode) {\n      process.emit('rejectionHandled', promise);\n    } else if (handler = global.onrejectionhandled) {\n      handler({ promise: promise, reason: promise._v });\n    }\n  });\n};\nvar $reject = function (value) {\n  var promise = this;\n  if (promise._d) return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  promise._v = value;\n  promise._s = 2;\n  if (!promise._a) promise._a = promise._c.slice();\n  notify(promise, true);\n};\nvar $resolve = function (value) {\n  var promise = this;\n  var then;\n  if (promise._d) return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  try {\n    if (promise === value) throw TypeError(\"Promise can't be resolved itself\");\n    if (then = isThenable(value)) {\n      microtask(function () {\n        var wrapper = { _w: promise, _d: false }; // wrap\n        try {\n          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));\n        } catch (e) {\n          $reject.call(wrapper, e);\n        }\n      });\n    } else {\n      promise._v = value;\n      promise._s = 1;\n      notify(promise, false);\n    }\n  } catch (e) {\n    $reject.call({ _w: promise, _d: false }, e); // wrap\n  }\n};\n\n// constructor polyfill\nif (!USE_NATIVE) {\n  // 25.4.3.1 Promise(executor)\n  $Promise = function Promise(executor) {\n    anInstance(this, $Promise, PROMISE, '_h');\n    aFunction(executor);\n    Internal.call(this);\n    try {\n      executor(ctx($resolve, this, 1), ctx($reject, this, 1));\n    } catch (err) {\n      $reject.call(this, err);\n    }\n  };\n  // eslint-disable-next-line no-unused-vars\n  Internal = function Promise(executor) {\n    this._c = [];             // <- awaiting reactions\n    this._a = undefined;      // <- checked in isUnhandled reactions\n    this._s = 0;              // <- state\n    this._d = false;          // <- done\n    this._v = undefined;      // <- value\n    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled\n    this._n = false;          // <- notify\n  };\n  Internal.prototype = require('./_redefine-all')($Promise.prototype, {\n    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\n    then: function then(onFulfilled, onRejected) {\n      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));\n      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;\n      reaction.fail = typeof onRejected == 'function' && onRejected;\n      reaction.domain = isNode ? process.domain : undefined;\n      this._c.push(reaction);\n      if (this._a) this._a.push(reaction);\n      if (this._s) notify(this, false);\n      return reaction.promise;\n    },\n    // 25.4.5.1 Promise.prototype.catch(onRejected)\n    'catch': function (onRejected) {\n      return this.then(undefined, onRejected);\n    }\n  });\n  OwnPromiseCapability = function () {\n    var promise = new Internal();\n    this.promise = promise;\n    this.resolve = ctx($resolve, promise, 1);\n    this.reject = ctx($reject, promise, 1);\n  };\n  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {\n    return C === $Promise || C === Wrapper\n      ? new OwnPromiseCapability(C)\n      : newGenericPromiseCapability(C);\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });\nrequire('./_set-to-string-tag')($Promise, PROMISE);\nrequire('./_set-species')(PROMISE);\nWrapper = require('./_core')[PROMISE];\n\n// statics\n$export($export.S + $export.F * !USE_NATIVE, PROMISE, {\n  // 25.4.4.5 Promise.reject(r)\n  reject: function reject(r) {\n    var capability = newPromiseCapability(this);\n    var $$reject = capability.reject;\n    $$reject(r);\n    return capability.promise;\n  }\n});\n$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {\n  // 25.4.4.6 Promise.resolve(x)\n  resolve: function resolve(x) {\n    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);\n  }\n});\n$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {\n  $Promise.all(iter)['catch'](empty);\n})), PROMISE, {\n  // 25.4.4.1 Promise.all(iterable)\n  all: function all(iterable) {\n    var C = this;\n    var capability = newPromiseCapability(C);\n    var resolve = capability.resolve;\n    var reject = capability.reject;\n    var result = perform(function () {\n      var values = [];\n      var index = 0;\n      var remaining = 1;\n      forOf(iterable, false, function (promise) {\n        var $index = index++;\n        var alreadyCalled = false;\n        values.push(undefined);\n        remaining++;\n        C.resolve(promise).then(function (value) {\n          if (alreadyCalled) return;\n          alreadyCalled = true;\n          values[$index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if (result.e) reject(result.v);\n    return capability.promise;\n  },\n  // 25.4.4.4 Promise.race(iterable)\n  race: function race(iterable) {\n    var C = this;\n    var capability = newPromiseCapability(C);\n    var reject = capability.reject;\n    var result = perform(function () {\n      forOf(iterable, false, function (promise) {\n        C.resolve(promise).then(capability.resolve, reject);\n      });\n    });\n    if (result.e) reject(result.v);\n    return capability.promise;\n  }\n});\n","// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)\nvar $export = require('./_export');\nvar aFunction = require('./_a-function');\nvar anObject = require('./_an-object');\nvar rApply = (require('./_global').Reflect || {}).apply;\nvar fApply = Function.apply;\n// MS Edge argumentsList argument is optional\n$export($export.S + $export.F * !require('./_fails')(function () {\n  rApply(function () { /* empty */ });\n}), 'Reflect', {\n  apply: function apply(target, thisArgument, argumentsList) {\n    var T = aFunction(target);\n    var L = anObject(argumentsList);\n    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);\n  }\n});\n","// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])\nvar $export = require('./_export');\nvar create = require('./_object-create');\nvar aFunction = require('./_a-function');\nvar anObject = require('./_an-object');\nvar isObject = require('./_is-object');\nvar fails = require('./_fails');\nvar bind = require('./_bind');\nvar rConstruct = (require('./_global').Reflect || {}).construct;\n\n// MS Edge supports only 2 arguments and argumentsList argument is optional\n// FF Nightly sets third argument as `new.target`, but does not create `this` from it\nvar NEW_TARGET_BUG = fails(function () {\n  function F() { /* empty */ }\n  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);\n});\nvar ARGS_BUG = !fails(function () {\n  rConstruct(function () { /* empty */ });\n});\n\n$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {\n  construct: function construct(Target, args /* , newTarget */) {\n    aFunction(Target);\n    anObject(args);\n    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);\n    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);\n    if (Target == newTarget) {\n      // w/o altered newTarget, optimization for 0-4 arguments\n      switch (args.length) {\n        case 0: return new Target();\n        case 1: return new Target(args[0]);\n        case 2: return new Target(args[0], args[1]);\n        case 3: return new Target(args[0], args[1], args[2]);\n        case 4: return new Target(args[0], args[1], args[2], args[3]);\n      }\n      // w/o altered newTarget, lot of arguments case\n      var $args = [null];\n      $args.push.apply($args, args);\n      return new (bind.apply(Target, $args))();\n    }\n    // with altered newTarget, not support built-in constructors\n    var proto = newTarget.prototype;\n    var instance = create(isObject(proto) ? proto : Object.prototype);\n    var result = Function.apply.call(Target, instance, args);\n    return isObject(result) ? result : instance;\n  }\n});\n","// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)\nvar dP = require('./_object-dp');\nvar $export = require('./_export');\nvar anObject = require('./_an-object');\nvar toPrimitive = require('./_to-primitive');\n\n// MS Edge has broken Reflect.defineProperty - throwing instead of returning false\n$export($export.S + $export.F * require('./_fails')(function () {\n  // eslint-disable-next-line no-undef\n  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });\n}), 'Reflect', {\n  defineProperty: function defineProperty(target, propertyKey, attributes) {\n    anObject(target);\n    propertyKey = toPrimitive(propertyKey, true);\n    anObject(attributes);\n    try {\n      dP.f(target, propertyKey, attributes);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n});\n","// 26.1.4 Reflect.deleteProperty(target, propertyKey)\nvar $export = require('./_export');\nvar gOPD = require('./_object-gopd').f;\nvar anObject = require('./_an-object');\n\n$export($export.S, 'Reflect', {\n  deleteProperty: function deleteProperty(target, propertyKey) {\n    var desc = gOPD(anObject(target), propertyKey);\n    return desc && !desc.configurable ? false : delete target[propertyKey];\n  }\n});\n","'use strict';\n// 26.1.5 Reflect.enumerate(target)\nvar $export = require('./_export');\nvar anObject = require('./_an-object');\nvar Enumerate = function (iterated) {\n  this._t = anObject(iterated); // target\n  this._i = 0;                  // next index\n  var keys = this._k = [];      // keys\n  var key;\n  for (key in iterated) keys.push(key);\n};\nrequire('./_iter-create')(Enumerate, 'Object', function () {\n  var that = this;\n  var keys = that._k;\n  var key;\n  do {\n    if (that._i >= keys.length) return { value: undefined, done: true };\n  } while (!((key = keys[that._i++]) in that._t));\n  return { value: key, done: false };\n});\n\n$export($export.S, 'Reflect', {\n  enumerate: function enumerate(target) {\n    return new Enumerate(target);\n  }\n});\n","// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)\nvar gOPD = require('./_object-gopd');\nvar $export = require('./_export');\nvar anObject = require('./_an-object');\n\n$export($export.S, 'Reflect', {\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {\n    return gOPD.f(anObject(target), propertyKey);\n  }\n});\n","// 26.1.8 Reflect.getPrototypeOf(target)\nvar $export = require('./_export');\nvar getProto = require('./_object-gpo');\nvar anObject = require('./_an-object');\n\n$export($export.S, 'Reflect', {\n  getPrototypeOf: function getPrototypeOf(target) {\n    return getProto(anObject(target));\n  }\n});\n","// 26.1.6 Reflect.get(target, propertyKey [, receiver])\nvar gOPD = require('./_object-gopd');\nvar getPrototypeOf = require('./_object-gpo');\nvar has = require('./_has');\nvar $export = require('./_export');\nvar isObject = require('./_is-object');\nvar anObject = require('./_an-object');\n\nfunction get(target, propertyKey /* , receiver */) {\n  var receiver = arguments.length < 3 ? target : arguments[2];\n  var desc, proto;\n  if (anObject(target) === receiver) return target[propertyKey];\n  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')\n    ? desc.value\n    : desc.get !== undefined\n      ? desc.get.call(receiver)\n      : undefined;\n  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);\n}\n\n$export($export.S, 'Reflect', { get: get });\n","// 26.1.9 Reflect.has(target, propertyKey)\nvar $export = require('./_export');\n\n$export($export.S, 'Reflect', {\n  has: function has(target, propertyKey) {\n    return propertyKey in target;\n  }\n});\n","// 26.1.10 Reflect.isExtensible(target)\nvar $export = require('./_export');\nvar anObject = require('./_an-object');\nvar $isExtensible = Object.isExtensible;\n\n$export($export.S, 'Reflect', {\n  isExtensible: function isExtensible(target) {\n    anObject(target);\n    return $isExtensible ? $isExtensible(target) : true;\n  }\n});\n","// 26.1.11 Reflect.ownKeys(target)\nvar $export = require('./_export');\n\n$export($export.S, 'Reflect', { ownKeys: require('./_own-keys') });\n","// 26.1.12 Reflect.preventExtensions(target)\nvar $export = require('./_export');\nvar anObject = require('./_an-object');\nvar $preventExtensions = Object.preventExtensions;\n\n$export($export.S, 'Reflect', {\n  preventExtensions: function preventExtensions(target) {\n    anObject(target);\n    try {\n      if ($preventExtensions) $preventExtensions(target);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n});\n","// 26.1.14 Reflect.setPrototypeOf(target, proto)\nvar $export = require('./_export');\nvar setProto = require('./_set-proto');\n\nif (setProto) $export($export.S, 'Reflect', {\n  setPrototypeOf: function setPrototypeOf(target, proto) {\n    setProto.check(target, proto);\n    try {\n      setProto.set(target, proto);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n});\n","// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])\nvar dP = require('./_object-dp');\nvar gOPD = require('./_object-gopd');\nvar getPrototypeOf = require('./_object-gpo');\nvar has = require('./_has');\nvar $export = require('./_export');\nvar createDesc = require('./_property-desc');\nvar anObject = require('./_an-object');\nvar isObject = require('./_is-object');\n\nfunction set(target, propertyKey, V /* , receiver */) {\n  var receiver = arguments.length < 4 ? target : arguments[3];\n  var ownDesc = gOPD.f(anObject(target), propertyKey);\n  var existingDescriptor, proto;\n  if (!ownDesc) {\n    if (isObject(proto = getPrototypeOf(target))) {\n      return set(proto, propertyKey, V, receiver);\n    }\n    ownDesc = createDesc(0);\n  }\n  if (has(ownDesc, 'value')) {\n    if (ownDesc.writable === false || !isObject(receiver)) return false;\n    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);\n    existingDescriptor.value = V;\n    dP.f(receiver, propertyKey, existingDescriptor);\n    return true;\n  }\n  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);\n}\n\n$export($export.S, 'Reflect', { set: set });\n","var global = require('./_global');\nvar inheritIfRequired = require('./_inherit-if-required');\nvar dP = require('./_object-dp').f;\nvar gOPN = require('./_object-gopn').f;\nvar isRegExp = require('./_is-regexp');\nvar $flags = require('./_flags');\nvar $RegExp = global.RegExp;\nvar Base = $RegExp;\nvar proto = $RegExp.prototype;\nvar re1 = /a/g;\nvar re2 = /a/g;\n// \"new\" creates a new object, old webkit buggy here\nvar CORRECT_NEW = new $RegExp(re1) !== re1;\n\nif (require('./_descriptors') && (!CORRECT_NEW || require('./_fails')(function () {\n  re2[require('./_wks')('match')] = false;\n  // RegExp constructor can alter flags and IsRegExp works correct with @@match\n  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';\n}))) {\n  $RegExp = function RegExp(p, f) {\n    var tiRE = this instanceof $RegExp;\n    var piRE = isRegExp(p);\n    var fiU = f === undefined;\n    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p\n      : inheritIfRequired(CORRECT_NEW\n        ? new Base(piRE && !fiU ? p.source : p, f)\n        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)\n      , tiRE ? this : proto, $RegExp);\n  };\n  var proxy = function (key) {\n    key in $RegExp || dP($RegExp, key, {\n      configurable: true,\n      get: function () { return Base[key]; },\n      set: function (it) { Base[key] = it; }\n    });\n  };\n  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);\n  proto.constructor = $RegExp;\n  $RegExp.prototype = proto;\n  require('./_redefine')(global, 'RegExp', $RegExp);\n}\n\nrequire('./_set-species')('RegExp');\n","// 21.2.5.3 get RegExp.prototype.flags()\nif (require('./_descriptors') && /./g.flags != 'g') require('./_object-dp').f(RegExp.prototype, 'flags', {\n  configurable: true,\n  get: require('./_flags')\n});\n","// @@match logic\nrequire('./_fix-re-wks')('match', 1, function (defined, MATCH, $match) {\n  // 21.1.3.11 String.prototype.match(regexp)\n  return [function match(regexp) {\n    'use strict';\n    var O = defined(this);\n    var fn = regexp == undefined ? undefined : regexp[MATCH];\n    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));\n  }, $match];\n});\n","// @@replace logic\nrequire('./_fix-re-wks')('replace', 2, function (defined, REPLACE, $replace) {\n  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)\n  return [function replace(searchValue, replaceValue) {\n    'use strict';\n    var O = defined(this);\n    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];\n    return fn !== undefined\n      ? fn.call(searchValue, O, replaceValue)\n      : $replace.call(String(O), searchValue, replaceValue);\n  }, $replace];\n});\n","// @@search logic\nrequire('./_fix-re-wks')('search', 1, function (defined, SEARCH, $search) {\n  // 21.1.3.15 String.prototype.search(regexp)\n  return [function search(regexp) {\n    'use strict';\n    var O = defined(this);\n    var fn = regexp == undefined ? undefined : regexp[SEARCH];\n    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));\n  }, $search];\n});\n","// @@split logic\nrequire('./_fix-re-wks')('split', 2, function (defined, SPLIT, $split) {\n  'use strict';\n  var isRegExp = require('./_is-regexp');\n  var _split = $split;\n  var $push = [].push;\n  var $SPLIT = 'split';\n  var LENGTH = 'length';\n  var LAST_INDEX = 'lastIndex';\n  if (\n    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||\n    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||\n    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||\n    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||\n    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||\n    ''[$SPLIT](/.?/)[LENGTH]\n  ) {\n    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group\n    // based on es5-shim implementation, need to rework it\n    $split = function (separator, limit) {\n      var string = String(this);\n      if (separator === undefined && limit === 0) return [];\n      // If `separator` is not a regex, use native split\n      if (!isRegExp(separator)) return _split.call(string, separator, limit);\n      var output = [];\n      var flags = (separator.ignoreCase ? 'i' : '') +\n                  (separator.multiline ? 'm' : '') +\n                  (separator.unicode ? 'u' : '') +\n                  (separator.sticky ? 'y' : '');\n      var lastLastIndex = 0;\n      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;\n      // Make `global` and avoid `lastIndex` issues by working with a copy\n      var separatorCopy = new RegExp(separator.source, flags + 'g');\n      var separator2, match, lastIndex, lastLength, i;\n      // Doesn't need flags gy, but they don't hurt\n      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\\\s)', flags);\n      while (match = separatorCopy.exec(string)) {\n        // `separatorCopy.lastIndex` is not reliable cross-browser\n        lastIndex = match.index + match[0][LENGTH];\n        if (lastIndex > lastLastIndex) {\n          output.push(string.slice(lastLastIndex, match.index));\n          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG\n          // eslint-disable-next-line no-loop-func\n          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {\n            for (i = 1; i < arguments[LENGTH] - 2; i++) if (arguments[i] === undefined) match[i] = undefined;\n          });\n          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));\n          lastLength = match[0][LENGTH];\n          lastLastIndex = lastIndex;\n          if (output[LENGTH] >= splitLimit) break;\n        }\n        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop\n      }\n      if (lastLastIndex === string[LENGTH]) {\n        if (lastLength || !separatorCopy.test('')) output.push('');\n      } else output.push(string.slice(lastLastIndex));\n      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;\n    };\n  // Chakra, V8\n  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {\n    $split = function (separator, limit) {\n      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);\n    };\n  }\n  // 21.1.3.17 String.prototype.split(separator, limit)\n  return [function split(separator, limit) {\n    var O = defined(this);\n    var fn = separator == undefined ? undefined : separator[SPLIT];\n    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);\n  }, $split];\n});\n","'use strict';\nrequire('./es6.regexp.flags');\nvar anObject = require('./_an-object');\nvar $flags = require('./_flags');\nvar DESCRIPTORS = require('./_descriptors');\nvar TO_STRING = 'toString';\nvar $toString = /./[TO_STRING];\n\nvar define = function (fn) {\n  require('./_redefine')(RegExp.prototype, TO_STRING, fn, true);\n};\n\n// 21.2.5.14 RegExp.prototype.toString()\nif (require('./_fails')(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {\n  define(function toString() {\n    var R = anObject(this);\n    return '/'.concat(R.source, '/',\n      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);\n  });\n// FF44- RegExp#toString has a wrong name\n} else if ($toString.name != TO_STRING) {\n  define(function toString() {\n    return $toString.call(this);\n  });\n}\n","'use strict';\nvar strong = require('./_collection-strong');\nvar validate = require('./_validate-collection');\nvar SET = 'Set';\n\n// 23.2 Set Objects\nmodule.exports = require('./_collection')(SET, function (get) {\n  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.2.3.1 Set.prototype.add(value)\n  add: function add(value) {\n    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);\n  }\n}, strong);\n","'use strict';\n// B.2.3.2 String.prototype.anchor(name)\nrequire('./_string-html')('anchor', function (createHTML) {\n  return function anchor(name) {\n    return createHTML(this, 'a', 'name', name);\n  };\n});\n","'use strict';\n// B.2.3.3 String.prototype.big()\nrequire('./_string-html')('big', function (createHTML) {\n  return function big() {\n    return createHTML(this, 'big', '', '');\n  };\n});\n","'use strict';\n// B.2.3.4 String.prototype.blink()\nrequire('./_string-html')('blink', function (createHTML) {\n  return function blink() {\n    return createHTML(this, 'blink', '', '');\n  };\n});\n","'use strict';\n// B.2.3.5 String.prototype.bold()\nrequire('./_string-html')('bold', function (createHTML) {\n  return function bold() {\n    return createHTML(this, 'b', '', '');\n  };\n});\n","'use strict';\nvar $export = require('./_export');\nvar $at = require('./_string-at')(false);\n$export($export.P, 'String', {\n  // 21.1.3.3 String.prototype.codePointAt(pos)\n  codePointAt: function codePointAt(pos) {\n    return $at(this, pos);\n  }\n});\n","// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])\n'use strict';\nvar $export = require('./_export');\nvar toLength = require('./_to-length');\nvar context = require('./_string-context');\nvar ENDS_WITH = 'endsWith';\nvar $endsWith = ''[ENDS_WITH];\n\n$export($export.P + $export.F * require('./_fails-is-regexp')(ENDS_WITH), 'String', {\n  endsWith: function endsWith(searchString /* , endPosition = @length */) {\n    var that = context(this, searchString, ENDS_WITH);\n    var endPosition = arguments.length > 1 ? arguments[1] : undefined;\n    var len = toLength(that.length);\n    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);\n    var search = String(searchString);\n    return $endsWith\n      ? $endsWith.call(that, search, end)\n      : that.slice(end - search.length, end) === search;\n  }\n});\n","'use strict';\n// B.2.3.6 String.prototype.fixed()\nrequire('./_string-html')('fixed', function (createHTML) {\n  return function fixed() {\n    return createHTML(this, 'tt', '', '');\n  };\n});\n","'use strict';\n// B.2.3.7 String.prototype.fontcolor(color)\nrequire('./_string-html')('fontcolor', function (createHTML) {\n  return function fontcolor(color) {\n    return createHTML(this, 'font', 'color', color);\n  };\n});\n","'use strict';\n// B.2.3.8 String.prototype.fontsize(size)\nrequire('./_string-html')('fontsize', function (createHTML) {\n  return function fontsize(size) {\n    return createHTML(this, 'font', 'size', size);\n  };\n});\n","var $export = require('./_export');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nvar fromCharCode = String.fromCharCode;\nvar $fromCodePoint = String.fromCodePoint;\n\n// length should be 1, old FF problem\n$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {\n  // 21.1.2.2 String.fromCodePoint(...codePoints)\n  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars\n    var res = [];\n    var aLen = arguments.length;\n    var i = 0;\n    var code;\n    while (aLen > i) {\n      code = +arguments[i++];\n      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');\n      res.push(code < 0x10000\n        ? fromCharCode(code)\n        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)\n      );\n    } return res.join('');\n  }\n});\n","// 21.1.3.7 String.prototype.includes(searchString, position = 0)\n'use strict';\nvar $export = require('./_export');\nvar context = require('./_string-context');\nvar INCLUDES = 'includes';\n\n$export($export.P + $export.F * require('./_fails-is-regexp')(INCLUDES), 'String', {\n  includes: function includes(searchString /* , position = 0 */) {\n    return !!~context(this, searchString, INCLUDES)\n      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n","'use strict';\n// B.2.3.9 String.prototype.italics()\nrequire('./_string-html')('italics', function (createHTML) {\n  return function italics() {\n    return createHTML(this, 'i', '', '');\n  };\n});\n","'use strict';\nvar $at = require('./_string-at')(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\nrequire('./_iter-define')(String, 'String', function (iterated) {\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var index = this._i;\n  var point;\n  if (index >= O.length) return { value: undefined, done: true };\n  point = $at(O, index);\n  this._i += point.length;\n  return { value: point, done: false };\n});\n","'use strict';\n// B.2.3.10 String.prototype.link(url)\nrequire('./_string-html')('link', function (createHTML) {\n  return function link(url) {\n    return createHTML(this, 'a', 'href', url);\n  };\n});\n","var $export = require('./_export');\nvar toIObject = require('./_to-iobject');\nvar toLength = require('./_to-length');\n\n$export($export.S, 'String', {\n  // 21.1.2.4 String.raw(callSite, ...substitutions)\n  raw: function raw(callSite) {\n    var tpl = toIObject(callSite.raw);\n    var len = toLength(tpl.length);\n    var aLen = arguments.length;\n    var res = [];\n    var i = 0;\n    while (len > i) {\n      res.push(String(tpl[i++]));\n      if (i < aLen) res.push(String(arguments[i]));\n    } return res.join('');\n  }\n});\n","var $export = require('./_export');\n\n$export($export.P, 'String', {\n  // 21.1.3.13 String.prototype.repeat(count)\n  repeat: require('./_string-repeat')\n});\n","'use strict';\n// B.2.3.11 String.prototype.small()\nrequire('./_string-html')('small', function (createHTML) {\n  return function small() {\n    return createHTML(this, 'small', '', '');\n  };\n});\n","// 21.1.3.18 String.prototype.startsWith(searchString [, position ])\n'use strict';\nvar $export = require('./_export');\nvar toLength = require('./_to-length');\nvar context = require('./_string-context');\nvar STARTS_WITH = 'startsWith';\nvar $startsWith = ''[STARTS_WITH];\n\n$export($export.P + $export.F * require('./_fails-is-regexp')(STARTS_WITH), 'String', {\n  startsWith: function startsWith(searchString /* , position = 0 */) {\n    var that = context(this, searchString, STARTS_WITH);\n    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));\n    var search = String(searchString);\n    return $startsWith\n      ? $startsWith.call(that, search, index)\n      : that.slice(index, index + search.length) === search;\n  }\n});\n","'use strict';\n// B.2.3.12 String.prototype.strike()\nrequire('./_string-html')('strike', function (createHTML) {\n  return function strike() {\n    return createHTML(this, 'strike', '', '');\n  };\n});\n","'use strict';\n// B.2.3.13 String.prototype.sub()\nrequire('./_string-html')('sub', function (createHTML) {\n  return function sub() {\n    return createHTML(this, 'sub', '', '');\n  };\n});\n","'use strict';\n// B.2.3.14 String.prototype.sup()\nrequire('./_string-html')('sup', function (createHTML) {\n  return function sup() {\n    return createHTML(this, 'sup', '', '');\n  };\n});\n","'use strict';\n// 21.1.3.25 String.prototype.trim()\nrequire('./_string-trim')('trim', function ($trim) {\n  return function trim() {\n    return $trim(this, 3);\n  };\n});\n","'use strict';\n// ECMAScript 6 symbols shim\nvar global = require('./_global');\nvar has = require('./_has');\nvar DESCRIPTORS = require('./_descriptors');\nvar $export = require('./_export');\nvar redefine = require('./_redefine');\nvar META = require('./_meta').KEY;\nvar $fails = require('./_fails');\nvar shared = require('./_shared');\nvar setToStringTag = require('./_set-to-string-tag');\nvar uid = require('./_uid');\nvar wks = require('./_wks');\nvar wksExt = require('./_wks-ext');\nvar wksDefine = require('./_wks-define');\nvar enumKeys = require('./_enum-keys');\nvar isArray = require('./_is-array');\nvar anObject = require('./_an-object');\nvar isObject = require('./_is-object');\nvar toIObject = require('./_to-iobject');\nvar toPrimitive = require('./_to-primitive');\nvar createDesc = require('./_property-desc');\nvar _create = require('./_object-create');\nvar gOPNExt = require('./_object-gopn-ext');\nvar $GOPD = require('./_object-gopd');\nvar $DP = require('./_object-dp');\nvar $keys = require('./_object-keys');\nvar gOPD = $GOPD.f;\nvar dP = $DP.f;\nvar gOPN = gOPNExt.f;\nvar $Symbol = global.Symbol;\nvar $JSON = global.JSON;\nvar _stringify = $JSON && $JSON.stringify;\nvar PROTOTYPE = 'prototype';\nvar HIDDEN = wks('_hidden');\nvar TO_PRIMITIVE = wks('toPrimitive');\nvar isEnum = {}.propertyIsEnumerable;\nvar SymbolRegistry = shared('symbol-registry');\nvar AllSymbols = shared('symbols');\nvar OPSymbols = shared('op-symbols');\nvar ObjectProto = Object[PROTOTYPE];\nvar USE_NATIVE = typeof $Symbol == 'function';\nvar QObject = global.QObject;\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDesc = DESCRIPTORS && $fails(function () {\n  return _create(dP({}, 'a', {\n    get: function () { return dP(this, 'a', { value: 7 }).a; }\n  })).a != 7;\n}) ? function (it, key, D) {\n  var protoDesc = gOPD(ObjectProto, key);\n  if (protoDesc) delete ObjectProto[key];\n  dP(it, key, D);\n  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);\n} : dP;\n\nvar wrap = function (tag) {\n  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n  sym._k = tag;\n  return sym;\n};\n\nvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  return it instanceof $Symbol;\n};\n\nvar $defineProperty = function defineProperty(it, key, D) {\n  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);\n  anObject(it);\n  key = toPrimitive(key, true);\n  anObject(D);\n  if (has(AllSymbols, key)) {\n    if (!D.enumerable) {\n      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));\n      it[HIDDEN][key] = true;\n    } else {\n      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;\n      D = _create(D, { enumerable: createDesc(0, false) });\n    } return setSymbolDesc(it, key, D);\n  } return dP(it, key, D);\n};\nvar $defineProperties = function defineProperties(it, P) {\n  anObject(it);\n  var keys = enumKeys(P = toIObject(P));\n  var i = 0;\n  var l = keys.length;\n  var key;\n  while (l > i) $defineProperty(it, key = keys[i++], P[key]);\n  return it;\n};\nvar $create = function create(it, P) {\n  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n};\nvar $propertyIsEnumerable = function propertyIsEnumerable(key) {\n  var E = isEnum.call(this, key = toPrimitive(key, true));\n  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;\n  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n};\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {\n  it = toIObject(it);\n  key = toPrimitive(key, true);\n  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;\n  var D = gOPD(it, key);\n  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;\n  return D;\n};\nvar $getOwnPropertyNames = function getOwnPropertyNames(it) {\n  var names = gOPN(toIObject(it));\n  var result = [];\n  var i = 0;\n  var key;\n  while (names.length > i) {\n    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);\n  } return result;\n};\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(it) {\n  var IS_OP = it === ObjectProto;\n  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));\n  var result = [];\n  var i = 0;\n  var key;\n  while (names.length > i) {\n    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);\n  } return result;\n};\n\n// 19.4.1.1 Symbol([description])\nif (!USE_NATIVE) {\n  $Symbol = function Symbol() {\n    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');\n    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n    var $set = function (value) {\n      if (this === ObjectProto) $set.call(OPSymbols, value);\n      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;\n      setSymbolDesc(this, tag, createDesc(1, value));\n    };\n    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });\n    return wrap(tag);\n  };\n  redefine($Symbol[PROTOTYPE], 'toString', function toString() {\n    return this._k;\n  });\n\n  $GOPD.f = $getOwnPropertyDescriptor;\n  $DP.f = $defineProperty;\n  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;\n  require('./_object-pie').f = $propertyIsEnumerable;\n  require('./_object-gops').f = $getOwnPropertySymbols;\n\n  if (DESCRIPTORS && !require('./_library')) {\n    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n  }\n\n  wksExt.f = function (name) {\n    return wrap(wks(name));\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });\n\nfor (var es6Symbols = (\n  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);\n\nfor (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);\n\n$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n  // 19.4.2.1 Symbol.for(key)\n  'for': function (key) {\n    return has(SymbolRegistry, key += '')\n      ? SymbolRegistry[key]\n      : SymbolRegistry[key] = $Symbol(key);\n  },\n  // 19.4.2.5 Symbol.keyFor(sym)\n  keyFor: function keyFor(sym) {\n    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');\n    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;\n  },\n  useSetter: function () { setter = true; },\n  useSimple: function () { setter = false; }\n});\n\n$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n  // 19.1.2.2 Object.create(O [, Properties])\n  create: $create,\n  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n  defineProperty: $defineProperty,\n  // 19.1.2.3 Object.defineProperties(O, Properties)\n  defineProperties: $defineProperties,\n  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n  // 19.1.2.7 Object.getOwnPropertyNames(O)\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n\n// 24.3.2 JSON.stringify(value [, replacer [, space]])\n$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {\n  var S = $Symbol();\n  // MS Edge converts symbol values to JSON as {}\n  // WebKit converts symbol values to JSON as null\n  // V8 throws on boxed symbols\n  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';\n})), 'JSON', {\n  stringify: function stringify(it) {\n    var args = [it];\n    var i = 1;\n    var replacer, $replacer;\n    while (arguments.length > i) args.push(arguments[i++]);\n    $replacer = replacer = args[1];\n    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined\n    if (!isArray(replacer)) replacer = function (key, value) {\n      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);\n      if (!isSymbol(value)) return value;\n    };\n    args[1] = replacer;\n    return _stringify.apply($JSON, args);\n  }\n});\n\n// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n// 19.4.3.5 Symbol.prototype[@@toStringTag]\nsetToStringTag($Symbol, 'Symbol');\n// 20.2.1.9 Math[@@toStringTag]\nsetToStringTag(Math, 'Math', true);\n// 24.3.3 JSON[@@toStringTag]\nsetToStringTag(global.JSON, 'JSON', true);\n","'use strict';\nvar $export = require('./_export');\nvar $typed = require('./_typed');\nvar buffer = require('./_typed-buffer');\nvar anObject = require('./_an-object');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nvar toLength = require('./_to-length');\nvar isObject = require('./_is-object');\nvar ArrayBuffer = require('./_global').ArrayBuffer;\nvar speciesConstructor = require('./_species-constructor');\nvar $ArrayBuffer = buffer.ArrayBuffer;\nvar $DataView = buffer.DataView;\nvar $isView = $typed.ABV && ArrayBuffer.isView;\nvar $slice = $ArrayBuffer.prototype.slice;\nvar VIEW = $typed.VIEW;\nvar ARRAY_BUFFER = 'ArrayBuffer';\n\n$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });\n\n$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {\n  // 24.1.3.1 ArrayBuffer.isView(arg)\n  isView: function isView(it) {\n    return $isView && $isView(it) || isObject(it) && VIEW in it;\n  }\n});\n\n$export($export.P + $export.U + $export.F * require('./_fails')(function () {\n  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;\n}), ARRAY_BUFFER, {\n  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)\n  slice: function slice(start, end) {\n    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix\n    var len = anObject(this).byteLength;\n    var first = toAbsoluteIndex(start, len);\n    var final = toAbsoluteIndex(end === undefined ? len : end, len);\n    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first));\n    var viewS = new $DataView(this);\n    var viewT = new $DataView(result);\n    var index = 0;\n    while (first < final) {\n      viewT.setUint8(index++, viewS.getUint8(first++));\n    } return result;\n  }\n});\n\nrequire('./_set-species')(ARRAY_BUFFER);\n","var $export = require('./_export');\n$export($export.G + $export.W + $export.F * !require('./_typed').ABV, {\n  DataView: require('./_typed-buffer').DataView\n});\n","require('./_typed-array')('Float32', 4, function (init) {\n  return function Float32Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","require('./_typed-array')('Float64', 8, function (init) {\n  return function Float64Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","require('./_typed-array')('Int16', 2, function (init) {\n  return function Int16Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","require('./_typed-array')('Int32', 4, function (init) {\n  return function Int32Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","require('./_typed-array')('Int8', 1, function (init) {\n  return function Int8Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","require('./_typed-array')('Uint16', 2, function (init) {\n  return function Uint16Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","require('./_typed-array')('Uint32', 4, function (init) {\n  return function Uint32Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","require('./_typed-array')('Uint8', 1, function (init) {\n  return function Uint8Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","require('./_typed-array')('Uint8', 1, function (init) {\n  return function Uint8ClampedArray(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n}, true);\n","'use strict';\nvar each = require('./_array-methods')(0);\nvar redefine = require('./_redefine');\nvar meta = require('./_meta');\nvar assign = require('./_object-assign');\nvar weak = require('./_collection-weak');\nvar isObject = require('./_is-object');\nvar fails = require('./_fails');\nvar validate = require('./_validate-collection');\nvar WEAK_MAP = 'WeakMap';\nvar getWeak = meta.getWeak;\nvar isExtensible = Object.isExtensible;\nvar uncaughtFrozenStore = weak.ufstore;\nvar tmp = {};\nvar InternalMap;\n\nvar wrapper = function (get) {\n  return function WeakMap() {\n    return get(this, arguments.length > 0 ? arguments[0] : undefined);\n  };\n};\n\nvar methods = {\n  // 23.3.3.3 WeakMap.prototype.get(key)\n  get: function get(key) {\n    if (isObject(key)) {\n      var data = getWeak(key);\n      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);\n      return data ? data[this._i] : undefined;\n    }\n  },\n  // 23.3.3.5 WeakMap.prototype.set(key, value)\n  set: function set(key, value) {\n    return weak.def(validate(this, WEAK_MAP), key, value);\n  }\n};\n\n// 23.3 WeakMap Objects\nvar $WeakMap = module.exports = require('./_collection')(WEAK_MAP, wrapper, methods, weak, true, true);\n\n// IE11 WeakMap frozen keys fix\nif (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {\n  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);\n  assign(InternalMap.prototype, methods);\n  meta.NEED = true;\n  each(['delete', 'has', 'get', 'set'], function (key) {\n    var proto = $WeakMap.prototype;\n    var method = proto[key];\n    redefine(proto, key, function (a, b) {\n      // store frozen objects on internal weakmap shim\n      if (isObject(a) && !isExtensible(a)) {\n        if (!this._f) this._f = new InternalMap();\n        var result = this._f[key](a, b);\n        return key == 'set' ? this : result;\n      // store all the rest on native weakmap\n      } return method.call(this, a, b);\n    });\n  });\n}\n","'use strict';\nvar weak = require('./_collection-weak');\nvar validate = require('./_validate-collection');\nvar WEAK_SET = 'WeakSet';\n\n// 23.4 WeakSet Objects\nrequire('./_collection')(WEAK_SET, function (get) {\n  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.4.3.1 WeakSet.prototype.add(value)\n  add: function add(value) {\n    return weak.def(validate(this, WEAK_SET), value, true);\n  }\n}, weak, false, true);\n","'use strict';\n// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap\nvar $export = require('./_export');\nvar flattenIntoArray = require('./_flatten-into-array');\nvar toObject = require('./_to-object');\nvar toLength = require('./_to-length');\nvar aFunction = require('./_a-function');\nvar arraySpeciesCreate = require('./_array-species-create');\n\n$export($export.P, 'Array', {\n  flatMap: function flatMap(callbackfn /* , thisArg */) {\n    var O = toObject(this);\n    var sourceLen, A;\n    aFunction(callbackfn);\n    sourceLen = toLength(O.length);\n    A = arraySpeciesCreate(O, 0);\n    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);\n    return A;\n  }\n});\n\nrequire('./_add-to-unscopables')('flatMap');\n","'use strict';\n// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten\nvar $export = require('./_export');\nvar flattenIntoArray = require('./_flatten-into-array');\nvar toObject = require('./_to-object');\nvar toLength = require('./_to-length');\nvar toInteger = require('./_to-integer');\nvar arraySpeciesCreate = require('./_array-species-create');\n\n$export($export.P, 'Array', {\n  flatten: function flatten(/* depthArg = 1 */) {\n    var depthArg = arguments[0];\n    var O = toObject(this);\n    var sourceLen = toLength(O.length);\n    var A = arraySpeciesCreate(O, 0);\n    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));\n    return A;\n  }\n});\n\nrequire('./_add-to-unscopables')('flatten');\n","'use strict';\n// https://github.com/tc39/Array.prototype.includes\nvar $export = require('./_export');\nvar $includes = require('./_array-includes')(true);\n\n$export($export.P, 'Array', {\n  includes: function includes(el /* , fromIndex = 0 */) {\n    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nrequire('./_add-to-unscopables')('includes');\n","// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask\nvar $export = require('./_export');\nvar microtask = require('./_microtask')();\nvar process = require('./_global').process;\nvar isNode = require('./_cof')(process) == 'process';\n\n$export($export.G, {\n  asap: function asap(fn) {\n    var domain = isNode && process.domain;\n    microtask(domain ? domain.bind(fn) : fn);\n  }\n});\n","// https://github.com/ljharb/proposal-is-error\nvar $export = require('./_export');\nvar cof = require('./_cof');\n\n$export($export.S, 'Error', {\n  isError: function isError(it) {\n    return cof(it) === 'Error';\n  }\n});\n","// https://github.com/tc39/proposal-global\nvar $export = require('./_export');\n\n$export($export.G, { global: require('./_global') });\n","// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from\nrequire('./_set-collection-from')('Map');\n","// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of\nrequire('./_set-collection-of')('Map');\n","// https://github.com/DavidBruant/Map-Set.prototype.toJSON\nvar $export = require('./_export');\n\n$export($export.P + $export.R, 'Map', { toJSON: require('./_collection-to-json')('Map') });\n","// https://rwaldron.github.io/proposal-math-extensions/\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  clamp: function clamp(x, lower, upper) {\n    return Math.min(upper, Math.max(lower, x));\n  }\n});\n","// https://rwaldron.github.io/proposal-math-extensions/\nvar $export = require('./_export');\n\n$export($export.S, 'Math', { DEG_PER_RAD: Math.PI / 180 });\n","// https://rwaldron.github.io/proposal-math-extensions/\nvar $export = require('./_export');\nvar RAD_PER_DEG = 180 / Math.PI;\n\n$export($export.S, 'Math', {\n  degrees: function degrees(radians) {\n    return radians * RAD_PER_DEG;\n  }\n});\n","// https://rwaldron.github.io/proposal-math-extensions/\nvar $export = require('./_export');\nvar scale = require('./_math-scale');\nvar fround = require('./_math-fround');\n\n$export($export.S, 'Math', {\n  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {\n    return fround(scale(x, inLow, inHigh, outLow, outHigh));\n  }\n});\n","// https://gist.github.com/BrendanEich/4294d5c212a6d2254703\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  iaddh: function iaddh(x0, x1, y0, y1) {\n    var $x0 = x0 >>> 0;\n    var $x1 = x1 >>> 0;\n    var $y0 = y0 >>> 0;\n    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;\n  }\n});\n","// https://gist.github.com/BrendanEich/4294d5c212a6d2254703\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  imulh: function imulh(u, v) {\n    var UINT16 = 0xffff;\n    var $u = +u;\n    var $v = +v;\n    var u0 = $u & UINT16;\n    var v0 = $v & UINT16;\n    var u1 = $u >> 16;\n    var v1 = $v >> 16;\n    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);\n    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);\n  }\n});\n","// https://gist.github.com/BrendanEich/4294d5c212a6d2254703\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  isubh: function isubh(x0, x1, y0, y1) {\n    var $x0 = x0 >>> 0;\n    var $x1 = x1 >>> 0;\n    var $y0 = y0 >>> 0;\n    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;\n  }\n});\n","// https://rwaldron.github.io/proposal-math-extensions/\nvar $export = require('./_export');\n\n$export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI });\n","// https://rwaldron.github.io/proposal-math-extensions/\nvar $export = require('./_export');\nvar DEG_PER_RAD = Math.PI / 180;\n\n$export($export.S, 'Math', {\n  radians: function radians(degrees) {\n    return degrees * DEG_PER_RAD;\n  }\n});\n","// https://rwaldron.github.io/proposal-math-extensions/\nvar $export = require('./_export');\n\n$export($export.S, 'Math', { scale: require('./_math-scale') });\n","// http://jfbastien.github.io/papers/Math.signbit.html\nvar $export = require('./_export');\n\n$export($export.S, 'Math', { signbit: function signbit(x) {\n  // eslint-disable-next-line no-self-compare\n  return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;\n} });\n","// https://gist.github.com/BrendanEich/4294d5c212a6d2254703\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  umulh: function umulh(u, v) {\n    var UINT16 = 0xffff;\n    var $u = +u;\n    var $v = +v;\n    var u0 = $u & UINT16;\n    var v0 = $v & UINT16;\n    var u1 = $u >>> 16;\n    var v1 = $v >>> 16;\n    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);\n    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);\n  }\n});\n","'use strict';\nvar $export = require('./_export');\nvar toObject = require('./_to-object');\nvar aFunction = require('./_a-function');\nvar $defineProperty = require('./_object-dp');\n\n// B.2.2.2 Object.prototype.__defineGetter__(P, getter)\nrequire('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {\n  __defineGetter__: function __defineGetter__(P, getter) {\n    $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });\n  }\n});\n","'use strict';\nvar $export = require('./_export');\nvar toObject = require('./_to-object');\nvar aFunction = require('./_a-function');\nvar $defineProperty = require('./_object-dp');\n\n// B.2.2.3 Object.prototype.__defineSetter__(P, setter)\nrequire('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {\n  __defineSetter__: function __defineSetter__(P, setter) {\n    $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });\n  }\n});\n","// https://github.com/tc39/proposal-object-values-entries\nvar $export = require('./_export');\nvar $entries = require('./_object-to-array')(true);\n\n$export($export.S, 'Object', {\n  entries: function entries(it) {\n    return $entries(it);\n  }\n});\n","// https://github.com/tc39/proposal-object-getownpropertydescriptors\nvar $export = require('./_export');\nvar ownKeys = require('./_own-keys');\nvar toIObject = require('./_to-iobject');\nvar gOPD = require('./_object-gopd');\nvar createProperty = require('./_create-property');\n\n$export($export.S, 'Object', {\n  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {\n    var O = toIObject(object);\n    var getDesc = gOPD.f;\n    var keys = ownKeys(O);\n    var result = {};\n    var i = 0;\n    var key, desc;\n    while (keys.length > i) {\n      desc = getDesc(O, key = keys[i++]);\n      if (desc !== undefined) createProperty(result, key, desc);\n    }\n    return result;\n  }\n});\n","'use strict';\nvar $export = require('./_export');\nvar toObject = require('./_to-object');\nvar toPrimitive = require('./_to-primitive');\nvar getPrototypeOf = require('./_object-gpo');\nvar getOwnPropertyDescriptor = require('./_object-gopd').f;\n\n// B.2.2.4 Object.prototype.__lookupGetter__(P)\nrequire('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {\n  __lookupGetter__: function __lookupGetter__(P) {\n    var O = toObject(this);\n    var K = toPrimitive(P, true);\n    var D;\n    do {\n      if (D = getOwnPropertyDescriptor(O, K)) return D.get;\n    } while (O = getPrototypeOf(O));\n  }\n});\n","'use strict';\nvar $export = require('./_export');\nvar toObject = require('./_to-object');\nvar toPrimitive = require('./_to-primitive');\nvar getPrototypeOf = require('./_object-gpo');\nvar getOwnPropertyDescriptor = require('./_object-gopd').f;\n\n// B.2.2.5 Object.prototype.__lookupSetter__(P)\nrequire('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {\n  __lookupSetter__: function __lookupSetter__(P) {\n    var O = toObject(this);\n    var K = toPrimitive(P, true);\n    var D;\n    do {\n      if (D = getOwnPropertyDescriptor(O, K)) return D.set;\n    } while (O = getPrototypeOf(O));\n  }\n});\n","// https://github.com/tc39/proposal-object-values-entries\nvar $export = require('./_export');\nvar $values = require('./_object-to-array')(false);\n\n$export($export.S, 'Object', {\n  values: function values(it) {\n    return $values(it);\n  }\n});\n","'use strict';\n// https://github.com/zenparsing/es-observable\nvar $export = require('./_export');\nvar global = require('./_global');\nvar core = require('./_core');\nvar microtask = require('./_microtask')();\nvar OBSERVABLE = require('./_wks')('observable');\nvar aFunction = require('./_a-function');\nvar anObject = require('./_an-object');\nvar anInstance = require('./_an-instance');\nvar redefineAll = require('./_redefine-all');\nvar hide = require('./_hide');\nvar forOf = require('./_for-of');\nvar RETURN = forOf.RETURN;\n\nvar getMethod = function (fn) {\n  return fn == null ? undefined : aFunction(fn);\n};\n\nvar cleanupSubscription = function (subscription) {\n  var cleanup = subscription._c;\n  if (cleanup) {\n    subscription._c = undefined;\n    cleanup();\n  }\n};\n\nvar subscriptionClosed = function (subscription) {\n  return subscription._o === undefined;\n};\n\nvar closeSubscription = function (subscription) {\n  if (!subscriptionClosed(subscription)) {\n    subscription._o = undefined;\n    cleanupSubscription(subscription);\n  }\n};\n\nvar Subscription = function (observer, subscriber) {\n  anObject(observer);\n  this._c = undefined;\n  this._o = observer;\n  observer = new SubscriptionObserver(this);\n  try {\n    var cleanup = subscriber(observer);\n    var subscription = cleanup;\n    if (cleanup != null) {\n      if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); };\n      else aFunction(cleanup);\n      this._c = cleanup;\n    }\n  } catch (e) {\n    observer.error(e);\n    return;\n  } if (subscriptionClosed(this)) cleanupSubscription(this);\n};\n\nSubscription.prototype = redefineAll({}, {\n  unsubscribe: function unsubscribe() { closeSubscription(this); }\n});\n\nvar SubscriptionObserver = function (subscription) {\n  this._s = subscription;\n};\n\nSubscriptionObserver.prototype = redefineAll({}, {\n  next: function next(value) {\n    var subscription = this._s;\n    if (!subscriptionClosed(subscription)) {\n      var observer = subscription._o;\n      try {\n        var m = getMethod(observer.next);\n        if (m) return m.call(observer, value);\n      } catch (e) {\n        try {\n          closeSubscription(subscription);\n        } finally {\n          throw e;\n        }\n      }\n    }\n  },\n  error: function error(value) {\n    var subscription = this._s;\n    if (subscriptionClosed(subscription)) throw value;\n    var observer = subscription._o;\n    subscription._o = undefined;\n    try {\n      var m = getMethod(observer.error);\n      if (!m) throw value;\n      value = m.call(observer, value);\n    } catch (e) {\n      try {\n        cleanupSubscription(subscription);\n      } finally {\n        throw e;\n      }\n    } cleanupSubscription(subscription);\n    return value;\n  },\n  complete: function complete(value) {\n    var subscription = this._s;\n    if (!subscriptionClosed(subscription)) {\n      var observer = subscription._o;\n      subscription._o = undefined;\n      try {\n        var m = getMethod(observer.complete);\n        value = m ? m.call(observer, value) : undefined;\n      } catch (e) {\n        try {\n          cleanupSubscription(subscription);\n        } finally {\n          throw e;\n        }\n      } cleanupSubscription(subscription);\n      return value;\n    }\n  }\n});\n\nvar $Observable = function Observable(subscriber) {\n  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);\n};\n\nredefineAll($Observable.prototype, {\n  subscribe: function subscribe(observer) {\n    return new Subscription(observer, this._f);\n  },\n  forEach: function forEach(fn) {\n    var that = this;\n    return new (core.Promise || global.Promise)(function (resolve, reject) {\n      aFunction(fn);\n      var subscription = that.subscribe({\n        next: function (value) {\n          try {\n            return fn(value);\n          } catch (e) {\n            reject(e);\n            subscription.unsubscribe();\n          }\n        },\n        error: reject,\n        complete: resolve\n      });\n    });\n  }\n});\n\nredefineAll($Observable, {\n  from: function from(x) {\n    var C = typeof this === 'function' ? this : $Observable;\n    var method = getMethod(anObject(x)[OBSERVABLE]);\n    if (method) {\n      var observable = anObject(method.call(x));\n      return observable.constructor === C ? observable : new C(function (observer) {\n        return observable.subscribe(observer);\n      });\n    }\n    return new C(function (observer) {\n      var done = false;\n      microtask(function () {\n        if (!done) {\n          try {\n            if (forOf(x, false, function (it) {\n              observer.next(it);\n              if (done) return RETURN;\n            }) === RETURN) return;\n          } catch (e) {\n            if (done) throw e;\n            observer.error(e);\n            return;\n          } observer.complete();\n        }\n      });\n      return function () { done = true; };\n    });\n  },\n  of: function of() {\n    for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++];\n    return new (typeof this === 'function' ? this : $Observable)(function (observer) {\n      var done = false;\n      microtask(function () {\n        if (!done) {\n          for (var j = 0; j < items.length; ++j) {\n            observer.next(items[j]);\n            if (done) return;\n          } observer.complete();\n        }\n      });\n      return function () { done = true; };\n    });\n  }\n});\n\nhide($Observable.prototype, OBSERVABLE, function () { return this; });\n\n$export($export.G, { Observable: $Observable });\n\nrequire('./_set-species')('Observable');\n","// https://github.com/tc39/proposal-promise-finally\n'use strict';\nvar $export = require('./_export');\nvar core = require('./_core');\nvar global = require('./_global');\nvar speciesConstructor = require('./_species-constructor');\nvar promiseResolve = require('./_promise-resolve');\n\n$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {\n  var C = speciesConstructor(this, core.Promise || global.Promise);\n  var isFunction = typeof onFinally == 'function';\n  return this.then(\n    isFunction ? function (x) {\n      return promiseResolve(C, onFinally()).then(function () { return x; });\n    } : onFinally,\n    isFunction ? function (e) {\n      return promiseResolve(C, onFinally()).then(function () { throw e; });\n    } : onFinally\n  );\n} });\n","'use strict';\n// https://github.com/tc39/proposal-promise-try\nvar $export = require('./_export');\nvar newPromiseCapability = require('./_new-promise-capability');\nvar perform = require('./_perform');\n\n$export($export.S, 'Promise', { 'try': function (callbackfn) {\n  var promiseCapability = newPromiseCapability.f(this);\n  var result = perform(callbackfn);\n  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);\n  return promiseCapability.promise;\n} });\n","var metadata = require('./_metadata');\nvar anObject = require('./_an-object');\nvar toMetaKey = metadata.key;\nvar ordinaryDefineOwnMetadata = metadata.set;\n\nmetadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {\n  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));\n} });\n","var metadata = require('./_metadata');\nvar anObject = require('./_an-object');\nvar toMetaKey = metadata.key;\nvar getOrCreateMetadataMap = metadata.map;\nvar store = metadata.store;\n\nmetadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {\n  var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);\n  var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);\n  if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;\n  if (metadataMap.size) return true;\n  var targetMetadata = store.get(target);\n  targetMetadata['delete'](targetKey);\n  return !!targetMetadata.size || store['delete'](target);\n} });\n","var Set = require('./es6.set');\nvar from = require('./_array-from-iterable');\nvar metadata = require('./_metadata');\nvar anObject = require('./_an-object');\nvar getPrototypeOf = require('./_object-gpo');\nvar ordinaryOwnMetadataKeys = metadata.keys;\nvar toMetaKey = metadata.key;\n\nvar ordinaryMetadataKeys = function (O, P) {\n  var oKeys = ordinaryOwnMetadataKeys(O, P);\n  var parent = getPrototypeOf(O);\n  if (parent === null) return oKeys;\n  var pKeys = ordinaryMetadataKeys(parent, P);\n  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;\n};\n\nmetadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {\n  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));\n} });\n","var metadata = require('./_metadata');\nvar anObject = require('./_an-object');\nvar getPrototypeOf = require('./_object-gpo');\nvar ordinaryHasOwnMetadata = metadata.has;\nvar ordinaryGetOwnMetadata = metadata.get;\nvar toMetaKey = metadata.key;\n\nvar ordinaryGetMetadata = function (MetadataKey, O, P) {\n  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);\n  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);\n  var parent = getPrototypeOf(O);\n  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;\n};\n\nmetadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {\n  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));\n} });\n","var metadata = require('./_metadata');\nvar anObject = require('./_an-object');\nvar ordinaryOwnMetadataKeys = metadata.keys;\nvar toMetaKey = metadata.key;\n\nmetadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {\n  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));\n} });\n","var metadata = require('./_metadata');\nvar anObject = require('./_an-object');\nvar ordinaryGetOwnMetadata = metadata.get;\nvar toMetaKey = metadata.key;\n\nmetadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {\n  return ordinaryGetOwnMetadata(metadataKey, anObject(target)\n    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));\n} });\n","var metadata = require('./_metadata');\nvar anObject = require('./_an-object');\nvar getPrototypeOf = require('./_object-gpo');\nvar ordinaryHasOwnMetadata = metadata.has;\nvar toMetaKey = metadata.key;\n\nvar ordinaryHasMetadata = function (MetadataKey, O, P) {\n  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);\n  if (hasOwn) return true;\n  var parent = getPrototypeOf(O);\n  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;\n};\n\nmetadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {\n  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));\n} });\n","var metadata = require('./_metadata');\nvar anObject = require('./_an-object');\nvar ordinaryHasOwnMetadata = metadata.has;\nvar toMetaKey = metadata.key;\n\nmetadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {\n  return ordinaryHasOwnMetadata(metadataKey, anObject(target)\n    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));\n} });\n","var $metadata = require('./_metadata');\nvar anObject = require('./_an-object');\nvar aFunction = require('./_a-function');\nvar toMetaKey = $metadata.key;\nvar ordinaryDefineOwnMetadata = $metadata.set;\n\n$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {\n  return function decorator(target, targetKey) {\n    ordinaryDefineOwnMetadata(\n      metadataKey, metadataValue,\n      (targetKey !== undefined ? anObject : aFunction)(target),\n      toMetaKey(targetKey)\n    );\n  };\n} });\n","// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from\nrequire('./_set-collection-from')('Set');\n","// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of\nrequire('./_set-collection-of')('Set');\n","// https://github.com/DavidBruant/Map-Set.prototype.toJSON\nvar $export = require('./_export');\n\n$export($export.P + $export.R, 'Set', { toJSON: require('./_collection-to-json')('Set') });\n","'use strict';\n// https://github.com/mathiasbynens/String.prototype.at\nvar $export = require('./_export');\nvar $at = require('./_string-at')(true);\n\n$export($export.P, 'String', {\n  at: function at(pos) {\n    return $at(this, pos);\n  }\n});\n","'use strict';\n// https://tc39.github.io/String.prototype.matchAll/\nvar $export = require('./_export');\nvar defined = require('./_defined');\nvar toLength = require('./_to-length');\nvar isRegExp = require('./_is-regexp');\nvar getFlags = require('./_flags');\nvar RegExpProto = RegExp.prototype;\n\nvar $RegExpStringIterator = function (regexp, string) {\n  this._r = regexp;\n  this._s = string;\n};\n\nrequire('./_iter-create')($RegExpStringIterator, 'RegExp String', function next() {\n  var match = this._r.exec(this._s);\n  return { value: match, done: match === null };\n});\n\n$export($export.P, 'String', {\n  matchAll: function matchAll(regexp) {\n    defined(this);\n    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');\n    var S = String(this);\n    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);\n    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);\n    rx.lastIndex = toLength(regexp.lastIndex);\n    return new $RegExpStringIterator(rx, S);\n  }\n});\n","'use strict';\n// https://github.com/tc39/proposal-string-pad-start-end\nvar $export = require('./_export');\nvar $pad = require('./_string-pad');\nvar userAgent = require('./_user-agent');\n\n// https://github.com/zloirock/core-js/issues/280\n$export($export.P + $export.F * /Version\\/10\\.\\d+(\\.\\d+)? Safari\\//.test(userAgent), 'String', {\n  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {\n    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);\n  }\n});\n","'use strict';\n// https://github.com/tc39/proposal-string-pad-start-end\nvar $export = require('./_export');\nvar $pad = require('./_string-pad');\nvar userAgent = require('./_user-agent');\n\n// https://github.com/zloirock/core-js/issues/280\n$export($export.P + $export.F * /Version\\/10\\.\\d+(\\.\\d+)? Safari\\//.test(userAgent), 'String', {\n  padStart: function padStart(maxLength /* , fillString = ' ' */) {\n    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);\n  }\n});\n","'use strict';\n// https://github.com/sebmarkbage/ecmascript-string-left-right-trim\nrequire('./_string-trim')('trimLeft', function ($trim) {\n  return function trimLeft() {\n    return $trim(this, 1);\n  };\n}, 'trimStart');\n","'use strict';\n// https://github.com/sebmarkbage/ecmascript-string-left-right-trim\nrequire('./_string-trim')('trimRight', function ($trim) {\n  return function trimRight() {\n    return $trim(this, 2);\n  };\n}, 'trimEnd');\n","require('./_wks-define')('asyncIterator');\n","require('./_wks-define')('observable');\n","// https://github.com/tc39/proposal-global\nvar $export = require('./_export');\n\n$export($export.S, 'System', { global: require('./_global') });\n","// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from\nrequire('./_set-collection-from')('WeakMap');\n","// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of\nrequire('./_set-collection-of')('WeakMap');\n","// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from\nrequire('./_set-collection-from')('WeakSet');\n","// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of\nrequire('./_set-collection-of')('WeakSet');\n","var $iterators = require('./es6.array.iterator');\nvar getKeys = require('./_object-keys');\nvar redefine = require('./_redefine');\nvar global = require('./_global');\nvar hide = require('./_hide');\nvar Iterators = require('./_iterators');\nvar wks = require('./_wks');\nvar ITERATOR = wks('iterator');\nvar TO_STRING_TAG = wks('toStringTag');\nvar ArrayValues = Iterators.Array;\n\nvar DOMIterables = {\n  CSSRuleList: true, // TODO: Not spec compliant, should be false.\n  CSSStyleDeclaration: false,\n  CSSValueList: false,\n  ClientRectList: false,\n  DOMRectList: false,\n  DOMStringList: false,\n  DOMTokenList: true,\n  DataTransferItemList: false,\n  FileList: false,\n  HTMLAllCollection: false,\n  HTMLCollection: false,\n  HTMLFormElement: false,\n  HTMLSelectElement: false,\n  MediaList: true, // TODO: Not spec compliant, should be false.\n  MimeTypeArray: false,\n  NamedNodeMap: false,\n  NodeList: true,\n  PaintRequestList: false,\n  Plugin: false,\n  PluginArray: false,\n  SVGLengthList: false,\n  SVGNumberList: false,\n  SVGPathSegList: false,\n  SVGPointList: false,\n  SVGStringList: false,\n  SVGTransformList: false,\n  SourceBufferList: false,\n  StyleSheetList: true, // TODO: Not spec compliant, should be false.\n  TextTrackCueList: false,\n  TextTrackList: false,\n  TouchList: false\n};\n\nfor (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {\n  var NAME = collections[i];\n  var explicit = DOMIterables[NAME];\n  var Collection = global[NAME];\n  var proto = Collection && Collection.prototype;\n  var key;\n  if (proto) {\n    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);\n    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);\n    Iterators[NAME] = ArrayValues;\n    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);\n  }\n}\n","var $export = require('./_export');\nvar $task = require('./_task');\n$export($export.G + $export.B, {\n  setImmediate: $task.set,\n  clearImmediate: $task.clear\n});\n","// ie9- setTimeout & setInterval additional parameters fix\nvar global = require('./_global');\nvar $export = require('./_export');\nvar userAgent = require('./_user-agent');\nvar slice = [].slice;\nvar MSIE = /MSIE .\\./.test(userAgent); // <- dirty ie9- check\nvar wrap = function (set) {\n  return function (fn, time /* , ...args */) {\n    var boundArgs = arguments.length > 2;\n    var args = boundArgs ? slice.call(arguments, 2) : false;\n    return set(boundArgs ? function () {\n      // eslint-disable-next-line no-new-func\n      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);\n    } : fn, time);\n  };\n};\n$export($export.G + $export.B + $export.F * MSIE, {\n  setTimeout: wrap(global.setTimeout),\n  setInterval: wrap(global.setInterval)\n});\n","require('./modules/es6.symbol');\nrequire('./modules/es6.object.create');\nrequire('./modules/es6.object.define-property');\nrequire('./modules/es6.object.define-properties');\nrequire('./modules/es6.object.get-own-property-descriptor');\nrequire('./modules/es6.object.get-prototype-of');\nrequire('./modules/es6.object.keys');\nrequire('./modules/es6.object.get-own-property-names');\nrequire('./modules/es6.object.freeze');\nrequire('./modules/es6.object.seal');\nrequire('./modules/es6.object.prevent-extensions');\nrequire('./modules/es6.object.is-frozen');\nrequire('./modules/es6.object.is-sealed');\nrequire('./modules/es6.object.is-extensible');\nrequire('./modules/es6.object.assign');\nrequire('./modules/es6.object.is');\nrequire('./modules/es6.object.set-prototype-of');\nrequire('./modules/es6.object.to-string');\nrequire('./modules/es6.function.bind');\nrequire('./modules/es6.function.name');\nrequire('./modules/es6.function.has-instance');\nrequire('./modules/es6.parse-int');\nrequire('./modules/es6.parse-float');\nrequire('./modules/es6.number.constructor');\nrequire('./modules/es6.number.to-fixed');\nrequire('./modules/es6.number.to-precision');\nrequire('./modules/es6.number.epsilon');\nrequire('./modules/es6.number.is-finite');\nrequire('./modules/es6.number.is-integer');\nrequire('./modules/es6.number.is-nan');\nrequire('./modules/es6.number.is-safe-integer');\nrequire('./modules/es6.number.max-safe-integer');\nrequire('./modules/es6.number.min-safe-integer');\nrequire('./modules/es6.number.parse-float');\nrequire('./modules/es6.number.parse-int');\nrequire('./modules/es6.math.acosh');\nrequire('./modules/es6.math.asinh');\nrequire('./modules/es6.math.atanh');\nrequire('./modules/es6.math.cbrt');\nrequire('./modules/es6.math.clz32');\nrequire('./modules/es6.math.cosh');\nrequire('./modules/es6.math.expm1');\nrequire('./modules/es6.math.fround');\nrequire('./modules/es6.math.hypot');\nrequire('./modules/es6.math.imul');\nrequire('./modules/es6.math.log10');\nrequire('./modules/es6.math.log1p');\nrequire('./modules/es6.math.log2');\nrequire('./modules/es6.math.sign');\nrequire('./modules/es6.math.sinh');\nrequire('./modules/es6.math.tanh');\nrequire('./modules/es6.math.trunc');\nrequire('./modules/es6.string.from-code-point');\nrequire('./modules/es6.string.raw');\nrequire('./modules/es6.string.trim');\nrequire('./modules/es6.string.iterator');\nrequire('./modules/es6.string.code-point-at');\nrequire('./modules/es6.string.ends-with');\nrequire('./modules/es6.string.includes');\nrequire('./modules/es6.string.repeat');\nrequire('./modules/es6.string.starts-with');\nrequire('./modules/es6.string.anchor');\nrequire('./modules/es6.string.big');\nrequire('./modules/es6.string.blink');\nrequire('./modules/es6.string.bold');\nrequire('./modules/es6.string.fixed');\nrequire('./modules/es6.string.fontcolor');\nrequire('./modules/es6.string.fontsize');\nrequire('./modules/es6.string.italics');\nrequire('./modules/es6.string.link');\nrequire('./modules/es6.string.small');\nrequire('./modules/es6.string.strike');\nrequire('./modules/es6.string.sub');\nrequire('./modules/es6.string.sup');\nrequire('./modules/es6.date.now');\nrequire('./modules/es6.date.to-json');\nrequire('./modules/es6.date.to-iso-string');\nrequire('./modules/es6.date.to-string');\nrequire('./modules/es6.date.to-primitive');\nrequire('./modules/es6.array.is-array');\nrequire('./modules/es6.array.from');\nrequire('./modules/es6.array.of');\nrequire('./modules/es6.array.join');\nrequire('./modules/es6.array.slice');\nrequire('./modules/es6.array.sort');\nrequire('./modules/es6.array.for-each');\nrequire('./modules/es6.array.map');\nrequire('./modules/es6.array.filter');\nrequire('./modules/es6.array.some');\nrequire('./modules/es6.array.every');\nrequire('./modules/es6.array.reduce');\nrequire('./modules/es6.array.reduce-right');\nrequire('./modules/es6.array.index-of');\nrequire('./modules/es6.array.last-index-of');\nrequire('./modules/es6.array.copy-within');\nrequire('./modules/es6.array.fill');\nrequire('./modules/es6.array.find');\nrequire('./modules/es6.array.find-index');\nrequire('./modules/es6.array.species');\nrequire('./modules/es6.array.iterator');\nrequire('./modules/es6.regexp.constructor');\nrequire('./modules/es6.regexp.to-string');\nrequire('./modules/es6.regexp.flags');\nrequire('./modules/es6.regexp.match');\nrequire('./modules/es6.regexp.replace');\nrequire('./modules/es6.regexp.search');\nrequire('./modules/es6.regexp.split');\nrequire('./modules/es6.promise');\nrequire('./modules/es6.map');\nrequire('./modules/es6.set');\nrequire('./modules/es6.weak-map');\nrequire('./modules/es6.weak-set');\nrequire('./modules/es6.typed.array-buffer');\nrequire('./modules/es6.typed.data-view');\nrequire('./modules/es6.typed.int8-array');\nrequire('./modules/es6.typed.uint8-array');\nrequire('./modules/es6.typed.uint8-clamped-array');\nrequire('./modules/es6.typed.int16-array');\nrequire('./modules/es6.typed.uint16-array');\nrequire('./modules/es6.typed.int32-array');\nrequire('./modules/es6.typed.uint32-array');\nrequire('./modules/es6.typed.float32-array');\nrequire('./modules/es6.typed.float64-array');\nrequire('./modules/es6.reflect.apply');\nrequire('./modules/es6.reflect.construct');\nrequire('./modules/es6.reflect.define-property');\nrequire('./modules/es6.reflect.delete-property');\nrequire('./modules/es6.reflect.enumerate');\nrequire('./modules/es6.reflect.get');\nrequire('./modules/es6.reflect.get-own-property-descriptor');\nrequire('./modules/es6.reflect.get-prototype-of');\nrequire('./modules/es6.reflect.has');\nrequire('./modules/es6.reflect.is-extensible');\nrequire('./modules/es6.reflect.own-keys');\nrequire('./modules/es6.reflect.prevent-extensions');\nrequire('./modules/es6.reflect.set');\nrequire('./modules/es6.reflect.set-prototype-of');\nrequire('./modules/es7.array.includes');\nrequire('./modules/es7.array.flat-map');\nrequire('./modules/es7.array.flatten');\nrequire('./modules/es7.string.at');\nrequire('./modules/es7.string.pad-start');\nrequire('./modules/es7.string.pad-end');\nrequire('./modules/es7.string.trim-left');\nrequire('./modules/es7.string.trim-right');\nrequire('./modules/es7.string.match-all');\nrequire('./modules/es7.symbol.async-iterator');\nrequire('./modules/es7.symbol.observable');\nrequire('./modules/es7.object.get-own-property-descriptors');\nrequire('./modules/es7.object.values');\nrequire('./modules/es7.object.entries');\nrequire('./modules/es7.object.define-getter');\nrequire('./modules/es7.object.define-setter');\nrequire('./modules/es7.object.lookup-getter');\nrequire('./modules/es7.object.lookup-setter');\nrequire('./modules/es7.map.to-json');\nrequire('./modules/es7.set.to-json');\nrequire('./modules/es7.map.of');\nrequire('./modules/es7.set.of');\nrequire('./modules/es7.weak-map.of');\nrequire('./modules/es7.weak-set.of');\nrequire('./modules/es7.map.from');\nrequire('./modules/es7.set.from');\nrequire('./modules/es7.weak-map.from');\nrequire('./modules/es7.weak-set.from');\nrequire('./modules/es7.global');\nrequire('./modules/es7.system.global');\nrequire('./modules/es7.error.is-error');\nrequire('./modules/es7.math.clamp');\nrequire('./modules/es7.math.deg-per-rad');\nrequire('./modules/es7.math.degrees');\nrequire('./modules/es7.math.fscale');\nrequire('./modules/es7.math.iaddh');\nrequire('./modules/es7.math.isubh');\nrequire('./modules/es7.math.imulh');\nrequire('./modules/es7.math.rad-per-deg');\nrequire('./modules/es7.math.radians');\nrequire('./modules/es7.math.scale');\nrequire('./modules/es7.math.umulh');\nrequire('./modules/es7.math.signbit');\nrequire('./modules/es7.promise.finally');\nrequire('./modules/es7.promise.try');\nrequire('./modules/es7.reflect.define-metadata');\nrequire('./modules/es7.reflect.delete-metadata');\nrequire('./modules/es7.reflect.get-metadata');\nrequire('./modules/es7.reflect.get-metadata-keys');\nrequire('./modules/es7.reflect.get-own-metadata');\nrequire('./modules/es7.reflect.get-own-metadata-keys');\nrequire('./modules/es7.reflect.has-metadata');\nrequire('./modules/es7.reflect.has-own-metadata');\nrequire('./modules/es7.reflect.metadata');\nrequire('./modules/es7.asap');\nrequire('./modules/es7.observable');\nrequire('./modules/web.timers');\nrequire('./modules/web.immediate');\nrequire('./modules/web.dom.iterable');\nmodule.exports = require('./modules/_core');\n","function stringify (obj, options) {\n  options = options || {}\n  var indent = JSON.stringify([1], null, get(options, 'indent', 2)).slice(2, -3)\n  var addMargin = get(options, 'margins', false)\n  var maxLength = (indent === '' ? Infinity : get(options, 'maxLength', 80))\n\n  return (function _stringify (obj, currentIndent, reserved) {\n    if (obj && typeof obj.toJSON === 'function') {\n      obj = obj.toJSON()\n    }\n\n    var string = JSON.stringify(obj)\n\n    if (string === undefined) {\n      return string\n    }\n\n    var length = maxLength - currentIndent.length - reserved\n\n    if (string.length <= length) {\n      var prettified = prettify(string, addMargin)\n      if (prettified.length <= length) {\n        return prettified\n      }\n    }\n\n    if (typeof obj === 'object' && obj !== null) {\n      var nextIndent = currentIndent + indent\n      var items = []\n      var delimiters\n      var comma = function (array, index) {\n        return (index === array.length - 1 ? 0 : 1)\n      }\n\n      if (Array.isArray(obj)) {\n        for (var index = 0; index < obj.length; index++) {\n          items.push(\n            _stringify(obj[index], nextIndent, comma(obj, index)) || 'null'\n          )\n        }\n        delimiters = '[]'\n      } else {\n        Object.keys(obj).forEach(function (key, index, array) {\n          var keyPart = JSON.stringify(key) + ': '\n          var value = _stringify(obj[key], nextIndent,\n                                 keyPart.length + comma(array, index))\n          if (value !== undefined) {\n            items.push(keyPart + value)\n          }\n        })\n        delimiters = '{}'\n      }\n\n      if (items.length > 0) {\n        return [\n          delimiters[0],\n          indent + items.join(',\\n' + nextIndent),\n          delimiters[1]\n        ].join('\\n' + currentIndent)\n      }\n    }\n\n    return string\n  }(obj, '', 0))\n}\n\n// Note: This regex matches even invalid JSON strings, but since we’re\n// working on the output of `JSON.stringify` we know that only valid strings\n// are present (unless the user supplied a weird `options.indent` but in\n// that case we don’t care since the output would be invalid anyway).\nvar stringOrChar = /(\"(?:[^\\\\\"]|\\\\.)*\")|[:,\\][}{]/g\n\nfunction prettify (string, addMargin) {\n  var m = addMargin ? ' ' : ''\n  var tokens = {\n    '{': '{' + m,\n    '[': '[' + m,\n    '}': m + '}',\n    ']': m + ']',\n    ',': ', ',\n    ':': ': '\n  }\n  return string.replace(stringOrChar, function (match, string) {\n    return string ? match : tokens[match]\n  })\n}\n\nfunction get (options, name, defaultValue) {\n  return (name in options ? options[name] : defaultValue)\n}\n\nmodule.exports = stringify\n","/**\n * The DoublyLinkedList class provides the main functionality of a doubly linked list.\n *\n * @class DoublyLinkedList\n */\nvar DoublyLinkedList = (function () {\n    function DoublyLinkedList() {\n        /**\n         * Count of elements in list\n         *\n         * @property _length\n         * @type number\n         * @private\n         */\n        this._length = 0;\n        /**\n         * Iteration pointer\n         *\n         * @property _key\n         * @type number\n         * @private\n         */\n        this._key = 0;\n        /**\n         * Reference to head(first) element in list\n         *\n         * @property _head\n         * @type DoublyLinkedListNode\n         * @private\n         */\n        this._head = null;\n        /**\n         * Reference to tail(last) element in list\n         *\n         * @property _tail\n         * @type DoublyLinkedListNode\n         * @private\n         */\n        this._tail = null;\n        /**\n         * Reference to iterated element in list\n         *\n         * @property _current\n         * @type DoublyLinkedListNode\n         * @private\n         */\n        this._current = null;\n    }\n    /**\n     * Insert a new value at the specified index\n     *\n     * @method add\n     * @param index The index where the new value is to be inserted.\n     * @param value The new value for the index.\n     * @return void\n     */\n    DoublyLinkedList.prototype.add = function (index, value) {\n        if (index < 0 || index >= this._length) {\n            throw new Error(\"Out of bounds\");\n        }\n        var i = 0;\n        var current = this._head;\n        while (i < index) {\n            current = current.next;\n            i++;\n        }\n        current.value = value;\n    };\n    /**\n     * Pops a node from the end of the doubly linked list\n     *\n     * @method pop\n     * @return any  The value of the popped node.\n     */\n    DoublyLinkedList.prototype.pop = function () {\n        if (this._length === 0) {\n            throw new Error(\"Can't pop from an empty data structure\");\n        }\n        var value = this._tail.value;\n        this._tail = this._tail.prev;\n        if (this._tail) {\n            delete this._tail.next;\n            this._tail.next = null;\n        }\n        this._length--;\n        if (this._length === 0) {\n            delete this._head;\n            this._head = null;\n        }\n        return value;\n    };\n    /**\n     * Shifts a node from the beginning of the doubly linked list\n     *\n     * @method shift\n     * @return any  The value of the shifted node.\n     */\n    DoublyLinkedList.prototype.shift = function () {\n        if (this._length === 0) {\n            throw new Error(\"Can't shift from an empty data structure\");\n        }\n        var value = this._head.value;\n        this._head = this._head.next;\n        if (this._head) {\n            delete this._head.prev;\n            this._head.prev = null;\n        }\n        this._length--;\n        return value;\n    };\n    /**\n     * Pushes an element at the end of the doubly linked list\n     *\n     * @method push\n     * @param value The value to push.\n     * @return void\n     */\n    DoublyLinkedList.prototype.push = function (value) {\n        // allocate new node\n        var node = {\n            value: value,\n            prev: this._tail,\n            next: null\n        };\n        if (this._length === 0) {\n            this._head = this._tail = node;\n        }\n        else {\n            this._tail.next = node;\n            this._tail = this._tail.next;\n        }\n        this._length++;\n    };\n    /**\n     * Prepends the doubly linked list with an element\n     *\n     * @method unshift\n     * @param value The value to unshift.\n     * @return void\n     */\n    DoublyLinkedList.prototype.unshift = function (value) {\n        // allocate new node\n        var node = {\n            value: value,\n            prev: null,\n            next: this._head\n        };\n        if (this._length === 0) {\n            this._head = this._tail = node;\n        }\n        else {\n            this._head.prev = node;\n            this._head = this._head.prev;\n        }\n        this._length++;\n    };\n    /**\n     * Peeks at the node from the end of the doubly linked list\n     *\n     * @method top\n     * @return any  The value of the last node.\n     */\n    DoublyLinkedList.prototype.top = function () {\n        if (this._tail)\n            return this._tail.value;\n    };\n    /**\n     * Peeks at the node from the beginning of the doubly linked list\n     *\n     * @method bottom\n     * @return any  The value of the first node.\n     */\n    DoublyLinkedList.prototype.bottom = function () {\n        if (this._head)\n            return this._head.value;\n    };\n    /**\n     * Counts the number of elements in the doubly linked list\n     *\n     * @method count\n     * @return number the number of elements in the doubly linked list.\n     */\n    DoublyLinkedList.prototype.count = function () {\n        return this._length;\n    };\n    /**\n     * Checks whether the doubly linked list is empty\n     *\n     * @method isEmpty\n     * @return boolean whether the doubly linked list is empty.\n     */\n    DoublyLinkedList.prototype.isEmpty = function () {\n        return (this._length === 0);\n    };\n    /**\n     * Rewind iterator back to the start\n     *\n     * @method rewind\n     * @return void\n     */\n    DoublyLinkedList.prototype.rewind = function () {\n        this._key = 0;\n        this._current = this._head;\n    };\n    /**\n     * Return current list entry\n     *\n     * @method current\n     * @return any  The current node value.\n     */\n    DoublyLinkedList.prototype.current = function () {\n        if (this._current) {\n            return this._current.value;\n        }\n        return null;\n    };\n    /**\n     * Return current node index\n     *\n     * @method key\n     * @return any  The current node index.\n     */\n    DoublyLinkedList.prototype.key = function () {\n        return this._key;\n    };\n    /**\n     * Move to next entry\n     *\n     * @method next\n     * @return void\n     */\n    DoublyLinkedList.prototype.next = function () {\n        this._current = this._current.next;\n        this._key++;\n    };\n    /**\n     * Move to previous entry\n     *\n     * @method prev\n     * @return void\n     */\n    DoublyLinkedList.prototype.prev = function () {\n        this._current = this._current.prev;\n        this._key--;\n    };\n    /**\n     * Check whether the doubly linked list contains more nodes\n     *\n     * @method valid\n     * @return boolean true if the doubly linked list contains any more nodes, false otherwise.\n     */\n    DoublyLinkedList.prototype.valid = function () {\n        return (this._key >= 0 && this._key < this._length);\n    };\n    /**\n     * Export the list to array\n     *\n     * @method toArray\n     * @return Array   The exported array\n     */\n    DoublyLinkedList.prototype.toArray = function () {\n        var list = [];\n        var current = this._head;\n        while (current) {\n            list.push(current.value);\n            current = current.next;\n        }\n        return list;\n    };\n    /**\n     * Serializes the list to string\n     *\n     * @method toString\n     * @return string   The serialized string.\n     */\n    DoublyLinkedList.prototype.toString = function () {\n        return \"{\" + this.toArray().join(\"->\") + \"}\";\n    };\n    return DoublyLinkedList;\n})();\nmodule.exports = DoublyLinkedList;\n//# sourceMappingURL=DoublyLinkedList.js.map","/**\n * The Heap class provides the main functionality of a Heap.\n *\n * @class Heap\n */\nvar Heap = (function () {\n    function Heap() {\n        /**\n         * Binary tree storage array\n         *\n         * @property _tree\n         * @type Array\n         * @private\n         */\n        this._tree = [];\n        /**\n         * Heap type\n         *\n         * @property _type\n         * @type number\n         * @private\n         */\n        this._type = Heap.MAX;\n        /**\n         * Iteration pointer\n         *\n         * @property _key\n         * @type number\n         * @private\n         */\n        this._key = 0;\n    }\n    /**\n     * Get index of left child element in binary tree stored in array\n     *\n     * @method _child\n     * @param n\n     * @return number\n     * @private\n     */\n    Heap.prototype._child = function (n) {\n        return 2 * n + 1;\n    };\n    /**\n     * Get index of parent element in binary tree stored in array\n     *\n     * @method _parent\n     * @param n\n     * @return number\n     * @private\n     */\n    Heap.prototype._parent = function (n) {\n        //console.log('n=', n, Math.floor(n / 2));\n        return Math.floor(n / 2);\n    };\n    /**\n     * Swap 2 elements in binary tree\n     *\n     * @method _swap\n     * @param first\n     * @param second\n     * @private\n     */\n    Heap.prototype._swap = function (first, second) {\n        var swap = this._tree[first];\n        this._tree[first] = this._tree[second];\n        this._tree[second] = swap;\n    };\n    /**\n     * Sift elements in binary tree\n     *\n     * @method _siftUp\n     * @param i\n     * @private\n     */\n    Heap.prototype._siftUp = function (i) {\n        while (i > 0) {\n            var parent = this._parent(i);\n            if (this.compare(this._tree[i], this._tree[parent]) * this._type > 0) {\n                this._swap(i, parent);\n                i = parent;\n            }\n            else {\n                break;\n            }\n        }\n    };\n    /**\n     * Sift down elements in binary tree\n     *\n     * @method _siftDown\n     * @param i\n     * @private\n     */\n    Heap.prototype._siftDown = function (i) {\n        while (i < this._tree.length) {\n            var left = this._child(i);\n            var right = left + 1;\n            if ((left < this._tree.length) && (right < this._tree.length) &&\n                (this.compare(this._tree[i], this._tree[left]) * this._type < 0 ||\n                    this.compare(this._tree[i], this._tree[right]) * this._type < 0)) {\n                // there is 2 children and one of them must be swapped\n                // get correct element to sift down\n                var sift = left;\n                if (this.compare(this._tree[left], this._tree[right]) * this._type < 0) {\n                    sift = right;\n                }\n                this._swap(i, sift);\n                i = sift;\n            }\n            else if (left < this._tree.length &&\n                this.compare(this._tree[i], this._tree[left]) * this._type < 0) {\n                // only one child exists\n                this._swap(i, left);\n                i = left;\n            }\n            else {\n                break;\n            }\n        }\n    };\n    /**\n     * Extracts a node from top of the heap and sift up\n     *\n     * @method extract\n     * @return any The value of the extracted node.\n     */\n    Heap.prototype.extract = function () {\n        if (this._tree.length === 0) {\n            throw new Error(\"Can't extract from an empty data structure\");\n        }\n        var extracted = this._tree[0];\n        if (this._tree.length === 1) {\n            this._tree = [];\n        }\n        else {\n            this._tree[0] = this._tree.pop();\n            this._siftDown(0);\n        }\n        return extracted;\n    };\n    /**\n     * Inserts an element in the heap by sifting it up\n     *\n     * @method insert\n     * @param value The value to insert.\n     * @return void\n     */\n    Heap.prototype.insert = function (value) {\n        this._tree.push(value);\n        this._siftUp(this._tree.length - 1);\n    };\n    /**\n     * Peeks at the node from the top of the heap\n     *\n     * @method top\n     * @return any The value of the node on the top.\n     */\n    Heap.prototype.top = function () {\n        if (this._tree.length === 0) {\n            throw new Error(\"Can't peek at an empty heap\");\n        }\n        return this._tree[0];\n    };\n    /**\n     * Counts the number of elements in the heap\n     *\n     * @method count\n     * @return number the number of elements in the heap.\n     */\n    Heap.prototype.count = function () {\n        return this._tree.length;\n    };\n    /**\n     * Checks whether the heap is empty\n     *\n     * @method isEmpty\n     * @return boolean whether the heap is empty.\n     */\n    Heap.prototype.isEmpty = function () {\n        return (this._tree.length === 0);\n    };\n    /**\n     * Rewind iterator back to the start (no-op)\n     *\n     * @method rewind\n     * @return void\n     */\n    Heap.prototype.rewind = function () {\n        this._key = 0;\n    };\n    /**\n     * Return current node pointed by the iterator\n     *\n     * @method current\n     * @return any The current node value.\n     */\n    Heap.prototype.current = function () {\n        return this._tree[this._key];\n    };\n    /**\n     * Return current node index\n     *\n     * @method key\n     * @return any The current node index.\n     */\n    Heap.prototype.key = function () {\n        return this._key;\n    };\n    /**\n     * Move to the next node\n     *\n     * @method next\n     * @return void\n     */\n    Heap.prototype.next = function () {\n        this._key++;\n    };\n    /**\n     * Move to previous entry\n     *\n     * @method prev\n     * @return void\n     */\n    Heap.prototype.prev = function () {\n        this._key--;\n    };\n    /**\n     * Check whether the heap contains more nodes\n     *\n     * @method valid\n     * @return boolean true if the heap contains any more nodes, false otherwise.\n     */\n    Heap.prototype.valid = function () {\n        return (this._key >= 0 && this._key < this._tree.length);\n    };\n    /**\n     * Compare elements in order to place them correctly in the heap while sifting up.\n     *\n     * @method compare\n     * @param first The value of the first node being compared.\n     * @param second The value of the second node being compared.\n     * @return number Result of the comparison, positive integer if first is greater than second, 0 if they are equal, negative integer otherwise.\n     * Having multiple elements with the same value in a Heap is not recommended. They will end up in an arbitrary relative position.\n     */\n    Heap.prototype.compare = function (first, second) {\n        if (first > second) {\n            return 1;\n        }\n        else if (first == second) {\n            return 0;\n        }\n        else {\n            return -1;\n        }\n    };\n    /**\n     * Visually display heap tree\n     *\n     * @method _displayNode\n     * @param node\n     * @param prefix\n     * @param last\n     * @return String\n     * @private\n     */\n    Heap.prototype._displayNode = function (node, prefix, last) {\n        if (prefix === void 0) { prefix = ''; }\n        if (last === void 0) { last = true; }\n        var line = prefix;\n        // get child indexes\n        var left = this._child(node);\n        var right = left + 1;\n        if (last) {\n            line += (prefix ? '└─' : '  ');\n        }\n        else {\n            line += '├─';\n        }\n        line += this._tree[node];\n        prefix += (last ? '  ' : '│ ');\n        if (left < this._tree.length) {\n            line += '\\n' + this._displayNode(left, prefix, (this._tree[right] == undefined ? true : false));\n        }\n        if (right < this._tree.length) {\n            line += '\\n' + this._displayNode(right, prefix, true);\n        }\n        return line;\n    };\n    /**\n     * Serializes the heap to string\n     *\n     * @method toString\n     * @return string   The serialized string.\n     */\n    Heap.prototype.toString = function () {\n        // start with root and recursively goes to each node\n        return this._displayNode(0);\n    };\n    /**\n     * Serializes the heap to array\n     *\n     * @method toArray\n     * @return Array   The serialized array.\n     */\n    Heap.prototype.toArray = function () {\n        return this._tree;\n    };\n    /**\n     * Max heap flag\n     *\n     * @property MAX\n     * @type number\n     * @static\n     */\n    Heap.MAX = 1;\n    /**\n     * Min heap flag\n     *\n     * @property MIN\n     * @type number\n     * @static\n     */\n    Heap.MIN = -1;\n    return Heap;\n})();\nmodule.exports = Heap;\n//# sourceMappingURL=Heap.js.map","var __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\nvar Heap = require('./Heap');\n/**\n * The MaxHeap class provides the main functionality of a heap, keeping the maximum on the top.\n *\n * @class MaxHeap\n * @extends Heap\n */\nvar MaxHeap = (function (_super) {\n    __extends(MaxHeap, _super);\n    function MaxHeap() {\n        _super.apply(this, arguments);\n        this._type = Heap.MAX;\n    }\n    return MaxHeap;\n})(Heap);\nmodule.exports = MaxHeap;\n//# sourceMappingURL=MaxHeap.js.map","var __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\nvar Heap = require('./Heap');\n/**\n * The MinHeap class provides the main functionality of a heap, keeping the minimum on the top.\n *\n * @class MinHeap\n * @extends Heap\n */\nvar MinHeap = (function (_super) {\n    __extends(MinHeap, _super);\n    function MinHeap() {\n        _super.apply(this, arguments);\n        this._type = Heap.MIN;\n    }\n    return MinHeap;\n})(Heap);\nmodule.exports = MinHeap;\n//# sourceMappingURL=MinHeap.js.map","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Heap = require('./Heap');\n/**\n * The PriorityQueue class provides the main functionality of an prioritized queue, implemented using a max heap.\n *\n * @class PriorityQueue\n * @extends Heap\n */\nvar PriorityQueue = (function (_super) {\n    __extends(PriorityQueue, _super);\n    function PriorityQueue() {\n        _super.apply(this, arguments);\n        this._type = Heap.MAX;\n    }\n    /**\n     * Adds an element to the queue\n     *\n     * @method enqueue\n     * @param value The value to enqueue.\n     * @param priority The priority of value.\n     * @return void\n     */\n    PriorityQueue.prototype.enqueue = function (value, priority) {\n        return this.insert(new PriorityQueueNode(value, priority));\n    };\n    /**\n     * Dequeues a node from the queue\n     *\n     * @method dequeue\n     * @return any  The value of the dequeued node.\n     */\n    PriorityQueue.prototype.dequeue = function () {\n        return this.extract().value;\n    };\n    /**\n     * Peeks at the node from the top of the heap\n     *\n     * @method top\n     * @return any The value of the node on the top.\n     */\n    PriorityQueue.prototype.top = function () {\n        return _super.prototype.top.call(this).value;\n    };\n    /**\n     * Compare elements in order to place them correctly in the heap while sifting up.\n     *\n     * @method compare\n     * @param first The value of the first node being compared.\n     * @param second The value of the second node being compared.\n     * @return number Result of the comparison, positive integer if first is greater than second, 0 if they are equal, negative integer otherwise.\n     * Having multiple elements with the same value in a Heap is not recommended. They will end up in an arbitrary relative position.\n     */\n    PriorityQueue.prototype.compare = function (first, second) {\n        if (first.priority > second.priority) {\n            return 1;\n        }\n        else if (first.priority == second.priority) {\n            return 0;\n        }\n        else {\n            return -1;\n        }\n    };\n    return PriorityQueue;\n})(Heap);\n/**\n * PriorityQueue Node\n *\n * @class PriorityQueueNode\n */\nvar PriorityQueueNode = (function () {\n    /**\n     * Constructor\n     *\n     * @method constructor\n     * @param value\n     * @param priority\n     */\n    function PriorityQueueNode(value, priority) {\n        this.value = value;\n        this.priority = priority;\n    }\n    /**\n     * Serializes the node to string\n     *\n     * @method toString\n     * @return string   The serialized string.\n     */\n    PriorityQueueNode.prototype.toString = function () {\n        return this.value + \" [\" + this.priority + \"]\";\n    };\n    return PriorityQueueNode;\n})();\nmodule.exports = PriorityQueue;\n//# sourceMappingURL=PriorityQueue.js.map","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DoublyLinkedList = require('./DoublyLinkedList');\n/**\n * The Queue class provides the main functionality of a queue implemented using a doubly linked list.\n *\n * @class Queue\n * @extends DoublyLinkedList\n */\nvar Queue = (function (_super) {\n    __extends(Queue, _super);\n    function Queue() {\n        _super.apply(this, arguments);\n    }\n    /**\n     * Adds an element to the queue\n     *\n     * @method enqueue\n     * @param value The value to enqueue.\n     * @return void\n     */\n    Queue.prototype.enqueue = function (value) {\n        return this.push(value);\n    };\n    /**\n     * Dequeues a node from the queue\n     *\n     * @method dequeue\n     * @return any  The value of the dequeued node.\n     */\n    Queue.prototype.dequeue = function () {\n        return this.shift();\n    };\n    return Queue;\n})(DoublyLinkedList);\nmodule.exports = Queue;\n//# sourceMappingURL=Queue.js.map","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DoublyLinkedList = require('./DoublyLinkedList');\n/**\n * The Stack class provides the main functionality of a stack implemented using a doubly linked list.\n *\n * @class Stack\n * @extends DoublyLinkedList\n */\nvar Stack = (function (_super) {\n    __extends(Stack, _super);\n    function Stack() {\n        _super.apply(this, arguments);\n    }\n    return Stack;\n})(DoublyLinkedList);\nmodule.exports = Stack;\n//# sourceMappingURL=Stack.js.map","/**\n * STL\n * @type {{DoublyLinkedList: exports, Stack: exports, Queue: exports, Heap: exports, MaxHeap: exports, MinHeap: exports, PriorityQueue: exports}}\n */\nmodule.exports = {\n\tDoublyLinkedList: require('./Datastructures/DoublyLinkedList'),\n\tStack: require('./Datastructures/Stack'),\n\tQueue: require('./Datastructures/Queue'),\n\tHeap: require('./Datastructures/Heap'),\n\tMaxHeap: require('./Datastructures/MaxHeap'),\n\tMinHeap: require('./Datastructures/MinHeap'),\n\tPriorityQueue: require('./Datastructures/PriorityQueue')\n};","\"use strict\";\n\n// import the babel polyfill that allows usage of generators\nimport \"babel-polyfill\";\n\n// import the main class\nimport Canvas from './modules/Canvas';\n\n/**\n * When the document is ready, initialize the application\n */\n$(() => {\n    new Canvas(\"#canvas\", 10);\n});\n","// editor elements (gates, wires...)\nimport * as editorElements from './editorElements'\n\n// svg elements\nimport {Pattern, Rectangle, PolyLinePoint, PolyLinePoints, PolyLine} from './svgObjects'\n\n// network logic and simulation\nimport Logic from './Logic'\nimport Simulation from './Simulation'\n\n// ui stuff\nimport ContextMenu from './ui/ContextMenu'\nimport FloatingMenu from './ui/FloatingMenu'\nimport Tutorial from './ui/Tutorial'\nimport Messages from './ui/Messages'\nimport ViewBox from './ui/ViewBox'\n\n// mouse scroll event listerer for ui, manhattan distance for importData\nimport {addMouseScrollEventListener, manhattanDistance} from './other/helperFunctions'\n\n// used in importData\n// note: imported from a node module\nimport {PriorityQueue} from 'libstl'\n\nconst ctrlKey = 17,\n    cmdKey = 91;\n\n/** @module Canvas */\n/**\n * Main class of the application. It represents an instance of the whole editor and holds\n * references to all its elements.\n */\nexport default class Canvas {\n    /**\n     * Initialize the Svg class\n     * @param {string} canvas   query selector of the SVG element, that will contain all SVG content of the application\n     * @param {number} gridSize initial size of the grid in SVG pixels\n     */\n    constructor(canvas, gridSize) {\n        /**\n         * jQuery element for the SVG document\n         */\n        this.$svg = $(canvas);\n\n        /**\n         * space between grid lines in SVG pixels\n         * @type {number}\n         */\n        this.gridSize = gridSize;\n\n        /**\n         * Array of all boxes (instances of objects derived from editorElements.Box) used on Canvas\n         * @type {Array}\n         */\n        this.boxes = []; // stores all boxes\n\n        /**\n         * Array of all wires (instances of editorElements.Wire) used on Canvas\n         * @type {Array}\n         */\n        this.wires = []; // stores all wires\n\n        // TODO document this\n        this.messages = new Messages();\n\n        this.simulationEnabled = true\n        this.simulation = new Simulation(this); // dummy, will be overwritten on startNewSimulation\n\n        /**\n         * distance from the left top corner to the first element in the imported network\n         * and distance from the left top corner to the imported black box _in grid pixels_\n         * @type {number}\n         */\n        this.leftTopPadding = 4;\n\n        // create the defs element, used for patterns\n        this.$defs = $(\"<defs>\");\n        this.$svg.prepend(this.$defs);\n\n        // BACKGROUND PATTERN\n        let pattern = new Pattern(\"grid\", this.gridSize, this.gridSize);\n\n        let patternPoints = new PolyLinePoints().append(new PolyLinePoint(0, 0)).append(new PolyLinePoint(this.gridSize, 0)).append(new PolyLinePoint(this.gridSize, this.gridSize));\n\n        pattern.addChild(new PolyLine(patternPoints, 2, \"#c2c3e4\"));\n        this.addPattern(pattern.get());\n\n        this.background = new Rectangle(0, 0, this.width, this.height, \"url(#grid)\", \"none\");\n        this.appendJQueryObject(this.background.get());\n        this.refresh();\n\n        // set the viewbox for future zooming and moving of the canvas\n        this.$svg.attr('preserveAspectRatio', 'xMinYMin slice')\n        this.viewbox = new ViewBox(0, 0, this.width, this.height)\n        this.applyViewbox()\n\n        // CONSTRUCT CONTEXT MENU\n        this.contextMenu = new ContextMenu(this);\n\n        // CONSTRUCT FLOATING MENU\n        this.floatingMenu = new FloatingMenu(this);\n\n        let target;\n\n        // ALL EVENT CALLBACKS\n        this.$svg.on('mousedown', event => {\n            target = this.getRealTarget(event.target);\n\n            if (target !== undefined) {\n                // propagate mousedown to the real target\n                target.onMouseDown(event);\n            } else {\n                // mousedown happened directly on the svg\n                this.onMouseDown(event)\n            }\n\n            this.hideContextMenu();\n            event.preventDefault();\n        }).on('mousemove', event => {\n            if (target !== undefined) {\n                target.onMouseMove(event);\n            } else {\n                // mousemove happened directly on the svg\n                this.onMouseMove(event)\n            }\n\n            event.preventDefault();\n        }).on('mouseup', event => {\n            if (target !== undefined) {\n                target.onMouseUp(event);\n            } else {\n                // mouseup happened directly on the svg\n                this.onMouseUp(event)\n            }\n\n            target = undefined;\n\n            event.preventDefault();\n        }).on(\"contextmenu\", event => {\n            this.displayContextMenu(event.pageX, event.pageY, this.getRealJQueryTarget(event.target));\n            event.preventDefault();\n        })\n\n        $(document).on('keydown', event => {\n            this.onKeyDown(event);\n        }).on(\"keyup\", event => {\n            this.onKeyUp(event);\n        });\n\n        // update the viewbox on window resize\n        $(window).on('resize', () => {\n            this.viewbox.newDimensions(this.width, this.height);\n            this.applyViewbox();\n        });\n\n        addMouseScrollEventListener(canvas, event => {\n            // zoom only if the ctrl key is not pressed\n            if (!event.ctrlKey) {\n                this.zoom += event.delta * 0.1;\n\n                event.preventDefault()\n            }\n        })\n\n        $(window).on('keydown', (event) => {\n            const actions = {\n                '+': 0.1,\n                '-': -0.1\n            }\n\n            if (actions[event.key]) {\n                this.zoom += actions[event.key];\n            }\n        })\n\n        /**\n         * property containing an instance of [Tutorial](./module-Tutorial.html), if there is any\n         * @type {Tutorial}\n         */\n        this.tutorial;\n\n        // check if the user visits for the first time, if so, start the tutorial\n        try {\n            if (!localStorage.userHasVisited) {\n                this.startTutorial();\n            }\n        } catch (e) {\n            console.warn(e);\n        }\n    }\n\n    /**\n     * Get the width of the main SVG element\n     * @return {number} width of the SVG element in pixels\n     */\n    get width() {\n        return this.$svg.width()\n    }\n\n    /**\n     * Get the height of the main SVG element\n     * @return {number} height of the SVG element in pixels\n     */\n    get height() {\n        return this.$svg.height()\n    }\n\n    /**\n     * Process all keydown events that are connected to Canvas\n     * @param  {jquery.KeyboardEvent} event KeyboardEvent generated by a listener\n     */\n    onKeyDown(event) {\n        if (event.keyCode === ctrlKey || event.keyCode === cmdKey) {\n            this.$svg.addClass('grabbable');\n        }\n    }\n\n    /**\n     * Process all keyup events that are connected to Canvas\n     * @param  {jquery.KeyboardEvent} event KeyboardEvent generated by a listener\n     */\n    onKeyUp(event) {\n        if (event.keyCode === ctrlKey || event.keyCode === cmdKey) {\n            this.$svg.removeClass('grabbable');\n        }\n    }\n\n    /**\n     * Process all mousedown events that are happening directly on the Canvas\n     * @param  {jquery.MouseEvent} event MouseEvent generated by a listener\n     */\n    onMouseDown(event) {\n        // any click on canvas cancels the wire creation\n        this.cancelWireCreation();\n\n        // middle mouse or left mouse + ctrl moves the canvas\n        if (event.which === 2 || (event.which === 1 && event.ctrlKey)) {\n            this.$svg.addClass('grabbed');\n            this.moveCanvas = {\n                left: event.pageX,\n                top: event.pageY\n            }\n        }\n    }\n\n    /**\n     * Process all mousemove events that are happening directly on the Canvas\n     * @param  {jquery.MouseEvent} event MouseEvent generated by a listener\n     */\n    onMouseMove(event) {\n        if (this.moveCanvas) {\n            let left = event.pageX - this.moveCanvas.left\n            let top = event.pageY - this.moveCanvas.top\n\n            this.viewbox.leftShift += left\n            this.viewbox.topShift += top\n            this.applyViewbox()\n\n            this.moveCanvas = {\n                left: event.pageX,\n                top: event.pageY\n            }\n        }\n    }\n\n    /**\n     * Process all mouseup events that are happening directly on the Canvas\n     */\n    onMouseUp() {\n        if (this.moveCanvas) {\n            this.$svg.removeClass('grabbed');\n            this.moveCanvas = undefined\n\n            // if tutorial exists, call tutorial callback\n            if (this.tutorial) {\n                this.tutorial.onCanvasMoved();\n            }\n        }\n    }\n\n    /**\n     * Set the viewBox attribute of the SVG element and size and position attributes\n     * of the rectangle with the background grid to match the values in this.viewbox\n     */\n    applyViewbox() {\n        // adjust background\n        this.background.addAttr({x: this.viewbox.left, y: this.viewbox.top, width: this.viewbox.width, height: this.viewbox.height})\n\n        // set the viewBox attribute\n        this.$svg.attr('viewBox', this.viewbox.str)\n    }\n\n    /**\n     * Get the current zoom multiplier of the canvas\n     * @return {number}\n     */\n    get zoom() {\n        return this.viewbox.zoom\n    }\n\n    /**\n     * Set the zoom multiplier of the canvas.\n     * I sets the viewbox zoom and then applies the new value by calling this.applyViewbox()\n     * @param  {number} value set the zoom to this value\n     */\n    set zoom(value) {\n        this.viewbox.zoom = value\n        this.applyViewbox()\n\n        // if tutorial exists, call tutorial callback\n        if (this.tutorial) {\n            this.tutorial.onCanvasZoomed();\n        }\n    }\n\n    /**\n     * start the tutorial\n     */\n    startTutorial() {\n        // instantiate the tutorial\n        this.tutorial = new Tutorial(this, () => {\n            // set userHasVisited to true when user closes (or finishes) the tutorial\n            localStorage.userHasVisited = true;\n\n            // unset the this.tutorial property\n            this.tutorial = undefined;\n        });\n\n        // start the tutorial\n        this.tutorial.start();\n    }\n\n    /**\n     * Generate an object containing export data for the Canvas and all elements.\n     * Data from this function should cover all important information needed to import the\n     * network in a different session.\n     * @return {object} object containing infomration about the network\n     */\n    get exportData() {\n        this.exportWireIdMap = new Map();\n        this.exportWireId = 0;\n\n        let data = {\n            boxes: []\n        };\n\n        for (const box of this.boxes) {\n            data.boxes.push(box.exportData)\n        }\n\n        return data;\n    }\n\n    /**\n     * Recreate a logic network from the data provided\n     * @param  {object} data object containing information about the imported network\n     * @param  {number} [x]  horizontal position of the left top corner of the network in grid pixels\n     * @param  {number} [y]  vertical position of the left top corner of the network in grid pixels\n     */\n    importData(data, x, y) {\n        return new Promise(resolve => {\n            let warnings = [];\n\n            // if the x or y is undefined, set it to leftTopPadding instead\n            // (cannot use x || leftTopPadding because of 0)\n            x = x !== undefined\n                ? x\n                : this.leftTopPadding\n            y = y !== undefined\n                ? y\n                : this.leftTopPadding\n\n            this.simulationEnabled = false\n\n            // list of wires to be added\n            let newWires = new Map();\n\n            // find the leftmost and topmost coordinate of any box, save them to leftTopCorner\n            let leftTopCorner = {\n                x: 0,\n                y: 0\n            };\n\n            for (const boxData of data.boxes) {\n                if (boxData.transform && boxData.transform.items) {\n                    for (const transformInfo of boxData.transform.items) {\n                        if (transformInfo.name === \"translate\") {\n                            if (leftTopCorner) {\n                                leftTopCorner = {\n                                    x: Math.min(leftTopCorner.x, transformInfo.args[0]),\n                                    y: Math.min(leftTopCorner.y, transformInfo.args[1])\n                                }\n                            } else {\n                                leftTopCorner = {\n                                    x: transformInfo.args[0],\n                                    y: transformInfo.args[1]\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            for (let boxData of data.boxes) {\n                // mapping of dataBox.name of the objects that have category \"other\"\n                const otherMap = {\n                    \"input\": () => this.newInput(0, 0, boxData.isOn, false),\n                    \"output\": () => this.newOutput(0, 0, false)\n                }\n\n                // mapping of dataBox.category\n                const boxMap = {\n                    \"gate\": () => this.newGate(boxData.name, 0, 0, false),\n                    \"blackbox\": () => this.newBlackbox(boxData.inputs, boxData.outputs, boxData.table, boxData.name, 0, 0, false),\n                    \"other\": () => {\n                        if (!boxData.name)\n                            throw `This network contains a box without a name.`\n\n                        if (!otherMap[boxData.name])\n                            throw `This network contains unknown box names. (${boxData.name})`\n\n                        return otherMap[boxData.name]()\n                    }\n                }\n\n                const createBox = () => {\n                    if (!boxData.category)\n                        throw `This network a box without a category.`;\n\n                    if (!boxMap[boxData.category])\n                        throw `This network contains unknown box categories. (${boxData.category})`;\n\n                    return boxMap[boxData.category]()\n                }\n\n                let box;\n\n                try {\n                    box = createBox();\n                } catch (e) {\n                    warnings.push(e);\n                }\n\n                if (box) {\n                    // proccess box transforms (translation and rotation)\n                    let transform = new editorElements.Transform();\n                    let rotationCount = 0;\n\n                    const transformItemMap = {\n                        \"translate\": (args) => {\n                            transform.setTranslate(\n                                args[0]\n                                    - leftTopCorner.x // make it the relative distance from the leftmost element\n                                    + x // apply the position\n                                    ,\n                                args[1]\n                                    - leftTopCorner.y // make it the relative distance from the topmost element\n                                    + y // apply the position\n                          );\n                        },\n                        \"rotate\": (args) => {\n                            rotationCount = args[0] % 360 / 90;\n                        }\n                    }\n\n                    if (boxData.transform && boxData.transform.items) {\n                        for (const transformItem of boxData.transform.items) {\n                            const {name, args} = transformItem;\n\n                            if (!name) {\n                                warnings.push(`This network contains unnamed transform properties.`);\n                                break;\n                            }\n\n                            if (!transformItemMap[name]) {\n                                warnings.push(`This network contains unknown transform properties. (${transformItem.name})`);\n                                break;\n                            }\n\n                            transformItemMap[name](args)\n                        }\n                    }\n\n                    transform.toSVGPixels(this);\n                    box.setTransform(transform);\n\n                    for (let i = 0; i < rotationCount; ++i) {\n                        box.rotate(true);\n                    }\n\n                    // add all wires to the list of wires to be added\n                    if (boxData.connections) {\n                        for (const connection of boxData.connections) {\n                            // get the artificial wire id\n                            let wireId = connection.wireId;\n\n                            // pass the values got from json into a variable that will be added into the map\n                            let value = {\n                                index: connection.index,\n                                boxId: box.id\n                            };\n\n                            // add the value to the map\n                            if (newWires.has(wireId)) {\n                                // if there already is a wire with this id in the map,\n                                // add the value to the end of the array of values\n                                let mapValue = newWires.get(wireId);\n                                mapValue.push(value);\n                                newWires.set(wireId, mapValue);\n                            } else {\n                                // if there is no wire with this id in the map\n                                // add the wire and set the value to be the first element in the array\n                                newWires.set(wireId, [value]);\n                            }\n                        }\n                    }\n                }\n            }\n\n            // refresh the SVG document (needed for wiring)\n            this.refresh();\n\n            // with all boxes added, we can now connect them with wires\n\n            // priority queue for the new wires, priority being (1 / manhattanDistance) between the conenctors, higher is better\n            let wireQueue = new PriorityQueue();\n\n            // get all ids for lal the\n            for (const wireInfo of newWires.values()) {\n                let connectorIds = [];\n\n                // create an array [connector1Id, connector2Id]\n                for (const {boxId, index}\n                of wireInfo) {\n                    connectorIds.push(this.getBoxById(boxId).connectors[index].id)\n                }\n\n                // create and array [{x, y}, {x, y}] containing positions for connectors 1 and 2\n                const connectorsPositions = connectorIds.map(connectorId => this.getConnectorPosition(this.getConnectorById(connectorId), true))\n\n                if (connectorsPositions.length === 2) {\n                    let wire = this.newWire(...connectorIds, false, false);\n\n                    // get the manhattan distance between these two connectors\n                    const distance = manhattanDistance(...connectorsPositions);\n\n                    // add connectorids to the priority queue\n                    wireQueue.enqueue(wire, 1 / distance);\n                } else {\n                    warnings.push(`Found a wire that does not have two endings. (It had ${connectorsPositions.length} instead.)`)\n                }\n            }\n\n            if (window.Worker) {\n                let wirePoints = [];\n                let wireReferences = [];\n\n                // convert the queue to an array (this is needed by the web worker)\n                while (!wireQueue.isEmpty()) {\n                    const wire = wireQueue.dequeue();\n\n                    let wireStart = this.getConnectorPosition(wire.connection.from.connector, true);\n                    let wireEnd = this.getConnectorPosition(wire.connection.to.connector, true);\n\n                    wirePoints.push([\n                        {\n                            x: wireStart.x / this.gridSize,\n                            y: wireStart.y / this.gridSize\n                        }, {\n                            x: wireEnd.x / this.gridSize,\n                            y: wireEnd.y / this.gridSize\n                        }\n                    ])\n\n                    wireReferences.push(wire);\n                }\n\n                // [routeWorkerFileName] replaced in the build process (defined in gulpfile) depending on devel / prod build\n                let myWorker = new Worker(\"js/[routeWorkerFileName]\");\n\n                let loadingMessage = this.messages.newLoadingMessage(\"looking for the best wiring…\");\n\n                myWorker.onmessage = (event) => {\n                    const {paths} = event.data\n                    // iterate wireReferences and paths synchronously\n                    wireReferences.forEach((wire, key) => {\n                        wire.setWirePath(wire.pathToPolyLine(paths[key]))\n                        wire.updateWireState();\n                        wire.generateInconvenientNodes();\n                    })\n\n                    loadingMessage.hide();\n                }\n\n                const message = {\n                    wires: wirePoints,\n                    nonRoutableNodes: this.getNonRoutableNodes(),\n                    inconvenientNodes: this.getInconvenientNodes()\n                }\n\n                myWorker.postMessage(message)\n\n            } else {\n                // web worker is not supported: use an interval to make the import a bit slower\n                // by dividing it into chunks, so the browser window is not entirely frozen when the wiring is happening\n\n                const wiresToBeRoutedAtOnce = 10;\n                const delayBetweenIterations = 200;\n\n                // add wires in the order from short to long\n                let wirePlacingInterval = window.setInterval(() => {\n                    if (!wireQueue.isEmpty()) {\n                        for (let i = 0; i < wiresToBeRoutedAtOnce; ++i) {\n                            if (wireQueue.isEmpty()) {\n                                break;\n                            }\n\n                            const wire = wireQueue.dequeue();\n                            wire.routeWire(true, false);\n                            wire.updateWireState();\n                        }\n                    } else {\n                        console.log(\"finished\");\n                        clearInterval(wirePlacingInterval);\n                    }\n                }, delayBetweenIterations)\n            }\n\n            // refresh the SVG document\n            this.refresh();\n\n            this.simulationEnabled = true;\n\n            resolve(warnings)\n        })\n    }\n\n    /**\n     * When user clicks on a connector, remember it until they click on some other connector.\n     * Than call newWire with the last two connectors ids as arguments.\n     * Visualize the process by displaying a grey wire between the first conenctor and the mouse pointer.\n     * @param  {string} connectorId id of the connector that the user clicked on\n     */\n    wireCreationHelper(connectorId, mousePosition) {\n        if (!this.wireCreation) {\n            this.wireCreation = {\n                fromId: connectorId\n            }\n\n            this.displayCreatedWire(mousePosition);\n        } else {\n            if (this.wireCreation.fromId !== connectorId) {\n                this.hideCreatedWire();\n\n                this.newWire(this.wireCreation.fromId, connectorId);\n\n                this.wireCreation = undefined;\n            }\n        }\n    }\n\n    /**\n     * helper for wireCreationHelper that displays a grey wire between the first connector and the specified mousePosition\n     * @param  {Object} mousePosition object with x and y coordinates in SVG pixels\n     */\n    displayCreatedWire(mousePosition) {\n        this.wireCreation.tempWire = new editorElements.HelperWire(this, this.wireCreation.fromId, mousePosition);\n\n        $(window).on('mousemove.wireCreation', event => {\n            event = this.viewbox.transformEvent(event)\n\n            mousePosition = {\n                x: event.pageX,\n                y: event.pageY\n            }\n\n            this.wireCreation.tempWire.updateMousePosition(mousePosition);\n        })\n\n        this.appendElement(this.wireCreation.tempWire);\n        this.moveToBackById(this.wireCreation.tempWire.id);\n    }\n\n    /**\n     * helper for wireCreationHelper that hides the temporary wire when wire creation is done\n     */\n    hideCreatedWire() {\n        $(window).off('mousemove.wireCreation');\n\n        this.wireCreation.tempWire.get().remove();\n        this.wireCreation.tempWire = undefined;\n    }\n\n    /**\n     * helper for wireCreationHelper that cancels the wire creation process\n     */\n    cancelWireCreation() {\n        if (this.wireCreation) {\n            this.hideCreatedWire();\n            this.wireCreation = undefined;\n        }\n    }\n\n    /**\n     * Run a logic simulation from the startingConnector.\n     * This refreshes the states of all elements in the network whose inputs are\n     * directly (or by transition) connected to startingConnector's output\n     * @param  {OutputConnector} startingConnector run simulation from this output connector\n     * @param  {Logic.state} state new state of the startingConnector\n     */\n    startNewSimulation(startingConnector, state) {\n        if (this.simulationEnabled) {\n            this.simulation = new Simulation(this)\n            this.simulation.notifyChange(startingConnector.id, state)\n            this.simulation.run()\n        }\n    }\n\n    /**\n     * Create a new gate on the specified position\n     * @param  {string}  name           type of the gate (and, or ...)\n     * @param  {number}  x              horizontal position of the gate in SVG pixels\n     * @param  {number}  y              vertical position of the gate in SVG pixels\n     * @param  {boolean} [refresh=true] if true, this.refresh() will be called after adding the gate\n     * @return {editorElements.Gate}    instance of Gate that has been newly added\n     */\n    newGate(name, x, y, refresh = true) {\n        return this.newBox(x, y, new editorElements.Gate(this, name, x, y), refresh);\n    }\n\n    /**\n     * Create an input box on the specified position\n     * @param  {number}  x              horizontal position of the gate in SVG pixels\n     * @param  {number}  y              vertical position of the gate in SVG pixels\n     * @param  {boolean} [isOn=false]   state of the input box (default is false (off))\n     * @param  {boolean} [refresh=true] if true, this.refresh() will be called after adding the input box\n     * @return {editorElements.InputBox}    instance of the InputBox that has been newly added\n     */\n    newInput(x, y, isOn = false, refresh = true) {\n        return this.newBox(x, y, new editorElements.InputBox(this, isOn), refresh);\n    }\n\n    /**\n     * Create an output box on the specified position\n     * @param  {number}  x              horizontal position of the gate in SVG pixels\n     * @param  {number}  y              vertical position of the gate in SVG pixels\n     * @param  {boolean} [refresh=true] if true, this.refresh() will be called after adding the output box\n     * @return {editorElements.InputBox}    instance of the OutputBox that has been newly added\n     */\n    newOutput(x, y, refresh = true) {\n        return this.newBox(x, y, new editorElements.OutputBox(this), refresh);\n    }\n\n    /**\n     * Add a new Box to the Canvas\n     * @param  {number}  x              horizontal position of the box in SVG pixels\n     * @param  {number}  y              vertical position of the box in SVG pixels\n     * @param  {editorElements.Box}  object         instance of an object derived from the editorElements.Box class\n     * @param  {Boolean} [refresh=true] if true, this.refresh() will be called after adding the box\n     * @return {editorElements.Box}                 return the instance of the newly added object\n     */\n    newBox(x, y, object, refresh = true) {\n        let index = this.boxes.length;\n\n        this.boxes[index] = object;\n\n        // translate the gate if x and y has been specified\n        if (x && y) {\n            let tr = new editorElements.Transform();\n            tr.setTranslate(x, y);\n\n            this.boxes[index].svgObj.addAttr({\"transform\": tr.get()});\n        }\n\n        this.appendElement(this.boxes[index], refresh);\n\n        // if tutorial exists, call tutorial callback\n        if (this.tutorial) {\n            this.tutorial.onElementAdded(this.boxes[index].name);\n        }\n\n        return this.boxes[index];\n    }\n\n    /**\n     * Remove a box from Canvas based on the provided ID\n     * @param {string} boxId id of the box that should be removed\n     */\n    removeBox(boxId) {\n        let $gate = $(\"#\" + boxId);\n\n        // find the gate in svg's list of gates\n        let gateIndex = -1;\n        for (let i = 0; i < this.boxes.length; i++) {\n            if (this.boxes[i].svgObj.id === boxId) {\n                gateIndex = i;\n                break;\n            }\n        }\n\n        if (gateIndex > -1) {\n            // remove all wires connected to this gate\n            for (let i = 0; i < this.boxes[gateIndex].connectors.length; i++) {\n                this.removeWiresByConnectorId(this.boxes[gateIndex].connectors[i].id);\n            }\n\n            // remove the gate\n            this.boxes.splice(gateIndex, 1);\n            $gate.remove();\n\n            // if tutorial exists, call tutorial callback\n            if (this.tutorial) {\n                this.tutorial.onElementRemoved();\n            }\n        } else {\n            console.error(\"Trying to remove an nonexisting box. Box id:\", boxId);\n        }\n    }\n\n    /**\n     * Remove all boxes from the canvas\n     */\n    cleanCanvas() {\n        // cannot simply iterate through the array because removeBox works with it\n\n        // create an array of ids\n        const ids = this.boxes.map(box => box.id);\n\n        // remove all boxes by their ids\n        for (const id of ids) {\n            this.removeBox(id);\n        }\n    }\n\n    /**\n     * Create a new wire connecting the provided connectors\n     * @param  {string}  fromId         id of the connector that the wire is attached to\n     * @param  {string}  toId           id of the connector that the wire is attached to\n     * @param  {Boolean} [refresh=true] if refresh is set to true, the SVG document will be reloaded after adding the wire\n     * @return {editorElements.Wire}    instance of editorElements.Wire that has been added to the Canvas\n     */\n    newWire(fromId, toId, refresh = true, route = true) {\n        // wire must connect two distinct connectors\n        if (fromId === toId)\n            return undefined\n\n        let connectors = [this.getConnectorById(fromId), this.getConnectorById(toId)]\n\n        // input connectors can be connected to one wire max\n        connectors.forEach(conn => {\n            if (conn.isInputConnector)\n                this.removeWiresByConnectorId(conn.id)\n        })\n        let index = this.wires.length;\n\n        try {\n            this.wires[index] = new editorElements.Wire(this, fromId, toId, refresh, route);\n        } catch (e) {\n            this.messages.newErrorMessage(e);\n            return undefined;\n        }\n\n        connectors.forEach(conn => {\n            conn.addWireId(this.wires[index].svgObj.id);\n        })\n\n        this.appendElement(this.wires[index], refresh);\n        this.moveToBackById(this.wires[index].svgObj.id);\n\n        if (refresh)\n            this.wires[index].updateWireState()\n\n        return this.wires[index];\n    }\n\n    /**\n     * get the coordinates of the specified connector\n     * @param  {Connector}  connector      instance of {@link Connector}\n     * @param  {Boolean} [snapToGrid=true] if true, the connector position will be snapped to the grid\n     * @return {Object}                    point - object containing numeric attributes `x` and `y`\n     */\n    getConnectorPosition(connector, snapToGrid = true) {\n        // connector.svgObj.id has to be called, else the getCoordinates does not work on the first call in Firefox 55\n        const dummy = connector.svgObj.id; // eslint-disable-line no-unused-vars\n\n        let $connector = connector.svgObj.$el;\n\n        let position = $connector.position();\n\n        position.left = this.viewbox.transformX(position.left)\n        position.top = this.viewbox.transformY(position.top)\n\n        let width = $connector.attr(\"width\");\n        let height = $connector.attr(\"height\");\n\n        let x = position.left + width / 2;\n        let y = position.top + height / 2;\n        if (snapToGrid) {\n            x = this.snapToGrid(x);\n            y = this.snapToGrid(y);\n        }\n\n        return {x: x, y: y};\n    }\n\n    /**\n     * creates a new blackbox\n     * @param  {number} x       horizontal position of the blackbox in SVG pixels\n     * @param  {number} y       vertical position of the gate in SVG pixels\n     * @param  {number} inputs  number of input pins of this blackbox\n     * @param  {number} outputs number of output pins of this blackbox\n     * @param  {Array} table   Array of arrays, each inner array contains list of [Logic.state](./module-Logic.html#.state)s,\n     *                          that describe the combination of input pin and output pin states in the order from the top to bottom for both input and output connectors.\n     *                          If we had an AND array as a blackbox, one of the states could be `[Logic.state.on, Logic.state.off, Logic.state.off]`\n     *                          which means that if the first input connector is in the `on` state and the second connector is in the `off` state,\n     *                          the state of the output connector will be `off`.\n     *                          The array can be described as `[state for input conn 1, state for input conn 2, ..., state for output conn 1, state for output conn 2 ...]`.\n     * @param  {string}  name   a name that will be displayed on the blackbox\n     * @param  {boolean} [refresh=true] if true, this.refresh() will be called after adding the gate\n     *\n     * @return {editorElements.Blackbox} instance of {@link Blackbox} that has been added to the [Canvas](./module-Canvas.html)\n     */\n    newBlackbox(inputs, outputs, table, name, x, y, refresh = true) {\n        const index = this.boxes.length;\n\n        this.boxes[index] = new editorElements.Blackbox(this, inputs, outputs, (...inputStates) => {\n            for (const line of table) {\n                const lineInputStates = line.slice(0, inputs);\n\n                // if every input state matches the corresponding input state in this line of the truth table\n                if (inputStates.every((value, index) => value === lineInputStates[index])) {\n                    // return the rest of the line as output\n                    return line.slice(inputs);\n                }\n            }\n            // if nothing matches, set all outputs to undefined\n            return Array.from(new Array(outputs), () => Logic.state.unknown)\n        }, name);\n\n        if (x && y) {\n            let tr = new editorElements.Transform();\n            tr.setTranslate(x, y);\n\n            this.boxes[index].svgObj.addAttr({\"transform\": tr.get()});\n        }\n\n        this.appendElement(this.boxes[index], refresh);\n\n        return this.boxes[index];\n    }\n\n    /**\n     * Find the correct instance of editorElements.Wire in the Canvas' wires by the provided id\n     * @param  {string} wireId id of the wire\n     * @return {editorElements.Wire} instance of the wire\n     */\n    getWireById(wireId) {\n        for (const wire of this.wires) {\n            if (wire.svgObj.id === wireId) {\n                return wire\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Find all wires that are connected to the specified connector\n     * @param  {string} connectorId id of the connector\n     * @return {Set} set of ID's of the wires connected to this connector\n     */\n    getWiresByConnectorId(connectorId) {\n        let connector = this.getConnectorById(connectorId);\n        return connector.wireIds;\n    }\n\n    /**\n     * Remove wire that has the provided ID\n     * @param  {string} wireId ID of the wire that should be removed\n     */\n    removeWireById(wireId) {\n        for (let i = 0; i < this.wires.length; ++i) {\n            if (this.wires[i].svgObj.id === wireId) {\n\n                let {connectors} = this.wires[i];\n\n                for (let connector of connectors) {\n                    connector.removeWireIdAndUpdate(wireId);\n                }\n\n                // start simulation from the input connector to\n                // refresh the network after this wire\n\n                let inputConnector = this.wires[i].connection.to.connector;\n                this.startNewSimulation(inputConnector, inputConnector.state);\n\n                this.wires[i].svgObj.$el.remove();\n                this.wires.splice(i, 1);\n\n                break;\n            }\n        }\n    }\n\n    /**\n     * Remove all wires that are connected to the connector provided by its ID\n     * @param  {string} connectorId ID of the connector\n     */\n    removeWiresByConnectorId(connectorId) {\n        let connector = this.getConnectorById(connectorId);\n\n        connector.wireIds.forEach(wireId => {\n            let wire = this.getWireById(wireId);\n\n            let {from, to} = wire.connection;\n\n            // get the other connector that is the wire connected to\n            let otherConnector = connectorId === from.id\n                ? to.connector\n                : from.connector;\n\n            // delete the wire record from the other connector\n            otherConnector.wireIds.delete(wireId);\n\n            // remove the wire representation using jQuery\n            $(\"#\" + wireId).remove();\n\n            // if otherConnector is an input connector, set its state to unknown\n            if (otherConnector.isInputConnector) {\n                otherConnector.setState(Logic.state.unknown)\n                this.startNewSimulation(otherConnector, Logic.state.unknown)\n            }\n        });\n\n        // clear the list of wire Ids\n        connector.wireIds.clear();\n        // if connector is an input connector, set its state to unknown\n        if (connector.isInputConnector) {\n            connector.setState(Logic.state.unknown)\n            this.startNewSimulation(connector, Logic.state.unknown)\n        }\n    }\n\n    /**\n     * Find the correct instance of editorElements.Box in the Canvas' boxes by the provided id\n     * @param  {string} boxId id of the box\n     * @return {editorElements.Box} instance of the box\n     */\n    getBoxById(boxId) {\n        for (let i = 0; i < this.boxes.length; i++) {\n            if (this.boxes[i].svgObj.id === boxId) {\n                return this.boxes[i];\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * Find the correct instance of editorElements.Box in the Canvas' boxes by ID of a connector that belongs to this box\n     * @param  {string} boxId id of the connector\n     * @return {editorElements.Box} instance of the box\n     */\n    getBoxByConnectorId(connectorId) {\n        for (let i = 0; i < this.boxes.length; i++) {\n            if (this.boxes[i].getConnectorById(connectorId) !== undefined) {\n                return this.boxes[i];\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Get instance of a connector based on it's ID (and also on an instance of editorElements.Wire if provided)\n     *\n     * The wire variable is used as heuristic: When we know the wire, we have to check only\n     * two gates instead of all of them\n     * @param  {string} connectorId id of the connector\n     * @param  {editorElements.Wire} [wire]      instance of the Wire that is connected to this connector\n     * @return {editorElements.Connector}        instance of the connector\n     */\n    getConnectorById(connectorId, wire = undefined) {\n\n        if (wire !== undefined) {\n            // we know the wire -- we can check only gates at the ends of this wire\n            const {from, to} = wire.connection;\n\n            if (from.id === connectorId)\n                return from.connector;\n\n            if (to.id === connectorId)\n                return to.connector;\n\n            }\n        else {\n            // we do not know the wire -- we have to check all gates\n            for (const box of this.boxes) {\n                const connector = box.getConnectorById(connectorId)\n                if (connector) {\n                    return connector\n                }\n            }\n        }\n\n        return undefined\n    }\n\n    getWireAnchorById(anchorId) {\n        for (const wire of this.wires) {\n            for (const anchor of wire.anchors) {\n                if (anchor.id===anchorId) {\n                    return anchor;\n                }\n            }\n        }\n    }\n\n    /**\n     * Get the logical jQuery target based on the factual jQuery target.\n     *\n     * If the object, that user interacted with, is not a connector and is in a group,\n     * return the group jQuery object instead of the original jQuery object.\n     * @param  {target} target jQuery target of the object user interacted with\n     * @return {target}        jQuery target of the object user wanted to interact with\n     */\n    getRealJQueryTarget(target) {\n        let $target = $(target);\n        if (!$target.hasClass(\"connector\") && $target.parents('g').length > 0) {\n            $target = $target.parent();\n            while ($target.prop(\"tagName\") !== \"G\" && $target.prop(\"tagName\") !== \"g\") {\n                $target = $target.parent();\n            }\n        }\n        return $target;\n    }\n\n    // returns the editorElement that user interacted with, the \"target\" argument is a jQuery element\n    /**\n     * Get instance of some object from editorElement based on the jQuery target\n     * @param  {target} target jQuery target that user interacted with\n     * @return {editorElements.NetworkElement} instance of an object derived from editorElements.NetworkElement that the user interacted with\n     */\n    getRealTarget(target) {\n        if (target === undefined) {\n            return undefined;\n        }\n\n        // eventy se museji zpracovat tady, protoze v SVG se eventy nepropaguji\n        let $target = $(target);\n\n        if ($target.hasClass(\"connector\")) {\n            // this is a connector, don't traverse groups\n            return this.getConnectorById($target.attr('id'));\n        } else if($target.hasClass(\"wireAnchor\")) {\n            return this.getWireAnchorById($target.attr('id'));\n        } else if ($target.parents('g').length > 0) {\n            // this element is in a group and it is not a connector\n\n            // traversing up the DOM tree until we find the closest group\n            let $parentGroup = $target.parent();\n            while ($parentGroup.prop(\"tagName\") !== \"G\" && $parentGroup.prop(\"tagName\") !== \"g\") {\n                $parentGroup = $parentGroup.parent();\n            }\n\n            // try to match the jQuery element to the logical element using DOM classes\n\n            if ($parentGroup.hasClass(\"box\")) {\n                // return the corresponding box\n                return this.getBoxById($parentGroup.attr('id'));\n            } else if ($parentGroup.hasClass(\"wire\")) {\n                // return the corresponding wire\n                return this.getWireById($parentGroup.attr('id'));\n            } else {\n                // found a group that contains the target, but this group does not match any known element types\n                return undefined;\n            }\n        } else {\n            // element does not match any known element types\n            return undefined;\n        }\n    }\n\n    /**\n     * Add an element to the Canvas\n     * @param  {editorElements.NetworkElement}  element Element that will be added on the Canvas\n     * @param  {Boolean} [refresh=true] if true, the SVG document will be reloaded after adding this element\n     */\n    appendElement(element, refresh = true) {\n        this.appendJQueryObject(element.get(), refresh);\n    }\n\n    /**\n     * Append a jQuery element to the SVG document (helper for this.appendElement)\n     * @param  {object}  object         jQuery element that will be added to the SVG document\n     * @param  {Boolean} [refresh=true] if true, the SVG document will be reloaded after adding this element\n     */\n    appendJQueryObject(object, refresh = true) {\n        this.$svg.append(object);\n        if (refresh)\n            this.refresh();\n        }\n\n    /**\n     * Add a new pattern to the definitions element in the SVG document\n     * @param {svgObj.Pattern} pattern pattern that will be added to the <devs> element in the SVG document\n     */\n    addPattern(pattern) {\n        this.$defs.append(pattern);\n        this.refresh();\n    }\n\n    /**\n     * Reload the SVG document (needed to display a newly appended jQuery object)\n     */\n    refresh() {\n        this.$svg.html(this.$svg.html());\n        console.log(\"SVG document has been reloaded.\")\n    }\n\n    /**\n     * Display the context menu on the specified position\n     * @param  {number} x       horizontal position in CSS pixels\n     * @param  {number} y       vertical position in CSS pixels\n     * @param  {jQuery.element} $target the item user clicked on (used to display \"remove this element\"-type items in the menu)\n     */\n    displayContextMenu(x, y, $target) {\n        this.contextMenu.display(x, y, $target);\n\n        // if tutorial exists, call tutorial callback\n        if (this.tutorial) {\n            this.tutorial.onContextMenuOpened();\n        }\n    }\n\n    /**\n     * hide the context menu\n     */\n    hideContextMenu() {\n        this.contextMenu.hide();\n    }\n\n    /**\n     * snap a value to a grid\n     * @param  {number} value value in SVG pixels\n     * @return {number}       the value rounded to the closest number divisible by the grid size\n     */\n    snapToGrid(value) {\n        return Math.round(value / this.gridSize) * this.gridSize;\n    }\n\n    /**\n     * convert grid pixels to SVG pixels\n     * @param  {number} value distance in grid pixels\n     * @return {number}       distance in SVG pixels\n     */\n    gridToSVG(value) {\n        return value * this.gridSize;\n    }\n\n    /**\n     * convert SVG pixels to grid pixels\n     * @param {number} value distance in SVG pixels\n     * @return {number}      distance in grud pixels\n     */\n    SVGToGrid(value) {\n        return value / this.gridSize;\n    }\n\n    /**\n     * static function for snapping a value to a grid\n     * @param  {number} value value in SVG pixels\n     * @param  {number} gridSize size of the grid in SVG pixels\n     * @return {number}       the value rounded to the closest number divisible by the grid size\n     */\n    static snapToGrid(value, gridSize) {\n        return Math.round(value / gridSize) * gridSize;\n    }\n\n    /**\n     * move an element to the front in the canvas\n     * @param  {string} objId id of the element\n     */\n    moveToFrontById(objId) {\n        this.$svg.append($(\"#\" + objId));\n    }\n\n    /**\n     * move an element to the back in the canvas\n     * @param  {string} objId id of the element\n     */\n    moveToBackById(objId) {\n        $(\"#\" + this.background.id).after($(\"#\" + objId));\n    }\n\n    /**\n     * get set of nodes, that cannot be used for wiring at any circumstances\n     * @return {Set} set of nodes (objects containing x and y coordinates) that are not suitable for wiring\n     */\n    getNonRoutableNodes() {\n        let blockedNodes = new Set();\n        // for each box\n        for (const box of this.boxes) {\n            const translate = box.getGridPixelTransform().getTranslate();\n\n            // for each item in blockedNodes (set of blocked nodes with coordinates relative\n            // to the left upper corner of rect; unit used is \"one gridSize\") convert the coordinates\n            // to absolute (multiple with gridSize and add position of rect) and add the result to the set\n            for (const node of box.blockedNodes) {\n                blockedNodes.add({\n                    x: translate.x + node.x,\n                    y: translate.y + node.y\n                });\n            }\n        }\n\n        // FOR DEBUG ONLY: display the non routable nodes\n        /*\n\n        if(this.nodeDisplay) {\n            for (const rectangleId of this.nodeDisplay) {\n                $(`#${rectangleId}`).remove();\n            }\n        }\n\n        this.nodeDisplay = [];\n\n        let first = true;\n\n        for (const node of blockedNodes) {\n            const x = this.gridToSVG(node.x);\n            const y = this.gridToSVG(node.y);\n\n            const w = 4;\n            const p = w / 2;\n\n            const nodeRectangle = new Rectangle(x - p, y - p, w, w, first ? \"blue\" : \"red\", \"none\")\n            this.nodeDisplay.push(nodeRectangle.id);\n            this.appendElement(nodeRectangle, false);\n\n            first = false;\n        }\n\n        this.refresh();\n\n        */\n        // END FOR DEBUG ONLY\n\n        // return the set\n        return blockedNodes;\n    }\n\n    /**\n     * get set of nodes, that are inconvenient for wiring, but can be used, just are not preferred\n     * @return {Set} set of nodes (objects containing x and y coordinates) that are not preferred for wiring\n     */\n    getInconvenientNodes(ignoreWireId) {\n        let inconvenientNodes = new Set();\n        // for each wire\n\n        for (const wire of this.wires) {\n            if (ignoreWireId === undefined || ignoreWireId !== wire.id) {\n                if (wire.inconvenientNodes) {\n                    for (const node of wire.inconvenientNodes) {\n                        inconvenientNodes.add(node);\n                    }\n                }\n            }\n        }\n\n        // FOR DEBUG ONLY: display the inconvenient nodes\n        /*\n\n        if(this.inconvenientNodeDisplay) {\n            for (const rectangleId of this.inconvenientNodeDisplay) {\n                $(`#${rectangleId}`).remove();\n            }\n        }\n\n        this.inconvenientNodeDisplay = [];\n\n        for (const node of inconvenientNodes) {\n            const x = this.gridToSVG(node.x);\n            const y = this.gridToSVG(node.y);\n\n            const w = 4;\n            const p = w / 2;\n\n            const nodeRectangle = new Rectangle(x - p, y - p, w, w, \"orange\", \"none\")\n            this.inconvenientNodeDisplay.push(nodeRectangle.id);\n            this.appendElement(nodeRectangle, false);\n        }\n\n        this.refresh();\n\n        */\n        // END FOR DEBUG ONLY\n\n        // return the set\n        return inconvenientNodes;\n    }\n}\n","/** @module Logic */\n/**\n * definitions of logic states and basic logic functions used in the simulation\n */\nexport default class Logic {\n    /**\n     * Enum for logic states.\n     *\n     * States:\n     * - `unknown`\n     * - `on`\n     * - `off`\n     * - `oscillating`\n     * @type {Number}\n     */\n    static get state() {\n        return {\n            unknown: 0,\n            on: 1,\n            off: 2,\n            oscillating: 3\n        }\n    }\n\n    /**\n     * list of all states that can be used in the simulation\n     *\n     * This getter iterates over Logic.state and returns an array containing all values of Logic.state's members\n     * @type {Array}\n     */\n    static get stateList() {\n        let states = [];\n\n        // iterate over all defined states and add their values to the states array\n        Object.keys(Logic.state).forEach(key => {\n            states.push(Logic.state[key]);\n        });\n\n        return states;\n    }\n\n    /**\n     * Logic AND\n     * @param  {Logic.state} a first input state\n     * @param  {Logic.state} b second input state\n     * @return {Logic.state}   output state\n     */\n    static and(a, b) {\n        return Logic.runSymmetricRules(a, b, [\n            [Logic.state.on, Logic.state.on, Logic.state.on],\n            [Logic.state.on, Logic.state.off, Logic.state.off],\n            [Logic.state.on, Logic.state.unknown, Logic.state.unknown],\n            [Logic.state.on, Logic.state.oscillating, Logic.state.oscillating],\n\n            [Logic.state.off, Logic.state.off, Logic.state.off],\n            [Logic.state.off, Logic.state.unknown, Logic.state.off],\n            [Logic.state.off, Logic.state.oscillating, Logic.state.off],\n\n            [Logic.state.unknown, Logic.state.unknown, Logic.state.unknown],\n            [Logic.state.unknown, Logic.state.oscillating, Logic.state.unknown],\n\n            [Logic.state.oscillating, Logic.state.oscillating, Logic.state.oscillating]\n        ]);\n    }\n    /**\n     * Logic NAND\n     * @param  {Logic.state} a first input state\n     * @param  {Logic.state} b second input state\n     * @return {Logic.state}   output state\n     */\n    static nand(a, b) {\n        return Logic.not(Logic.and(a, b));\n    }\n\n    /**\n     * Logic NOR\n     * @param  {Logic.state} a first input state\n     * @param  {Logic.state} b second input state\n     * @return {Logic.state}   output state\n     */\n    static nor(a, b) {\n        return Logic.not(Logic.or(a, b));\n    }\n\n    /**\n     * Logic NOT\n     * @param  {Logic.state} a first input state\n     * @return {Logic.state}   output state\n     */\n    static not(a) {\n        if(a === Logic.state.on) {\n            return Logic.state.off;\n        } else if (a === Logic.state.off) {\n            return Logic.state.on;\n        } else {\n            return a;\n        }\n    }\n\n    /**\n     * Logic OR\n     * @param  {Logic.state} a first input state\n     * @param  {Logic.state} b second input state\n     * @return {Logic.state}   output state\n     */\n    static or(a, b) {\n        return Logic.runSymmetricRules(a, b, [\n            [Logic.state.on, Logic.state.on, Logic.state.on],\n            [Logic.state.on, Logic.state.off, Logic.state.on],\n            [Logic.state.on, Logic.state.unknown, Logic.state.on],\n            [Logic.state.on, Logic.state.oscillating, Logic.state.on],\n\n            [Logic.state.off, Logic.state.off, Logic.state.off],\n            [Logic.state.off, Logic.state.unknown, Logic.state.unknown],\n            [Logic.state.off, Logic.state.oscillating, Logic.state.oscillating],\n\n            [Logic.state.unknown, Logic.state.unknown, Logic.state.unknown],\n            [Logic.state.unknown, Logic.state.oscillating, Logic.state.unknown],\n\n            [Logic.state.oscillating, Logic.state.oscillating, Logic.state.oscillating]\n        ]);\n    }\n\n    /**\n     * Logic XNOR\n     * @param  {Logic.state} a first input state\n     * @param  {Logic.state} b second input state\n     * @return {Logic.state}   output state\n     */\n    static xnor(a, b) {\n        return Logic.not(Logic.xor(a, b));\n    }\n\n    /**\n     * Logic XOR\n     * @param  {Logic.state} a first input state\n     * @param  {Logic.state} b second input state\n     * @return {Logic.state}   output state\n     */\n    static xor(a, b) {\n        return Logic.runSymmetricRules(a, b, [\n            [Logic.state.on, Logic.state.on, Logic.state.off],\n            [Logic.state.on, Logic.state.off, Logic.state.on],\n            [Logic.state.on, Logic.state.unknown, Logic.state.unknown],\n            [Logic.state.on, Logic.state.oscillating, Logic.state.oscillating],\n\n            [Logic.state.off, Logic.state.off, Logic.state.off],\n            [Logic.state.off, Logic.state.unknown, Logic.state.unknown],\n            [Logic.state.off, Logic.state.oscillating, Logic.state.oscillating],\n\n            [Logic.state.unknown, Logic.state.unknown, Logic.state.unknown],\n            [Logic.state.unknown, Logic.state.oscillating, Logic.state.unknown],\n\n            [Logic.state.oscillating, Logic.state.oscillating, Logic.state.oscillating]\n        ]);\n    }\n\n    /**\n     * Finds the correct rule in the array of rules and returns the corresponding return value.\n     * This function expects rules to be symmetric (so `a RULE b` should returns the same value as `b RULE a`),\n     * which allows to cut down on the `rules` array quite a bit\n     * @param  {Logic.state} a     first input state\n     * @param  {Logic.state} b     second input state\n     * @param  {Array} rules       Array of arrays. Each inner array represents a rule in the format [input1, input2, output].\n     *                             The function finds an array, where `a === input1` and `b === input1` (or `a === input2` and `b === input1`)\n     *                             and returns `output` from this array.\n     * @return {Logic.state}       output state\n     */\n    static runSymmetricRules(a, b, rules) {\n        // iterate through all the rules\n        for (const rule of rules) {\n            if ((rule[0] === a && rule[1] === b) || (rule[0] === b && rule[1] === a)) {\n                return rule[2];\n            }\n        }\n\n        // if no rule matches, the output state is unknown\n        return Logic.state.unknown;\n    }\n}\n","import Logic from './Logic'\n\n/**\n * @module Simulation\n */\n\n\nclass stateChange {\n    constructor(connectorId, state, whoCausedIt) {\n        this.connectorId = connectorId\n        this.state = state\n        this.whoCausedIt = whoCausedIt\n    }\n}\n\n/**\n * This class runs the network simulation.\n *\n * _note: all connectors that are used in this class are **output connectors**_\n */\nexport default class Simulation {\n    /**\n     * @param {Canvas} parentSVG instance of [Canvas](./module-Canvas.html)\n     */\n    constructor(parentSVG) {\n        /**\n         * instance of Canvas this Simulation belongs to\n         * @type {Canvas}\n         */\n        this.parentSVG = parentSVG\n\n        /**\n         * maps each affected output connector to it's directly preceeding output connectors\n         * @type {Map}\n         */\n        this.predecessors = new Map();\n\n        /**\n         * maps waveId to an array of affected outputConnectors\n         * @type {Map}\n         */\n        this.waves = new Map();\n        this.wave = 0\n\n        /**\n         * maps cycled connector id to set of states this connector was in\n         * @type {Map}\n         */\n        this.cycledConnectors = new Map()\n\n        /**\n         * set of cycled connectors that have been already resolved\n         * @type {Set}\n         */\n        this.resolvedCycledConnectors = new Set()\n\n    }\n\n    /**\n     * run the simulation\n     */\n    run() {\n        this.wave++;\n        while(this.waves.has(this.wave)) {\n            this.step()\n            this.waves.delete(this.wave) // clean old waves on the go\n            this.wave++\n        }\n    }\n\n    /**\n     * one step/wave of the simulation\n     *\n     * determines states of the connectors in the current wave, detects cycles\n     */\n    step() {\n        for (let {connectorId, state, whoCausedIt} of this.waves.get(this.wave)) {\n            // skip resolved cycles\n            if(this.resolvedCycledConnectors.has(connectorId)) {\n                continue\n            }\n\n            // skip connector that are cycles\n            if (this.cycledConnectors.has(connectorId)) {\n                // get the set of states that this connector appeared from the moment the signal first cycled\n                let states = this.cycledConnectors.get(connectorId)\n\n                // if the connector already had this state in this cycle, resolve the cycle\n                if(states.has(state)) {\n\n                    // if there are more states in the set, the connector is oscillating\n                    // (else it keeps its state and we just break the cycle)\n                    if(states.size > 1) {\n                        state = Logic.state.oscillating\n                    }\n\n                    // mark this connector as resolved\n                    this.resolvedCycledConnectors.add(connectorId)\n\n                // this is a new, unseen state, add it to the set and continue simulating the cycle\n                } else {\n                    states.add(state)\n                }\n\n                // map the modified set of states to the connector\n                this.cycledConnectors.set(connectorId, states)\n            }\n\n            this.whoCausedIt = connectorId\n            /*  process all outputConnectors by setting their state\n                this will trigger a following event chain:\n                    outputConnector changes\n                    -> all connected wires change\n                    -> all inputConnectors connected to these wires change\n                    -> all elements that contain these inputConnectors change\n                    -> these elements compute the new state of their output connectors and call notifyChange()\n            */\n\n\n            if(whoCausedIt) {\n                this.addPredecessor(connectorId, whoCausedIt)\n            }\n\n            if (!this.cycledConnectors.has(connectorId) && this.getAllPredecessors(connectorId).has(connectorId)) {\n                this.cycledConnectors.set(connectorId, new Set([state]))\n            }\n\n\n            // reflect the changes in SVG\n            let connector = this.parentSVG.getConnectorById(connectorId)\n            if(connector) {\n                connector.setState(state)\n            }\n        }\n        this.whoCausedIt = undefined\n    }\n\n    /**\n     * mark a predecessorConnectorId as a predecessor of connectorId\n     * @param {string} connectorId ID of a connector\n     * @param {string} predecessorConnectorId predecessor of `connectorId`\n     */\n    addPredecessor(connectorId, predecessorConnectorId) {\n        if(!this.predecessors.has(connectorId)) {\n            this.predecessors.set(connectorId, new Set())\n        }\n\n        this.predecessors.get(connectorId).add(predecessorConnectorId)\n    }\n\n    /**\n     * get set of all output connectors that are before this output connector\n     * @param  {string} connectorId ID of a connector\n     * @return {Set}                set of connector ids that are before this output connector\n     */\n    getAllPredecessors(connectorId) {\n        if(!this.predecessors.has(connectorId)) {\n            this.predecessors.set(connectorId, new Set())\n        }\n\n        let all = new Set()\n\n        this.predecessors.get(connectorId).forEach(all.add, all);\n\n        let prevSize = 0\n        let size = all.size\n        while(prevSize < size) {\n            for (let connector of all) {\n                if (this.predecessors.has(connector)) {\n                    this.predecessors.get(connector).forEach(all.add, all);\n                }\n            }\n            prevSize = size\n            size = all.size\n        }\n\n        return all\n    }\n\n    /**\n     * Notify a change in the network. This function adds the changed connector to the next wave\n     * @param  {string} connectorId ID of the changed connector\n     * @param  {Logic.state} state  new [Logic.state](./module-Logic.html#.state) of the connector\n     */\n    notifyChange(connectorId, state) {\n        let waveId = this.wave + 1\n\n        if(!this.waves.has(waveId)) {\n            this.waves.set(waveId, [])\n        }\n\n        this.waves.get(waveId).push(new stateChange(connectorId, state, this.whoCausedIt));\n    }\n}\n","/** @module editorElements */\n\n// transform\nexport { default as Transform } from './editorElements/Transform'\n\n// connectors\nexport { default as InputConnector} from './editorElements/InputConnector'\nexport { default as OutputConnector} from './editorElements/OutputConnector'\n\n// boxes\nexport { default as InputBox} from './editorElements/InputBox'\nexport { default as OutputBox} from './editorElements/OutputBox'\nexport { default as Gate} from './editorElements/Gate'\nexport { default as Blackbox} from './editorElements/Blackbox'\n\n// helper wire\nexport { default as HelperWire} from './editorElements/HelperWire'\n\n// wire\nexport { default as Wire} from './editorElements/Wire'\n","import {Group, Rectangle, MultiLineText, PolyLine, PolyLinePoints, PolyLinePoint} from '../svgObjects'\nimport Logic from '../Logic'\n\nimport Box from './Box'\n\n/** @module editorElements.Blackbox */\n\n/**\n * Blackbox is a box that is defined by its evaluation function\n * @extends Box\n */\nexport default class Blackbox extends Box {\n    /**\n     * @param {Canvas} parentSVG  instance of [Canvas](./module-Canvas.html)\n     * @param {number} inputConnectors  number of input connectors\n     * @param {number} outputConnectors number of output connectors\n     * @param {Function} evalFunction   function that takes `inputConnectors` [Logic.state](./module-Logic.html#.state)s\n     *                                  and returns `outputConnectors` Logic.states.\n     * @param {String} [name]        name that will be displayed on the blackbox\n     */\n    constructor(parentSVG, inputConnectors, outputConnectors, evalFunction, name = \"\") {\n        const width = 11;\n        const height = Math.max(inputConnectors, outputConnectors) * 2;\n\n        super(parentSVG, name, \"blackbox\", width, height);\n\n        const connectorPinLenght = 2.5 * this.gridSize;\n\n        // override default svgObj structure\n        this.svgObj = new Group();\n\n        // transparent background rectangle\n        let hitbox = new Rectangle(0, 0, this.width, this.height, \"none\", \"none\");\n        hitbox.$el.addClass('rect');\n\n        this.svgObj.addChild(hitbox);\n\n        // main rectangle\n        const bodyWidth = this.width - 2 * connectorPinLenght;\n\n        let rectangle = new Rectangle(connectorPinLenght, 0, bodyWidth, this.height, \"white\", \"black\");\n        rectangle.addAttr({'stroke-width': '2.5'});\n        rectangle.$el.addClass('rect');\n\n        this.svgObj.addChild(rectangle);\n\n        // text description of the box\n        const textWidth = bodyWidth - this.gridSize;\n        const textHeight = this.height - this.gridSize;\n        let text = new MultiLineText(\n            (this.width - textWidth) / 2, // horizontal centering\n            (this.height - textHeight) / 2, // vertical centering\n            textWidth,\n            textHeight,\n            name.toUpperCase(),\n            this.gridSize * 1.2\n        );\n        this.svgObj.addChild(text);\n\n        // add input connectors\n        for (let i = 0 ; i < inputConnectors ; ++i) {\n            const gridPosition = (i * 2) + 1;\n            const pixelPosition = gridPosition * this.gridSize;\n\n            let pin = new PolyLine(\n                new PolyLinePoints([\n                    new PolyLinePoint(0, pixelPosition),\n                    new PolyLinePoint(connectorPinLenght, pixelPosition),\n                ]),\n                1,\n                \"black\"\n            )\n\n            this.svgObj.addChild(pin);\n\n            // add the connector\n            this.addInputConnector(0, gridPosition);\n        }\n\n        // add output connectors\n        for (let i = 0 ; i < outputConnectors ; ++i) {\n            const gridPosition = (i * 2) + 1;\n            const pixelPosition = gridPosition * this.gridSize;\n\n            let pin = new PolyLine(\n                new PolyLinePoints([\n                    new PolyLinePoint(this.width - connectorPinLenght, pixelPosition),\n                    new PolyLinePoint(this.width, pixelPosition),\n                ]),\n                1,\n                \"black\"\n            )\n\n            this.svgObj.addChild(pin);\n\n            this.addOutputConnector(width, gridPosition);\n        }\n\n        this.svgObj.$el.addClass(\"box\");\n\n        /**\n         * function that takes `inputConnectors` [Logic.state](./module-Logic.html#.state)s\n         * and returns `outputConnectors` Logic.states.\n         */\n        this.evalFunction = evalFunction;\n\n        // regenerate the blocked nodes after adding all the connectors\n        this.generateBlockNodes();\n    }\n\n    /**\n     * get data of this blackbox as a JSON-ready object\n     * @return {Object} javascript object containing essential data for this blackbox\n     */\n    get exportData() {\n        let data = super.exportData;\n        data.inputs = this.inputConnectors.length;\n        data.outputs = this.outputConnectors.length;\n\n        // generate the truth table\n\n        data.table = []\n\n        // array of tested input states\n        const stateList = Logic.stateList;\n\n        // recursive function that generates all possible inputs\n        const getPermutations = (length) => {\n            let permutations = [];\n            switch (length) {\n                case 0:\n                    return [];\n                case 1:\n                    for (const state of stateList) {\n                        permutations.push([state])\n                    }\n                    return permutations;\n                default:\n                    for (const state of stateList) {\n                        for(const perm of getPermutations(length - 1)) {\n                            permutations.push([state, ...perm])\n                        }\n                    }\n                    return permutations;\n            }\n        }\n\n        // generate outputs for all the possible inputs\n        for (const inputValues of getPermutations(data.inputs)) {\n            const outputValues = this.evalFunction(...inputValues);\n\n            // if there is an output value that is not Logic.state.unknown, add this line to the\n            // truthtable, otherwise don't add it (if all output values are Logic.state.unknown,\n            // the input combination does not have to be defines, because Logic.state.unknown is the default value)\n            if (outputValues.reduce((accumulator, current) => {\n                return accumulator || current !== Logic.state.unknown\n            })) {\n                data.table.push([...inputValues, ...outputValues])\n            }\n        }\n\n        return data;\n    }\n\n    /**\n     * proccess the input connector states and reflect them in the output connector states according\n     * to the logic defined by this.evalFunction\n     */\n    refreshState() {\n        const inputStates = this.inputConnectors.map(conn => conn.state);\n        // call the evalFunction to get the output states\n        const outputStates = this.evalFunction(...inputStates);\n\n        // apply the outputStates to the outputConnectors\n        for (let i = 0; i < outputStates.length ; ++i) {\n            this.outputConnectors[i].setState(outputStates[i]);\n        }\n    }\n\n    generateBlockNodes() {\n        // add blocked nodes on the connectors and between them as well\n\n        let specialNodes = []\n        for (let i = 1 ; i < this.inputConnectors.length * 2 ; ++i) {\n            specialNodes.push({\n                x: 0,\n                y: i\n            })\n        }\n        for (let i = 1 ; i < this.outputConnectors.length * 2 ; ++i) {\n            specialNodes.push({\n                x: this.gridWidth,\n                y: i\n            })\n        }\n\n        super.generateBlockNodes(0, 1, 0, 1, ...specialNodes);\n    }\n}\n","import {Group, Rectangle, SvgImage} from '../svgObjects'\n\nimport NetworkElement from './NetworkElement'\nimport InputConnector from './InputConnector'\nimport OutputConnector from './OutputConnector'\nimport Transform from './Transform'\n\n/** @module editorElements.Box */\n\n/**\n * Parent class for gates and input and output boxes. Defines all the factors\n * that the boxes have in common (svgObj structure, draggability and rotatability...)\n * @extends NetworkElement\n */\nexport default class Box extends NetworkElement {\n    /**\n     * @param {Canvas} parentSVG  instance of [Canvas](./module-Canvas.html)\n     * @param {string} name       name of the element (input, output, and, or, xor...)\n     * @param {string} category   type of the element (io, gate)\n     * @param {number} gridWidth  width of the element in grid pixels\n     * @param {number} gridHeight height of the element in grid pixels\n     */\n    constructor(parentSVG, name, category, gridWidth, gridHeight) {\n        super(parentSVG);\n\n        /**\n         * specifies the box type within the category (input/output in io, and/or/... in gate)\n         * @type {string}\n         */\n        this.name = name;\n\n        /**\n         * specifies the box category (io for input or output, gate for logic gates)\n         * @type {string}\n         */\n        this.category = category;\n\n        /**\n         * size of the grid in SVG pixels\n         * @type {number}\n         */\n        this.gridSize = this.parentSVG.gridSize;\n\n        /**\n         * array of connectors of this box\n         * @type {Array}\n         */\n        this.connectors = [];\n\n        /**\n         * svgObj containing all SVG data used to display this box\n         * @type {svgObj}\n         */\n        this.svgObj = new Group();\n\n        /**\n         * width of this element in SVG pixels\n         * @type {number}\n         */\n        this.width = gridWidth * this.gridSize;\n        /**\n         * height of this element in SVG pixels\n         * @type {number}\n         */\n        this.height = gridHeight * this.gridSize;\n\n        /**\n         * width of this element in grid pixels\n         * @type {number}\n         */\n        this.gridWidth = gridWidth;\n        /**\n         * height of this element in grid pixels\n         * @type {number}\n         */\n        this.gridHeight = gridHeight;\n\n        // transparent background rectangle\n        let rectangle = new Rectangle(0, 0, this.width, this.height, \"none\", \"none\");\n        rectangle.$el.addClass('rect');\n\n        this.svgObj.addChild(rectangle);\n\n        // image of the element\n        this.image = new SvgImage(0, 0, this.width, this.height, this.url);\n        this.svgObj.addChild(this.image);\n\n        // add type=\"gate\", used in special callbacks in contextmenu\n        this.svgObj.addAttr({\"type\": category});\n\n        this.svgObj.$el.addClass(\"box\");\n        this.svgObj.$el.addClass(category);\n    }\n\n    /**\n     * url of the image depicting this object\n     * @type {string}\n     */\n    get url() {\n        const\n            category = this.category || \"\",\n            name = this.name || \"\",\n            suffix = this.imgSuffix || \"\";\n\n        return `img/svg/${category}/${name}${suffix}.svg`;\n    }\n\n    /**\n     * get all input connectors of this box\n     * @return {Array} array of input connectors\n     */\n    get inputConnectors() {\n        return this.connectors.filter(conn => conn.isInputConnector)\n    }\n\n    /**\n     * get all output connectors of this box\n     * @return {Array} array of output connectors\n     */\n    get outputConnectors() {\n        return this.connectors.filter(conn => conn.isOutputConnector)\n    }\n\n    /**\n     * get data of this box as a JSON-ready object\n     * @return {Object} javascript object containing essential data for this box\n     */\n    get exportData() {\n        let connections = [];\n\n        // go through all connectors\n        let counter = 0\n        for (const conn of this.connectors) {\n            // go through each its wire id\n            for (const item of conn.wireIds) {\n                let thisWireId;\n                if(!this.parentSVG.exportWireIdMap.has(item)) {\n                    // if the wire id is not in the map, add it and assign new arbitrary id\n                    this.parentSVG.exportWireIdMap.set(item, this.parentSVG.exportWireId);\n                    thisWireId = this.parentSVG.exportWireId;\n                    this.parentSVG.exportWireId++;\n                } else {\n                    // else get id from the map\n                    thisWireId = this.parentSVG.exportWireIdMap.get(item);\n                }\n\n\n                // add this connection to the list\n                connections[connections.length] = {\n                    index: counter,\n                    type: conn.type,\n                    wireId: thisWireId\n                };\n            }\n            counter++\n        }\n\n        return {\n            name: this.name,\n            category: this.category,\n            transform: this.getTransform(true),\n            connections: connections\n        };\n    }\n\n    /**\n     * get set of nodes that are not suitable for wire routing\n     * @param  {Number} [marginTop=0]    top margin of the element (distance from the element that should be also blocked)\n     * @param  {Number} [marginRight=0]  right margin of the element\n     * @param  {Number} [marginBottom=0] bottom margin of the element\n     * @param  {Number} [marginLeft=0]   left margin of the element\n     * @param  {Number} specialNodes     additional nodes that should be added to the set\n     * @return {Set}                     set of not suitable nodes\n     */\n    generateBlockNodes(marginTop = 0, marginRight = 0, marginBottom = 0, marginLeft = 0, ...specialNodes) {\n        this.blockedNodes = new Set();\n        for(let x = marginLeft ; x <= this.gridWidth - marginRight ; x++) {\n            for(let y = marginTop ; y <= this.gridHeight - marginBottom ; y++) {\n                this.blockedNodes.add({\n                    x: x,\n                    y: y\n                });\n            }\n        }\n\n        for (let node of specialNodes) {\n            this.blockedNodes.add(node);\n        }\n    }\n\n    /**\n     * empty function, redefined in inherited elements\n     * refreshState takes input connector values and sets output values accordingly\n     */\n    refreshState() {\n        console.warn(\"Calling the virtual function refreshState has no effect.\");\n    }\n\n    /**\n     * change image to another one that ends with a specified suffix\n     *\n     * *usage:* `changeImage(\"abc\")` changes image url to `image-abc.svg`,\n     * `changeImage()` changes image url to the default one (`image.svg`)\n     * @param  {string} [suffix] new suffix for the image\n     */\n    changeImage(suffix) {\n        if(suffix === undefined || suffix === \"\") {\n            this.imgSuffix = \"\";\n        } else {\n            this.imgSuffix = \"-\" + suffix;\n        }\n\n        this.image.changeUrl(this.url);\n    }\n\n    /**\n     * get a jQuery element representing this box\n     * @return {jQuery.element}\n     */\n    get() {\n        return this.svgObj.get();\n    }\n\n    /**\n     * rotate the set of blocked nodes by 90 degrees to the right or to the left, depending on the parameter\n     *\n     * used to rotate the nodes when the object itself is rotated\n     * @param  {boolean} right rotate clockwise if true, counterclockwise if false\n     */\n    rotateBlockedNodes(center, right) {\n        if(this.rotationParity===undefined) {\n            this.rotationParity = false;\n        }\n\n        this.rotationParity = !this.rotationParity;\n\n        let newBlockedNodes = new Set();\n\n        // rotate the node\n\n        for (const node of this.blockedNodes) {\n            let newNode;\n\n            const parityFactor =  (this.rotationParity ? 1 : -1);\n\n            if(right) {\n                newNode = {\n                    x: - node.y + this.gridHeight + (center.x - center.y) * parityFactor,\n                    y: node.x + (center.y - center.x) * parityFactor\n                };\n            } else {\n                newNode = {\n                    x: node.y + (center.x - center.y) * parityFactor\n                }\n\n                if(this.rotationParity) {\n                    newNode.y = - node.x + this.gridWidth + ((this.gridHeight - center.y) - (this.gridWidth - center.x))\n                } else {\n                    newNode.y = - node.x + this.gridHeight + (center.y - center.x)\n                }\n            }\n\n            newBlockedNodes.add(newNode);\n        }\n\n        this.blockedNodes = newBlockedNodes;\n    }\n\n    /**\n     * rotate the set of blocked nodes to the right\n     *\n     * used to rotate the nodes when the object itself is rotated\n     */\n    rotateBlockedNodesRight(center) {\n        this.rotateBlockedNodes(center, true);\n    }\n\n    /**\n     * rotate the set of blocked nodes to the right\n     *\n     * used to rotate the nodes when the object itself is rotated\n     */\n    rotateBlockedNodesLeft(center) {\n        this.rotateBlockedNodes(center, false);\n    }\n\n    rotate(clockWise) {\n        // get the transform value for this box\n        let transform = this.getTransform();\n\n        // get the bounding rectangle for this box\n        let rect = this.svgObj.$el[0].getBoundingClientRect();\n\n        // use the bounding rectangle dimensions to figure out the geometrical center of the box\n        const center = {\n            x: Math.round(rect.width / 2),\n            y: Math.round(rect.height / 2)\n        }\n\n        center.x -= center.x % this.gridSize;\n        center.y -= center.y % this.gridSize;\n\n        // apply the rotation to the transform object\n        if(clockWise) {\n            transform.rotateRight(center.x, center.y);\n        } else {\n            transform.rotateLeft(center.x, center.y);\n        }\n\n\n        // apply the modified transform object ot the svgObj\n        this.svgObj.addAttr({\"transform\": transform.get()});\n\n        const gridCenter = {\n            x: center.x / this.gridSize,\n            y: center.y / this.gridSize\n        };\n\n        // rotate also the blocked nodes\n        if(clockWise) {\n            this.rotateBlockedNodesRight(gridCenter);\n        } else {\n            this.rotateBlockedNodesLeft(gridCenter);\n        }\n\n        // update the wires\n        this.updateWires();\n\n        // if tutorial exists, call tutorial callback\n        if(this.parentSVG.tutorial) {\n            this.parentSVG.tutorial.onBoxRotated();\n        }\n    }\n\n    /**\n     * add a connector to the element on the specified position\n     * @param {number}  left             horizontal distance from the left edge of the element\n     * @param {number}  top              vertical distance from the top edge of the element\n     * @param {Boolean} isInputConnector whether or not should this connector an input connector (`true` for input connector, `false` for output connector)\n     */\n    addConnector(left, top, isInputConnector) {\n        let index = this.connectors.length;\n        if(isInputConnector) {\n            this.connectors[index] = new InputConnector(this.parentSVG, left, top);\n        } else {\n            this.connectors[index] = new OutputConnector(this.parentSVG, left, top);\n        }\n        this.svgObj.addChild(this.connectors[index].get());\n    }\n\n    /**\n     * add an input connector to the element on the specified position\n     * @param {number} left horizontal distance from the left edge of the element\n     * @param {number} top  vertical distance from the top edge of the element\n     */\n    addInputConnector(left, top) {\n        return this.addConnector(left, top, true)\n    }\n\n    /**\n     * add an output connector to the element on the specified position\n     * @param {number} left horizontal distance from the left edge of the element\n     * @param {number} top  vertical distance from the top edge of the element\n     */\n    addOutputConnector(left, top) {\n        return this.addConnector(left, top, false)\n    }\n\n    /**\n     * get the connector object based on its id\n     * @param  {string} connectorId ID of the {@link Connector}\n     * @return {Connector}             instance of the {@link Connector} or `undefined` if not found\n     */\n    getConnectorById(connectorId) {\n        for(let i = 0 ; i < this.connectors.length ; i++) {\n            if(this.connectors[i].id===connectorId) {\n                return this.connectors[i];\n            }\n        }\n        // if connector not found, return undefined\n        return undefined;\n    }\n\n    /**\n     * get the instance of {@link Transform} representing the state of the transform attribute of this element\n     * @param  {Boolean} [gridPixels=false] if `true`, function will return the result in grid pixels instead of SVG pixels\n     * @return {Transform}                  {@link Transform} of the element\n     */\n    getTransform(gridPixels = false) {\n        let transform;\n        if (!this.svgObj.$el.attr(\"transform\")) {\n            // the element does not have a \"transform\" property --> create it\n            transform = new Transform();\n            transform.setTranslate(0, 0);\n            this.svgObj.addAttr({\"transform\": transform.get()});\n        } else {\n            // the element does have a \"transform\" property --> change it\n            transform = new Transform(this.svgObj.$el.attr(\"transform\"));\n        }\n\n        // convert values to grid pixels\n        if(gridPixels) {\n            transform.toGridPixels(this.parentSVG);\n        }\n\n        return transform;\n    }\n\n    /**\n     * get the instance of {@link Transform} representing the state of the transform attribute of this element _with lenght units in grid pixels_\n     * @return {Transform} {@link Transform} of the element\n     */\n    getGridPixelTransform() {\n        return this.getTransform(true);\n    }\n\n    /**\n     * set the transform attribute of this element\n     * @param {Transform} transform {@link Transform} of the element (with lengths specified in SVG pixels)\n     */\n    setTransform(transform) {\n        this.svgObj.addAttr({\"transform\": transform.get()});\n    }\n\n    /**\n     * function that is called on every mouse down on this element\n     *\n     * moves the element to the front and calls onMouseDownLeft if applicable\n     * @param  {jQuery.MouseEvent} event\n     */\n    onMouseDown(event) {\n        this.mouseLeft = false;\n        if(event.which === 1) {\n            this.mouseLeft = true;\n            this.onMouseDownLeft(event);\n\n            // move the DOM element to front\n            this.parentSVG.moveToFrontById(this.svgObj.id);\n        }\n    }\n\n    /**\n     * function that is called on every left mouse down on this element\n     *\n     * prepares element for the \"click\" and \"drag and drop\" actions\n     * @param  {jQuery.MouseEvent} event\n     */\n    onMouseDownLeft(event) {\n        this.mouseMoved = false;\n\n        let transform = this.getTransform();\n\n        // save the current item position into a variable\n        let currentPosition = transform.getTranslate();\n\n        let {pageX, pageY} = this.parentSVG.viewbox.transformEvent(event)\n\n        // calculate mouse offset from the object origin\n        this.offset = {\n            x: pageX - currentPosition.x,\n            y: pageY - currentPosition.y\n        };\n    }\n\n    /**\n     * function that is called on every left mouse move with this element\n     * applies the correct transform values to provide the \"drag and drop\" functionality\n     * @param  {jQuery.MouseEvent} event\n     */\n    onMouseMove(event) {\n        if(this.mouseLeft) {\n            this.svgObj.$el.addClass('grabbed');\n\n            this.mouseMoved = true;\n\n            let {pageX, pageY} = this.parentSVG.viewbox.transformEvent(event)\n\n            const left = pageX - this.offset.x;\n            const top = pageY - this.offset.y;\n\n            let transform = this.getTransform();\n            transform.setTranslate(left, top);\n\n            this.setTransform(transform);\n\n            this.updateWires(true);\n        }\n    }\n\n    /**\n     * function that is called on every mouse up on this element\n     * provides the \"click\" functionality and calls the onDrop handler for the \"drag and drop\" functionality\n     * @param  {jQuery.MouseEvent} event\n     */\n    onMouseUp(event) {\n        if(event.which === 1) {\n            if(this.mouseMoved) {\n                this.onDrop(event);\n            } else {\n                this.onClick();\n            }\n        } else if (event.which === 2 ) {\n            this.onClickMiddle(event);\n        }\n\n        this.svgObj.$el.removeClass('grabbed');\n    }\n\n    /**\n     * called by onMouseUp when the mouse has been moved between onMouseDown and onMouseUp\n     *\n     * applies grid snapping of the element on the end of the \"drag and drop\" action\n     * @param  {jQuery.MouseEvent} event\n     */\n    onDrop(event) {\n        let {pageX, pageY} = this.parentSVG.viewbox.transformEvent(event)\n\n        let left = pageX - this.offset.x;\n        let top = pageY - this.offset.y;\n\n        left = this.parentSVG.snapToGrid(left);\n        top = this.parentSVG.snapToGrid(top);\n\n        let transform = this.getTransform();\n        transform.setTranslate(left, top);\n\n        this.setTransform(transform);\n\n        this.updateWires();\n\n        // if tutorial exists, call tutorial callback\n        if(this.parentSVG.tutorial) {\n            this.parentSVG.tutorial.onBoxMoved();\n        }\n    }\n\n    /**\n     * empty function, will be redefined in InputBox\n     */\n    onClick() {}\n\n    /**\n     * custom callback function for middle click that rotates the box by 90 degrees to the right\n     */\n    onClickMiddle(event) {\n        if(event.ctrlKey) {\n            this.rotate(false);\n        } else {\n            this.rotate(true);\n        }\n    }\n\n    /**\n     * Updates all wires connected to this box. Iterates over all wires that are connected to this box\n     * and calls routeWire (or temporaryWire if the `temporary` parameter is set to true) to update the wire routing\n     * @param  {Boolean} [temporary=false] [description]\n     */\n    updateWires(temporary = false) {\n        this.connectors.forEach(conn => {\n            conn.wireIds.forEach(wireId => {\n                let wire = this.parentSVG.getWireById(wireId);\n                if(temporary) {\n                    wire.temporaryWire();\n                } else {\n                    wire.routeWire();\n                }\n            })\n        })\n    }\n}\n","import NetworkElement from './NetworkElement';\nimport {Rectangle} from '../svgObjects'\nimport Logic from '../Logic'\n\nimport stateClasses from './stateClasses'\n\n/** @module editorElements.Connector */\n\n/**\n * parent class for input and output connectors\n * @extends NetworkElement\n */\nexport default class Connector extends NetworkElement {\n    /**\n     * @param {Canvas} parentSVG link to the {@link Canvas} instance that this connector will belong to\n     * @param {number} gridSize  size of the grid in SVG pixels\n     * @param {number} left      horizontal position defined in grid units (SVG pixels divided by the grid size)\n     * @param {number} top       vertical position defined in grid units (SVG pixels divided by the grid size)\n     */\n    constructor(parentSVG, left, top) {\n        super(parentSVG);\n\n        /**\n         * size of the grid in SVG pixels\n         * @type {number}\n         */\n        this.gridSize = parentSVG.gridSize;\n        /**\n         * size of the connector in SVG pixels\n         * @type {number}\n         */\n        this.connectorSize = parentSVG.gridSize;\n        /**\n         * offset of the connector from the grid in SVG pixels\n         * @type {number}\n         */\n        this.connectorOffset = this.connectorSize / 2;\n\n        /**\n         * instance of {@link svgObjects.svgObj} that holds all SVG information about this connector\n         * @type {svgObj}\n         */\n        this.svgObj = new Rectangle(\n            left * this.gridSize - this.connectorOffset,\n            top * this.gridSize - this.connectorOffset,\n            this.connectorSize,\n            this.connectorSize,\n            \"none\",\n            \"black\"\n        );\n\n        this.svgObj.$el.addClass(\"connector\");\n\n        /**\n         * this flag describes whether this connector is an input connector\n         * @type {Boolean}\n         */\n        this.isInputConnector = false;\n\n        /**\n         * current logical state of this connector\n         * @type {Logic.state}\n         */\n        this.elementState = Logic.state.unknown;\n        this.svgObj.addClass(stateClasses[Logic.state.unknown]);\n\n        /**\n         * set of ids of all wires connected to this connector\n         * @type {Set}\n         */\n        this.wireIds = new Set();\n    }\n\n    /**\n     * whether this connector is an output connector\n     * @return {Boolean}\n     */\n    get isOutputConnector() {\n        return !this.isInputConnector;\n    }\n\n    /**\n     * whether this connector is an output connector\n     * @return {Boolean}\n     */\n    set isOutputConnector(value) {\n        this.isInputConnector = !value;\n    }\n\n    /**\n     * add a wire id to the list of wire ids\n     * @param {string} wireId\n     */\n    addWireId(wireId) {\n        this.wireIds.add(wireId);\n    }\n\n    /**\n     * remove a wire id from the list of wire ids\n     * @param {string} wireId\n     */\n    removeWireId(wireId) {\n        this.wireIds.delete(wireId);\n    }\n\n    /**\n     * remove a wire specified by ID and update the connector\n     * @param  {string} wireId ID of the wire to be removed\n     */\n    removeWireIdAndUpdate(wireId) {\n        this.removeWireId(wireId);\n    }\n\n    /**\n     * set logical state of the connector\n     * @param {Logic.state} state new state of the connector\n     */\n    setState(state) {\n        this.svgObj.removeClasses(...stateClasses);\n        this.svgObj.addClass(stateClasses[state]);\n\n        this.elementState = state;\n    }\n\n    /**\n     * get state of this connector\n     * @return {Logic.state}\n     */\n    get state() {\n        return this.elementState;\n    }\n\n    /**\n     * get svgObj instance content of this connector\n     * @return {svgObjects.Rectangle}\n     */\n    get() {\n        return this.svgObj;\n    }\n\n    /**\n     * call [wireCreationHelper](./module-Canvas.html#wireCreationHelper) on mouse up\n     */\n    onMouseUp(event) {\n        // only left click counts\n        if(event.which === 1) {\n            event = this.parentSVG.viewbox.transformEvent(event);\n\n            const mousePosition = {\n                x: event.pageX,\n                y: event.pageY\n            }\n\n            this.parentSVG.wireCreationHelper(this.svgObj.id, mousePosition);\n        }\n    }\n}\n","import Logic from '../Logic'\n\nimport Box from './Box'\n\n/** @module editorElements.Gate */\n\n/**\n * Gate is a box that processes the states of its input connectors and returns the result in its output connectors.\n * @extends Box\n */\nexport default class Gate extends Box {\n    /**\n     * @param {Canvas} parentSVG  instance of [Canvas](./module-Canvas.html)\n     * @param {string} name       name of the gate (and, not, xor...)\n     */\n    constructor(parentSVG, name) {\n        const width = 9;\n        const height = 4;\n\n        super(parentSVG, name, \"gate\", width, height);\n\n        // ADD CONNECTORS\n\n        let specialNodes = [];\n\n        // output\n        this.addConnector(width, height / 2, false);\n\n        // block the output connector\n        specialNodes.push({\n            x: width,\n            y: height / 2\n        });\n\n        if(this.name===\"not\" || this.name===\"repeater\") {\n            // input\n            this.addConnector(0, height / 2, true);\n            // block the input connector\n            specialNodes.push({\n                x: 0,\n                y: height / 2\n            });\n        } else {\n            // input\n            this.addConnector(0, height / 4, true);\n            this.addConnector(0, height / (4/3), true);\n\n            // block the input connectors\n            specialNodes.push({\n                x: 0,\n                y: height / 4\n            })\n            specialNodes.push({\n                x: 0,\n                y: height / (4/3)\n            });\n\n            // add one blocked node between the inputs (for better looking wiring)\n            specialNodes.push({\n                x: 0,\n                y: height / 2\n            });\n        }\n\n        this.generateBlockNodes(...specialNodes);\n\n        this.refreshState();\n    }\n\n    /**\n     * array of valid gate names\n     * @type {Set}\n     */\n    static get validGates() {\n        return new Set([\"not\", \"and\", \"or\", \"nand\", \"nor\", \"xor\", \"xnor\", \"repeater\"]);\n    }\n\n    generateBlockNodes(...specialNodes) {\n        if(specialNodes!==undefined) {\n            super.generateBlockNodes(0, 1, 0, 1, ...specialNodes);\n        } else {\n            super.generateBlockNodes(0, 1, 0, 1);\n        }\n    }\n\n    /**\n     * proccess the input connector states and reflect them in the output connector states according\n     * to the logic corresponding to this gate's name\n     */\n    refreshState() {\n        // map gate names to their logic functions\n        const stateMap = {\n            \"and\": () => Logic.and(this.connectors[1].state, this.connectors[2].state),\n            \"nand\": () => Logic.nand(this.connectors[1].state, this.connectors[2].state),\n            \"nor\": () => Logic.nor(this.connectors[1].state, this.connectors[2].state),\n            \"not\": () => Logic.not(this.connectors[1].state),\n            \"or\": () => Logic.or(this.connectors[1].state, this.connectors[2].state),\n            \"xnor\": () => Logic.xnor(this.connectors[1].state, this.connectors[2].state),\n            \"xor\": () => Logic.xor(this.connectors[1].state, this.connectors[2].state),\n            \"repeater\": () => this.connectors[1].state\n        }\n\n        let state = Logic.state.unknown\n\n        if(stateMap[this.name]) {\n            state = stateMap[this.name]()\n        }\n\n        // notify the simulator about this change\n        this.parentSVG.simulation.notifyChange(this.connectors[0].id, state)\n    }\n}\n","import {PolyLine, PolyLinePoints, PolyLinePoint} from '../svgObjects'\n\nimport NetworkElement from './NetworkElement'\n\n/** @module editorElements.HelperWire */\n\n/**\n * A temporary wire that is connecting a {@link Connector} with a mouse pointer when user creates a wire.\n * @extends NetworkElement\n */\nexport default class HelperWire extends NetworkElement {\n    constructor(parentSVG, fromId, mousePosition) {\n        super(parentSVG);\n\n        const connector = this.parentSVG.getConnectorById(fromId);\n        this.connectorPosition = this.parentSVG.getConnectorPosition(connector, true);\n\n        const from = new PolyLinePoint(this.connectorPosition.x, this.connectorPosition.y);\n        const to = new PolyLinePoint(mousePosition.x, mousePosition.y);\n\n        const points = new PolyLinePoints([from, to]);\n\n        this.svgObj = new PolyLine(points, 2, \"#8b8b8b\");\n    }\n\n    updateMousePosition(mousePosition) {\n        const from = new PolyLinePoint(this.connectorPosition.x, this.connectorPosition.y);\n        const to = new PolyLinePoint(mousePosition.x, mousePosition.y);\n\n        const points = new PolyLinePoints([from, to]);\n\n        this.svgObj.updatePoints(points);\n    }\n\n    /**\n     * get the jQuery element for this helper wire\n     * @return {jQuery.element}\n     */\n    get() {\n        return this.svgObj.get();\n    }\n}\n","import Logic from '../Logic'\n\nimport Box from './Box'\n\n/** @module editorElements.InputBox */\n\n/**\n * InputBox has only output connectors and is used to set the input states for the logic network.\n * @extends Box\n */\nexport default class InputBox extends Box {\n    /**\n     * @param {Canvas} parentSVG  instance of [Canvas](./module-Canvas.html)\n     * @param {Boolean} [isOn=false] the initial state of the inputbox (`true` is *on*, `false` is *off*)\n     */\n    constructor(parentSVG, isOn = false) {\n        const gridWidth = 7;\n        const gridHeight = 4;\n\n        super(parentSVG, \"input\", \"other\", gridWidth, gridHeight);\n\n        this.addConnector(gridWidth, gridHeight / 2, false);\n\n        this.on = isOn;\n\n        this.generateBlockNodes();\n    }\n\n    /**\n     * get data of this input box as a JSON-ready object\n     * @return {Object} javascript object containing essential data for this input box\n     */\n    get exportData() {\n        let data = super.exportData;\n        data.isOn = this.isOn;\n\n        return data;\n    }\n\n    generateBlockNodes() {\n        // block the input connector node\n        const specialNode = {\n            x: this.gridWidth,\n            y: this.gridHeight / 2\n        }\n        super.generateBlockNodes(0, 1, 1, 0, specialNode);\n    }\n\n    /**\n     * start a new simulation from the output connector\n     */\n    refreshState() {\n        this.parentSVG.startNewSimulation(this.connectors[0], this.connectors[0].state)\n    }\n\n    /**\n     * set the state of the inputbox to the corresponding value\n     * @param  {Boolean} isOn set to *on* if `true`, set to *off* if `false`\n     */\n    set on(isOn) {\n        if (isOn) {\n            // turn on\n            this.changeImage(\"on\");\n            this.connectors[0].setState(Logic.state.on);\n            this.refreshState()\n        } else {\n            // turn off\n            this.changeImage();\n            this.connectors[0].setState(Logic.state.off);\n            this.refreshState()\n        }\n\n        this.isOn = isOn;\n    }\n\n    /**\n     * get the state of the inputbox (`true` if *on*, `false` if *off*)\n     * @return {Boolean} [description]\n     */\n    get on() {\n        return this.isOn;\n    }\n\n    /**\n     * toggle the state of the inputbox\n     */\n    onClick() {\n        this.on = !this.on;\n\n        if(this.parentSVG.tutorial) {\n            this.parentSVG.tutorial.onChangeInputBoxState();\n        }\n    }\n}\n","import Connector from './Connector'\nimport Logic from '../Logic'\n\n/** @module editorElements.InputConnector */\n\n/**\n * Connector that gets its state from a connected value and passes it through to the {@link Box} this connector belongs to.\n * @extends Connector\n */\nexport default class InputConnector extends Connector {\n    /**\n     * Call the constructor from the parent {@link Connector} class and set isInputConnector to true.\n     * @param {Canvas} parentSVG link to the {@link Canvas} instance that this connector will belong to\n     * @param {number} left      horizontal position defined in grid units (SVG pixels divided by the grid size)\n     * @param {number} top       vertical position defined in grid units (SVG pixels divided by the grid size)\n     */\n    constructor(parentSVG, left, top) {\n        super(parentSVG, left, top);\n\n        this.isInputConnector = true;\n    }\n\n    /**\n     * Call the setState method of {@link Connector} and than refresh the state of the connected {@link Box}\n     * @param {Logic.state} state new {@link Logic.state} of the connector\n     */\n    setState(state) {\n        super.setState(state);\n        // console.log(\"SET STATE ON IC\", this.id, \":\", state)\n\n        let box = this.parentSVG.getBoxByConnectorId(this.svgObj.id);\n        box.refreshState();\n    }\n\n    /**\n     * remove the wire (by calling the removeWireIdAndUpdate of {@link Connector})\n     * and update state of this connector by setting it to undefined using the setState method\n     * @param  {string} wireId ID of the {@link Wire}\n     */\n    removeWireIdAndUpdate(wireId) {\n        super.removeWireIdAndUpdate(wireId);\n        this.setState(Logic.state.unknown);\n    }\n}\n","/** @module editorElements.NetworkElement */\n\n/**\n * parent class for all network elements\n */\nexport default class NetworkElement {\n    /**\n     * Basic constructor for NetworkElement\n     * @param {Canvas} parentSVG reference to the instance of {@link Canvas} that this element belongs to\n     */\n    constructor(parentSVG) {\n        if(!parentSVG) {\n            console.error(\"Parent SVG element has to be defined.\");\n        }\n        this.parentSVG = parentSVG;\n\n        // used to store the svjObject's instance of this element\n        this.svgObj = undefined;\n    }\n\n    /**\n     * Get the unique ID of the SVG element tied to this logical element\n     * @return {string} ID of the SVG element\n     */\n    get id() {\n        return this.svgObj.id;\n    }\n\n    /**\n     * empty callback function to prevent error messages, function is implemented later in the {@link Box} class\n     */\n    onMouseDown() {}\n\n    /**\n     * empty function to prevent error messages, function is implemented later in the {@link Box} and {@link Connector} classes\n     */\n    onMouseUp() {}\n\n    /**\n     * empty function to prevent error messages, function is implemented later in the {@link Box} class\n     */\n    onMouseMove() {}\n\n    /**\n     * \"virtual\" getter for json data, prints an error that it has to be redefined in the derived classes\n     */\n    get exportData() {\n        console.error(\"'json' getter has not been defined for this element\", this);\n        return undefined;\n    }\n}\n","import Logic from '../Logic'\n\nimport Box from './Box'\n\n/** @module editorElements.OutputBox */\n\n/**\n * OutputBox has only input connectors and is used to visualize the output states of the logic network.\n * @extends Box\n */\nexport default class OutputBox extends Box {\n    /**\n     * @param {Canvas} parentSVG  instance of [Canvas](./module-Canvas.html)\n     */\n    constructor(parentSVG) {\n        const gridHeight = 4;\n        const gridWidth = 5;\n\n        super(parentSVG, \"output\", \"other\", gridWidth, gridHeight);\n\n        this.addConnector(0, gridHeight / 2, true);\n\n        this.generateBlockNodes();\n    }\n\n    /**\n     * set state of this output box to match the state of its input connector\n     */\n    refreshState() {\n        this.setState(this.connectors[0].state);\n    }\n\n    /**\n     * Reflect the input connector state in the appearance of the element - set\n     * the element image to represent the corresponding state\n     * @param {Logic.state} state new state of this outputBox\n     */\n    setState(state) {\n        if(state===Logic.state.on){\n            if(this.parentSVG.tutorial) {\n                this.parentSVG.tutorial.onOutputBoxTrue();\n            }\n        }\n\n        let stateMap = {};\n        stateMap[Logic.state.on] = \"on\"\n        stateMap[Logic.state.off] = \"off\"\n        stateMap[Logic.state.unknown] = \"\"\n        stateMap[Logic.state.oscillating] = \"osc\"\n\n        this.changeImage(stateMap[state]);\n    }\n\n    generateBlockNodes() {\n        // block the input connector node\n        const specialNode = {\n            x: 0,\n            y: this.gridHeight / 2\n        }\n        super.generateBlockNodes(0, 0, 0, 1, specialNode);\n    }\n}\n","import Connector from './Connector'\n\n/** @module editorElements.OutputConnector */\n\n/**\n * Connector that takes a state defined by the {@link Box} it belongs to and passes it to all connected wire\n * @extends Connector\n */\nexport default class OutputConnector extends Connector {\n    /**\n     * Call the constructor from the parent {@link Connector} class and set isOutputConnector to true.\n     * @param {Canvas} parentSVG link to the {@link Canvas} instance that this connector will belong to\n     * @param {number} left      horizontal position defined in grid units (SVG pixels divided by the grid size)\n     * @param {number} top       vertical position defined in grid units (SVG pixels divided by the grid size)\n     */\n    constructor(parentSVG, left, top) {\n        super(parentSVG, left, top);\n\n        this.isOutputConnector = true;\n    }\n\n    /**\n     * Call the setState method of {@link Connector} and than set the state of the connected {@link Wire}s\n     * @param {Logic.state} state new {@link Logic.state} of the connector\n     */\n    setState(state) {\n        super.setState(state);\n\n        for (const wireId of this.wireIds) {\n            this.parentSVG.getWireById(wireId).setState(state);\n        }\n    }\n}\n","/** @module editorElements.Transform */\n\n/**\n * Helper class used by {@link Transform}.\n *\n * Represents one single property of the transform argument, for example `translate(360 150)`\n * that may be a part of longer transform argument like `transform=\"translate(360 150) rotate(90 30 20)\"`\n */\nclass Property {\n    /**\n     * Initialize the Property object\n     * @param {string} [string] string in the property format `propertyname(list of space separated values)`\n     */\n    constructor(string) {\n        if(string!==undefined) {\n            this.name = string.replace(/^[ ]*([^(]+).*/, \"$1\");\n            this.args = string.replace(/^[^(]+\\((.*)\\)/, \"$1\").split(' ');\n        }\n    }\n\n    /**\n     * set or replace the name of this property\n     * @param {string} name new name for this property\n     */\n    setName(name) {\n        this.name = name;\n    }\n\n    /**\n     * set arguments of this property\n     * @param {array} args array of arguments\n     */\n    setArguments(args) {\n        this.args = args;\n    }\n\n    /**\n     * get string representation of the property\n     * @return {string} property in the property format `name(arg1 arg2)`\n     */\n    get() {\n        return this.name + \"(\" + this.args.join(\" \") + \")\";\n    }\n}\n\n/**\n * API for manipulating the transform argument used in SVG\n */\nexport default class Transform {\n    /**\n     * Initialize the Transform object\n     * @param {string} [string] string in the format of the `transform` argument in SVG, for example `translate(360 150) rotate(90 30 20)`\n     */\n    constructor(string) {\n        /**\n         * array of {@link Property} instances\n         * @type {Array}\n         */\n        this.items = [];\n\n        if(string!==undefined) {\n            for (const item of string.split(\")\")) {\n                if(item) { // if not empty\n                    this.items.push(new Property(item + \")\"));\n                }\n            }\n        }\n    }\n\n    /**\n     * convert distances from SVG pixels to grid pixels\n     * @param  {Canvas} parentSVG instance of [Canvas](./module-Canvas.html)\n     */\n    toGridPixels(parentSVG) {\n        this.pixelConversion((val) => parentSVG.SVGToGrid(val))\n    }\n\n    /**\n     * convert distances from grid pixels to SVG pixels\n     * @param  {Canvas} parentSVG instance of [Canvas](./module-Canvas.html)\n     */\n    toSVGPixels(parentSVG) {\n        this.pixelConversion((val) => parentSVG.gridToSVG(val))\n    }\n\n    /**\n     * Convert distances using a specified convertor. Used by toGridPixels and toSVGPixels\n     * @param  {Function} convertor function that converts int to int\n     */\n    pixelConversion(convertor) {\n        const propertyMap = {\n            \"translate\": (item) => {\n                item.args = item.args.map(arg => convertor(arg))\n                return item;\n            },\n            \"rotate\": (item) => {\n                item.args = [\n                    item.args[0],\n                    convertor(item.args[1]),\n                    convertor(item.args[2])\n                ]\n                return item;\n            }\n        }\n\n        this.items = this.items.map((item) => {\n            return propertyMap[item.name] ? propertyMap[item.name](item) : item\n        })\n    }\n\n    /**\n     * find a transform property by name and get its index in the [items](#items) array\n     * @param  {string} name name of the property\n     * @return {number}      index of the property in the array of properties or `-1` if not found\n     */\n    getIndex(name) {\n        for(let i = 0 ; i < this.items.length; i++) {\n            if(name === this.items[i].name) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    /**\n     * get the translate property\n     * @return {Object} object containing parameters of the translate attribute\n     */\n    getTranslate() {\n        let args = this.getArguments(this.getIndex(\"translate\"));\n\n        return {\n            x: Number(args[0]),\n            y: Number(args[1])\n        }\n    }\n\n    /**\n     * get the rotate property\n     * @return {Object} object containing parameters of the rotate attribute\n     */\n    getRotate() {\n        let args = this.getArguments(this.getIndex(\"rotate\"));\n\n        return {\n            deg: Number(args[0]),\n            centerX: Number(args[1]),\n            centerY: Number(args[2])\n        }\n    }\n\n    /**\n     * set translate to the specified values\n     * @param {number} x horizontal translation\n     * @param {number} y vertical translation\n     */\n    setTranslate(x, y) {\n        this.setParameter(\"translate\", [x, y]);\n    }\n\n    /**\n     * set rotate to the specified values\n     * @param {number} deg     angle of the rotation in degrees\n     * @param {number} centerX horizontal position of the center of the rotation\n     * @param {number} centerY vertical position of the center of the rotation\n     */\n    setRotate(deg, centerX, centerY) {\n        this.setParameter(\"rotate\", [deg, centerX, centerY]);\n    }\n\n    /**\n     * rotate by 90 degrees to the right or left, depending on the parameter `right`\n     * @param {number} centerX horizontal position of the center of the rotation\n     * @param {number} centerY vertical position of the center of the rotation\n     * @param {boolean} right rotate to the right if `true`, to the left if `false`\n     */\n    rotateRightAngle(centerX, centerY, right) {\n        const amount = right ? 90 : 270;\n\n        if(this.getIndex(\"rotate\")===-1) {\n            this.setRotate(amount, centerX, centerY);\n        } else {\n            let newRotation = (parseInt(this.getRotate().deg) + amount) % 360;\n\n            if(newRotation===180) {\n                // swap center coordinates\n                // because rotate(c, x, y) is defined like transform(-x, -y) rotate(c) transform(x, y)\n                let a = centerX;\n                centerX = centerY;\n                centerY = a;\n            }\n\n            this.setRotate(\n                newRotation,\n                centerX,\n                centerY\n            );\n        }\n    }\n\n    /**\n     * rotate by 90 degrees to the right\n     * @param  {number} centerX horizontal position of the center of the rotation\n     * @param  {number} centerY vertical position of the center of the rotation\n     */\n    rotateRight(centerX, centerY) {\n        this.rotateRightAngle(centerX, centerY, true);\n    }\n\n    /**\n     * rotate by 90 degrees to the left\n     * @param  {number} centerX horizontal position of the center of the rotation\n     * @param  {number} centerY vertical position of the center of the rotation\n     */\n    rotateLeft(centerX, centerY) {\n        this.rotateRightAngle(centerX, centerY, false);\n    }\n\n    /**\n     * get the transform values in a string\n     * @return {string} string that can be used as a value for the transform property of a SVG element\n     */\n    get() {\n        let retVal;\n        for(const item of this.items) {\n            if(retVal) {\n                retVal += \" \" + item.get();\n            } else {\n                retVal = item.get();\n            }\n        }\n        return retVal;\n    }\n\n    /**\n     * get arguments of a property specified by index\n     * @param  {number} index index of the property\n     * @return {array}       array of arguments of the specified property\n     */\n    getArguments(index) {\n        return this.items[index].args;\n    }\n\n    /**\n     * set argumets of a property specified by name\n     * @param {string} name name of the property\n     * @param {array} args array of arguments of the specified property\n     */\n    setParameter(name, args) {\n        // determine index of the parameter (if set), else index == -1\n        let index = this.getIndex(name);\n\n        // if the property has been already set, change it (rewrite the array in the right index)\n        // else create a new one (set index to the length of an array --> ad an item to the end)\n        if(index===-1) {\n            index = this.items.length;\n            this.items[index] = new Property();\n            this.items[index].setName(name);\n        }\n\n        // save args under the right index\n        this.items[index].setArguments(args);\n    }\n}\n","/** @module editorElements.Wire */\n\nimport {PolyLine, PolyLinePoints, PolyLinePoint, Group} from '../svgObjects'\nimport Logic from '../Logic'\nimport stateClasses from './stateClasses'\nimport findPath from '../findPath'\nimport pointTraveller from './pointTraveller'\n\nimport NetworkElement from './NetworkElement'\nimport WireAnchor from './WireAnchor'\n\n/**\n * Wire represents connection of two {@link Connector}s.\n * @extends NetworkElement\n */\nexport default class Wire extends NetworkElement {\n    /**\n     * @param {Canvas} parentSVG  instance of [Canvas](./module-Canvas.html)\n     * @param {string}  fromId    id of the first connector this wire will be connected to\n     * @param {string}  toId      id of the second connector this wire will be connected to\n     * @param {Boolean} [refresh=true] if `true`, the [Canvas](./module-Canvas.html) will refresh after creating this wire\n     */\n    constructor(parentSVG, fromId, toId, refresh = true, route = true) {\n        super(parentSVG);\n\n        this.gridSize = parentSVG.gridSize;\n\n        /**\n         * array of anchors defined for this array,\n         * each anchor is an instance of the {@link WireAnchor} class\n         * @type {Array}\n         */\n        this.anchors = []\n\n        /**\n         * All information about the wire endpoints, contains two members: `from` and `to`.\n         *\n         * Both members are objects with members `id`, `box` and `connector` containing\n         * the connector id, box object reference and connector object reference for the endpoint.\n         * @type {Object}\n         */\n        this.connection = {\n            from: {\n                id: fromId,\n                box: this.parentSVG.getBoxByConnectorId(fromId),\n                connector: this.parentSVG.getConnectorById(fromId)\n            },\n            to: {\n                id: toId,\n                box: this.parentSVG.getBoxByConnectorId(toId),\n                connector: this.parentSVG.getConnectorById(toId)\n            }\n        }\n\n        if(this.connection.from.connector.isOutputConnector) {\n            if(this.connection.to.connector.isInputConnector) {\n                // desired state\n            } else {\n                // connecting two output connectors\n                throw \"Can not place wire between two output connectors\";\n            }\n        } else {\n            if(this.connection.to.connector.isInputConnector) {\n                // connecting two input connectors\n                throw \"Can not place wire between two input connectors\";\n            } else {\n                // swap them and we are ready to go\n                [ this.connection.from, this.connection.to ] = [ this.connection.to, this.connection.from ];\n            }\n        }\n\n        if(route) {\n            this.routeWire(true, refresh);\n        } else {\n            this.temporaryWire();\n        }\n\n        /**\n         * current state of the element\n         * @type {Logic.state}\n         */\n        this.elementState = Logic.state.unknown;\n\n        this.setState(this.connection.from.connector.state)\n\n        if(refresh) {\n            const {connector} = this.connection.to;\n            this.parentSVG.startNewSimulation(connector, connector.state);\n        }\n\n        this.svgObj.addClass(\"wire\");\n    }\n\n    /**\n     * get the box objects that this wire is connecting\n     * @return {Array} array containing two instances of the {@link Box} class\n     */\n    get boxes() {\n        return [this.connection.from.box, this.connection.to.box];\n    }\n\n    /**\n     * get the connector objects that this wire is connecting\n     * @return {Array} array containing two instances of the {@link Connector} class\n     */\n    get connectors() {\n        return [this.connection.from.connector, this.connection.to.connector];\n    }\n\n    /**\n     * get data of this wire as a JSON-ready object\n     * @return {Object} javascript object containing essential data for this wire\n     */\n    get exportData() {\n        return {\n            fromId: this.connection.from.id,\n            toId: this.connection.to.id\n        };\n    }\n\n    /**\n     * set the state of this wire to match the state of the input connector it is connected to\n     * @param {Logic.state} state [description]\n     */\n    setState(state) {\n        this.svgObj.removeClasses(...stateClasses);\n        this.svgObj.addClass(stateClasses[state]);\n\n        this.connection.to.connector.setState(state);\n\n        this.elementState = state;\n\n        // update states of all anchors as well\n        for(let anchor of this.anchors) {\n            anchor.setState(state);\n        }\n    }\n\n    /**\n     * get the current [Logic.state](./modules-Logic.html#.state) of this wire\n     * @return {Logic.state}\n     */\n    get state() {\n        return this.elementState;\n    }\n\n    /**\n     * update the state of this wire\n     */\n    updateWireState() {\n        for (const box of this.boxes) {\n            box.refreshState()\n        }\n    }\n\n    /**\n     * get the jQuery element for this wire\n     * @return {jQuery.element}\n     */\n    get() {\n        return this.svgObj.get();\n    }\n\n    /**\n     * route the wire using the temporary wire points\n     */\n    temporaryWire() {\n        const [from, to] = this.connectors.map(connector => {\n            return this.parentSVG.getConnectorPosition(connector, false)\n        })\n\n        let points = new PolyLinePoints();\n        points.append(new PolyLinePoint(from.x, from.y));\n\n        for(const anchor of this.anchors) {\n            points.append(new PolyLinePoint(anchor.svgPosition.x, anchor.svgPosition.y))\n        }\n\n        points.append(new PolyLinePoint(to.x, to.y));\n\n        this.setWirePath(points);\n    }\n\n    /**\n     * route the wire using the modified A* wire routing algorithm\n     */\n    routeWire(snapToGrid = true, refresh = true) {\n        let endpoints = this.connectors.map(connector => {\n            const {x, y} = this.parentSVG.getConnectorPosition(connector, snapToGrid);\n            return {\n                x: this.parentSVG.SVGToGrid(x),\n                y: this.parentSVG.SVGToGrid(y)\n            }\n        })\n\n        // get route between the endpoints\n        const points = this.findRoute(...endpoints);\n\n        // set the wire path to the generated points\n        this.setWirePath(points);\n\n        if (refresh)\n            this.updateWireState();\n\n        // regenerate inconvenient nodes\n        this.generateInconvenientNodes();\n    }\n\n    /**\n     * set the wire to follow the specified points\n     * @param {PolyLinePoints} points instance of {@link PolyLinePoints}\n     */\n    setWirePath(points) {\n        // set the line\n        if(this.svgObj!==undefined) {\n            // this.svgObj.updatePoints(points);\n            for (let child of this.svgObj.children) {\n                child.updatePoints(points);\n            }\n        } else {\n            this.svgObj = new Group();\n\n            let hitbox = new PolyLine(points, 10, 'white');\n            hitbox.addClass(\"hitbox\");\n            hitbox.addAttr({opacity: 0});\n            this.svgObj.addChild(hitbox);\n\n            let mainLine = new PolyLine(points, 2);\n            mainLine.addClass(\"main\", \"stateUnknown\");\n            this.svgObj.addChild(mainLine);\n        }\n\n        this.points = points;\n    }\n\n    pathToPolyLine(path) {\n        // create array of polyline points from the coordinates from `path` transformed from grid pixels to SVG pixels\n        const points = path.map(({x, y}) => new PolyLinePoint(this.parentSVG.gridToSVG(x), this.parentSVG.gridToSVG(y)));\n\n        const totalPath = new PolyLinePoints(points);\n\n        return totalPath;\n    }\n\n    /**\n     * find a nice route for the wire\n     * @param  {Object} start object containing numeric attributes `x` and `y` that represent the first endpoint of the wire in grid pixel\n     * @param  {Object} end   object containing numeric attributes `x` and `y` that represent the second endpoint of the wire in grid pixels\n     * @return {PolyLinePoints}       [description]\n     */\n    findRoute(start, end) {\n        let nonRoutable = this.parentSVG.getNonRoutableNodes();\n\n        let punishedButRoutable;\n        if(this.svgObj===undefined) {\n            punishedButRoutable = this.parentSVG.getInconvenientNodes();\n        } else {\n            punishedButRoutable = this.parentSVG.getInconvenientNodes(this.svgObj.id);\n        }\n\n        let routePoints = [\n            start,\n            ...this.anchors.map(({x, y}) => ({x, y})), // strip all other data that x and y coordinates\n            end\n        ];\n\n        // add start here because of the slice(1) below\n        let path = [start];\n\n        let prev;\n        for (const routePoint of routePoints) {\n            if(prev) {\n                // find the best path from 'prev' to 'routePoints'\n                const foundPath = findPath(prev, routePoint, nonRoutable, punishedButRoutable);\n\n                // to avoid repetition of the joints, ignore the first point\n                path.push(...foundPath.slice(1));\n\n                // add the new points to the punishedButRoutable set\n                const pt = pointTraveller(foundPath);\n                for (const point of pt) {\n                    punishedButRoutable.add(point);\n                }\n            }\n            prev = routePoint;\n        }\n\n        // let path = findPath(start, end, nonRoutable, punishedButRoutable, this.gridSize);\n\n        if(path) {\n            return this.pathToPolyLine(path);\n        }\n\n\n        // if a path was not found, try again but don't take into account the punished and non routable node\n        path = findPath(start, end, new Set(), new Set(), this.gridSize);\n\n        if(path) {\n            return this.pathToPolyLine(path);\n        }\n\n        // if the path was still not found, give up and return temporary points\n        return this.getTemporaryWirePoints();\n    }\n\n    /**\n     * Generator that travels the path from the start to the end and each item\n     * is a point with `x` and `y` coordinates in grid pixels\n     * @return {Generator}\n    */\n    *pathTraveller() {\n        const traveller = pointTraveller(this.points.map(({x, y}) => ({\n            x: this.parentSVG.SVGToGrid(x),\n            y: this.parentSVG.SVGToGrid(y)\n        })));\n\n        for(const point of traveller) {\n            yield point;\n        }\n    }\n\n    /**\n     * generate a set of nodes, that are inconvenient for wiring, but can be used, just are not preferred\n     * @return {Set} set of nodes (objects containing x and y coordinates) that are not preferred for wiring\n     */\n    generateInconvenientNodes() {\n        this.inconvenientNodes = new Set();\n\n        const pt = this.pathTraveller();\n        for (const point of pt) {\n            this.inconvenientNodes.add(point);\n        }\n    }\n\n    /**\n     * add a new anchor at the specified position\n     *\n     * if there is already an anchor at this position, do nothing\n     * @param {Object} anchor object with `x` and `y` in grid pixels\n     */\n    addAnchor({x, y}) {\n        // place the anchor to the right position in the array\n\n        let newAnchor = new WireAnchor(this, x, y);\n\n        // travel the path\n        const pt = this.pathTraveller();\n        let pointer = 0;\n        for (const point of pt) {\n            // get the current anchor that the pointer is pointing at\n            const currentAnchor = this.anchors[pointer];\n\n            // if the current anchor does not exist, that means that\n            // the pointer passed all current anchors, so the\n            // new anchor is the last anchor on this wire\n            if(!currentAnchor) {\n                this.anchors.push(newAnchor);\n                break;\n            }\n\n            // if the current anchor has the same coordinates as this point\n            // move the pointer to the next anchor\n            if(currentAnchor.x === point.x && currentAnchor.y === point.y) {\n                pointer++;\n\n                // this continue assures that there can be at most one\n                // anchor on one position. If the new anchor had the same\n                // coordinates as this one, it will be skipped\n                //\n                // but technically this should never happen because user\n                // should be not able to click on the wire at this\n                // position if there is already an anchor\n                continue;\n            }\n\n            // if the new anchor has the same coordinates as this point\n            // put it in the place of the pointer (the rest of the array is moved to the right)\n            if(newAnchor.x === point.x && newAnchor.y === point.y) {\n                this.anchors.splice(pointer, 0, newAnchor);\n                break;\n            }\n        }\n\n        // set the anchor class to the current wire state\n        newAnchor.setState(this.state);\n\n        this.parentSVG.appendElement(newAnchor);\n    }\n\n    /**\n     * remove an anchor specified by its position\n     * @param {Object} anchor object with `x` and `y` in grid pixels\n     */\n    removeAnchor(anchor) {\n        const {x, y} = anchor;\n        let $el = anchor.svgObj.$el;\n\n        // remove the anchor from the array\n        this.anchors = this.anchors.filter(anchor => {\n            return anchor.x !== x || anchor.y !== y\n        })\n\n        // remove the anchor from the SVG\n        $el.remove();\n\n        // reroute the wire\n        this.routeWire();\n    }\n\n    anchorMoved() {\n        this.temporaryWire();\n    }\n\n    anchorDropped() {\n        this.routeWire();\n    }\n\n    /**\n     * Callback for a mousedown, that adds a new anchor on the place that user clicked on.\n     * @param  {jQuery.MouseEvent} event the mousedown event\n     */\n    onMouseDown(event) {\n        // only left click counts\n        if(event.which===1) {\n            // convert pixels in the event from CSS pixels to SVG pixels relative to the SVG document\n            event = this.parentSVG.viewbox.transformEvent(event);\n\n            let click = {\n                x: event.pageX,\n                y: event.pageY\n            }\n\n            for(const key in click) {\n                if(click.hasOwnProperty(key)) {\n                    click[key] = this.parentSVG.snapToGrid(click[key]);\n                    click[key] = this.parentSVG.SVGToGrid(click[key]);\n                }\n            }\n\n            // add an anchor on this position\n            this.addAnchor(click);\n        }\n    }\n}\n","import NetworkElement from './NetworkElement';\nimport Transform from './Transform'\nimport stateClasses from './stateClasses';\n\nimport {Rectangle} from '../svgObjects'\n// import Logic from '../Logic'\n\n// import stateClasses from './stateClasses'\n\n/** @module editorElements.WireAnchor */\n\n/**\n * parent class for input and output connectors\n * @extends NetworkElement\n */\nexport default class WireAnchor extends NetworkElement {\n    /**\n     * @param {Canvas} parentSVG link to the {@link Canvas} instance that this connector will belong to\n     * @param {number} gridSize  size of the grid in SVG pixels\n     * @param {number} x      horizontal position defined in grid pixels\n     * @param {number} y       vertical position defined in grid pixels\n     */\n    constructor(parentWire, x, y) {\n        super(parentWire.parentSVG);\n\n        this.parentWire = parentWire;\n\n        this.x = x;\n        this.y = y;\n\n        this.anchorSize = 10;\n        this.anchorCenter = this.anchorSize / 2;\n\n        this.svgPosition = {\n            x: this.parentSVG.gridToSVG(x),\n            y: this.parentSVG.gridToSVG(y)\n        }\n\n        this.svgObj = new Rectangle(\n            0,\n            0,\n            this.anchorSize,\n            this.anchorSize,\n            \"none\",\n            \"black\"\n        );\n\n        // move to the correct position\n        this.move(this.svgPosition.x, this.svgPosition.y);\n\n        // rotate the anchor by 45 degrees\n        let transform = new Transform(this.svgObj.getAttr(\"transform\"));\n        transform.setRotate(\n            45,\n            this.anchorCenter,\n            this.anchorCenter\n        );\n        this.svgObj.addAttr({transform: transform.get()});\n\n        this.svgObj.$el.addClass(\"wireAnchor\");\n\n        this.mouseEvent;\n    }\n\n    move(x, y) {\n        let transform = new Transform(this.svgObj.getAttr(\"transform\"));\n        transform.setTranslate(x - this.anchorCenter, y - this.anchorCenter)\n        this.svgObj.addAttr({transform: transform.get()})\n\n        this.svgPosition = { x, y }\n\n        this.x = this.parentSVG.SVGToGrid(this.parentSVG.snapToGrid(x));\n        this.y = this.parentSVG.SVGToGrid(this.parentSVG.snapToGrid(y));\n    }\n\n    setState(state) {\n        this.svgObj.removeClasses(...stateClasses);\n        this.svgObj.addClass(stateClasses[state]);\n    }\n\n    get() {\n        return this.svgObj.$el;\n    }\n\n    onMouseDown() {\n        this.mouseEvent = {\n            moved:false\n        }\n    }\n\n    onMouseMove(event) {\n        this.mouseEvent.moved = true;\n\n        event = this.parentSVG.viewbox.transformEvent(event);\n\n        this.move(event.pageX, event.pageY)\n\n        this.parentWire.anchorMoved()\n    }\n\n    onMouseUp(event) {\n        if(this.mouseEvent.moved) {\n            event = this.parentSVG.viewbox.transformEvent(event);\n\n            const x = this.parentSVG.snapToGrid(event.pageX)\n            const y = this.parentSVG.snapToGrid(event.pageY)\n\n            this.move(x, y);\n\n            this.parentWire.anchorDropped()\n        } else {\n            // it was a click -- delete this anchor\n            this.parentWire.removeAnchor(this);\n        }\n\n        this.mouseEvent = undefined;\n    }\n}\n","/**\n * Create a generator that travels between specified points returning each visited point\n * @param  {Array}    points array of points represented by an object: `{x, y}`, subsequent points must have one equal\n *                           coordinate (so the traveller can travel either vertically or horizontally)\n * @return {Generator}       generator that travels between specified points returning each visited point\n */\nexport default function* (points) {\n    let prevPoint;\n\n    for (const {x, y} of points) {\n\n        if (prevPoint === undefined) {\n            // if the prevPoint is undefined, add the first point\n            // yield ({x, y});\n        } else {\n            // else add all the point between the prevPoint (excluded) and point (included)\n\n            if (prevPoint.x === x) {\n                // if the line is horizontal\n                let from = Math.min(prevPoint.y, y);\n                let to = Math.max(prevPoint.y, y);\n\n                while (from <= to) {\n                    yield({x: x, y: from});\n                    from++;\n                }\n            } else if (prevPoint.y === y) {\n                // if the line is vertical\n                let from = Math.min(prevPoint.x, x);\n                let to = Math.max(prevPoint.x, x);\n\n                while (from <= to) {\n                    yield({x: from, y: y});\n                    from++;\n                }\n            } else {\n                // line is neither horizontal nor vertical, throw an error for better future debugging\n                // console.error(\"getInconvenientNodes: line between two points is neither horizontal nor vertical\");\n            }\n        }\n\n        // set new prevPoint\n        prevPoint = {\n            x,\n            y\n        };\n    }\n}\n","import Logic from '../Logic'\n\n/**\n * mapping of logical states to css classes\n * @type {Object}\n */\n\nlet map = []; // array so we can use the ...spread operator\n\nmap[Logic.state.on] = \"stateOn\"\nmap[Logic.state.off] = \"stateOff\"\nmap[Logic.state.unknown] = \"stateUnknown\"\nmap[Logic.state.oscillating] = \"stateOscillating\"\n\nexport default map;\n","import { manhattanDistance } from './other/helperFunctions'\nimport MapWithDefaultValue from './other/mapWithDefaultValue'\n\nimport { PriorityQueue } from 'libstl'; // note: imported from a node module\n\n/** @module findPath */\n\n/**\n * Heavily modified implementation of the A* algorithm\n * @param  {Object} start object containing numeric attributes `x` and `y` that represent the first endpoint of the wire in grid pixels\n * @param  {Object} end   object containing numeric attributes `x` and `y` that represent the second endpoint of the wire in grid pixels\n * @param  {Set} nonRoutable set of non routable nodes\n * @param  {Set} punishedButRoutable set of nodes that are not optimal for routing\n * @return {Array} array of objects containing numeric attributes `x` and `y`\n */\nexport default function findPath(start, end, nonRoutable, punishedButRoutable) {\n    const distanceFunction = manhattanDistance;\n\n    const wireCrossPunishment = 1;\n    const wireBendPunishment = 1;\n\n    // number of nodes, that can be opened at once\n    // once is this limit exceeded, aStar will fail and return undefined\n    const maxNodeLimit = 100000;\n\n    let closedNodes = new Set();\n    let openNodes = new Set();\n    let openNodeQueue = new PriorityQueue();\n\n    // functions for working with open nodes:\n\n    /**\n     * add a new open node to the structure\n     * @param {Object} node   object containing numeric attributes `x` and `y` that represent the first endpoint of the wire\n     * @param {number} fscore fScore of this node\n     */\n    const addOpenNode = (node, fscore) => {\n        openNodes.add(node);\n        // flip the fscore, because PriorityQueue uses max heap\n        openNodeQueue.enqueue(node, 1 / fscore);\n    }\n\n    /**\n     * get the open node with the lowest fScore and remove it\n     * @return {Object} object containing numeric attributes `x` and `y` that represent the first endpoint of the wire\n     */\n    const getOpenNode = () => {\n        const node = openNodeQueue.dequeue();\n        openNodes.delete(node);\n        return node;\n    }\n\n    let cameFrom = new Map();\n\n    // default value: infinity\n    let gScore = new MapWithDefaultValue(Infinity);\n    gScore.set(start, 0);\n\n    let startFScore = distanceFunction(start, end);\n\n    addOpenNode(start, startFScore);\n\n    openNodes.add(start);\n    openNodeQueue.enqueue(start, 1 / startFScore);\n\n    while (openNodes.size > 0) {\n        // get the value from openNodes that has the lowest fScore\n        const currentNode = getOpenNode();\n\n        // if we reached the end point, reconstruct the path and return it\n        if (currentNode.x == end.x && currentNode.y == end.y) {\n            return reconstructPath(cameFrom, currentNode);\n        }\n\n        // add this node to the closed nodes\n        closedNodes.add(currentNode);\n\n        // the farthest points accessible without avoiding obstacles in every direction\n        // (but max 50 in each direction)\n        for (let direction = 0; direction < 4; direction++) {\n            let newPoint = movePoint(currentNode, direction);\n\n            let wiresCrossed = 0;\n\n            for (let i = 0; i < 50; i++) {\n                // if newPoint is in the set of non routable points,\n                // don't add it and stop proceeding in this direction\n                if (setHasThisPoint(nonRoutable, newPoint)) {\n                    // if this not the end or start point, break\n                    if (!(newPoint.x === end.x && newPoint.y === end.y) &&\n                        !(newPoint.x === start.x && newPoint.y === start.y)) {\n                            break;\n                    }\n                }\n\n                // skip this node, if it has been already closed\n                // or if it is on the list of non routable nodes\n                if (closedNodes.has(newPoint)) {\n                    continue;\n                }\n\n                // calculate possible GScore by applying a punishment for each node (\"bend\") in the path\n                let newGScore = wireBendPunishment + gScore.getWithDefault(currentNode);\n\n                if (setHasThisPoint(punishedButRoutable, newPoint)) {\n                    // if the node is in the set of punished nodes, apply the punishment\n                    wiresCrossed++;\n                }\n\n                // apply the punishment for each wire crossed in this direction\n                // note: we are counting the wires crossed when exporting this direction, not the wires\n                // crossed in the final path, there will be probably only at most of these nodes in the\n                // final path, not multiple\n                newGScore += wiresCrossed * wireCrossPunishment;\n\n                // skip this node if it has worst estimage gscore than in the gscore table\n                if (newGScore >= gScore.getWithDefault(newPoint)) {\n                    continue;\n                }\n\n                cameFrom.set(newPoint, currentNode);\n                gScore.set(newPoint, newGScore);\n\n                const newFScore = newGScore + distanceFunction(newPoint, end);\n\n                if (!openNodes.has(newPoint)) {\n                    // add the point to the list of points\n                    addOpenNode(newPoint, newFScore);\n                }\n\n                // move to the next point in the direciton\n                newPoint = movePoint(newPoint, direction);\n            }\n        }\n\n        if (openNodes.size > maxNodeLimit) {\n            console.log(`aStar: Number of open nodes (${openNodes.size}) exceeded the limit for open nodes (${maxNodeLimit}).`)\n            break;\n        }\n    }\n    // if we got here, the path was not found\n\n    return undefined;\n}\n\n/**\n * returns `true` if the specified set of points contains the specified point (and returns `false` otherwise)\n * @param {Set} set set of points\n * @param {Object} point object containing numeric attributes `x` and `y`\n */\nfunction setHasThisPoint(set, point) {\n    for (let item of set) {\n        if (item.x === point.x && item.y === point.y) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Helper that moves the passed point in the specified direction. It simply adds or subtracts 1 from one of the coordinates depending on the direction attribute.\n * @param  {Object} point     object containing numeric attributes `x` and `y`\n * @param  {number} direction directions:\n *     - 0: up\n *     - 1: right\n *     - 2: down\n *     - 3: left\n * @return {Object}           object containing numeric attributes `x` and `y`\n */\nfunction movePoint({x, y}, direction) {\n    // map direction do point coordinate modification\n    const dirMap = {\n        0: () => {\n            y -= 1\n        },\n        1: () => {\n            x += 1\n        },\n        2: () => {\n            y += 1\n        },\n        3: () => {\n            x -= 1\n        }\n    }\n\n    dirMap[direction]();\n\n    return {x, y}\n}\n\n/**\n * helper backtracking function used by the aStar algorithm to construct the final path\n * @param  {Object} cameFrom    object containing numeric attributes `x` and `y`\n * @param  {Object} currentNode object containing numeric attributes `x` and `y`\n * @return {Array} array of objects containing numeric attributes `x` and `y`\n */\nfunction reconstructPath(cameFrom, currentNode) {\n    let path = [];\n\n    path.push({\n        x: currentNode.x,\n        y: currentNode.y\n    })\n\n    while (cameFrom.has(currentNode)) {\n        currentNode = cameFrom.get(currentNode);\n        // push the point on the beginning of the array instead of the end\n        path.splice(0, 0, {\n            x: currentNode.x,\n            y: currentNode.y\n        })\n    }\n\n    return path;\n}\n","/**\n * @module HelperFunctions\n */\n\nimport stringify from \"json-stringify-pretty-compact\"; // note: imported from a module\n\n/**\n * add a cross browser event listener on a mouse scroll\n * @param {string} query DOM query of the element that the listener will be added to\n * @param {Function} func  Function that will be called when the event occurs. The function takes as a parameter an event object.\n */\nexport function addMouseScrollEventListener(query, func) {\n    let MouseWheelHandler = event => {\n        // redeclare for old IE support\n        var event = window.event || event; // eslint-disable-line no-redeclare\n\n        event.delta = Math.max(-1, Math.min(1, (event.wheelDelta || -event.detail)));\n\n        func(event)\n\n        return false;\n    }\n\n    let svgelement;\n\n    // if the query is a simple DOM id selector, we can use getElementById which has better backwards compatibility\n    if(query.match(/^#\\w+$/)) {\n        svgelement = document.getElementById(query.substr(1))\n    } else {\n        svgelement = document.querySelector(query)\n    }\n\n    if (svgelement.addEventListener) {\n        // IE9, Chrome, Safari, Opera\n        svgelement.addEventListener(\"mousewheel\", MouseWheelHandler, false);\n        // Firefox\n        svgelement.addEventListener(\"DOMMouseScroll\", MouseWheelHandler, false);\n    } else  {\n        // IE 6/7/8\n        svgelement.attachEvent(\"onmousewheel\", MouseWheelHandler);\n    }\n    svgelement.addEventListener('mousewheel', function(e) {\n        console.log('event', e)\n    }, false)\n}\n\n/**\n * convert a data object to JSON string or to a data URI containing a JSON string\n * @param  {Object}  data            object that will be serialized into a JSON string\n * @param  {Boolean} [pretty=false]  if `true`, the code will be proprerly indented, else a more compact syntax will be used\n * @param  {Boolean} [dataUri=false] return dataUri containing the JSON string instead of the pure JSON string\n * @return {string}\n */\nexport function getJSONString(data, pretty = false, dataUri = false) {\n    if(dataUri) {\n        return 'data:application/json;charset=utf-8,'\n            + encodeURIComponent(getJSONString(data, pretty));\n    } else {\n        if (pretty)\n            return stringify(data, {maxLength: 50});\n\n        return JSON.stringify(data);\n    }\n}\n\n/**\n * returns the Manhattan distance between the points _a_ and _b_\n * @param  {Object} a object containing numeric attributes `x` and `y`\n * @param  {Object} b object containing numeric attributes `x` and `y`\n * @return {number}\n */\nexport function manhattanDistance(a, b) {\n    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\n}\n","/** @module Id */\n\n/**\n * the current instance of Id\n * @type {Id}\n */\nlet existingIdInstance;\n\n/**\n * singleton to generate unique id's\n *\n * usage: `let id = new Id().unique`\n */\nexport default class Id {\n    constructor() {\n        if(!existingIdInstance){\n            existingIdInstance = this;\n        }\n\n        /**\n         * prefix for the id, that is common in all the Ids\n         * @type {String}\n         */\n        this.prefix = \"id\";\n\n        /**\n         * numeric part of the next id (the next id without the prefix)\n         * @type {number}\n         */\n        this.nextId = 0;\n\n        return existingIdInstance;\n    }\n\n    /**\n     * get unique ID\n     * @return {string} new unique ID\n     */\n    get unique() {\n        let retVal = this.prefix + this.nextId;\n\n        // find next unused idXXXX to prevent id collision that might be caused by some other component\n        // (it really should not happen, but this is a simple way to ensure it)\n        while($(\"#\"+retVal).length) {\n            this.nextId++;\n            retVal = this.generate();\n        }\n        // return this id\n        this.nextId++;\n\n        return retVal;\n    }\n}\n","/** @module MapWithDefaultValue */\n/**\n * Map that has a default value specified in the constructor.\n *\n * For the complete documentation of the Map see [Map in the MDN web docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\n *\n * Usage:\n * ```JavaScript\n let myMap = new MapWithDefaultValue(Infinity);\n const value = myMap.getWithDefault(key)\n ```\n *\n * _Note: This version is written specially for ES6 compiled into ES5. In non-compiled ES6 is the implementation far more elegant:_\n *\n * ```JavaScript\n export class MapWithDefaultValue extends Map {\n     constructor(defaultValue) {\n         super();\n\n         this.default = defaultValue;\n     }\n\n     get(key) {\n         if(this.has(key)) {\n             return super.get(key);\n         } else {\n             return this.default;\n         }\n     }\n }```\n * @class MapWithDefaultValue\n * @param defaultValue {any} default value that will be returned when the requested key is not found in the map\n */\nexport default function(defaultValue) {\n    let map = new Map();\n    /**\n     * @param  {any} key key of a requested item\n     * @return {any} value of the item with the corresponding key, or defaultValue if the key is not found in the map\n     */\n    map.getWithDefault = (key) => {\n        return map.has(key)\n            ? map.get(key)\n            : defaultValue;\n    }\n    return map;\n}\n","/** @module svgObjects */\n\n// non-svg classes used as helpers\nexport { default as PolyLinePoint } from './svgObjects/PolyLinePoint'\nexport { default as PolyLinePoints } from './svgObjects/PolyLinePoints'\n\n// virtual svg elements\nexport { default as Pattern } from './svgObjects/Pattern'\nexport { default as Group } from './svgObjects/Group'\n\n// \"physical/touchable\" svg elements\nexport { default as Rectangle } from './svgObjects/Rectangle'\nexport { default as SvgImage } from './svgObjects/SvgImage'\nexport { default as PolyLine } from './svgObjects/PolyLine'\n\nexport { default as Text } from './svgObjects/Text'\nexport { default as MultiLineText } from './svgObjects/MultiLineText'\n","import Tag from './Tag'\n\n/** @module svgObjects.Group */\n\n/**\n * SVG group, used for grouping elements, for example a gate is represented by many elements (rectangle, image, inivisible hitbox rectangle...),\n * but all of the elements need to be transformed together. Using groups the transform property can be set on the group which contains all the elements.\n * @extends Tag\n */\nexport default class Group extends Tag {\n    constructor() {\n        super(\"g\");\n\n        this.children = [];\n    }\n\n    /**\n     * add an element to the group\n     * @param {SvgElement} el an instance of {@link SvgElement}\n     */\n    addChild(el) {\n        this.children.push(el);\n\n        this.$el.append(el.$el);\n        return el; // pro jednodussi \"let rect = g.addChild(new Rectangle(...\"\n    }\n}\n","import Tag from './Tag'\nimport Text from './Text'\n\n/** @module svgObjects.MultiLineText */\n\n/**\n * Multi line text element in SVG\n *\n * Multi line text is not natively supportend in SVG 1.1,\n * the workaround is to use the <foreignObject> element and display\n * a HTML paragraph inside of the SVG document.\n *\n * Because this technique is not supported by all of the browsers,\n * the foreignObject element is wrapped in <switch>, which\n * provides fallback for those cases.\n *\n * read more: [foreignObject on MDN web docs](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/foreignObject)\n *\n * @extends Tag\n */\nexport default class MultiLineText extends Tag {\n    /**\n     * @param {number} x       horizontal position in SVG pixels\n     * @param {number} y       vertical position in SVG pixels\n     * @param {number} w       width of the text box in SVG pixels\n     * @param {number} h       height of the text box in SVG pixels\n     * @param {number} text    text content of the text box\n     * @param {string} size    CSS font size of the text\n     * @param {String} [color=\"black\"] color of the text\n     *\n     */\n    constructor(x, y, w, h, text, size, color = \"black\") {\n        super(\"switch\");\n\n        let foreignObject = new Tag(\"foreignObject\");\n        let alternativeText = new Text(x, y, w, h, text, size, color);\n\n        foreignObject.addAttr({\n            x,\n            y,\n            width: w,\n            height: h\n        });\n\n        let $wrapper = $(\"<div>\")\n            .attr(\"xmlns\", \"http://www.w3.org/1999/xhtml\")\n            .addClass(\"multilinetext\")\n            .css(\"height\", h);\n\n        let $paragraph = $(\"<p>\")\n            .attr(\"xmlns\", \"http://www.w3.org/1999/xhtml\")\n            .css(\"font-size\", size)\n            .append(text);\n\n        $wrapper.append($paragraph);\n        foreignObject.$el.append($wrapper)\n\n        this.$el.append(\n            foreignObject.$el\n        ).append(\n            alternativeText.$el\n        )\n    }\n}\n","import Tag from './Tag'\n\n/** @module svgObjects.Pattern */\n\n/**\n * pattern object in SVG\n * @extends Tag\n */\nexport default class Pattern extends Tag {\n    /**\n     * @param {string} id     unique id of this pattern\n     * @param {number} width  width of one pattern tile in SVG pixels\n     * @param {number} height height of one pattern tile in SVG pixels\n     */\n    constructor(id, width, height) {\n        super(\"pattern\");\n\n        this.addAttr({\n            id: id,\n            x: 0,\n            y: 0,\n            width: width,\n            height: height,\n            patternUnits: \"userSpaceOnUse\",\n            viewBox: \"0 0 \"+width+\" \"+height\n        });\n    }\n\n    /**\n     * add a child to this pattern\n     *\n     * pattern behaves a little like {@link Group} - it contains child elements, which represent the content of one tile of the pattern\n     * and the whole package of the child elements is repeated on each tile of the pattern\n     * @param {SvgElement} el element that will be added to the pattern\n     */\n    addChild(el) {\n        this.$el.append(el.$el);\n        return el;\n    }\n}\n","import Tag from './Tag'\n\n/** @module svgObjects.PolyLine */\n\n/**\n * SVG PolyLine (a path defined by sequence of points on plane)\n * @extends Tag\n */\nexport default class PolyLine extends Tag {\n    /**\n     * @param {PolyLinePoints} points points describing this PolyLine\n     * @param {number} [strokeWidth] width of the stroke for this PolyLine in SVG pixels\n     * @param {string} [color] CSS color of this PolyLine\n     */\n    constructor(points, strokeWidth, color) {\n        super(\"PolyLine\");\n\n        let attributes = {\n            points: points.string,\n            fill: \"none\",\n            \"stroke-width\": strokeWidth\n        };\n\n        if(color!==undefined) {\n            attributes.stroke = color\n        }\n\n        this.addAttr(attributes);\n    }\n\n    /**\n     * update points of this PolyLine\n     * @param {PolyLinePoints} points new set of points describing this PolyLine\n     */\n    updatePoints(points) {\n        this.addAttr({\n            points: points.string\n        });\n    }\n}\n","/** @module svgObjects.PolyLinePoint */\n\n/**\n * one point of {@link PolyLinePoints}, used in the {@link PolyLine} object\n */\nexport default class PolyLinePoint {\n    /**\n     * @param {number} x horizontal coordinate of the PolyLine point\n     * @param {number} y vertical coordinate of the PolyLine point\n     */\n    constructor(x, y) {\n        this.x = 0;\n        this.y = 0;\n        if(x !== undefined && y !== undefined) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    /**\n     * change the coordinates of this point\n     * @param {number} x horizontal coordinate of the PolyLine point\n     * @param {number} y vertical coordinate of the PolyLine point\n     */\n    set(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * create PolyLine from a comma separated string (e.g. from a string formatted like this: \"x,y\", for example \"15,8\")\n     * @param  {string} string string in the format \"x,y\" representing a point in the SVG PolyLine\n     * @return {PolyLinePoint} newly created instance of {@link PolyLinePoint}\n     */\n    static parseFromString(string) {\n        let arr = string.split(\",\");\n        return new PolyLinePoint(arr[0], arr[1]);\n    }\n\n    /**\n     * return a string representation of this PolyLine point\n     * @return {string} string in the format \"x,y\"\n     */\n    get string() {\n        return this.x + \",\" + this.y;\n    }\n\n    /**\n     * compare PolyLine points, return `true` if they are equal, else return `false`\n     * @param  {PolyLinePoint} a\n     * @param  {PolyLinePoint} b\n     * @return {boolean}\n     */\n    static equals(a, b) {\n        return a.x === b.x && a.y === b.y;\n    }\n}\n","import PolyLinePoint from './PolyLinePoint'\n\n/** @module svgObjects.PolyLinePoints */\n\n/**\n * array-like structure used in {@link PolyLinePoints}\n */\nclass SmartArray {\n    /**\n     * @param {Array} [arr] if set, initialized SmartArray will contain these values\n     */\n    constructor(arr) {\n        if(arr !== undefined) {\n            this.arr = arr;\n        } else {\n            this.arr = [];\n        }\n    }\n\n    /**\n     * get a deep copy of this array\n     * @return {SmartArray}\n     */\n    copy() {\n        return SmartArray($.extend(true, [], this.arr));\n    }\n\n    /**\n     * append an item to the array\n     * @param item new item that will be appended to the array\n     */\n    append(item) {\n        return this.addWithIndex(item, this.arr.length);\n    }\n\n    /**\n     * prepend an item to the array\n     * @param item new item that will be prepended to the array\n     */\n    prepend(item) {\n        return this.addWithIndex(item, 0);\n    }\n\n    /**\n     * add a new item at the specified index, move all following items\n     * @param item new item that will be added at the specified index\n     * @param {number} index index of this item\n     */\n    addWithIndex(item, index) {\n        for(let i = this.arr.length ; i > index ; --i) {\n            this.arr[i] = this.arr[i-1];\n        }\n        this.arr[index] = item;\n        return this; // to enable chaining of append / preppend / addWithIndex commands\n    }\n\n    /**\n     * get length of the array\n     * @return {number}\n     */\n    get length() {\n        return this.arr.length;\n    }\n\n    /**\n     * get item by index\n     * @param  {number} index index of the item\n     * @return contents of the array on the specified index\n     */\n    getItem(index) {\n        return this.arr[index];\n    }\n\n    /**\n     * @return last element of the array\n     */\n    get last() {\n        if(this.length!==0) {\n            return this.arr[this.length - 1];\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @return first element of the array\n     */\n    get first() {\n        if(this.length!==0) {\n            return this.arr[0];\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * remove an item from the array by index\n     * @param  {number} index index of the item that will be removed\n     */\n    remove(index) {\n        let length = this.length;\n\n        for(let i = index ; i < length ; ++i) {\n            this.arr[i] = this.arr[i + 1];\n        }\n        this.arr.pop();\n    }\n\n    /**\n     * make the array iterable\n     * @type {Number}\n     */\n    [Symbol.iterator]() {\n        let index = -1;\n        let data = this.arr;\n\n        return {\n            next: () => ({\n                value: data[++index],\n                done: !(index in data)\n            })\n        };\n    }\n\n    map(func) {\n        return this.arr.map(func);\n    }\n}\n\n/**\n * points of the {@link PolyLine}\n * @extends SmartArray\n */\nexport default class PolyLinePoints extends SmartArray {\n    /**\n     * @param {Array} [arr] array containing instances of {@link PolyLinePoint}\n     */\n    constructor(arr) {\n        super(arr);\n    }\n\n    /**\n     * get a deep copy of this object\n     * @return {PolyLinePoints}\n     */\n    copy() {\n        return new PolyLinePoints($.extend(true, [], this.arr));\n    }\n\n    /**\n     * append a point\n     * @param  {PolyLinePoint} point a new point\n     */\n    append(point) {\n        // call inherited function to handle the appending\n        super.append(point);\n\n        // if the second to last point is unnecessary, remove it\n        let length = this.length;\n        if ( length >= 3\n                && (    ( this.getItem(length - 3).x === this.getItem(length - 2).x &&\n                          this.getItem(length - 2).x === this.getItem(length - 1).x )\n                     || ( this.getItem(length - 3).y === this.getItem(length - 2).y &&\n                          this.getItem(length - 2).y === this.getItem(length - 1).y )\n                   )\n           )\n        {\n            this.remove(length - 2);\n        }\n\n        // return this element (to allow chaining)\n        return this;\n    }\n\n    /**\n     * parse PolyLine from string\n     * @param  {string} string string in the PolyLine format (`x1,y1 x2,y2, x3,y3`)\n     * @return {PolyLinePoints} a new instance of {@link PolyLinePoints} created by parsing the string\n     */\n    static parseFromString(string) {\n        let pointStrings = string.split(\" \");\n        let points = new PolyLinePoints();\n\n        for(let i = 0 ; i < pointStrings.length ; ++i) {\n            points.append(PolyLinePoint.parseFromString(pointStrings[i]));\n        }\n\n        return points;\n    }\n\n    /**\n     * get a string representation of this PolyLine\n     * @return {string} string in the PolyLine format (`x1,y1 x2,y2, x3,y3`)\n     */\n    get string() {\n        let string = \"\";\n        for(let i = 0 ; i < this.length ; ++i) {\n            if(i !== 0) {\n                string += \" \";\n            }\n            string += this.arr[i].string;\n        }\n        return string;\n    }\n\n    /**\n     * wrapper for foreach on the PolyLine points\n     * @param  {Function} func function that will be called on each element\n     */\n    forEach(func) {\n        for(let i = 0 ; i < this.arr.length ; ++i) {\n            func(this.arr[i]);\n        }\n    }\n}\n","import SvgElement from './SvgElement'\n\n/** @module svgObjects.Rectangle */\n\n/**\n * a rectangle in SVG\n * @extends SvgElement\n */\nexport default class Rectangle extends SvgElement {\n    /**\n     * @param {number} x       horizontal position in SVG pixels\n     * @param {number} y       vertical position in SVG pixels\n     * @param {number} w       width in SVG pixels\n     * @param {number} h       height in SVG pixels\n     * @param {string} fill    filling color of the rectangle\n     * @param {string} stroke  stroke color of the rectangle\n     */\n    constructor(x, y, w, h, fill, stroke) {\n        super(x, y, w, h, \"rect\");\n        this.addAttr({\n            fill: fill,\n            stroke: stroke,\n            'stroke-width': 0.5,\n            'pointer-events': 'all' // to trigger hover even with transparent background\n        });\n    }\n}\n","import Tag from './Tag'\n\n/** @module svgObjects.SvgElement */\n\n/**\n * represents visible element in SVG that has position and dimensions (for example `rectangle` is a SvgElement, but `pattern` is not, even though both are tags)\n * @extends Tag\n */\nexport default class SvgElement extends Tag {\n    /**\n     * @param {number} x       horizontal position in SVG pixels\n     * @param {number} y       vertical position in SVG pixels\n     * @param {number} w       width in SVG pixels\n     * @param {number} h       height in SVG pixels\n     * @param {string} tagName tag name of the element\n     */\n    constructor(x, y, w, h, tagName) {\n        super(tagName);\n\n        this.addAttr({\n            x: x,\n            y: y,\n            width: w,\n            height: h\n        });\n    }\n}\n","import SvgElement from './SvgElement'\n\n/** @module svgObjects.SvgImage */\n\n/**\n * an image in SVG\n * @extends SvgElement\n */\nexport default class SvgImage extends SvgElement {\n    constructor(x, y, w, h, url) {\n        super(x, y, w, h, \"image\");\n        this.addAttr({\n            \"xlink:href\": url\n        });\n    }\n\n    /**\n     * change url of the image\n     * @param {string} url the new url of the image\n     */\n    changeUrl(url) {\n        this.addAttr({\n            \"xlink:href\": url\n        });\n    }\n}\n","import Id from '../other/id'\n\n/** @module svgObjects.Tag */\n\n/**\n * Parent class for all svgObjects\n */\nexport default class Tag {\n    /**\n     * @param {string} tagName SVG tag identifier (`rect`, `image`, `PolyLine`)\n     */\n    constructor(tagName) {\n        /**\n         * SVG tag identifier (`rect`, `image`, `PolyLine`)\n         * @type {string}\n         */\n        this.tagName = tagName;\n\n        /**\n         * jQuery element for this tag\n         * @type {jQuery.element}\n         */\n        this.$el = $(\"<\"+this.tagName+\">\");\n\n        /**\n         * unique ID of this SVG object\n         * @type {string}\n         */\n        this.id = new Id().unique;\n    }\n\n    /**\n     * add a class to this element\n     * @param {string} name class name to be added\n     */\n    addClass(name) {\n        this.checkIfElementExistsInDOM();\n\n        this.$el.addClass(name);\n    }\n\n    /**\n     * remove class names from this element\n     * @param  {string} classes class names to be removed\n     */\n    removeClasses(...classes) {\n        this.checkIfElementExistsInDOM();\n\n        for(let item of classes) {\n            this.$el.removeClass(item);\n        }\n    }\n\n    /**\n     * set attributes of this element\n     * @param {Object} assoc javascript object that will be mapped into attributes (`{key: value}` -> `key=\"value\"`)\n     */\n    addAttr(assoc) {\n        this.checkIfElementExistsInDOM();\n\n        // add attributes to the element\n        this.$el.attr(assoc);\n    }\n\n    /**\n     * get attribute value by name\n     * @param  {string} name name of the attribute\n     * @return {string}      value of the attribute\n     */\n    getAttr(name) {\n        this.checkIfElementExistsInDOM();\n\n        return this.$el.attr(name);\n    }\n\n    /**\n     * remove attribute by value\n     * @param  {string} name name of the attribute to be removed\n     */\n    removeAttr(name) {\n        this.checkIfElementExistsInDOM();\n\n        this.$el.removeAttr(name);\n    }\n\n    /**\n     * set id of this SVG object\n     * @param  {string} id new id for this object\n     */\n    set id(id) {\n        this.addAttr({\"id\": id});\n    }\n\n    /**\n     * get id of this SVG object\n     * @return {string}\n     */\n    get id() {\n        return this.getAttr(\"id\");\n    }\n\n    /**\n     * get jQuery element for this SVG object\n     * @return {jQuery.element}\n     */\n    get() {\n        this.checkIfElementExistsInDOM();\n        return this.$el;\n    }\n\n    /**\n     * check if the element exists in dom, if so, refetch it from DOM using jQuery\n     */\n    checkIfElementExistsInDOM() {\n        let $jqElement = $(\"#\"+this.$el.attr('id'));\n        if($jqElement.length) {\n            this.$el = $jqElement;\n        }\n    }\n}\n","import Tag from './Tag'\n\n/** @module svgObjects.Text */\n\n/**\n * Text element in SVG\n * @extends Tag\n */\nexport default class Text extends Tag {\n    /**\n     * @param {number} x       horizontal position in SVG pixels\n     * @param {number} y       vertical position in SVG pixels\n     * @param {number} w       width of the text box in SVG pixels\n     * @param {number} h       height of the text box in SVG pixels\n     * @param {number} text    text content of the text box\n     * @param {string} size    CSS font size of the text\n     * @param {String} [color=\"black\"] color of the text\n     *\n     */\n    constructor(x, y, w, h, text, size, color = \"black\") {\n        super(\"text\");\n        this.addAttr({\n            x: x,\n            y: y,\n            width: w,\n            height: h,\n            fill: color\n        });\n\n        if(size) {\n            this.addAttr({\n                'font-size': size\n            })\n        }\n\n        this.$el.append(text);\n    }\n}\n","import {\n    getLibrary,\n    getNetworkFromLibrary\n} from './networkLibrary';\n\nimport {Gate} from '../editorElements'\n\n/**\n * Item in the [ContextMenu](./module-ContextMenu.html). ContextMenuItems can be nested using the appendItem function.\n */\nclass ContextMenuItem {\n    /**\n     * @param {string} text          text on the button\n     * @param {ContextMenu} contextMenu instance of the [ContextMenu](./module-ContextMenu.html) this item belongs to\n     * @param {Function} clickFunction callback function that will be called when user clicks this item\n     */\n    constructor(text, contextMenu, clickFunction) {\n        /**\n         * text on the button\n         * @type {string}\n         */\n        this.text = text;\n\n        /**\n         * instance of the [ContextMenu](./module-ContextMenu.html) this item belongs to\n         * @type {ContextMenu}\n         */\n        this.contextMenu = contextMenu;\n\n        /**\n         * jQuery element representing DOM content of this menu item\n         * @type {jQuery.element}\n         */\n        this.$el = $(\"<li>\").text(text);\n\n        // set up click callback if clickFunction is defined\n        if(clickFunction!==undefined) {\n            $(this.$el).click(\n                (event) => {\n                    clickFunction();\n                    contextMenu.hide();\n\n                    event.stopPropagation();\n                }\n            );\n        }\n\n        /**\n         * jQuery element containing the submenu (or undefined, if item has no subitems)\n         * @type {jQuery.element}\n         */\n        this.$submenu = undefined\n\n        /**\n         * submenu item counter\n         * @type {Number}\n         */\n        this.itemCount = 0\n\n        // set hover callback\n        $(this.$el).hover((event) => {\n            // mouse on\n\n            if(this.length > 0) {\n                this.$submenu.css({\n                    display: \"block\",\n                    top: this.$el.offset().top,\n                    left: this.$el.parent().offset().left + this.$el.parent().width(),\n                })\n\n                this.contextMenu.$el.after(this.$submenu);\n\n                event.stopPropagation()\n            }\n        }, () => {\n            // mouse out\n            if(this.$submenu) {\n                this.$submenu.css({\n                    display: \"none\"\n                })\n            }\n\n            // do not stop event propagation, here it is wanted\n            // (because submenu overrides display: none when user moves from this menu item to the submenu)\n        })\n    }\n\n    /**\n     * instance of [Canvas](./module-Canvas.html) this menu belongs to\n     * @type {Canvas}\n     */\n    get parentSVG() {\n        return this.contextMenu.parentSVG;\n    }\n\n    /**\n     * number of items in the submenu\n     * @return {Number}\n     */\n    get length() {\n        return this.itemCount;\n    }\n\n    /**\n     * add a CSS class to this item\n     * @param {string} cls [description]\n     */\n    addClass(cls) {\n        this.$el.addClass(cls);\n        return this;\n    }\n\n    /**\n     * append a nested {@link ContextMenuItem} to this item\n     * @param  {ContextMenuItem} item item that will be appended\n     */\n    appendItem(item) {\n        if(!this.$submenu) {\n            this.$submenu = $(\"<ul>\").addClass(\"subList\");\n            this.$submenu.hover(() => {\n                this.$submenu.css(\"display\", \"block\");\n            }, () => {\n                this.$submenu.css(\"display\", \"none\");\n            })\n        }\n        this.$submenu.append(item.$el);\n\n        this.itemCount++;\n\n        return item;\n    }\n\n    /**\n     * get jQuery element of this menu item\n     * @return {jQuery.element} jQuery element containing all DOM content for this menu item\n     */\n    get jQuery() {\n        return this.$el;\n    }\n\n    get jQuerySubmenu() {\n        return this.$submenu;\n    }\n}\n\n/**\n * Menu item that has a custom click callback function that adds a {@link Gate} of the specified type to the [Canvas](./module-Canvas.html)\n * @extends ContextMenuItem\n */\nclass GateMenuItem extends ContextMenuItem {\n    /**\n     * @param {string} type        type of the gate {@link Gate} (and, or, ...)\n     * @param {ContextMenu} contextMenu instance of the [ContextMenu](./module-ContextMenu.html) that this item belongs to\n     */\n    constructor(type, contextMenu) {\n        super(\n            `${type.toUpperCase()} gate`,\n            contextMenu,\n            () => {\n                this.parentSVG.newGate(\n                    type,\n                    this.parentSVG.snapToGrid(this.parentSVG.viewbox.transformX(contextMenu.position.x)),\n                    this.parentSVG.snapToGrid(this.parentSVG.viewbox.transformY(contextMenu.position.y))\n                );\n            }\n        );\n    }\n}\n\n/**\n * Menu item that has a custom click callback function that adds a specified {@link Blackbox} to the [Canvas](./module-Canvas.html)\n * @extends ContextMenuItem\n */\nclass BlackboxMenuItem extends ContextMenuItem {\n    constructor(name, file, contextMenu) {\n        super(\n            name,\n            contextMenu,\n            () => {\n                getNetworkFromLibrary(file).then(({blackbox, name}) => {\n                    const {inputs, outputs, table} = blackbox;\n\n                    // use the name specified in the blackbox item, if it does not exist, use the name for the network\n                    let usedName = blackbox.name || name;\n\n                    this.parentSVG.newBlackbox(\n                        inputs,\n                        outputs,\n                        table,\n                        usedName,\n                        this.parentSVG.snapToGrid(this.parentSVG.viewbox.transformX(contextMenu.position.x)),\n                        this.parentSVG.snapToGrid(this.parentSVG.viewbox.transformY(contextMenu.position.y))\n                    );\n                }).catch(error => {\n                    console.error(error);\n                })\n            }\n        )\n    }\n}\n\n/**\n * Menu item that has a custom click callback function that adds a specified Network to the [Canvas](./module-Canvas.html)\n * @extends ContextMenuItem\n */\nclass NetworkMenuItem extends ContextMenuItem {\n    constructor(name, file, contextMenu) {\n        super(\n            name,\n            contextMenu,\n            () => {\n                getNetworkFromLibrary(file).then(data => {\n                    this.parentSVG.importData(\n                        data,\n                        Math.round(this.parentSVG.viewbox.transformX(contextMenu.position.x) / this.parentSVG.gridSize),\n                        Math.round(this.parentSVG.viewbox.transformY(contextMenu.position.y) / this.parentSVG.gridSize)\n                    ).then(warnings => {\n                        for (const warning of warnings) {\n                            this.parentSVG.messages.newWarningMessage(warning)\n                        }\n                    })\n                }).catch(error => {\n                    this.parentSVG.messages.newErrorMessage(error);\n                })\n            }\n        )\n    }\n}\n\n/** @module ContextMenu */\n/**\n * ContextMenu represents the menu that is displayed to the user when they right click on a canvas.\n * This menu allows user to add elements to the Canvas and in the case that user rightclicked\n * on a specific element, this menu allows them to remove this element.\n */\nexport default class ContextMenu {\n    /**\n     * @param {Canvas} parentSVG instance of [Canvas](./module-Canvas.html) this menu belongs to\n     */\n    constructor(parentSVG) {\n        /**\n         * instance of [Canvas](./module-Canvas.html) this menu belongs to\n         * @type {Canvas}\n         */\n        this.parentSVG = parentSVG;\n\n        /**\n         * Position of the context menu. It is used to add the new elements to the correct position on the Canvas.\n         * @type {Object}\n         */\n        this.position = {\n            x: 0, y: 0\n        };\n\n        /**\n         * jQuery element containing the context menu\n         * @type {jQuery.element}\n         */\n        this.$el = $(\"<ul>\");\n        this.$el.attr('id', 'contextMenu');\n\n        let special = new ContextMenuItem(\"Special elements\", this);\n\n        // add input box\n        special.appendItem(\n            new ContextMenuItem(\"Input box\", this,\n                () => {\n                    let position = {\n                        left: this.parentSVG.snapToGrid(parentSVG.viewbox.transformX(this.position.x)),\n                        top: this.parentSVG.snapToGrid(parentSVG.viewbox.transformY(this.position.y))\n                    };\n\n                    parentSVG.newInput(position.left, position.top);\n                }\n            )\n        );\n\n        // add output box\n        special.appendItem(new ContextMenuItem(\"Output box\", this, () => {\n            let position = {\n                left: this.parentSVG.snapToGrid(parentSVG.viewbox.transformX(this.position.x)),\n                top: this.parentSVG.snapToGrid(parentSVG.viewbox.transformY(this.position.y))\n            };\n\n            parentSVG.newOutput(position.left, position.top);\n        }));\n\n        this.appendItem(special);\n\n        // list of gates that can be added\n        const gates = Gate.validGates;\n        let gateList = new ContextMenuItem(\"New gate\", this, parentSVG);\n        for (const name of gates) {\n            gateList.appendItem(\n                new GateMenuItem(name, this)\n            );\n        }\n        this.appendItem(gateList);\n\n        // more options will be added in the getLibrary() callback below\n        let networkList = new ContextMenuItem(\"Add a network\", this);\n        networkList.appendItem(new ContextMenuItem(\"Paste a network\", this, () => {\n            this.displayImportDialog()\n        }));\n        this.appendItem(networkList); // always append\n\n        let blackboxList = new ContextMenuItem(\"Add a blackbox\", this); // appends only if contains items (see the callback)\n\n        // network import (blackbox, network)\n        getLibrary().then(networks => {\n\n            for (const {name, file, hasTable, hasNetwork} of networks) {\n                // add a network as a blackbox\n                if(hasTable) {\n                    blackboxList.appendItem(\n                        new BlackboxMenuItem(name, file, this)\n                    );\n                }\n\n                // load a network as a network of components connected with wires\n                if(hasNetwork) {\n                    networkList.appendItem(\n                        new NetworkMenuItem(name, file, this)\n                    );\n                }\n            }\n\n            if(blackboxList.length > 0) {\n                this.appendItem(blackboxList);\n            }\n        }).catch(error => {\n            console.error(error);\n        })\n\n        // add conditional items for box and wire removal\n        this.appendConditionalItem('box', 'Remove this item', id => {this.parentSVG.removeBox(id)});\n        this.appendConditionalItem('wire', 'Remove this wire', id => {this.parentSVG.removeWireById(id)});\n\n        // add the context menu to the DOM\n        parentSVG.$svg.before(this.$el);\n\n        /**\n         * Number of items in this menu (used in the .lenght getter). Conditional items do not count.\n         * @type {Number}\n         */\n        this.itemCount = 0;\n    }\n\n    get length() {\n        return this.itemCount;\n    }\n\n    /**\n     * append a context menu item to the context menu\n     * @param  {ContextMenuItem} item instance of {@link ContextMenuItem} that will be added to this menu\n     */\n    appendItem(item) {\n        this.$el.append(item.jQuery);\n\n        this.itemCount++;\n\n        return item;\n    }\n\n    /**\n     * appends an connditional item (that is shown only if the target has the class itemClass)\n     * @param  {string} itemClass     show the item only if the target has this class\n     * @param  {string} text          text of this menu item\n     * @param  {Function} clickFunction function with one argument (ID of the target) that will be called on click\n     */\n    appendConditionalItem(itemClass, text, clickFunction) {\n        if(!this.conditionalItems) {\n            this.conditionalItems = [];\n        }\n\n        this.conditionalItems[this.conditionalItems.length] = {\n            itemClass: itemClass,\n            text: text,\n            clickFunction: clickFunction\n        }\n    }\n\n    /**\n     * display the dialog for importing a network from a clipboard\n     */\n    displayImportDialog() {\n        let $popup = $(\"<div>\")\n            .addClass(\"importExport\")\n            .addClass(\"import\");\n\n        let textareaId = \"importJSON\";\n        let $textblock = $(\"<textarea>\").attr('id', textareaId);\n\n        let lityInstance;\n\n        $popup.append(\n            $textblock\n        ).append(\n            $(\"<a>\").attr({\n                \"href\": \"#\",\n                \"class\": \"upload\"\n            })\n            .append(\n                $(\"<img>\").attr('src', \"img/gui/import.svg\")\n            )\n            .append(\" import from JSON\")\n            .on('click', () => {\n                let data;\n\n                try {\n                    data = JSON.parse($('#' + textareaId).val());\n                } catch(e) {\n                    this.parentSVG.messages.newErrorMessage(\"The imported file is not a valid JSON file.\");\n                    lityInstance.close();\n                }\n\n                if(data) {\n                    // proccess the imported data\n                    this.parentSVG.importData(\n                        data,\n                        Math.round(this.parentSVG.viewbox.transformX(this.position.x) / this.parentSVG.gridSize),\n                        Math.round(this.parentSVG.viewbox.transformY(this.position.y) / this.parentSVG.gridSize)\n                    ).then(warnings => {\n                        for (const warning of warnings) {\n                            this.parentSVG.messages.newWarningMessage(warning)\n                        }\n                    }).finally(() => {\n                        lityInstance.close();\n                    })\n                }\n            })\n        );\n\n        lityInstance = lity($popup);\n\n        // focus on the textblock\n        $textblock.focus();\n    }\n\n    /**\n     * decide whether or not to display specific conditional items\n     * @param  {jQuery.element} $target jQuery target of a MouseEvent (element that user clicked on)\n     */\n    resolveConditionalItems($target) {\n        for(let item of this.conditionalItems) {\n            if($target.hasClass(item.itemClass)) {\n                this.appendItem(\n                    new ContextMenuItem(\n                        item.text, this,\n                        () => {\n                            item.clickFunction($target.attr('id'));\n                        }\n                    )\n                ).addClass('conditional');\n            }\n        }\n    }\n\n    /**\n     * hide all conditional items\n     */\n    hideAllConditionalItems() {\n        this.$el.children('.conditional').remove();\n    }\n\n    /**\n     * displays the context menu with the right set of conditional items\n     * @param  {number} x       horizontal position of the context menu in CSS pixels\n     * @param  {number} y       vertical position of the context menu in CSS pixels\n     * @param  {jQuery.element} $target jQuery target of a MouseEvent (element that user clicked on)\n     */\n    display(x, y, $target) {\n        this.position = {\n            x: x,\n            y: y\n        };\n\n        this.resolveConditionalItems($target);\n\n        this.$el.css({\n            display: 'block',\n            top: y,\n            left: x\n        })\n        // set the width expicitly, or else the menu will widen when displaying a submenu\n        // 2 is to prevent a weird text wrap bug\n        .css('width', 'auto')\n        .css('width', this.$el.innerWidth() + 2);\n    }\n\n    /**\n     * hide the context menu\n     */\n    hide() {\n        this.$el.css({display: 'none'});\n        $(\".subList\").css({display: 'none'});\n        this.hideAllConditionalItems();\n    }\n}\n","import { getJSONString } from \"../other/helperFunctions\";\n\n/**\n * FloatingButton represents a button that is used in the floating menu in the right bottom corner\n * of the application. It may have a custom tooltip and callback on the click event\n */\nclass FloatingButton {\n    /**\n     * @param {string} buttonClass Custom string that identifies the SVG icon used on this button. This string is also added as a CSS class to the button.\n     * @param {string} tooltip     tooltip for the button, that will be displayed on hover and also used as alternative title for the image\n     * @param {Function} clickEvent  custom callback when user clicks the button\n     * @param {Canvas} parentSVG   reference to the parent SVG element\n     */\n    constructor(buttonClass, tooltip, clickEvent, parentSVG) {\n        /**\n         * jQuery element representing the button\n         * @type {jQuery.element}\n         */\n        this.$el = $('<a>')\n\n        // add classes to the element\n        this.$el.addClass(\"button\");\n        this.$el.addClass(buttonClass);\n\n        // add the icon\n        this.$el.append(\n            $(\"<img>\")\n            .attr(\"src\", `img/gui/${buttonClass}.svg`)\n            .attr(\"alt\", tooltip)\n        );\n\n        // add the tooltip element and an event listener if tooltip is defined\n        if (tooltip) {\n            /**\n             * jQuery element representing the tooltip\n             * @type {jQuery.element}\n             */\n            this.$tooltip = $(\"<div>\");\n            this.$tooltip\n                .addClass(\"tooltip\")\n                .html(tooltip);\n\n            parentSVG.$svg.after(this.$tooltip);\n\n            this.$el.hover(() => {\n                this.$tooltip.fadeIn(200);\n            }, () => {\n                this.$tooltip.fadeOut(200);\n            });\n        }\n\n        // add an event listener on click, if the callback function is defined\n        if (clickEvent) {\n            this.$el.on(\"click\", clickEvent);\n        }\n    }\n}\n\n/** @module FloatingMenu */\n/**\n * Class to represent the floating menu in the right bottom corner of the page.\n * It instantiates all the buttons and their callbacks.\n */\nexport default class FloatingMenu {\n    /**\n     * @param {Canvas} parentSVG reference to the Canvas element this menu is associated with\n     */\n    constructor(parentSVG) {\n        /**\n         * the jQuery element containing all buttons\n         * @type {jQuery.element}\n         */\n        this.$el = $('<div>')\n\n        const id = 'floatingMenu';\n\n        this.$el.attr(\"id\", id);\n\n        // const $loader = $(\"<div>\").addClass(\"loader\").addClass(\"hidden\");\n\n\n        /* EXPORT */\n        this.append(\n            new FloatingButton(\"export\", \"Get code for this network\", () => {\n                // create the popup container holding all popup content (that will be passed to lity)\n                let $popup = $(\"<div>\")\n                    .addClass(\"importExport\")\n                    .addClass(\"export\");\n\n                // generate the block with code to be displayed and append it to the popup element\n                const $textblock = $(\"<textarea>\").text(\n                    getJSONString(parentSVG.exportData, true)\n                )\n\n                $popup.append($textblock);\n\n                // generate the links\n                $popup.append(\n                    $(\"<a>\").attr({\n                        \"href\": getJSONString(parentSVG.exportData, true, true),\n                        \"class\": \"download\",\n                        \"download\": \"network.json\"\n                    }).append(\n                        $(\"<img>\").attr('src', \"img/gui/export.svg\")\n                    ).append(\" expanded JSON\")\n                );\n                $popup.append(\n                    $(\"<a>\").attr({\n                        \"href\": getJSONString(parentSVG.exportData, false, true),\n                        \"class\": \"download\",\n                        \"download\": \"network.min.json\"\n                    }).append(\n                        $(\"<img>\").attr('src', \"img/gui/export.svg\")\n                    ).append(\" compact JSON\")\n                );\n\n                lity($popup);\n\n                // highlight the text in the textblock\n                $textblock.select();\n            }, parentSVG)\n        );\n\n        /* Tutorial */\n        this.append(\n            new FloatingButton(\"tutorial\", \"Start the tutorial\", () => {\n                parentSVG.startTutorial();\n            }, parentSVG)\n        );\n\n        parentSVG.$svg.after(this.$el);\n\n        /* HELP */\n\n        let help = new FloatingButton(\"help\", \"Display a help page\", false, parentSVG);\n        help.$el.attr({\n            'href': './docs/user.html',\n            'data-lity': ''\n        });\n        this.append(help);\n\n        parentSVG.$svg.after(this.$el);\n    }\n\n    /**\n     * append a FloatingButton to this menu\n     * @param  {FloatingButton} menuItem append an instance of  {@link FloatingButton} to this menu\n     */\n    append(menuItem) {\n        this.$el.append(menuItem.$el);\n    }\n}\n","/** @module Messages */\n\n/**\n * a generic message that can be displayed in the {@link Messages} box\n */\nclass Message {\n    /**\n     * @param {string} text               text of the message\n     * @param {Function} [onHide] a function that will be called when the `hide()` method is called\n     */\n    constructor(text, onHide) {\n        this.$el = $(\"<div>\").addClass(\"message\").text(text);\n\n        /**\n         * callback function that will be called when the `hide()` method is called\n         * @type {Function}\n         */\n        this.onHide = onHide;\n    }\n\n    /**\n     * hide the message (and call the onHide callback if there is any)\n     */\n    hide() {\n        this.$el.remove();\n\n        if(this.onHide) {\n            this.onHide();\n        }\n    }\n}\n\n/**\n * a loading message that can be displayed in the {@link Messages} box\n * @extends Message\n */\nclass LoadingMessage extends Message {\n    constructor(text, onHide = undefined) {\n        super(text, onHide);\n\n        this.$el.addClass(\"loading\");\n    }\n}\n\n/**\n * a message that has a close button and that can be displayed in the {@link Messages} box\n * @extends Message\n */\nclass ClosableMessage extends Message {\n    constructor(text, onHide = undefined) {\n        super(text, onHide);\n\n        this.$el.append(\n            $(\"<span>\").addClass(\"close\").click(() => {\n                this.hide();\n            })\n        )\n    }\n}\n\n/**\n * an error message that can be displayed in the {@link Messages} box\n * @extends ClosableMessage\n */\nclass ErrorMessage extends ClosableMessage {\n    constructor(text, onHide = undefined) {\n        super(text, onHide);\n\n        this.$el.addClass(\"error\");\n    }\n}\n\n/**\n * a warning message that can be displayed in the {@link Messages} box\n * @extends ClosableMessage\n */\nclass WarningMessage extends ClosableMessage {\n    constructor(text, onHide = undefined) {\n        super(text, onHide);\n\n        this.$el.addClass(\"warning\");\n    }\n}\n\n/**\n * display messages to the user in a nice UI\n */\nexport default class Messages {\n    constructor() {\n        /**\n         * jQuery element that represents the message interface. This element contains all the currently displayed messages.\n         * @type {jQuery.element}\n         */\n        this.$el = $(\"<div>\").addClass('messages');\n\n        /**\n         * number of currently displayed messages, has a specified setter and getter\n         * @type {number}\n         */\n        this.count = 0;\n\n        // place the progress info element\n        $('body').append(this.$el);\n    }\n\n    /**\n     * get the number of currently displayed messages\n     * @return {number} [description]\n     */\n    get count() {\n        return this.messageCount;\n    }\n\n    /**\n     * Set the number of currently displayed messages. Should be called only through functions that add messages.\n     *\n     * If the message count is >= 1, the jQuery element for the UI is displayed, if the message count is <1, the UI is hidden.\n     * @param  {number} value [description]\n     * @return {number}       [description]\n     */\n    set count(value) {\n        this.messageCount = value;\n\n        if(this.messageCount < 1) {\n            this.hide();\n        } else {\n            this.display();\n        }\n    }\n\n    /**\n     * hide the message box by adding a `hidden` class to the element\n     */\n    hide() {\n        this.$el.addClass('hidden');\n    }\n\n    /**\n     * display the message box by removing the `hidden` class to the element\n     */\n    display() {\n        this.$el.removeClass('hidden');\n    }\n\n    /**\n     * add a new message to the message box\n     * @param  {string} text             text of the message\n     * @param  {Message} [constr=Message] constructor of the message, must be a derivate of the {@link Message} class\n     * @return {Message}                  the newly constructed message (instance made by the specified constructor)\n     */\n    newMessage(text, constr = Message) {\n        // Create the message by calling the constructor,\n        // provide it with text and a callback function that will be called when hiding the message.\n        // This callback subtracts 1 from the\n        let message = new constr(text, () => {\n            this.count--;\n        });\n\n        this.$el.append(message.$el);\n        this.count++;\n\n        return message;\n    }\n\n    /**\n     * create a new loading message and add it to the message box\n     * @param  {string} text text of the message\n     * @return {LoadingMessage} the newly constructed {@link LoadingMessage}\n     */\n    newLoadingMessage(text) {\n        return this.newMessage(text, LoadingMessage);\n    }\n\n    /**\n     * create a new error message and add it to the message box\n     * @param  {string} text text of the message\n     * @return {ErrorMessage} the newly constructed {@link ErrorMessage}\n     */\n    newErrorMessage(text) {\n        return this.newMessage(text, ErrorMessage);\n    }\n\n    /**\n     * create a new warning message and add it to the message box\n     * @param  {string} text text of the message\n     * @return {WarningMessage} the newly constructed {@link WarningMessage}\n     */\n    newWarningMessage(text) {\n        return this.newMessage(text, WarningMessage);\n    }\n}\n","/** @module Tutorial */\n/**\n * Display and manage the tutorial\n */\nexport default class Tutorial {\n    /**\n     * @param {Canvas} parentSVG instance of [Canvas](./module-Canvas.html) for this tutorial\n     * @param {Function} [onTutorialClosed] callback function when user closes or finishes the tutorial\n     */\n    constructor(parentSVG, onTutorialClosed) {\n        /**\n         * instance of [Canvas](./module-Canvas.html) for this tutorial\n         * @type {Canvas}\n         */\n        this.parentSVG = parentSVG;\n\n        /**\n         * helper variable for the `step` property, stores current state of the tutorial (step `0` means that tutorial is closed)\n         * @type {Number}\n         */\n        this.currentStep = 0;\n\n        /**\n         * jQuery element containing the tutorial popup\n         * @type {jQuery.element}\n         */\n        this.$tutorialWindow;\n        /**\n         * jQuery element for the dynamic part of the tutorial popup\n         * (text and buttons that are dependent on the current state of the tutorial)\n         * @type {Array}\n         */\n        this.$tutorialContent;\n\n        /**\n         * array of functions that represent intividual steps in the tutorial\n         * by default populated with step `0` that closes the tutorial\n         * @type {Array}\n         */\n        this.steps = [() => { this.closeWindow(onTutorialClosed) }];\n\n        // set up the tutorial\n        this.setUpTutorial();\n    }\n\n    /**\n     * get the current step of the tutorial, this number corresponds to the index in the `this.steps` array\n     * that contains the function for the last displayed step\n     * @return {Number}\n     */\n    get step() {\n        return this.currentStep;\n    }\n\n    /**\n     * change the current step of the tutorial, `0` means \"stop the tutorial\"\n     * @param  {Number} value the step of the tutorial to be displayed\n     */\n    set step(value) {\n        // reset all hooks\n        this.resetHooks();\n\n        this.currentStep = value;\n\n        if(this.step < this.steps.length) {\n            this.steps[this.step]();\n\n            if(this.step === 1)\n                this.displayWindow();\n        } else {\n            this.step = 0;\n        }\n    }\n\n    /**\n     * reset all tutorial hooks\n     */\n    resetHooks() {\n        /**\n         * _tutorial hook_, called when the context menu is opened\n         */\n        this.onContextMenuOpened = () => {};\n\n        /**\n         * _tutorial hook_, called when a new element is added\n         */\n        this.onElementAdded = () => {};\n\n        /**\n         * _tutorial hook_, called when a box is moved\n         */\n        this.onBoxMoved = () => {};\n\n        /**\n         * _tutorial hook_, called when a box is rotated\n         */\n        this.onBoxRotated = () => {};\n\n        /**\n         * _tutorial hook_, called when an output box value is set to `on`\n         */\n        this.onOutputBoxTrue = () => {};\n\n        /**\n         * _tutorial hook_, called when the canvas is moved\n         */\n        this.onCanvasMoved = () => {};\n\n        /**\n         * _tutorial hook_, called when the canvas is zoomed\n         */\n        this.onCanvasZoomed = () => {};\n\n        /**\n         * _tutorial hook_, called when a box is removed\n         */\n        this.onElementRemoved = () => {};\n\n        /**\n         * _tutorial hook_, called when user changes the state of an input box\n         */\n        this.onChangeInputBoxState = () => {};\n    }\n\n    /**\n     * set up the tutorial: reset all tutorial hooks and define the order of tutorial steps\n     */\n    setUpTutorial() {\n        this.resetHooks();\n\n        this.steps.push(\n            () => { this.stepWelcome() },\n            () => { this.stepAddBoxes() },\n            () => { this.stepMoveCanvas() },\n            () => { this.stepZoomCanvas() },\n            () => { this.stepMoveBoxes() },\n            () => { this.stepWiring() },\n            () => { this.switchInputBox() },\n            () => { this.stepRemoveBox() },\n            () => { this.stepFinish() }\n        )\n    }\n\n    /**\n     * _tutorial step_: display context menu\n     */\n    stepWelcome() {\n        this.windowContent(\n            `Welcome to Hradla! To get started, click anywhere on the editing area with your right mouse button.`\n        )\n\n        this.onContextMenuOpened = () => {\n            this.next();\n        }\n    }\n\n    /**\n     * _tutorial step_: add input box, output box and a NOT gate\n     */\n    stepAddBoxes() {\n        this.windowContent(\n            `Great job! Now you know, how to open the editor menu.\n            Now try to add an <em>Input box</em>, <em>Output box</em> and a <em>NOT gate</em>\n            to the editing area.`)\n\n        let elementsAdded = {\n            inputBox: false,\n            outputBox: false,\n            notGate: false\n        }\n\n        this.onElementAdded = (name) => {\n            switch (name) {\n                case \"input\":\n                    elementsAdded.inputBox = true;\n                    break;\n                case \"output\":\n                    elementsAdded.outputBox = true;\n                    break;\n                case \"not\":\n                    elementsAdded.notGate = true;\n                    break;\n                default:\n                    // no action on default\n                    break;\n            }\n\n            if(elementsAdded.inputBox && elementsAdded.outputBox && elementsAdded.notGate) {\n                // proceed to the next step of the tutorial\n                this.next();\n            }\n        };\n    }\n\n    /**\n     * _tutorial step_: move the canvas\n     */\n    stepMoveCanvas() {\n        this.windowContent(\n            `You can move the editing area (sometimes called canvas) by dragging\n            with the middle mouse button or by holding the <code>Ctrl</code> key\n            and dragging with the left mouse button. Check it out.`)\n\n        this.onCanvasMoved = () => {\n            this.next();\n        }\n    }\n\n    /**\n     * _tutorial step_: zoom the canvas\n     */\n    stepZoomCanvas() {\n        this.windowContent(\n            `You can also zoom in and out using the mouse wheel\n            or with the <code>+</code>&nbsp;and <code>−</code>&nbsp;keys.`\n        )\n\n        this.onCanvasZoomed = () => {\n            this.next();\n        }\n    }\n\n    /**\n     * _tutorial step_: move the boxes\n     */\n    stepMoveBoxes() {\n        this.windowContent(`You can move the elements on the editing canvas by dragging them\n            using the left mouse button. You can also rotate them using middle click. Try it out.`)\n\n        let boxMoved = false;\n        let boxRotated = false;\n\n        let moveRotateCallback = () => {\n            if(boxMoved && boxRotated) {\n                this.next();\n            }\n        }\n\n        this.onBoxMoved = () => {\n            boxMoved = true;\n            moveRotateCallback()\n        }\n\n        this.onBoxRotated = () => {\n            boxRotated = true;\n            moveRotateCallback()\n        }\n    }\n\n    /**\n     * _tutorial step_: create an invertor\n     */\n    stepWiring() {\n        this.windowContent(`Essential part of logic networks is the wiring. Create a very simple\n            inverter by connecting the <em>Input box</em> to the input of the <em>NOT gate</em>\n            and the output of the <em>NOT gate</em> to the input of the <em>Output box</em>.`,\n            `To connect two elemnts, simply click on a connector of the first element,\n            than click on a conector of the second element.`)\n\n        this.onOutputBoxTrue = () => {\n            this.next();\n        };\n    }\n\n    /**\n     * _tutorial step_: change the state of an input box\n     */\n    switchInputBox() {\n        this.windowContent(`\n            The input boxes can be in two states: <em>ON</em> and <em>OFF</em>, signalled\n            by the green and red colors respectively. You can left click on an Input box to\n            switch its state. Try it out!\n        `)\n\n        this.onChangeInputBoxState = () => {\n            this.next();\n        };\n    }\n\n    /**\n     * _tutorial step_: remove a box\n     */\n    stepRemoveBox() {\n        this.windowContent(\n            `When you right click on an element, you can find a new item in the menu,\n            that allows you to remove the element. This works for wires as well as for gates and other types of boxes.\n            Try to remove an element!`\n        )\n\n        this.onElementRemoved = () => {\n            this.next();\n        }\n    }\n\n    /**\n     * _tutorial step_: ask the user if they want to clean the canvas before closing the tutorial\n     */\n    stepFinish() {\n        this.windowContent(`You're all set, enjoy your stay!`,\n                           `Do you wish to start with empty canvas?`)\n        this.windowChoice(\n            {\n                text: 'yes, clean the canvas',\n                func: () => {\n                    this.parentSVG.cleanCanvas();\n                    this.stop();\n                }\n            },\n            {\n                text: 'no, keep the canvas as it is',\n                func: () => {\n                    this.stop();\n                }\n            }\n        )\n    }\n\n    /**\n     * display the tutorial window\n     */\n    displayWindow() {\n        this.parentSVG.$svg.after(this.$tutorialWindow)\n    }\n\n    /**\n     * close the tutorial window\n     * @param  {Function} [onTutorialClosed] callback function that is called when the tutorial is closed\n     */\n    closeWindow(onTutorialClosed) {\n        this.$tutorialWindow.remove();\n\n        if(onTutorialClosed!==undefined) {\n            onTutorialClosed();\n        }\n    }\n\n    /**\n     * set the tutorial window text content\n     * @param  {...string} text each string is a separate paragraph\n     */\n    windowContent(...text) {\n        if(!this.$tutorialWindow) {\n            this.$tutorialWindow = $(\"<div>\").attr(\"id\", \"tutorial\");\n\n            this.$topButtonsLeft = $(\"<div>\").addClass(\"left\");\n\n            this.$tutorialWindow.append(\n                $(\"<div>\").addClass(\"topButtons\")\n                    .append(this.$topButtonsLeft)\n                    .append( // the .right div can be added here because it is not modified during the tutorial\n                        $(\"<div>\").addClass(\"right\")\n                        .append(\n                            $(\"<a>\").attr({\n                                href: \"#\",\n                                title: \"close tutorial\"\n                            }).addClass(\"button close\")\n                            .click(() => {\n                                this.stop();\n                            })\n                        )\n                    )\n            )\n\n            this.$tutorialWindow.append(this.$topButtons);\n\n            this.$tutorialContent = $(\"<div>\").addClass(\"content\");\n            this.$tutorialWindow.append(this.$tutorialContent);\n        }\n\n        this.$topButtonsLeft.html(\"\");\n\n        let $prev = $(\"<a>\").attr({\n            href: \"#\",\n            title: \"go back\"\n        }).addClass(\"button prev\");\n\n        if(this.step>1) {\n            $prev.click(() => {\n                this.prev();\n            });\n        } else {\n            $prev.addClass(\"disabled\");\n        }\n\n        let $next = $(\"<a>\").attr({\n            href: \"#\",\n            title: \"go forward\"\n        }).addClass(\"button next\");\n\n        if(this.step < this.steps.length - 1) {\n            $next.click(() => {\n                this.next();\n            });\n        } else {\n            $next.addClass(\"disabled\");\n        }\n\n        this.$topButtonsLeft.append($prev).append($next);\n\n        // set the text content\n\n        this.$tutorialContent.html(\"\");\n        for (const paragraph of text) {\n            this.$tutorialContent.append(\n                $(\"<p>\").html(paragraph)\n            );\n        }\n\n        // // render the buttons in each step (to remove focus and to\n        // // ensure there is no \"back\" button on the first step or \"next\" button on the last step)\n        // if(this.$prevNext) {\n        //     this.$prevNext.remove();\n        // }\n        //\n        // this.$prevNext = $(\"<div>\").addClass(\"bottomButtons\");\n        //\n        // if(this.step>1) {\n        //     this.$prevNext.append(\n        //         $(\"<a>\").attr(\"href\", \"#\").addClass(\"button prev\")\n        //         // .text(\"back\")\n        //         .click(() => {\n        //             this.step--;\n        //         })\n        //     )\n        // }\n        //\n        // if(this.step < this.steps.length - 1) {\n        //     this.$prevNext.append(\n        //         $(\"<a>\").attr(\"href\", \"#\").addClass(\"button next\")\n        //         // .text(\"next\")\n        //         .click(() => {\n        //             this.next();\n        //         })\n        //     )\n        // }\n        //\n        // this.$tutorialWindow.append(this.$prevNext);\n    }\n\n    /**\n     * add buttons with choices to the tutorial window\n     * @param  {...object} choices each choice is an object in with a `string` property _text_ and a `function` property _func_\n     */\n    windowChoice(...choices) {\n        let $choices = $(\"<ol>\").addClass(\"choices\");\n        for (const choice of choices) {\n            $choices.append(\n                $(\"<li>\").append(\n                    $(\"<a>\").attr(\"href\", \"#\").click(() => {\n                        choice.func()\n                    }).html(choice.text)\n                )\n            )\n        }\n        this.$tutorialContent.append($choices);\n    }\n\n    /**\n     * start the tutorial\n     */\n    start() { this.step = 1; }\n\n    /**\n     * go to the next step of the tutorial\n     */\n    next() { this.step++; }\n\n    /**\n     * go to the previous step of the tutorial\n     */\n    prev() { this.step--; }\n\n    /**\n     * stop the tutorial\n     */\n    stop() { this.step = 0 }\n}\n","/** @module ViewBox */\n/**\n * ViewBox provides an api for oprerating with the viewBox argument of the <svg> DOM element.\n */\nexport default class ViewBox {\n    /**\n     * Initialize viewBox\n     * @param {number} left   distance of the left edge of the viewbox from document's y axis in SVG pixels\n     * @param {number} top    distance of the top edge of the viewbox from the document's x axis in SVG pixels\n     * @param {number} width  width of the viewbox in SVG pixels\n     * @param {number} height height of the viewbox in SVG pixels\n     */\n    constructor(left, top, width, height) {\n        /**\n         * ViewBox attributes before applying zoom and shift\n         * @type {object}\n         */\n        this.real = { left, top, width, height }\n\n        /**\n         * The maximum amount of zoom on the viewbox\n         * @type {number}\n         */\n        this.maxZoom = 8;\n        /**\n         * The minimum amount of zoom on the viewbox\n         * @type {number}\n         */\n        this.minZoom = 0.1;\n\n        /**\n         * Amount of zoom on the viewbox, always between this.minZoom and this.maxZoom\n         * @type {number}\n         */\n        this.realZoom = 1\n\n        /**\n         * amount of horizontal shift of the document\n         * @type {number}\n         */\n        this.leftShift = 0\n        /**\n         * amount of vertical shift of the document\n         * @type {number}\n         */\n        this.topShift = 0\n    }\n\n    /**\n     * update the dimensions of the viewbox (used on window resize)\n     * @param  {Number} width  new width of the viewbox in SVG pixels\n     * @param  {Number} height new height of the viewbox in SVG pixels\n     */\n    newDimensions(width, height) {\n        // keep the viewbox centered\n        this.real.left += (this.real.width - width)/2\n        this.real.top += (this.real.height - height)/2\n\n        // update the dimensions\n        this.real.width = width;\n        this.real.height = height;\n    }\n\n    /**\n     * get the amount of zoom on the viewbox\n     * @return {number}\n     */\n    get zoom() {\n        return this.realZoom;\n    }\n\n    /**\n     * set the amount of zoom on the viewbox\n     * @param {number} value the new amount of zoom\n     */\n    set zoom(value) {\n        // fit this.realZoom to fit between this.minZoom and this.maxZoom\n        this.realZoom = Math.max(Math.min(value, this.maxZoom), this.minZoom);\n    }\n\n    /**\n     * get the width of the viewbox with the current zoom applied\n     * @return {number} the final width of the viewbox\n     */\n    get width() {\n        return this.real.width / this.zoom\n    }\n\n    /**\n     * get the height of the viewbox with the current zoom applied\n     * @return {number} the final height of the viewbox\n     */\n    get height() {\n        return this.real.height / this.zoom\n    }\n\n    /**\n     * get the horizontal distance from the y axis of the document with zoom and shift value applied\n     * @return {number}\n     */\n    get left() {\n        return this.real.left - (this.leftShift / this.zoom) + ((this.real.width - this.width) / 2)\n    }\n\n    /**\n     * get the vertical distance from the x axis of the document with zoom and shift value applied\n     * @return {number}\n     */\n    get top() {\n        return this.real.top - (this.topShift / this.zoom) + ((this.real.height - this.height) / 2)\n    }\n\n    /**\n     * get the computed viewbox values as a string in the correct format that can be used in the viewBox attribute of the SVG element\n     * @return {string} string in format \"left top width height\"\n     */\n    get str() {\n        return `${this.left} ${this.top} ${this.width} ${this.height}`\n    }\n\n    /**\n     * transform horizontal units to the scale and shift of the editor\n     * @param  {number} x original horizontal value\n     * @return {number}   transformed horizontal value\n     */\n    transformX(x) {\n        return this.left + (x / this.zoom)\n    }\n\n    /**\n     * transform vertical units to the scale and shift of the editor\n     * @param  {number} y original vertical value\n     * @return {number}   transformed vertical value\n     */\n    transformY(y) {\n        return this.top + (y / this.zoom)\n    }\n\n    /**\n     * transform pageX and pageY parameters of the jquery event to match the zoom and shift of the viewbox\n     * @param  {jquery.MouseEvent} event original event\n     * @return {jquery.MouseEvent}       the same event but with transformed pageX and pageY members\n     */\n    transformEvent(event) {\n        event.pageX = this.transformX(event.pageX)\n        event.pageY = this.transformY(event.pageY)\n\n        return event\n    }\n}\n","/**\n * @module Library\n */\n\nconst libraryDir = './library/'\n\n/**\n * get list of networks from the library\n * @return {Promise} promise, the resolution is an object containing a list of libraries\n */\nexport function getLibrary() {\n    return new Promise((resolve, reject) => {\n        const libraryFile = libraryDir + 'networkList.json';\n\n        let request = new XMLHttpRequest();\n\n        request.addEventListener(\"load\", function() {\n            if(this.response) {\n                resolve(this.response.networks);\n            }\n        });\n\n        request.addEventListener([\"error\", \"abort\"], () => {\n            reject(\"Failed loading libraries.\")\n        });\n\n        request.open('GET', libraryFile, true);\n        request.responseType = 'json';\n        request.send();\n    });\n}\n\n/**\n * get a network from the library, specified by filename\n * @param  {string} networkName library file name without the extension\n * @return {Promise} promise, the resolution is an object containing the library import data\n */\nexport function getNetworkFromLibrary(networkName) {\n    return new Promise((resolve, reject) => {\n        let request = new XMLHttpRequest();\n\n        request.addEventListener(\"load\", function() {\n            if(this.response) {\n                resolve(this.response);\n            }\n        });\n\n        request.addEventListener([\"error\", \"abort\"], () => {\n            reject(`Failed loading library ${networkName}.`)\n        });\n\n        request.open('GET', libraryDir + networkName + '.json', true);\n        request.responseType = 'json';\n        request.send();\n    });\n}\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcG9seWZpbGwvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXBvbHlmaWxsL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9mbi9yZWdleHAvZXNjYXBlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtbnVtYmVyLXZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4taW5zdGFuY2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1jb3B5LXdpdGhpbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZpbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1mcm9tLWl0ZXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1tZXRob2RzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktcmVkdWNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYmluZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NsYXNzb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXN0cm9uZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tdG8tanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24td2Vhay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY3JlYXRlLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY3R4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGF0ZS10by1pc28tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGF0ZS10by1wcmltaXRpdmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZWZpbmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0ta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLWlzLXJlZ2V4cC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZml4LXJlLXdrcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZsYWdzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmxhdHRlbi1pbnRvLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZm9yLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGlkZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2luaGVyaXQtaWYtcmVxdWlyZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pbnZva2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtaW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLXJlZ2V4cC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2xpYnJhcnkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLWV4cG0xLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1mcm91bmQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLWxvZzFwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1zY2FsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21ldGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tZXRhZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21pY3JvdGFzay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX25ldy1wcm9taXNlLWNhcGFiaWxpdHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZm9yY2VkLXBhbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1ncG8uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1zYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtdG8tYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vd24ta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWZsb2F0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcGFyc2UtaW50LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcGVyZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Byb21pc2UtcmVzb2x2ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS1hbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlcGxhY2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2FtZS12YWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1jb2xsZWN0aW9uLWZyb20uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtY29sbGVjdGlvbi1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1wcm90by5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1zcGVjaWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmljdC1tZXRob2QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctY29udGV4dC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1odG1sLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXBhZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1yZXBlYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctdHJpbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy13cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Rhc2suanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1hYnNvbHV0ZS1pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWluZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLWJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdXNlci1hZ2VudC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3ZhbGlkYXRlLWNvbGxlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MtZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLWV4dC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9jb3JlLnJlZ2V4cC5lc2NhcGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZm9yLWVhY2guanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaW5kZXgtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pcy1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuam9pbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5tYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS1yaWdodC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNsaWNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29tZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNvcnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS5ub3cuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWlzby1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWpzb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLXByaW1pdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmFjb3NoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hc2luaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXRhbmguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNicnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNsejMyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jb3NoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5leHBtMS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5oeXBvdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaW11bC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMTAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzFwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaW5oLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50YW5oLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50cnVuYy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5lcHNpbG9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1zYWZlLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5taW4tc2FmZS1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWludC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1maXhlZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1wcmVjaXNpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1mcm96ZW4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtc2VhbGVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QucHJldmVudC1leHRlbnNpb25zLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNlYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1mbG9hdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnBhcnNlLWludC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnByb21pc2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5lbnVtZXJhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5oYXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5tYXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zZXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYW5jaG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJpZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ibGluay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ib2xkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmNvZGUtcG9pbnQtYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZW5kcy13aXRoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZpeGVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mcm9tLWNvZGUtcG9pbnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRhbGljcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5saW5rLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJhdy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc21hbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RyaWtlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1Yi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcudHJpbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmFycmF5LWJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmRhdGEtdmlldy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0MzItYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MTYtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDgtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MTYtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MzItYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWNsYW1wZWQtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLW1hcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstc2V0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuZmxhdC1tYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5hcnJheS5mbGF0dGVuLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5hc2FwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuZXJyb3IuaXMtZXJyb3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXAuZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC5vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC50by1qc29uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5jbGFtcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguZGVnLXBlci1yYWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmRlZ3JlZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmZzY2FsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaWFkZGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmltdWxoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pc3ViaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGgucmFkLXBlci1kZWcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnJhZGlhbnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnNjYWxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5zaWduYml0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC51bXVsaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtZ2V0dGVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1zZXR0ZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZW50cmllcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1nZXR0ZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLXNldHRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC52YWx1ZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucHJvbWlzZS5maW5hbGx5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucHJvbWlzZS50cnkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlZmluZS1tZXRhZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVsZXRlLW1ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1tZXRhZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW93bi1tZXRhZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QubWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zZXQuZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC5vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC50by1qc29uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLmF0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLm1hdGNoLWFsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtZW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1zdGFydC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy50cmltLWxlZnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1yaWdodC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3lzdGVtLmdsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LndlYWstbWFwLmZyb20uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy53ZWFrLW1hcC5vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LndlYWstc2V0LmZyb20uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy53ZWFrLXNldC5vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmltbWVkaWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLnRpbWVycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL3NoaW0uanMiLCJub2RlX21vZHVsZXMvanNvbi1zdHJpbmdpZnktcHJldHR5LWNvbXBhY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL0RvdWJseUxpbmtlZExpc3QuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL0hlYXAuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL01heEhlYXAuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL01pbkhlYXAuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL1ByaW9yaXR5UXVldWUuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL1F1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL2xpYnN0bC9EYXRhc3RydWN0dXJlcy9TdGFjay5qcyIsIm5vZGVfbW9kdWxlcy9saWJzdGwvbm9kZS1tb2R1bGUuanMiLCJzcmMvZXM2L21haW4uanMiLCJzcmMvZXM2L21vZHVsZXMvQ2FudmFzLmpzIiwic3JjL2VzNi9tb2R1bGVzL0xvZ2ljLmpzIiwic3JjL2VzNi9tb2R1bGVzL1NpbXVsYXRpb24uanMiLCJzcmMvZXM2L21vZHVsZXMvZWRpdG9yRWxlbWVudHMuanMiLCJzcmMvZXM2L21vZHVsZXMvZWRpdG9yRWxlbWVudHMvQmxhY2tib3guanMiLCJzcmMvZXM2L21vZHVsZXMvZWRpdG9yRWxlbWVudHMvQm94LmpzIiwic3JjL2VzNi9tb2R1bGVzL2VkaXRvckVsZW1lbnRzL0Nvbm5lY3Rvci5qcyIsInNyYy9lczYvbW9kdWxlcy9lZGl0b3JFbGVtZW50cy9HYXRlLmpzIiwic3JjL2VzNi9tb2R1bGVzL2VkaXRvckVsZW1lbnRzL0hlbHBlcldpcmUuanMiLCJzcmMvZXM2L21vZHVsZXMvZWRpdG9yRWxlbWVudHMvSW5wdXRCb3guanMiLCJzcmMvZXM2L21vZHVsZXMvZWRpdG9yRWxlbWVudHMvSW5wdXRDb25uZWN0b3IuanMiLCJzcmMvZXM2L21vZHVsZXMvZWRpdG9yRWxlbWVudHMvTmV0d29ya0VsZW1lbnQuanMiLCJzcmMvZXM2L21vZHVsZXMvZWRpdG9yRWxlbWVudHMvT3V0cHV0Qm94LmpzIiwic3JjL2VzNi9tb2R1bGVzL2VkaXRvckVsZW1lbnRzL091dHB1dENvbm5lY3Rvci5qcyIsInNyYy9lczYvbW9kdWxlcy9lZGl0b3JFbGVtZW50cy9UcmFuc2Zvcm0uanMiLCJzcmMvZXM2L21vZHVsZXMvZWRpdG9yRWxlbWVudHMvV2lyZS5qcyIsInNyYy9lczYvbW9kdWxlcy9lZGl0b3JFbGVtZW50cy9XaXJlQW5jaG9yLmpzIiwic3JjL2VzNi9tb2R1bGVzL2VkaXRvckVsZW1lbnRzL3BvaW50VHJhdmVsbGVyLmpzIiwic3JjL2VzNi9tb2R1bGVzL2VkaXRvckVsZW1lbnRzL3N0YXRlQ2xhc3Nlcy5qcyIsInNyYy9lczYvbW9kdWxlcy9maW5kUGF0aC5qcyIsInNyYy9lczYvbW9kdWxlcy9vdGhlci9oZWxwZXJGdW5jdGlvbnMuanMiLCJzcmMvZXM2L21vZHVsZXMvb3RoZXIvaWQuanMiLCJzcmMvZXM2L21vZHVsZXMvb3RoZXIvbWFwV2l0aERlZmF1bHRWYWx1ZS5qcyIsInNyYy9lczYvbW9kdWxlcy9zdmdPYmplY3RzLmpzIiwic3JjL2VzNi9tb2R1bGVzL3N2Z09iamVjdHMvR3JvdXAuanMiLCJzcmMvZXM2L21vZHVsZXMvc3ZnT2JqZWN0cy9NdWx0aUxpbmVUZXh0LmpzIiwic3JjL2VzNi9tb2R1bGVzL3N2Z09iamVjdHMvUGF0dGVybi5qcyIsInNyYy9lczYvbW9kdWxlcy9zdmdPYmplY3RzL1BvbHlMaW5lLmpzIiwic3JjL2VzNi9tb2R1bGVzL3N2Z09iamVjdHMvUG9seUxpbmVQb2ludC5qcyIsInNyYy9lczYvbW9kdWxlcy9zdmdPYmplY3RzL1BvbHlMaW5lUG9pbnRzLmpzIiwic3JjL2VzNi9tb2R1bGVzL3N2Z09iamVjdHMvUmVjdGFuZ2xlLmpzIiwic3JjL2VzNi9tb2R1bGVzL3N2Z09iamVjdHMvU3ZnRWxlbWVudC5qcyIsInNyYy9lczYvbW9kdWxlcy9zdmdPYmplY3RzL1N2Z0ltYWdlLmpzIiwic3JjL2VzNi9tb2R1bGVzL3N2Z09iamVjdHMvVGFnLmpzIiwic3JjL2VzNi9tb2R1bGVzL3N2Z09iamVjdHMvVGV4dC5qcyIsInNyYy9lczYvbW9kdWxlcy91aS9Db250ZXh0TWVudS5qcyIsInNyYy9lczYvbW9kdWxlcy91aS9GbG9hdGluZ01lbnUuanMiLCJzcmMvZXM2L21vZHVsZXMvdWkvTWVzc2FnZXMuanMiLCJzcmMvZXM2L21vZHVsZXMvdWkvVHV0b3JpYWwuanMiLCJzcmMvZXM2L21vZHVsZXMvdWkvVmlld0JveC5qcyIsInNyYy9lczYvbW9kdWxlcy91aS9uZXR3b3JrTGlicmFyeS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2h1QkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFVLE9BQVYsQ0FBekIsRUFBNkMsWUFBTTtBQUMvQywrQ0FBaUMsV0FBakM7QUFDSCxTQUZEOztBQUlBLGdCQUFRLElBQVIsQ0FBYSxLQUFiLEVBQW9CLGFBQWEsV0FBYixHQUEyQixPQUEvQyxFQUF3RCxJQUF4RDtBQUNBLGdCQUFRLFlBQVIsR0FBdUIsTUFBdkI7QUFDQSxnQkFBUSxJQUFSO0FBQ0gsS0FoQk0sQ0FBUDtBQWlCSCIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9cmV0dXJuIGV9KSgpIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL3NoaW1cIik7XG5cbnJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWVcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL2ZuL3JlZ2V4cC9lc2NhcGVcIik7XG5cbmlmIChnbG9iYWwuX2JhYmVsUG9seWZpbGwpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwib25seSBvbmUgaW5zdGFuY2Ugb2YgYmFiZWwtcG9seWZpbGwgaXMgYWxsb3dlZFwiKTtcbn1cbmdsb2JhbC5fYmFiZWxQb2x5ZmlsbCA9IHRydWU7XG5cbnZhciBERUZJTkVfUFJPUEVSVFkgPSBcImRlZmluZVByb3BlcnR5XCI7XG5mdW5jdGlvbiBkZWZpbmUoTywga2V5LCB2YWx1ZSkge1xuICBPW2tleV0gfHwgT2JqZWN0W0RFRklORV9QUk9QRVJUWV0oTywga2V5LCB7XG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9KTtcbn1cblxuZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIFwicGFkTGVmdFwiLCBcIlwiLnBhZFN0YXJ0KTtcbmRlZmluZShTdHJpbmcucHJvdG90eXBlLCBcInBhZFJpZ2h0XCIsIFwiXCIucGFkRW5kKTtcblxuXCJwb3AscmV2ZXJzZSxzaGlmdCxrZXlzLHZhbHVlcyxlbnRyaWVzLGluZGV4T2YsZXZlcnksc29tZSxmb3JFYWNoLG1hcCxmaWx0ZXIsZmluZCxmaW5kSW5kZXgsaW5jbHVkZXMsam9pbixzbGljZSxjb25jYXQscHVzaCxzcGxpY2UsdW5zaGlmdCxzb3J0LGxhc3RJbmRleE9mLHJlZHVjZSxyZWR1Y2VSaWdodCxjb3B5V2l0aGluLGZpbGxcIi5zcGxpdChcIixcIikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIFtdW2tleV0gJiYgZGVmaW5lKEFycmF5LCBrZXksIEZ1bmN0aW9uLmNhbGwuYmluZChbXVtrZXldKSk7XG59KTsiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBodHRwczovL3Jhdy5naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL21hc3Rlci9MSUNFTlNFIGZpbGUuIEFuXG4gKiBhZGRpdGlvbmFsIGdyYW50IG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW5cbiAqIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGdsb2JhbC5wcm9jZXNzID09PSBcIm9iamVjdFwiICYmIGdsb2JhbC5wcm9jZXNzLmRvbWFpbikge1xuICAgICAgaW52b2tlID0gZ2xvYmFsLnByb2Nlc3MuZG9tYWluLmJpbmQoaW52b2tlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBydW50aW1lLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEFtb25nIHRoZSB2YXJpb3VzIHRyaWNrcyBmb3Igb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWxcbiAgLy8gb2JqZWN0LCB0aGlzIHNlZW1zIHRvIGJlIHRoZSBtb3N0IHJlbGlhYmxlIHRlY2huaXF1ZSB0aGF0IGRvZXMgbm90XG4gIC8vIHVzZSBpbmRpcmVjdCBldmFsICh3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSkuXG4gIHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOlxuICB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDpcbiAgdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdGhpc1xuKTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvY29yZS5yZWdleHAuZXNjYXBlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5SZWdFeHAuZXNjYXBlO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIG1zZykge1xuICBpZiAodHlwZW9mIGl0ICE9ICdudW1iZXInICYmIGNvZihpdCkgIT0gJ051bWJlcicpIHRocm93IFR5cGVFcnJvcihtc2cpO1xuICByZXR1cm4gK2l0O1xufTtcbiIsIi8vIDIyLjEuMy4zMSBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbnZhciBVTlNDT1BBQkxFUyA9IHJlcXVpcmUoJy4vX3drcycpKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5pZiAoQXJyYXlQcm90b1tVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSByZXF1aXJlKCcuL19oaWRlJykoQXJyYXlQcm90bywgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKSB7XG4gIGlmICghKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxuJ3VzZSBzdHJpY3QnO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtdLmNvcHlXaXRoaW4gfHwgZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXQgLyogPSAwICovLCBzdGFydCAvKiA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbiA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIHRvID0gdG9BYnNvbHV0ZUluZGV4KHRhcmdldCwgbGVuKTtcbiAgdmFyIGZyb20gPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbik7XG4gIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGNvdW50ID0gTWF0aC5taW4oKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuKSkgLSBmcm9tLCBsZW4gLSB0byk7XG4gIHZhciBpbmMgPSAxO1xuICBpZiAoZnJvbSA8IHRvICYmIHRvIDwgZnJvbSArIGNvdW50KSB7XG4gICAgaW5jID0gLTE7XG4gICAgZnJvbSArPSBjb3VudCAtIDE7XG4gICAgdG8gKz0gY291bnQgLSAxO1xuICB9XG4gIHdoaWxlIChjb3VudC0tID4gMCkge1xuICAgIGlmIChmcm9tIGluIE8pIE9bdG9dID0gT1tmcm9tXTtcbiAgICBlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICB0byArPSBpbmM7XG4gICAgZnJvbSArPSBpbmM7XG4gIH0gcmV0dXJuIE87XG59O1xuIiwiLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG4ndXNlIHN0cmljdCc7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyogLCBzdGFydCA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGVuZFBvcyA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuZ3RoKTtcbiAgd2hpbGUgKGVuZFBvcyA+IGluZGV4KSBPW2luZGV4KytdID0gdmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyLCBJVEVSQVRPUikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvck9mKGl0ZXIsIGZhbHNlLCByZXN1bHQucHVzaCwgcmVzdWx0LCBJVEVSQVRPUik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG4iLCIvLyAwIC0+IEFycmF5I2ZvckVhY2hcbi8vIDEgLT4gQXJyYXkjbWFwXG4vLyAyIC0+IEFycmF5I2ZpbHRlclxuLy8gMyAtPiBBcnJheSNzb21lXG4vLyA0IC0+IEFycmF5I2V2ZXJ5XG4vLyA1IC0+IEFycmF5I2ZpbmRcbi8vIDYgLT4gQXJyYXkjZmluZEluZGV4XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgYXNjID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRZUEUsICRjcmVhdGUpIHtcbiAgdmFyIElTX01BUCA9IFRZUEUgPT0gMTtcbiAgdmFyIElTX0ZJTFRFUiA9IFRZUEUgPT0gMjtcbiAgdmFyIElTX1NPTUUgPSBUWVBFID09IDM7XG4gIHZhciBJU19FVkVSWSA9IFRZUEUgPT0gNDtcbiAgdmFyIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDY7XG4gIHZhciBOT19IT0xFUyA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYO1xuICB2YXIgY3JlYXRlID0gJGNyZWF0ZSB8fCBhc2M7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgc2VsZiA9IElPYmplY3QoTyk7XG4gICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgdGhhdCwgMyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciByZXN1bHQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuICAgIHZhciB2YWwsIHJlcztcbiAgICBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpIHtcbiAgICAgIHZhbCA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzID0gZih2YWwsIGluZGV4LCBPKTtcbiAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgIGlmIChJU19NQVApIHJlc3VsdFtpbmRleF0gPSByZXM7ICAgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYgKHJlcykgc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbDsgICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHJlc3VsdC5wdXNoKHZhbCk7ICAgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIGlmIChJU19FVkVSWSkgcmV0dXJuIGZhbHNlOyAvLyBldmVyeVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogcmVzdWx0O1xuICB9O1xufTtcbiIsInZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIGNhbGxiYWNrZm4sIGFMZW4sIG1lbW8sIGlzUmlnaHQpIHtcbiAgYUZ1bmN0aW9uKGNhbGxiYWNrZm4pO1xuICB2YXIgTyA9IHRvT2JqZWN0KHRoYXQpO1xuICB2YXIgc2VsZiA9IElPYmplY3QoTyk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gIHZhciBpbmRleCA9IGlzUmlnaHQgPyBsZW5ndGggLSAxIDogMDtcbiAgdmFyIGkgPSBpc1JpZ2h0ID8gLTEgOiAxO1xuICBpZiAoYUxlbiA8IDIpIGZvciAoOzspIHtcbiAgICBpZiAoaW5kZXggaW4gc2VsZikge1xuICAgICAgbWVtbyA9IHNlbGZbaW5kZXhdO1xuICAgICAgaW5kZXggKz0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpbmRleCArPSBpO1xuICAgIGlmIChpc1JpZ2h0ID8gaW5kZXggPCAwIDogbGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICB9XG4gIH1cbiAgZm9yICg7aXNSaWdodCA/IGluZGV4ID49IDAgOiBsZW5ndGggPiBpbmRleDsgaW5kZXggKz0gaSkgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmW2luZGV4XSwgaW5kZXgsIE8pO1xuICB9XG4gIHJldHVybiBtZW1vO1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICB2YXIgQztcbiAgaWYgKGlzQXJyYXkob3JpZ2luYWwpKSB7XG4gICAgQyA9IG9yaWdpbmFsLmNvbnN0cnVjdG9yO1xuICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgaWYgKHR5cGVvZiBDID09ICdmdW5jdGlvbicgJiYgKEMgPT09IEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSkgQyA9IHVuZGVmaW5lZDtcbiAgICBpZiAoaXNPYmplY3QoQykpIHtcbiAgICAgIEMgPSBDW1NQRUNJRVNdO1xuICAgICAgaWYgKEMgPT09IG51bGwpIEMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IHJldHVybiBDID09PSB1bmRlZmluZWQgPyBBcnJheSA6IEM7XG59O1xuIiwiLy8gOS40LjIuMyBBcnJheVNwZWNpZXNDcmVhdGUob3JpZ2luYWxBcnJheSwgbGVuZ3RoKVxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWwsIGxlbmd0aCkge1xuICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWwpKShsZW5ndGgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBpbnZva2UgPSByZXF1aXJlKCcuL19pbnZva2UnKTtcbnZhciBhcnJheVNsaWNlID0gW10uc2xpY2U7XG52YXIgZmFjdG9yaWVzID0ge307XG5cbnZhciBjb25zdHJ1Y3QgPSBmdW5jdGlvbiAoRiwgbGVuLCBhcmdzKSB7XG4gIGlmICghKGxlbiBpbiBmYWN0b3JpZXMpKSB7XG4gICAgZm9yICh2YXIgbiA9IFtdLCBpID0gMDsgaSA8IGxlbjsgaSsrKSBuW2ldID0gJ2FbJyArIGkgKyAnXSc7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgZmFjdG9yaWVzW2xlbl0gPSBGdW5jdGlvbignRixhJywgJ3JldHVybiBuZXcgRignICsgbi5qb2luKCcsJykgKyAnKScpO1xuICB9IHJldHVybiBmYWN0b3JpZXNbbGVuXShGLCBhcmdzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24uYmluZCB8fCBmdW5jdGlvbiBiaW5kKHRoYXQgLyogLCAuLi5hcmdzICovKSB7XG4gIHZhciBmbiA9IGFGdW5jdGlvbih0aGlzKTtcbiAgdmFyIHBhcnRBcmdzID0gYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBib3VuZCA9IGZ1bmN0aW9uICgvKiBhcmdzLi4uICovKSB7XG4gICAgdmFyIGFyZ3MgPSBwYXJ0QXJncy5jb25jYXQoYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgYm91bmQgPyBjb25zdHJ1Y3QoZm4sIGFyZ3MubGVuZ3RoLCBhcmdzKSA6IGludm9rZShmbiwgYXJncywgdGhhdCk7XG4gIH07XG4gIGlmIChpc09iamVjdChmbi5wcm90b3R5cGUpKSBib3VuZC5wcm90b3R5cGUgPSBmbi5wcm90b3R5cGU7XG4gIHJldHVybiBib3VuZDtcbn07XG4iLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBBUkcgPSBjb2YoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgJGl0ZXJEZWZpbmUgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBzZXRTcGVjaWVzID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgZmFzdEtleSA9IHJlcXVpcmUoJy4vX21ldGEnKS5mYXN0S2V5O1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFNJWkUgPSBERVNDUklQVE9SUyA/ICdfcycgOiAnc2l6ZSc7XG5cbnZhciBnZXRFbnRyeSA9IGZ1bmN0aW9uICh0aGF0LCBrZXkpIHtcbiAgLy8gZmFzdCBjYXNlXG4gIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KTtcbiAgdmFyIGVudHJ5O1xuICBpZiAoaW5kZXggIT09ICdGJykgcmV0dXJuIHRoYXQuX2lbaW5kZXhdO1xuICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcbiAgZm9yIChlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pIHtcbiAgICBpZiAoZW50cnkuayA9PSBrZXkpIHJldHVybiBlbnRyeTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll90ID0gTkFNRTsgICAgICAgICAvLyBjb2xsZWN0aW9uIHR5cGVcbiAgICAgIHRoYXQuX2kgPSBjcmVhdGUobnVsbCk7IC8vIGluZGV4XG4gICAgICB0aGF0Ll9mID0gdW5kZWZpbmVkOyAgICAvLyBmaXJzdCBlbnRyeVxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgICAgLy8gbGFzdCBlbnRyeVxuICAgICAgdGhhdFtTSVpFXSA9IDA7ICAgICAgICAgLy8gc2l6ZVxuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICBmb3IgKHZhciB0aGF0ID0gdmFsaWRhdGUodGhpcywgTkFNRSksIGRhdGEgPSB0aGF0Ll9pLCBlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pIHtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZW50cnkucCkgZW50cnkucCA9IGVudHJ5LnAubiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0Ll9mID0gdGhhdC5fbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhhdFtTSVpFXSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdGhhdCA9IHZhbGlkYXRlKHRoaXMsIE5BTUUpO1xuICAgICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm47XG4gICAgICAgICAgdmFyIHByZXYgPSBlbnRyeS5wO1xuICAgICAgICAgIGRlbGV0ZSB0aGF0Ll9pW2VudHJ5LmldO1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmIChwcmV2KSBwcmV2Lm4gPSBuZXh0O1xuICAgICAgICAgIGlmIChuZXh0KSBuZXh0LnAgPSBwcmV2O1xuICAgICAgICAgIGlmICh0aGF0Ll9mID09IGVudHJ5KSB0aGF0Ll9mID0gbmV4dDtcbiAgICAgICAgICBpZiAodGhhdC5fbCA9PSBlbnRyeSkgdGhhdC5fbCA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG4gICAgICAgIHZhbGlkYXRlKHRoaXMsIE5BTUUpO1xuICAgICAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMyk7XG4gICAgICAgIHZhciBlbnRyeTtcbiAgICAgICAgd2hpbGUgKGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhpcy5fZikge1xuICAgICAgICAgIGYoZW50cnkudiwgZW50cnkuaywgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnIpIGVudHJ5ID0gZW50cnkucDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy43IE1hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjIuMy43IFNldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIWdldEVudHJ5KHZhbGlkYXRlKHRoaXMsIE5BTUUpLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChERVNDUklQVE9SUykgZFAoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZSh0aGlzLCBOQU1FKVtTSVpFXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgdmFyIHByZXYsIGluZGV4O1xuICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuICAgIGlmIChlbnRyeSkge1xuICAgICAgZW50cnkudiA9IHZhbHVlO1xuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fbCA9IGVudHJ5ID0ge1xuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSwgLy8gPC0gaW5kZXhcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxuICAgICAgICB2OiB2YWx1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgICAgcDogcHJldiA9IHRoYXQuX2wsICAgICAgICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSByZW1vdmVkXG4gICAgICB9O1xuICAgICAgaWYgKCF0aGF0Ll9mKSB0aGF0Ll9mID0gZW50cnk7XG4gICAgICBpZiAocHJldikgcHJldi5uID0gZW50cnk7XG4gICAgICB0aGF0W1NJWkVdKys7XG4gICAgICAvLyBhZGQgdG8gaW5kZXhcbiAgICAgIGlmIChpbmRleCAhPT0gJ0YnKSB0aGF0Ll9pW2luZGV4XSA9IGVudHJ5O1xuICAgIH0gcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbiAoQywgTkFNRSwgSVNfTUFQKSB7XG4gICAgLy8gYWRkIC5rZXlzLCAudmFsdWVzLCAuZW50cmllcywgW0BAaXRlcmF0b3JdXG4gICAgLy8gMjMuMS4zLjQsIDIzLjEuMy44LCAyMy4xLjMuMTEsIDIzLjEuMy4xMiwgMjMuMi4zLjUsIDIzLjIuMy44LCAyMy4yLjMuMTAsIDIzLjIuMy4xMVxuICAgICRpdGVyRGVmaW5lKEMsIE5BTUUsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICAgICAgdGhpcy5fdCA9IHZhbGlkYXRlKGl0ZXJhdGVkLCBOQU1FKTsgLy8gdGFyZ2V0XG4gICAgICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gICAgICB0aGlzLl9sID0gdW5kZWZpbmVkOyAgICAgICAgICAgICAgICAvLyBwcmV2aW91c1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHZhciBraW5kID0gdGhhdC5faztcbiAgICAgIHZhciBlbnRyeSA9IHRoYXQuX2w7XG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yKSBlbnRyeSA9IGVudHJ5LnA7XG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxuICAgICAgaWYgKCF0aGF0Ll90IHx8ICEodGhhdC5fbCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhhdC5fdC5fZikpIHtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgdGhhdC5fdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHN0ZXAoMSk7XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gc3RlcCBieSBraW5kXG4gICAgICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGVudHJ5LmspO1xuICAgICAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIGVudHJ5LnYpO1xuICAgICAgcmV0dXJuIHN0ZXAoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJywgIUlTX01BUCwgdHJ1ZSk7XG5cbiAgICAvLyBhZGQgW0BAc3BlY2llc10sIDIzLjEuMi4yLCAyMy4yLjIuMlxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG4gIH1cbn07XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBmcm9tID0gcmVxdWlyZSgnLi9fYXJyYXktZnJvbS1pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSkge1xuICByZXR1cm4gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIGlmIChjbGFzc29mKHRoaXMpICE9IE5BTUUpIHRocm93IFR5cGVFcnJvcihOQU1FICsgXCIjdG9KU09OIGlzbid0IGdlbmVyaWNcIik7XG4gICAgcmV0dXJuIGZyb20odGhpcyk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgZ2V0V2VhayA9IHJlcXVpcmUoJy4vX21ldGEnKS5nZXRXZWFrO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIGNyZWF0ZUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpO1xudmFyICRoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBhcnJheUZpbmQgPSBjcmVhdGVBcnJheU1ldGhvZCg1KTtcbnZhciBhcnJheUZpbmRJbmRleCA9IGNyZWF0ZUFycmF5TWV0aG9kKDYpO1xudmFyIGlkID0gMDtcblxuLy8gZmFsbGJhY2sgZm9yIHVuY2F1Z2h0IGZyb3plbiBrZXlzXG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gIHJldHVybiB0aGF0Ll9sIHx8ICh0aGF0Ll9sID0gbmV3IFVuY2F1Z2h0RnJvemVuU3RvcmUoKSk7XG59O1xudmFyIFVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYSA9IFtdO1xufTtcbnZhciBmaW5kVW5jYXVnaHRGcm96ZW4gPSBmdW5jdGlvbiAoc3RvcmUsIGtleSkge1xuICByZXR1cm4gYXJyYXlGaW5kKHN0b3JlLmEsIGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICB9KTtcbn07XG5VbmNhdWdodEZyb3plblN0b3JlLnByb3RvdHlwZSA9IHtcbiAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSByZXR1cm4gZW50cnlbMV07XG4gIH0sXG4gIGhhczogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhIWZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSBlbnRyeVsxXSA9IHZhbHVlO1xuICAgIGVsc2UgdGhpcy5hLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSxcbiAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgaW5kZXggPSBhcnJheUZpbmRJbmRleCh0aGlzLmEsIGZ1bmN0aW9uIChpdCkge1xuICAgICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gICAgfSk7XG4gICAgaWYgKH5pbmRleCkgdGhpcy5hLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuICEhfmluZGV4O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX3QgPSBOQU1FOyAgICAgIC8vIGNvbGxlY3Rpb24gdHlwZVxuICAgICAgdGhhdC5faSA9IGlkKys7ICAgICAgLy8gY29sbGVjdGlvbiBpZFxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgLy8gbGVhayBzdG9yZSBmb3IgdW5jYXVnaHQgZnJvemVuIG9iamVjdHNcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMy4zLjIgV2Vha01hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjQuMy4zIFdlYWtTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIE5BTUUpKVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKSAmJiBkZWxldGUgZGF0YVt0aGlzLl9pXTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4zLjMuNCBXZWFrTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuNC4zLjQgV2Vha1NldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIE5BTUUpKS5oYXMoa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBkYXRhID0gZ2V0V2Vhayhhbk9iamVjdChrZXkpLCB0cnVlKTtcbiAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGF0KS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgZWxzZSBkYXRhW3RoYXQuX2ldID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIHVmc3RvcmU6IHVuY2F1Z2h0RnJvemVuU3RvcmVcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciAkaXRlckRldGVjdCA9IHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0Jyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSykge1xuICB2YXIgQmFzZSA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIEMgPSBCYXNlO1xuICB2YXIgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnO1xuICB2YXIgcHJvdG8gPSBDICYmIEMucHJvdG90eXBlO1xuICB2YXIgTyA9IHt9O1xuICB2YXIgZml4TWV0aG9kID0gZnVuY3Rpb24gKEtFWSkge1xuICAgIHZhciBmbiA9IHByb3RvW0tFWV07XG4gICAgcmVkZWZpbmUocHJvdG8sIEtFWSxcbiAgICAgIEtFWSA9PSAnZGVsZXRlJyA/IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnaGFzJyA/IGZ1bmN0aW9uIGhhcyhhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnZ2V0JyA/IGZ1bmN0aW9uIGdldChhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IHVuZGVmaW5lZCA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2FkZCcgPyBmdW5jdGlvbiBhZGQoYSkgeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7IHJldHVybiB0aGlzOyB9XG4gICAgICAgIDogZnVuY3Rpb24gc2V0KGEsIGIpIHsgZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEsIGIpOyByZXR1cm4gdGhpczsgfVxuICAgICk7XG4gIH07XG4gIGlmICh0eXBlb2YgQyAhPSAnZnVuY3Rpb24nIHx8ICEoSVNfV0VBSyB8fCBwcm90by5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IEMoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpIHtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIEMgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICAgIG1ldGEuTkVFRCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3IEMoKTtcbiAgICAvLyBlYXJseSBpbXBsZW1lbnRhdGlvbnMgbm90IHN1cHBvcnRzIGNoYWluaW5nXG4gICAgdmFyIEhBU05UX0NIQUlOSU5HID0gaW5zdGFuY2VbQURERVJdKElTX1dFQUsgPyB7fSA6IC0wLCAxKSAhPSBpbnN0YW5jZTtcbiAgICAvLyBWOCB+ICBDaHJvbWl1bSA0MC0gd2Vhay1jb2xsZWN0aW9ucyB0aHJvd3Mgb24gcHJpbWl0aXZlcywgYnV0IHNob3VsZCByZXR1cm4gZmFsc2VcbiAgICB2YXIgVEhST1dTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IGluc3RhbmNlLmhhcygxKTsgfSk7XG4gICAgLy8gbW9zdCBlYXJseSBpbXBsZW1lbnRhdGlvbnMgZG9lc24ndCBzdXBwb3J0cyBpdGVyYWJsZXMsIG1vc3QgbW9kZXJuIC0gbm90IGNsb3NlIGl0IGNvcnJlY3RseVxuICAgIHZhciBBQ0NFUFRfSVRFUkFCTEVTID0gJGl0ZXJEZXRlY3QoZnVuY3Rpb24gKGl0ZXIpIHsgbmV3IEMoaXRlcik7IH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIC8vIGZvciBlYXJseSBpbXBsZW1lbnRhdGlvbnMgLTAgYW5kICswIG5vdCB0aGUgc2FtZVxuICAgIHZhciBCVUdHWV9aRVJPID0gIUlTX1dFQUsgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVjggfiBDaHJvbWl1bSA0Mi0gZmFpbHMgb25seSB3aXRoIDUrIGVsZW1lbnRzXG4gICAgICB2YXIgJGluc3RhbmNlID0gbmV3IEMoKTtcbiAgICAgIHZhciBpbmRleCA9IDU7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkgJGluc3RhbmNlW0FEREVSXShpbmRleCwgaW5kZXgpO1xuICAgICAgcmV0dXJuICEkaW5zdGFuY2UuaGFzKC0wKTtcbiAgICB9KTtcbiAgICBpZiAoIUFDQ0VQVF9JVEVSQUJMRVMpIHtcbiAgICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0YXJnZXQsIGl0ZXJhYmxlKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGFyZ2V0LCBDLCBOQU1FKTtcbiAgICAgICAgdmFyIHRoYXQgPSBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSgpLCB0YXJnZXQsIEMpO1xuICAgICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgICAgfSk7XG4gICAgICBDLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgcHJvdG8uY29uc3RydWN0b3IgPSBDO1xuICAgIH1cbiAgICBpZiAoVEhST1dTX09OX1BSSU1JVElWRVMgfHwgQlVHR1lfWkVSTykge1xuICAgICAgZml4TWV0aG9kKCdkZWxldGUnKTtcbiAgICAgIGZpeE1ldGhvZCgnaGFzJyk7XG4gICAgICBJU19NQVAgJiYgZml4TWV0aG9kKCdnZXQnKTtcbiAgICB9XG4gICAgaWYgKEJVR0dZX1pFUk8gfHwgSEFTTlRfQ0hBSU5JTkcpIGZpeE1ldGhvZChBRERFUik7XG4gICAgLy8gd2VhayBjb2xsZWN0aW9ucyBzaG91bGQgbm90IGNvbnRhaW5zIC5jbGVhciBtZXRob2RcbiAgICBpZiAoSVNfV0VBSyAmJiBwcm90by5jbGVhcikgZGVsZXRlIHByb3RvLmNsZWFyO1xuICB9XG5cbiAgc2V0VG9TdHJpbmdUYWcoQywgTkFNRSk7XG5cbiAgT1tOQU1FXSA9IEM7XG4gICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEMgIT0gQmFzZSksIE8pO1xuXG4gIGlmICghSVNfV0VBSykgY29tbW9uLnNldFN0cm9uZyhDLCBOQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDO1xufTtcbiIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjUuMycgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBpbmRleCwgdmFsdWUpIHtcbiAgaWYgKGluZGV4IGluIG9iamVjdCkgJGRlZmluZVByb3BlcnR5LmYob2JqZWN0LCBpbmRleCwgY3JlYXRlRGVzYygwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcbn07XG4iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyMC4zLjQuMzYgLyAxNS45LjUuNDMgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcoKVxudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBnZXRUaW1lID0gRGF0ZS5wcm90b3R5cGUuZ2V0VGltZTtcbnZhciAkdG9JU09TdHJpbmcgPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZztcblxudmFyIGx6ID0gZnVuY3Rpb24gKG51bSkge1xuICByZXR1cm4gbnVtID4gOSA/IG51bSA6ICcwJyArIG51bTtcbn07XG5cbi8vIFBoYW50b21KUyAvIG9sZCBXZWJLaXQgaGFzIGEgYnJva2VuIGltcGxlbWVudGF0aW9uc1xubW9kdWxlLmV4cG9ydHMgPSAoZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJHRvSVNPU3RyaW5nLmNhbGwobmV3IERhdGUoLTVlMTMgLSAxKSkgIT0gJzAzODUtMDctMjVUMDc6MDY6MzkuOTk5Wic7XG59KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAkdG9JU09TdHJpbmcuY2FsbChuZXcgRGF0ZShOYU4pKTtcbn0pKSA/IGZ1bmN0aW9uIHRvSVNPU3RyaW5nKCkge1xuICBpZiAoIWlzRmluaXRlKGdldFRpbWUuY2FsbCh0aGlzKSkpIHRocm93IFJhbmdlRXJyb3IoJ0ludmFsaWQgdGltZSB2YWx1ZScpO1xuICB2YXIgZCA9IHRoaXM7XG4gIHZhciB5ID0gZC5nZXRVVENGdWxsWWVhcigpO1xuICB2YXIgbSA9IGQuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gIHZhciBzID0geSA8IDAgPyAnLScgOiB5ID4gOTk5OSA/ICcrJyA6ICcnO1xuICByZXR1cm4gcyArICgnMDAwMDAnICsgTWF0aC5hYnMoeSkpLnNsaWNlKHMgPyAtNiA6IC00KSArXG4gICAgJy0nICsgbHooZC5nZXRVVENNb250aCgpICsgMSkgKyAnLScgKyBseihkLmdldFVUQ0RhdGUoKSkgK1xuICAgICdUJyArIGx6KGQuZ2V0VVRDSG91cnMoKSkgKyAnOicgKyBseihkLmdldFVUQ01pbnV0ZXMoKSkgK1xuICAgICc6JyArIGx6KGQuZ2V0VVRDU2Vjb25kcygpKSArICcuJyArIChtID4gOTkgPyBtIDogJzAnICsgbHoobSkpICsgJ1onO1xufSA6ICR0b0lTT1N0cmluZztcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgTlVNQkVSID0gJ251bWJlcic7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGhpbnQpIHtcbiAgaWYgKGhpbnQgIT09ICdzdHJpbmcnICYmIGhpbnQgIT09IE5VTUJFUiAmJiBoaW50ICE9PSAnZGVmYXVsdCcpIHRocm93IFR5cGVFcnJvcignSW5jb3JyZWN0IGhpbnQnKTtcbiAgcmV0dXJuIHRvUHJpbWl0aXZlKGFuT2JqZWN0KHRoaXMpLCBoaW50ICE9IE5VTUJFUik7XG59O1xuIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcbiIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IGdldEtleXMoaXQpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYgKGdldFN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpO1xuICAgIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAoc3ltYm9scy5sZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgc291cmNlKSB7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRztcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XG4gIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG4gIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSB8fCAoZ2xvYmFsW25hbWVdID0ge30pIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSk7XG4gIHZhciBrZXksIG93biwgb3V0LCBleHA7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSAob3duID8gdGFyZ2V0IDogc291cmNlKVtrZXldO1xuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgZXhwID0gSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIGlmICh0YXJnZXQpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBvdXQsIHR5cGUgJiAkZXhwb3J0LlUpO1xuICAgIC8vIGV4cG9ydFxuICAgIGlmIChleHBvcnRzW2tleV0gIT0gb3V0KSBoaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcbiAgICBpZiAoSVNfUFJPVE8gJiYgZXhwUHJvdG9ba2V5XSAhPSBvdXQpIGV4cFByb3RvW2tleV0gPSBvdXQ7XG4gIH1cbn07XG5nbG9iYWwuY29yZSA9IGNvcmU7XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG4iLCJ2YXIgTUFUQ0ggPSByZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSkge1xuICB2YXIgcmUgPSAvLi87XG4gIHRyeSB7XG4gICAgJy8uLydbS0VZXShyZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0cnkge1xuICAgICAgcmVbTUFUQ0hdID0gZmFsc2U7XG4gICAgICByZXR1cm4gIScvLi8nW0tFWV0ocmUpO1xuICAgIH0gY2F0Y2ggKGYpIHsgLyogZW1wdHkgKi8gfVxuICB9IHJldHVybiB0cnVlO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBsZW5ndGgsIGV4ZWMpIHtcbiAgdmFyIFNZTUJPTCA9IHdrcyhLRVkpO1xuICB2YXIgZm5zID0gZXhlYyhkZWZpbmVkLCBTWU1CT0wsICcnW0tFWV0pO1xuICB2YXIgc3RyZm4gPSBmbnNbMF07XG4gIHZhciByeGZuID0gZm5zWzFdO1xuICBpZiAoZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHZhciBPID0ge307XG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfTtcbiAgICByZXR1cm4gJydbS0VZXShPKSAhPSA3O1xuICB9KSkge1xuICAgIHJlZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIEtFWSwgc3RyZm4pO1xuICAgIGhpZGUoUmVnRXhwLnByb3RvdHlwZSwgU1lNQk9MLCBsZW5ndGggPT0gMlxuICAgICAgLy8gMjEuMi41LjggUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdKHN0cmluZywgcmVwbGFjZVZhbHVlKVxuICAgICAgLy8gMjEuMi41LjExIFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF0oc3RyaW5nLCBsaW1pdClcbiAgICAgID8gZnVuY3Rpb24gKHN0cmluZywgYXJnKSB7IHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzLCBhcmcpOyB9XG4gICAgICAvLyAyMS4yLjUuNiBSZWdFeHAucHJvdG90eXBlW0BAbWF0Y2hdKHN0cmluZylcbiAgICAgIC8vIDIxLjIuNS45IFJlZ0V4cC5wcm90b3R5cGVbQEBzZWFyY2hdKHN0cmluZylcbiAgICAgIDogZnVuY3Rpb24gKHN0cmluZykgeyByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcyk7IH1cbiAgICApO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gYW5PYmplY3QodGhpcyk7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoYXQuZ2xvYmFsKSByZXN1bHQgKz0gJ2cnO1xuICBpZiAodGhhdC5pZ25vcmVDYXNlKSByZXN1bHQgKz0gJ2knO1xuICBpZiAodGhhdC5tdWx0aWxpbmUpIHJlc3VsdCArPSAnbSc7XG4gIGlmICh0aGF0LnVuaWNvZGUpIHJlc3VsdCArPSAndSc7XG4gIGlmICh0aGF0LnN0aWNreSkgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLWZsYXRNYXAvI3NlYy1GbGF0dGVuSW50b0FycmF5XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIElTX0NPTkNBVF9TUFJFQURBQkxFID0gcmVxdWlyZSgnLi9fd2tzJykoJ2lzQ29uY2F0U3ByZWFkYWJsZScpO1xuXG5mdW5jdGlvbiBmbGF0dGVuSW50b0FycmF5KHRhcmdldCwgb3JpZ2luYWwsIHNvdXJjZSwgc291cmNlTGVuLCBzdGFydCwgZGVwdGgsIG1hcHBlciwgdGhpc0FyZykge1xuICB2YXIgdGFyZ2V0SW5kZXggPSBzdGFydDtcbiAgdmFyIHNvdXJjZUluZGV4ID0gMDtcbiAgdmFyIG1hcEZuID0gbWFwcGVyID8gY3R4KG1hcHBlciwgdGhpc0FyZywgMykgOiBmYWxzZTtcbiAgdmFyIGVsZW1lbnQsIHNwcmVhZGFibGU7XG5cbiAgd2hpbGUgKHNvdXJjZUluZGV4IDwgc291cmNlTGVuKSB7XG4gICAgaWYgKHNvdXJjZUluZGV4IGluIHNvdXJjZSkge1xuICAgICAgZWxlbWVudCA9IG1hcEZuID8gbWFwRm4oc291cmNlW3NvdXJjZUluZGV4XSwgc291cmNlSW5kZXgsIG9yaWdpbmFsKSA6IHNvdXJjZVtzb3VyY2VJbmRleF07XG5cbiAgICAgIHNwcmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmIChpc09iamVjdChlbGVtZW50KSkge1xuICAgICAgICBzcHJlYWRhYmxlID0gZWxlbWVudFtJU19DT05DQVRfU1BSRUFEQUJMRV07XG4gICAgICAgIHNwcmVhZGFibGUgPSBzcHJlYWRhYmxlICE9PSB1bmRlZmluZWQgPyAhIXNwcmVhZGFibGUgOiBpc0FycmF5KGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3ByZWFkYWJsZSAmJiBkZXB0aCA+IDApIHtcbiAgICAgICAgdGFyZ2V0SW5kZXggPSBmbGF0dGVuSW50b0FycmF5KHRhcmdldCwgb3JpZ2luYWwsIGVsZW1lbnQsIHRvTGVuZ3RoKGVsZW1lbnQubGVuZ3RoKSwgdGFyZ2V0SW5kZXgsIGRlcHRoIC0gMSkgLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRhcmdldEluZGV4ID49IDB4MWZmZmZmZmZmZmZmZmYpIHRocm93IFR5cGVFcnJvcigpO1xuICAgICAgICB0YXJnZXRbdGFyZ2V0SW5kZXhdID0gZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0SW5kZXgrKztcbiAgICB9XG4gICAgc291cmNlSW5kZXgrKztcbiAgfVxuICByZXR1cm4gdGFyZ2V0SW5kZXg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbkludG9BcnJheTtcbiIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgQlJFQUsgPSB7fTtcbnZhciBSRVRVUk4gPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUikge1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyYWJsZTsgfSA6IGdldEl0ZXJGbihpdGVyYWJsZSk7XG4gIHZhciBmID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmIChpc0FycmF5SXRlcihpdGVyRm4pKSBmb3IgKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOykge1xuICAgIHJlc3VsdCA9IGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuIiwidmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIHRhcmdldCwgQykge1xuICB2YXIgUyA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgdmFyIFA7XG4gIGlmIChTICE9PSBDICYmIHR5cGVvZiBTID09ICdmdW5jdGlvbicgJiYgKFAgPSBTLnByb3RvdHlwZSkgIT09IEMucHJvdG90eXBlICYmIGlzT2JqZWN0KFApICYmIHNldFByb3RvdHlwZU9mKSB7XG4gICAgc2V0UHJvdG90eXBlT2YodGhhdCwgUCk7XG4gIH0gcmV0dXJuIHRoYXQ7XG59O1xuIiwiLy8gZmFzdCBhcHBseSwgaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgYXJncywgdGhhdCkge1xuICB2YXIgdW4gPSB0aGF0ID09PSB1bmRlZmluZWQ7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgfSByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJncyk7XG59O1xuIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcbiIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59O1xuIiwiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG4iLCIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNJbnRlZ2VyKGl0KSB7XG4gIHJldHVybiAhaXNPYmplY3QoaXQpICYmIGlzRmluaXRlKGl0KSAmJiBmbG9vcihpdCkgPT09IGl0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuIiwiLy8gNy4yLjggSXNSZWdFeHAoYXJndW1lbnQpXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBNQVRDSCA9IHJlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSF0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY29mKGl0KSA9PSAnUmVnRXhwJyk7XG59O1xuIiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gKCFCVUdHWSAmJiAkbmF0aXZlKSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG4iLCJ2YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbiAoKSB7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgc2tpcENsb3NpbmcpIHtcbiAgaWYgKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IFs3XTtcbiAgICB2YXIgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7IGRvbmU6IHNhZmUgPSB0cnVlIH07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmUgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcbiIsIi8vIDIwLjIuMi4xNCBNYXRoLmV4cG0xKHgpXG52YXIgJGV4cG0xID0gTWF0aC5leHBtMTtcbm1vZHVsZS5leHBvcnRzID0gKCEkZXhwbTFcbiAgLy8gT2xkIEZGIGJ1Z1xuICB8fCAkZXhwbTEoMTApID4gMjIwMjUuNDY1Nzk0ODA2NzE5IHx8ICRleHBtMSgxMCkgPCAyMjAyNS40NjU3OTQ4MDY3MTY1MTY4XG4gIC8vIFRvciBCcm93c2VyIGJ1Z1xuICB8fCAkZXhwbTEoLTJlLTE3KSAhPSAtMmUtMTdcbikgPyBmdW5jdGlvbiBleHBtMSh4KSB7XG4gIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IHggPiAtMWUtNiAmJiB4IDwgMWUtNiA/IHggKyB4ICogeCAvIDIgOiBNYXRoLmV4cCh4KSAtIDE7XG59IDogJGV4cG0xO1xuIiwiLy8gMjAuMi4yLjE2IE1hdGguZnJvdW5kKHgpXG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpO1xudmFyIHBvdyA9IE1hdGgucG93O1xudmFyIEVQU0lMT04gPSBwb3coMiwgLTUyKTtcbnZhciBFUFNJTE9OMzIgPSBwb3coMiwgLTIzKTtcbnZhciBNQVgzMiA9IHBvdygyLCAxMjcpICogKDIgLSBFUFNJTE9OMzIpO1xudmFyIE1JTjMyID0gcG93KDIsIC0xMjYpO1xuXG52YXIgcm91bmRUaWVzVG9FdmVuID0gZnVuY3Rpb24gKG4pIHtcbiAgcmV0dXJuIG4gKyAxIC8gRVBTSUxPTiAtIDEgLyBFUFNJTE9OO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLmZyb3VuZCB8fCBmdW5jdGlvbiBmcm91bmQoeCkge1xuICB2YXIgJGFicyA9IE1hdGguYWJzKHgpO1xuICB2YXIgJHNpZ24gPSBzaWduKHgpO1xuICB2YXIgYSwgcmVzdWx0O1xuICBpZiAoJGFicyA8IE1JTjMyKSByZXR1cm4gJHNpZ24gKiByb3VuZFRpZXNUb0V2ZW4oJGFicyAvIE1JTjMyIC8gRVBTSUxPTjMyKSAqIE1JTjMyICogRVBTSUxPTjMyO1xuICBhID0gKDEgKyBFUFNJTE9OMzIgLyBFUFNJTE9OKSAqICRhYnM7XG4gIHJlc3VsdCA9IGEgLSAoYSAtICRhYnMpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIGlmIChyZXN1bHQgPiBNQVgzMiB8fCByZXN1bHQgIT0gcmVzdWx0KSByZXR1cm4gJHNpZ24gKiBJbmZpbml0eTtcbiAgcmV0dXJuICRzaWduICogcmVzdWx0O1xufTtcbiIsIi8vIDIwLjIuMi4yMCBNYXRoLmxvZzFwKHgpXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGgubG9nMXAgfHwgZnVuY3Rpb24gbG9nMXAoeCkge1xuICByZXR1cm4gKHggPSAreCkgPiAtMWUtOCAmJiB4IDwgMWUtOCA/IHggLSB4ICogeCAvIDIgOiBNYXRoLmxvZygxICsgeCk7XG59O1xuIiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnNjYWxlIHx8IGZ1bmN0aW9uIHNjYWxlKHgsIGluTG93LCBpbkhpZ2gsIG91dExvdywgb3V0SGlnaCkge1xuICBpZiAoXG4gICAgYXJndW1lbnRzLmxlbmd0aCA9PT0gMFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgfHwgeCAhPSB4XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICB8fCBpbkxvdyAhPSBpbkxvd1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgfHwgaW5IaWdoICE9IGluSGlnaFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgfHwgb3V0TG93ICE9IG91dExvd1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgfHwgb3V0SGlnaCAhPSBvdXRIaWdoXG4gICkgcmV0dXJuIE5hTjtcbiAgaWYgKHggPT09IEluZmluaXR5IHx8IHggPT09IC1JbmZpbml0eSkgcmV0dXJuIHg7XG4gIHJldHVybiAoeCAtIGluTG93KSAqIChvdXRIaWdoIC0gb3V0TG93KSAvIChpbkhpZ2ggLSBpbkxvdykgKyBvdXRMb3c7XG59O1xuIiwiLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24gc2lnbih4KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgfHwgeCAhPSB4ID8geCA6IHggPCAwID8gLTEgOiAxO1xufTtcbiIsInZhciBNRVRBID0gcmVxdWlyZSgnLi9fdWlkJykoJ21ldGEnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHNldERlc2MgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGlkID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIEZSRUVaRSA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgc2V0RGVzYyhpdCwgTUVUQSwgeyB2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gfSk7XG59O1xudmFyIGZhc3RLZXkgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIGhhc2ggd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSByZXR1cm4gaXRbTUVUQV0udztcbn07XG4vLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcbnZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoRlJFRVpFICYmIG1ldGEuTkVFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXMoaXQsIE1FVEEpKSBzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogTUVUQSxcbiAgTkVFRDogZmFsc2UsXG4gIGZhc3RLZXk6IGZhc3RLZXksXG4gIGdldFdlYWs6IGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcbiIsInZhciBNYXAgPSByZXF1aXJlKCcuL2VzNi5tYXAnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ21ldGFkYXRhJyk7XG52YXIgc3RvcmUgPSBzaGFyZWQuc3RvcmUgfHwgKHNoYXJlZC5zdG9yZSA9IG5ldyAocmVxdWlyZSgnLi9lczYud2Vhay1tYXAnKSkoKSk7XG5cbnZhciBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwID0gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0S2V5LCBjcmVhdGUpIHtcbiAgdmFyIHRhcmdldE1ldGFkYXRhID0gc3RvcmUuZ2V0KHRhcmdldCk7XG4gIGlmICghdGFyZ2V0TWV0YWRhdGEpIHtcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBzdG9yZS5zZXQodGFyZ2V0LCB0YXJnZXRNZXRhZGF0YSA9IG5ldyBNYXAoKSk7XG4gIH1cbiAgdmFyIGtleU1ldGFkYXRhID0gdGFyZ2V0TWV0YWRhdGEuZ2V0KHRhcmdldEtleSk7XG4gIGlmICgha2V5TWV0YWRhdGEpIHtcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB0YXJnZXRNZXRhZGF0YS5zZXQodGFyZ2V0S2V5LCBrZXlNZXRhZGF0YSA9IG5ldyBNYXAoKSk7XG4gIH0gcmV0dXJuIGtleU1ldGFkYXRhO1xufTtcbnZhciBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gZnVuY3Rpb24gKE1ldGFkYXRhS2V5LCBPLCBQKSB7XG4gIHZhciBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgZmFsc2UpO1xuICByZXR1cm4gbWV0YWRhdGFNYXAgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogbWV0YWRhdGFNYXAuaGFzKE1ldGFkYXRhS2V5KTtcbn07XG52YXIgb3JkaW5hcnlHZXRPd25NZXRhZGF0YSA9IGZ1bmN0aW9uIChNZXRhZGF0YUtleSwgTywgUCkge1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIGZhbHNlKTtcbiAgcmV0dXJuIG1ldGFkYXRhTWFwID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBtZXRhZGF0YU1hcC5nZXQoTWV0YWRhdGFLZXkpO1xufTtcbnZhciBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhID0gZnVuY3Rpb24gKE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlLCBPLCBQKSB7XG4gIGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgdHJ1ZSkuc2V0KE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlKTtcbn07XG52YXIgb3JkaW5hcnlPd25NZXRhZGF0YUtleXMgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRLZXkpIHtcbiAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCh0YXJnZXQsIHRhcmdldEtleSwgZmFsc2UpO1xuICB2YXIga2V5cyA9IFtdO1xuICBpZiAobWV0YWRhdGFNYXApIG1ldGFkYXRhTWFwLmZvckVhY2goZnVuY3Rpb24gKF8sIGtleSkgeyBrZXlzLnB1c2goa2V5KTsgfSk7XG4gIHJldHVybiBrZXlzO1xufTtcbnZhciB0b01ldGFLZXkgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiBTdHJpbmcoaXQpO1xufTtcbnZhciBleHAgPSBmdW5jdGlvbiAoTykge1xuICAkZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCBPKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzdG9yZTogc3RvcmUsXG4gIG1hcDogZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCxcbiAgaGFzOiBvcmRpbmFyeUhhc093bk1ldGFkYXRhLFxuICBnZXQ6IG9yZGluYXJ5R2V0T3duTWV0YWRhdGEsXG4gIHNldDogb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSxcbiAga2V5czogb3JkaW5hcnlPd25NZXRhZGF0YUtleXMsXG4gIGtleTogdG9NZXRhS2V5LFxuICBleHA6IGV4cFxufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBtYWNyb3Rhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0O1xudmFyIE9ic2VydmVyID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIFByb21pc2UgPSBnbG9iYWwuUHJvbWlzZTtcbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGVhZCwgbGFzdCwgbm90aWZ5O1xuXG4gIHZhciBmbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZiAoaXNOb2RlICYmIChwYXJlbnQgPSBwcm9jZXNzLmRvbWFpbikpIHBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgIGZuID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoaGVhZCkgbm90aWZ5KCk7XG4gICAgICAgIGVsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHBhcmVudCkgcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gTm9kZS5qc1xuICBpZiAoaXNOb2RlKSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcbiAgLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyLCBleGNlcHQgaU9TIFNhZmFyaSAtIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8zMzlcbiAgfSBlbHNlIGlmIChPYnNlcnZlciAmJiAhKGdsb2JhbC5uYXZpZ2F0b3IgJiYgZ2xvYmFsLm5hdmlnYXRvci5zdGFuZGFsb25lKSkge1xuICAgIHZhciB0b2dnbGUgPSB0cnVlO1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcbiAgICB9O1xuICAvLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxuICB9IGVsc2UgaWYgKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKSB7XG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuY2FsbChnbG9iYWwpXG4gICAgICBtYWNyb3Rhc2suY2FsbChnbG9iYWwsIGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgIHZhciB0YXNrID0geyBmbjogZm4sIG5leHQ6IHVuZGVmaW5lZCB9O1xuICAgIGlmIChsYXN0KSBsYXN0Lm5leHQgPSB0YXNrO1xuICAgIGlmICghaGVhZCkge1xuICAgICAgaGVhZCA9IHRhc2s7XG4gICAgICBub3RpZnkoKTtcbiAgICB9IGxhc3QgPSB0YXNrO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDI1LjQuMS41IE5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xuXG5mdW5jdGlvbiBQcm9taXNlQ2FwYWJpbGl0eShDKSB7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uICgkJHJlc29sdmUsICQkcmVqZWN0KSB7XG4gICAgaWYgKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ID0gYUZ1bmN0aW9uKHJlamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiAoQykge1xuICByZXR1cm4gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgUyA9IFN5bWJvbCgpO1xuICB2YXIgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICB3aGlsZSAoYUxlbiA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikgaWYgKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpIFRba2V5XSA9IFNba2V5XTtcbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBkUHMgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKTtcbiAgdmFyIGkgPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHZhciBsdCA9ICc8JztcbiAgdmFyIGd0ID0gJz4nO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUgKGktLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5KCk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgUDtcbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEZvcmNlZCByZXBsYWNlbWVudCBwcm90b3R5cGUgYWNjZXNzb3JzIG1ldGhvZHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fbGlicmFyeScpIHx8ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgdmFyIEsgPSBNYXRoLnJhbmRvbSgpO1xuICAvLyBJbiBGRiB0aHJvd3Mgb25seSBkZWZpbmUgbWV0aG9kc1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWYsIG5vLXVzZWxlc3MtY2FsbFxuICBfX2RlZmluZVNldHRlcl9fLmNhbGwobnVsbCwgSywgZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbiAgZGVsZXRlIHJlcXVpcmUoJy4vX2dsb2JhbCcpW0tdO1xufSk7XG4iLCJ2YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcbiIsIi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdPUE4oaXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XG59O1xuIiwiLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGhpZGRlbktleXMpO1xufTtcbiIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4iLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTtcbiIsInZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pIGlmIChrZXkgIT0gSUVfUFJPVE8pIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcbiIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuIiwiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBleGVjKSB7XG4gIHZhciBmbiA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXTtcbiAgdmFyIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07XG4iLCJ2YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGlzRW51bSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXNFbnRyaWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdChpdCk7XG4gICAgdmFyIGtleXMgPSBnZXRLZXlzKE8pO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGkpIGlmIChpc0VudW0uY2FsbChPLCBrZXkgPSBrZXlzW2krK10pKSB7XG4gICAgICByZXN1bHQucHVzaChpc0VudHJpZXMgPyBba2V5LCBPW2tleV1dIDogT1trZXldKTtcbiAgICB9IHJldHVybiByZXN1bHQ7XG4gIH07XG59O1xuIiwiLy8gYWxsIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9sc1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgUmVmbGVjdCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IFJlZmxlY3QgJiYgUmVmbGVjdC5vd25LZXlzIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnT1BOLmYoYW5PYmplY3QoaXQpKTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIHJldHVybiBnZXRTeW1ib2xzID8ga2V5cy5jb25jYXQoZ2V0U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG4iLCJ2YXIgJHBhcnNlRmxvYXQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5wYXJzZUZsb2F0O1xudmFyICR0cmltID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltO1xuXG5tb2R1bGUuZXhwb3J0cyA9IDEgLyAkcGFyc2VGbG9hdChyZXF1aXJlKCcuL19zdHJpbmctd3MnKSArICctMCcpICE9PSAtSW5maW5pdHkgPyBmdW5jdGlvbiBwYXJzZUZsb2F0KHN0cikge1xuICB2YXIgc3RyaW5nID0gJHRyaW0oU3RyaW5nKHN0ciksIDMpO1xuICB2YXIgcmVzdWx0ID0gJHBhcnNlRmxvYXQoc3RyaW5nKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gMCAmJiBzdHJpbmcuY2hhckF0KDApID09ICctJyA/IC0wIDogcmVzdWx0O1xufSA6ICRwYXJzZUZsb2F0O1xuIiwidmFyICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnBhcnNlSW50O1xudmFyICR0cmltID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltO1xudmFyIHdzID0gcmVxdWlyZSgnLi9fc3RyaW5nLXdzJyk7XG52YXIgaGV4ID0gL15bLStdPzBbeFhdLztcblxubW9kdWxlLmV4cG9ydHMgPSAkcGFyc2VJbnQod3MgKyAnMDgnKSAhPT0gOCB8fCAkcGFyc2VJbnQod3MgKyAnMHgxNicpICE9PSAyMiA/IGZ1bmN0aW9uIHBhcnNlSW50KHN0ciwgcmFkaXgpIHtcbiAgdmFyIHN0cmluZyA9ICR0cmltKFN0cmluZyhzdHIpLCAzKTtcbiAgcmV0dXJuICRwYXJzZUludChzdHJpbmcsIChyYWRpeCA+Pj4gMCkgfHwgKGhleC50ZXN0KHN0cmluZykgPyAxNiA6IDEwKSk7XG59IDogJHBhcnNlSW50O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiB7IGU6IGZhbHNlLCB2OiBleGVjKCkgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7IGU6IHRydWUsIHY6IGUgfTtcbiAgfVxufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEMsIHgpIHtcbiAgYW5PYmplY3QoQyk7XG4gIGlmIChpc09iamVjdCh4KSAmJiB4LmNvbnN0cnVjdG9yID09PSBDKSByZXR1cm4geDtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZihDKTtcbiAgdmFyIHJlc29sdmUgPSBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlO1xuICByZXNvbHZlKHgpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuIiwidmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBzYWZlKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgc2FmZSk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgU1JDID0gcmVxdWlyZSgnLi9fdWlkJykoJ3NyYycpO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgJHRvU3RyaW5nID0gRnVuY3Rpb25bVE9fU1RSSU5HXTtcbnZhciBUUEwgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbnJlcXVpcmUoJy4vX2NvcmUnKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiAkdG9TdHJpbmcuY2FsbChpdCk7XG59O1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywga2V5LCB2YWwsIHNhZmUpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgdmFsID09ICdmdW5jdGlvbic7XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCAnbmFtZScpIHx8IGhpZGUodmFsLCAnbmFtZScsIGtleSk7XG4gIGlmIChPW2tleV0gPT09IHZhbCkgcmV0dXJuO1xuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgU1JDKSB8fCBoaWRlKHZhbCwgU1JDLCBPW2tleV0gPyAnJyArIE9ba2V5XSA6IFRQTC5qb2luKFN0cmluZyhrZXkpKSk7XG4gIGlmIChPID09PSBnbG9iYWwpIHtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSBpZiAoIXNhZmUpIHtcbiAgICBkZWxldGUgT1trZXldO1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9IGVsc2UgaWYgKE9ba2V5XSkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgfVxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbn0pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocmVnRXhwLCByZXBsYWNlKSB7XG4gIHZhciByZXBsYWNlciA9IHJlcGxhY2UgPT09IE9iamVjdChyZXBsYWNlKSA/IGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgcmV0dXJuIHJlcGxhY2VbcGFydF07XG4gIH0gOiByZXBsYWNlO1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIFN0cmluZyhpdCkucmVwbGFjZShyZWdFeHAsIHJlcGxhY2VyKTtcbiAgfTtcbn07XG4iLCIvLyA3LjIuOSBTYW1lVmFsdWUoeCwgeSlcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmlzIHx8IGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICByZXR1cm4geCA9PT0geSA/IHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5IDogeCAhPSB4ICYmIHkgIT0geTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT0xMRUNUSU9OKSB7XG4gICRleHBvcnQoJGV4cG9ydC5TLCBDT0xMRUNUSU9OLCB7IGZyb206IGZ1bmN0aW9uIGZyb20oc291cmNlIC8qICwgbWFwRm4sIHRoaXNBcmcgKi8pIHtcbiAgICB2YXIgbWFwRm4gPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIG1hcHBpbmcsIEEsIG4sIGNiO1xuICAgIGFGdW5jdGlvbih0aGlzKTtcbiAgICBtYXBwaW5nID0gbWFwRm4gIT09IHVuZGVmaW5lZDtcbiAgICBpZiAobWFwcGluZykgYUZ1bmN0aW9uKG1hcEZuKTtcbiAgICBpZiAoc291cmNlID09IHVuZGVmaW5lZCkgcmV0dXJuIG5ldyB0aGlzKCk7XG4gICAgQSA9IFtdO1xuICAgIGlmIChtYXBwaW5nKSB7XG4gICAgICBuID0gMDtcbiAgICAgIGNiID0gY3R4KG1hcEZuLCBhcmd1bWVudHNbMl0sIDIpO1xuICAgICAgZm9yT2Yoc291cmNlLCBmYWxzZSwgZnVuY3Rpb24gKG5leHRJdGVtKSB7XG4gICAgICAgIEEucHVzaChjYihuZXh0SXRlbSwgbisrKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yT2Yoc291cmNlLCBmYWxzZSwgQS5wdXNoLCBBKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyB0aGlzKEEpO1xuICB9IH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENPTExFQ1RJT04pIHtcbiAgJGV4cG9ydCgkZXhwb3J0LlMsIENPTExFQ1RJT04sIHsgb2Y6IGZ1bmN0aW9uIG9mKCkge1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBBID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSBBW2xlbmd0aF0gPSBhcmd1bWVudHNbbGVuZ3RoXTtcbiAgICByZXR1cm4gbmV3IHRoaXMoQSk7XG4gIH0gfSk7XG59O1xuIiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uIChPLCBwcm90bykge1xuICBhbk9iamVjdChPKTtcbiAgaWYgKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpIHRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uICh0ZXN0LCBidWdneSwgc2V0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaCAoZSkgeyBidWdneSA9IHRydWU7IH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmIChidWdneSkgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgdmFyIEMgPSBnbG9iYWxbS0VZXTtcbiAgaWYgKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pIGRQLmYoQywgU1BFQ0lFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59O1xuIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTtcbn07XG4iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07XG4iLCIvLyA3LjMuMjAgU3BlY2llc0NvbnN0cnVjdG9yKE8sIGRlZmF1bHRDb25zdHJ1Y3RvcilcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIEQpIHtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvcjtcbiAgdmFyIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gRCA6IGFGdW5jdGlvbihTKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtZXRob2QsIGFyZykge1xuICByZXR1cm4gISFtZXRob2QgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNhbGxcbiAgICBhcmcgPyBtZXRob2QuY2FsbChudWxsLCBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sIDEpIDogbWV0aG9kLmNhbGwobnVsbCk7XG4gIH0pO1xufTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUT19TVFJJTkcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBwb3MpIHtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbiAgICB2YXIgaSA9IHRvSW50ZWdlcihwb3MpO1xuICAgIHZhciBsID0gcy5sZW5ndGg7XG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKGkgPCAwIHx8IGkgPj0gbCkgcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG4iLCIvLyBoZWxwZXIgZm9yIFN0cmluZyN7c3RhcnRzV2l0aCwgZW5kc1dpdGgsIGluY2x1ZGVzfVxudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGhhdCwgc2VhcmNoU3RyaW5nLCBOQU1FKSB7XG4gIGlmIChpc1JlZ0V4cChzZWFyY2hTdHJpbmcpKSB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZyMnICsgTkFNRSArIFwiIGRvZXNuJ3QgYWNjZXB0IHJlZ2V4IVwiKTtcbiAgcmV0dXJuIFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbn07XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xudmFyIHF1b3QgPSAvXCIvZztcbi8vIEIuMi4zLjIuMSBDcmVhdGVIVE1MKHN0cmluZywgdGFnLCBhdHRyaWJ1dGUsIHZhbHVlKVxudmFyIGNyZWF0ZUhUTUwgPSBmdW5jdGlvbiAoc3RyaW5nLCB0YWcsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgdmFyIFMgPSBTdHJpbmcoZGVmaW5lZChzdHJpbmcpKTtcbiAgdmFyIHAxID0gJzwnICsgdGFnO1xuICBpZiAoYXR0cmlidXRlICE9PSAnJykgcDEgKz0gJyAnICsgYXR0cmlidXRlICsgJz1cIicgKyBTdHJpbmcodmFsdWUpLnJlcGxhY2UocXVvdCwgJyZxdW90OycpICsgJ1wiJztcbiAgcmV0dXJuIHAxICsgJz4nICsgUyArICc8LycgKyB0YWcgKyAnPic7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSwgZXhlYykge1xuICB2YXIgTyA9IHt9O1xuICBPW05BTUVdID0gZXhlYyhjcmVhdGVIVE1MKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRlc3QgPSAnJ1tOQU1FXSgnXCInKTtcbiAgICByZXR1cm4gdGVzdCAhPT0gdGVzdC50b0xvd2VyQ2FzZSgpIHx8IHRlc3Quc3BsaXQoJ1wiJykubGVuZ3RoID4gMztcbiAgfSksICdTdHJpbmcnLCBPKTtcbn07XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgcmVwZWF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIG1heExlbmd0aCwgZmlsbFN0cmluZywgbGVmdCkge1xuICB2YXIgUyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbiAgdmFyIHN0cmluZ0xlbmd0aCA9IFMubGVuZ3RoO1xuICB2YXIgZmlsbFN0ciA9IGZpbGxTdHJpbmcgPT09IHVuZGVmaW5lZCA/ICcgJyA6IFN0cmluZyhmaWxsU3RyaW5nKTtcbiAgdmFyIGludE1heExlbmd0aCA9IHRvTGVuZ3RoKG1heExlbmd0aCk7XG4gIGlmIChpbnRNYXhMZW5ndGggPD0gc3RyaW5nTGVuZ3RoIHx8IGZpbGxTdHIgPT0gJycpIHJldHVybiBTO1xuICB2YXIgZmlsbExlbiA9IGludE1heExlbmd0aCAtIHN0cmluZ0xlbmd0aDtcbiAgdmFyIHN0cmluZ0ZpbGxlciA9IHJlcGVhdC5jYWxsKGZpbGxTdHIsIE1hdGguY2VpbChmaWxsTGVuIC8gZmlsbFN0ci5sZW5ndGgpKTtcbiAgaWYgKHN0cmluZ0ZpbGxlci5sZW5ndGggPiBmaWxsTGVuKSBzdHJpbmdGaWxsZXIgPSBzdHJpbmdGaWxsZXIuc2xpY2UoMCwgZmlsbExlbik7XG4gIHJldHVybiBsZWZ0ID8gc3RyaW5nRmlsbGVyICsgUyA6IFMgKyBzdHJpbmdGaWxsZXI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcGVhdChjb3VudCkge1xuICB2YXIgc3RyID0gU3RyaW5nKGRlZmluZWQodGhpcykpO1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBuID0gdG9JbnRlZ2VyKGNvdW50KTtcbiAgaWYgKG4gPCAwIHx8IG4gPT0gSW5maW5pdHkpIHRocm93IFJhbmdlRXJyb3IoXCJDb3VudCBjYW4ndCBiZSBuZWdhdGl2ZVwiKTtcbiAgZm9yICg7biA+IDA7IChuID4+Pj0gMSkgJiYgKHN0ciArPSBzdHIpKSBpZiAobiAmIDEpIHJlcyArPSBzdHI7XG4gIHJldHVybiByZXM7XG59O1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBzcGFjZXMgPSByZXF1aXJlKCcuL19zdHJpbmctd3MnKTtcbnZhciBzcGFjZSA9ICdbJyArIHNwYWNlcyArICddJztcbnZhciBub24gPSAnXFx1MjAwYlxcdTAwODUnO1xudmFyIGx0cmltID0gUmVnRXhwKCdeJyArIHNwYWNlICsgc3BhY2UgKyAnKicpO1xudmFyIHJ0cmltID0gUmVnRXhwKHNwYWNlICsgc3BhY2UgKyAnKiQnKTtcblxudmFyIGV4cG9ydGVyID0gZnVuY3Rpb24gKEtFWSwgZXhlYywgQUxJQVMpIHtcbiAgdmFyIGV4cCA9IHt9O1xuICB2YXIgRk9SQ0UgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhc3BhY2VzW0tFWV0oKSB8fCBub25bS0VZXSgpICE9IG5vbjtcbiAgfSk7XG4gIHZhciBmbiA9IGV4cFtLRVldID0gRk9SQ0UgPyBleGVjKHRyaW0pIDogc3BhY2VzW0tFWV07XG4gIGlmIChBTElBUykgZXhwW0FMSUFTXSA9IGZuO1xuICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIEZPUkNFLCAnU3RyaW5nJywgZXhwKTtcbn07XG5cbi8vIDEgLT4gU3RyaW5nI3RyaW1MZWZ0XG4vLyAyIC0+IFN0cmluZyN0cmltUmlnaHRcbi8vIDMgLT4gU3RyaW5nI3RyaW1cbnZhciB0cmltID0gZXhwb3J0ZXIudHJpbSA9IGZ1bmN0aW9uIChzdHJpbmcsIFRZUEUpIHtcbiAgc3RyaW5nID0gU3RyaW5nKGRlZmluZWQoc3RyaW5nKSk7XG4gIGlmIChUWVBFICYgMSkgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UobHRyaW0sICcnKTtcbiAgaWYgKFRZUEUgJiAyKSBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShydHJpbSwgJycpO1xuICByZXR1cm4gc3RyaW5nO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0gJ1xceDA5XFx4MEFcXHgwQlxceDBDXFx4MERcXHgyMFxceEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzJyArXG4gICdcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOFxcdTIwMjlcXHVGRUZGJztcbiIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBpbnZva2UgPSByZXF1aXJlKCcuL19pbnZva2UnKTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi9faHRtbCcpO1xudmFyIGNlbCA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgc2V0VGFzayA9IGdsb2JhbC5zZXRJbW1lZGlhdGU7XG52YXIgY2xlYXJUYXNrID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlO1xudmFyIE1lc3NhZ2VDaGFubmVsID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsO1xudmFyIERpc3BhdGNoID0gZ2xvYmFsLkRpc3BhdGNoO1xudmFyIGNvdW50ZXIgPSAwO1xudmFyIHF1ZXVlID0ge307XG52YXIgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG52YXIgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG52YXIgcnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaWQgPSArdGhpcztcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICBpZiAocXVldWUuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZiAoIXNldFRhc2sgfHwgIWNsZWFyVGFzaykge1xuICBzZXRUYXNrID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgaSA9IDE7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICAgIGludm9rZSh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhclRhc2sgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCkge1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZiAocmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBTcGhlcmUgKEpTIGdhbWUgZW5naW5lKSBEaXNwYXRjaCBBUElcbiAgfSBlbHNlIGlmIChEaXNwYXRjaCAmJiBEaXNwYXRjaC5ub3cpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgRGlzcGF0Y2gubm93KGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICB9IGVsc2UgaWYgKE1lc3NhZ2VDaGFubmVsKSB7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdGVuZXI7XG4gICAgZGVmZXIgPSBjdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcbiAgICB9O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYgKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjZWwoJ3NjcmlwdCcpKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY2VsKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBzZXRUaW1lb3V0KGN0eChydW4sIGlkLCAxKSwgMCk7XG4gICAgfTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9pbmRleFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09PSB1bmRlZmluZWQpIHJldHVybiAwO1xuICB2YXIgbnVtYmVyID0gdG9JbnRlZ2VyKGl0KTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKG51bWJlcik7XG4gIGlmIChudW1iZXIgIT09IGxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcignV3JvbmcgbGVuZ3RoIScpO1xuICByZXR1cm4gbGVuZ3RoO1xufTtcbiIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgUykge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5pZiAocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSkge1xuICB2YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbiAgdmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xuICB2YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xuICB2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuICB2YXIgJHR5cGVkID0gcmVxdWlyZSgnLi9fdHlwZWQnKTtcbiAgdmFyICRidWZmZXIgPSByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKTtcbiAgdmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xuICB2YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG4gIHZhciBwcm9wZXJ0eURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG4gIHZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xuICB2YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbiAgdmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbiAgdmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG4gIHZhciB0b0luZGV4ID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKTtcbiAgdmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG4gIHZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuICB2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG4gIHZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xuICB2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbiAgdmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG4gIHZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbiAgdmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbiAgdmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuICB2YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbiAgdmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG4gIHZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbiAgdmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xuICB2YXIgY3JlYXRlQXJyYXlNZXRob2QgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJyk7XG4gIHZhciBjcmVhdGVBcnJheUluY2x1ZGVzID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKTtcbiAgdmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbiAgdmFyIEFycmF5SXRlcmF0b3JzID0gcmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbiAgdmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xuICB2YXIgJGl0ZXJEZXRlY3QgPSByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpO1xuICB2YXIgc2V0U3BlY2llcyA9IHJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJyk7XG4gIHZhciBhcnJheUZpbGwgPSByZXF1aXJlKCcuL19hcnJheS1maWxsJyk7XG4gIHZhciBhcnJheUNvcHlXaXRoaW4gPSByZXF1aXJlKCcuL19hcnJheS1jb3B5LXdpdGhpbicpO1xuICB2YXIgJERQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG4gIHZhciAkR09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG4gIHZhciBkUCA9ICREUC5mO1xuICB2YXIgZ09QRCA9ICRHT1BELmY7XG4gIHZhciBSYW5nZUVycm9yID0gZ2xvYmFsLlJhbmdlRXJyb3I7XG4gIHZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xuICB2YXIgVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5O1xuICB2YXIgQVJSQVlfQlVGRkVSID0gJ0FycmF5QnVmZmVyJztcbiAgdmFyIFNIQVJFRF9CVUZGRVIgPSAnU2hhcmVkJyArIEFSUkFZX0JVRkZFUjtcbiAgdmFyIEJZVEVTX1BFUl9FTEVNRU5UID0gJ0JZVEVTX1BFUl9FTEVNRU5UJztcbiAgdmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuICB2YXIgQXJyYXlQcm90byA9IEFycmF5W1BST1RPVFlQRV07XG4gIHZhciAkQXJyYXlCdWZmZXIgPSAkYnVmZmVyLkFycmF5QnVmZmVyO1xuICB2YXIgJERhdGFWaWV3ID0gJGJ1ZmZlci5EYXRhVmlldztcbiAgdmFyIGFycmF5Rm9yRWFjaCA9IGNyZWF0ZUFycmF5TWV0aG9kKDApO1xuICB2YXIgYXJyYXlGaWx0ZXIgPSBjcmVhdGVBcnJheU1ldGhvZCgyKTtcbiAgdmFyIGFycmF5U29tZSA9IGNyZWF0ZUFycmF5TWV0aG9kKDMpO1xuICB2YXIgYXJyYXlFdmVyeSA9IGNyZWF0ZUFycmF5TWV0aG9kKDQpO1xuICB2YXIgYXJyYXlGaW5kID0gY3JlYXRlQXJyYXlNZXRob2QoNSk7XG4gIHZhciBhcnJheUZpbmRJbmRleCA9IGNyZWF0ZUFycmF5TWV0aG9kKDYpO1xuICB2YXIgYXJyYXlJbmNsdWRlcyA9IGNyZWF0ZUFycmF5SW5jbHVkZXModHJ1ZSk7XG4gIHZhciBhcnJheUluZGV4T2YgPSBjcmVhdGVBcnJheUluY2x1ZGVzKGZhbHNlKTtcbiAgdmFyIGFycmF5VmFsdWVzID0gQXJyYXlJdGVyYXRvcnMudmFsdWVzO1xuICB2YXIgYXJyYXlLZXlzID0gQXJyYXlJdGVyYXRvcnMua2V5cztcbiAgdmFyIGFycmF5RW50cmllcyA9IEFycmF5SXRlcmF0b3JzLmVudHJpZXM7XG4gIHZhciBhcnJheUxhc3RJbmRleE9mID0gQXJyYXlQcm90by5sYXN0SW5kZXhPZjtcbiAgdmFyIGFycmF5UmVkdWNlID0gQXJyYXlQcm90by5yZWR1Y2U7XG4gIHZhciBhcnJheVJlZHVjZVJpZ2h0ID0gQXJyYXlQcm90by5yZWR1Y2VSaWdodDtcbiAgdmFyIGFycmF5Sm9pbiA9IEFycmF5UHJvdG8uam9pbjtcbiAgdmFyIGFycmF5U29ydCA9IEFycmF5UHJvdG8uc29ydDtcbiAgdmFyIGFycmF5U2xpY2UgPSBBcnJheVByb3RvLnNsaWNlO1xuICB2YXIgYXJyYXlUb1N0cmluZyA9IEFycmF5UHJvdG8udG9TdHJpbmc7XG4gIHZhciBhcnJheVRvTG9jYWxlU3RyaW5nID0gQXJyYXlQcm90by50b0xvY2FsZVN0cmluZztcbiAgdmFyIElURVJBVE9SID0gd2tzKCdpdGVyYXRvcicpO1xuICB2YXIgVEFHID0gd2tzKCd0b1N0cmluZ1RhZycpO1xuICB2YXIgVFlQRURfQ09OU1RSVUNUT1IgPSB1aWQoJ3R5cGVkX2NvbnN0cnVjdG9yJyk7XG4gIHZhciBERUZfQ09OU1RSVUNUT1IgPSB1aWQoJ2RlZl9jb25zdHJ1Y3RvcicpO1xuICB2YXIgQUxMX0NPTlNUUlVDVE9SUyA9ICR0eXBlZC5DT05TVFI7XG4gIHZhciBUWVBFRF9BUlJBWSA9ICR0eXBlZC5UWVBFRDtcbiAgdmFyIFZJRVcgPSAkdHlwZWQuVklFVztcbiAgdmFyIFdST05HX0xFTkdUSCA9ICdXcm9uZyBsZW5ndGghJztcblxuICB2YXIgJG1hcCA9IGNyZWF0ZUFycmF5TWV0aG9kKDEsIGZ1bmN0aW9uIChPLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gYWxsb2NhdGUoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSksIGxlbmd0aCk7XG4gIH0pO1xuXG4gIHZhciBMSVRUTEVfRU5ESUFOID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVWludDE2QXJyYXkoWzFdKS5idWZmZXIpWzBdID09PSAxO1xuICB9KTtcblxuICB2YXIgRk9SQ0VEX1NFVCA9ICEhVWludDhBcnJheSAmJiAhIVVpbnQ4QXJyYXlbUFJPVE9UWVBFXS5zZXQgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyBVaW50OEFycmF5KDEpLnNldCh7fSk7XG4gIH0pO1xuXG4gIHZhciB0b09mZnNldCA9IGZ1bmN0aW9uIChpdCwgQllURVMpIHtcbiAgICB2YXIgb2Zmc2V0ID0gdG9JbnRlZ2VyKGl0KTtcbiAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgJSBCWVRFUykgdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0IScpO1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgaWYgKGlzT2JqZWN0KGl0KSAmJiBUWVBFRF9BUlJBWSBpbiBpdCkgcmV0dXJuIGl0O1xuICAgIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgdHlwZWQgYXJyYXkhJyk7XG4gIH07XG5cbiAgdmFyIGFsbG9jYXRlID0gZnVuY3Rpb24gKEMsIGxlbmd0aCkge1xuICAgIGlmICghKGlzT2JqZWN0KEMpICYmIFRZUEVEX0NPTlNUUlVDVE9SIGluIEMpKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ0l0IGlzIG5vdCBhIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9yIScpO1xuICAgIH0gcmV0dXJuIG5ldyBDKGxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIHNwZWNpZXNGcm9tTGlzdCA9IGZ1bmN0aW9uIChPLCBsaXN0KSB7XG4gICAgcmV0dXJuIGZyb21MaXN0KHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pLCBsaXN0KTtcbiAgfTtcblxuICB2YXIgZnJvbUxpc3QgPSBmdW5jdGlvbiAoQywgbGlzdCkge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBhbGxvY2F0ZShDLCBsZW5ndGgpO1xuICAgIHdoaWxlIChsZW5ndGggPiBpbmRleCkgcmVzdWx0W2luZGV4XSA9IGxpc3RbaW5kZXgrK107XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgYWRkR2V0dGVyID0gZnVuY3Rpb24gKGl0LCBrZXksIGludGVybmFsKSB7XG4gICAgZFAoaXQsIGtleSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RbaW50ZXJuYWxdOyB9IH0pO1xuICB9O1xuXG4gIHZhciAkZnJvbSA9IGZ1bmN0aW9uIGZyb20oc291cmNlIC8qICwgbWFwZm4sIHRoaXNBcmcgKi8pIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHNvdXJjZSk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBtYXBmbiA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgaXRlckZuID0gZ2V0SXRlckZuKE8pO1xuICAgIHZhciBpLCBsZW5ndGgsIHZhbHVlcywgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZiAoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhaXNBcnJheUl0ZXIoaXRlckZuKSkge1xuICAgICAgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCB2YWx1ZXMgPSBbXSwgaSA9IDA7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaSsrKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKHN0ZXAudmFsdWUpO1xuICAgICAgfSBPID0gdmFsdWVzO1xuICAgIH1cbiAgICBpZiAobWFwcGluZyAmJiBhTGVuID4gMikgbWFwZm4gPSBjdHgobWFwZm4sIGFyZ3VtZW50c1syXSwgMik7XG4gICAgZm9yIChpID0gMCwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpLCByZXN1bHQgPSBhbGxvY2F0ZSh0aGlzLCBsZW5ndGgpOyBsZW5ndGggPiBpOyBpKyspIHtcbiAgICAgIHJlc3VsdFtpXSA9IG1hcHBpbmcgPyBtYXBmbihPW2ldLCBpKSA6IE9baV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyICRvZiA9IGZ1bmN0aW9uIG9mKC8qIC4uLml0ZW1zICovKSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gYWxsb2NhdGUodGhpcywgbGVuZ3RoKTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHJlc3VsdFtpbmRleF0gPSBhcmd1bWVudHNbaW5kZXgrK107XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBpT1MgU2FmYXJpIDYueCBmYWlscyBoZXJlXG4gIHZhciBUT19MT0NBTEVfQlVHID0gISFVaW50OEFycmF5ICYmIGZhaWxzKGZ1bmN0aW9uICgpIHsgYXJyYXlUb0xvY2FsZVN0cmluZy5jYWxsKG5ldyBVaW50OEFycmF5KDEpKTsgfSk7XG5cbiAgdmFyICR0b0xvY2FsZVN0cmluZyA9IGZ1bmN0aW9uIHRvTG9jYWxlU3RyaW5nKCkge1xuICAgIHJldHVybiBhcnJheVRvTG9jYWxlU3RyaW5nLmFwcGx5KFRPX0xPQ0FMRV9CVUcgPyBhcnJheVNsaWNlLmNhbGwodmFsaWRhdGUodGhpcykpIDogdmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgdmFyIHByb3RvID0ge1xuICAgIGNvcHlXaXRoaW46IGZ1bmN0aW9uIGNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCAvKiAsIGVuZCAqLykge1xuICAgICAgcmV0dXJuIGFycmF5Q29weVdpdGhpbi5jYWxsKHZhbGlkYXRlKHRoaXMpLCB0YXJnZXQsIHN0YXJ0LCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBldmVyeTogZnVuY3Rpb24gZXZlcnkoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUV2ZXJ5KHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmaWxsOiBmdW5jdGlvbiBmaWxsKHZhbHVlIC8qICwgc3RhcnQsIGVuZCAqLykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlGaWxsLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiBzcGVjaWVzRnJvbUxpc3QodGhpcywgYXJyYXlGaWx0ZXIodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sXG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKSk7XG4gICAgfSxcbiAgICBmaW5kOiBmdW5jdGlvbiBmaW5kKHByZWRpY2F0ZSAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUZpbmQodmFsaWRhdGUodGhpcyksIHByZWRpY2F0ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgocHJlZGljYXRlIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIGFycmF5RmluZEluZGV4KHZhbGlkYXRlKHRoaXMpLCBwcmVkaWNhdGUsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIGFycmF5Rm9yRWFjaCh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlJbmRleE9mKHZhbGlkYXRlKHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCAqLykge1xuICAgICAgcmV0dXJuIGFycmF5SW5jbHVkZXModmFsaWRhdGUodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheUpvaW4uYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCAqLykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlMYXN0SW5kZXhPZi5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIG1hcDogZnVuY3Rpb24gbWFwKG1hcGZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuICRtYXAodmFsaWRhdGUodGhpcyksIG1hcGZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheVJlZHVjZS5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbiByZWR1Y2VSaWdodChjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheVJlZHVjZVJpZ2h0LmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZSgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHZhciBsZW5ndGggPSB2YWxpZGF0ZSh0aGF0KS5sZW5ndGg7XG4gICAgICB2YXIgbWlkZGxlID0gTWF0aC5mbG9vcihsZW5ndGggLyAyKTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICB3aGlsZSAoaW5kZXggPCBtaWRkbGUpIHtcbiAgICAgICAgdmFsdWUgPSB0aGF0W2luZGV4XTtcbiAgICAgICAgdGhhdFtpbmRleCsrXSA9IHRoYXRbLS1sZW5ndGhdO1xuICAgICAgICB0aGF0W2xlbmd0aF0gPSB2YWx1ZTtcbiAgICAgIH0gcmV0dXJuIHRoYXQ7XG4gICAgfSxcbiAgICBzb21lOiBmdW5jdGlvbiBzb21lKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlTb21lKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikge1xuICAgICAgcmV0dXJuIGFycmF5U29ydC5jYWxsKHZhbGlkYXRlKHRoaXMpLCBjb21wYXJlZm4pO1xuICAgIH0sXG4gICAgc3ViYXJyYXk6IGZ1bmN0aW9uIHN1YmFycmF5KGJlZ2luLCBlbmQpIHtcbiAgICAgIHZhciBPID0gdmFsaWRhdGUodGhpcyk7XG4gICAgICB2YXIgbGVuZ3RoID0gTy5sZW5ndGg7XG4gICAgICB2YXIgJGJlZ2luID0gdG9BYnNvbHV0ZUluZGV4KGJlZ2luLCBsZW5ndGgpO1xuICAgICAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSkpKFxuICAgICAgICBPLmJ1ZmZlcixcbiAgICAgICAgTy5ieXRlT2Zmc2V0ICsgJGJlZ2luICogTy5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgdG9MZW5ndGgoKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuZ3RoKSkgLSAkYmVnaW4pXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICB2YXIgJHNsaWNlID0gZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBzcGVjaWVzRnJvbUxpc3QodGhpcywgYXJyYXlTbGljZS5jYWxsKHZhbGlkYXRlKHRoaXMpLCBzdGFydCwgZW5kKSk7XG4gIH07XG5cbiAgdmFyICRzZXQgPSBmdW5jdGlvbiBzZXQoYXJyYXlMaWtlIC8qICwgb2Zmc2V0ICovKSB7XG4gICAgdmFsaWRhdGUodGhpcyk7XG4gICAgdmFyIG9mZnNldCA9IHRvT2Zmc2V0KGFyZ3VtZW50c1sxXSwgMSk7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIHZhciBzcmMgPSB0b09iamVjdChhcnJheUxpa2UpO1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aChzcmMubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGlmIChsZW4gKyBvZmZzZXQgPiBsZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICB3aGlsZSAoaW5kZXggPCBsZW4pIHRoaXNbb2Zmc2V0ICsgaW5kZXhdID0gc3JjW2luZGV4KytdO1xuICB9O1xuXG4gIHZhciAkaXRlcmF0b3JzID0ge1xuICAgIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgICByZXR1cm4gYXJyYXlFbnRyaWVzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH0sXG4gICAga2V5czogZnVuY3Rpb24ga2V5cygpIHtcbiAgICAgIHJldHVybiBhcnJheUtleXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfSxcbiAgICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgIHJldHVybiBhcnJheVZhbHVlcy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzVEFJbmRleCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHJldHVybiBpc09iamVjdCh0YXJnZXQpXG4gICAgICAmJiB0YXJnZXRbVFlQRURfQVJSQVldXG4gICAgICAmJiB0eXBlb2Yga2V5ICE9ICdzeW1ib2wnXG4gICAgICAmJiBrZXkgaW4gdGFyZ2V0XG4gICAgICAmJiBTdHJpbmcoK2tleSkgPT0gU3RyaW5nKGtleSk7XG4gIH07XG4gIHZhciAkZ2V0RGVzYyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkge1xuICAgIHJldHVybiBpc1RBSW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKVxuICAgICAgPyBwcm9wZXJ0eURlc2MoMiwgdGFyZ2V0W2tleV0pXG4gICAgICA6IGdPUEQodGFyZ2V0LCBrZXkpO1xuICB9O1xuICB2YXIgJHNldERlc2MgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIGlmIChpc1RBSW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKVxuICAgICAgJiYgaXNPYmplY3QoZGVzYylcbiAgICAgICYmIGhhcyhkZXNjLCAndmFsdWUnKVxuICAgICAgJiYgIWhhcyhkZXNjLCAnZ2V0JylcbiAgICAgICYmICFoYXMoZGVzYywgJ3NldCcpXG4gICAgICAvLyBUT0RPOiBhZGQgdmFsaWRhdGlvbiBkZXNjcmlwdG9yIHcvbyBjYWxsaW5nIGFjY2Vzc29yc1xuICAgICAgJiYgIWRlc2MuY29uZmlndXJhYmxlXG4gICAgICAmJiAoIWhhcyhkZXNjLCAnd3JpdGFibGUnKSB8fCBkZXNjLndyaXRhYmxlKVxuICAgICAgJiYgKCFoYXMoZGVzYywgJ2VudW1lcmFibGUnKSB8fCBkZXNjLmVudW1lcmFibGUpXG4gICAgKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IGRlc2MudmFsdWU7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0gcmV0dXJuIGRQKHRhcmdldCwga2V5LCBkZXNjKTtcbiAgfTtcblxuICBpZiAoIUFMTF9DT05TVFJVQ1RPUlMpIHtcbiAgICAkR09QRC5mID0gJGdldERlc2M7XG4gICAgJERQLmYgPSAkc2V0RGVzYztcbiAgfVxuXG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIUFMTF9DT05TVFJVQ1RPUlMsICdPYmplY3QnLCB7XG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0RGVzYyxcbiAgICBkZWZpbmVQcm9wZXJ0eTogJHNldERlc2NcbiAgfSk7XG5cbiAgaWYgKGZhaWxzKGZ1bmN0aW9uICgpIHsgYXJyYXlUb1N0cmluZy5jYWxsKHt9KTsgfSkpIHtcbiAgICBhcnJheVRvU3RyaW5nID0gYXJyYXlUb0xvY2FsZVN0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGFycmF5Sm9pbi5jYWxsKHRoaXMpO1xuICAgIH07XG4gIH1cblxuICB2YXIgJFR5cGVkQXJyYXlQcm90b3R5cGUkID0gcmVkZWZpbmVBbGwoe30sIHByb3RvKTtcbiAgcmVkZWZpbmVBbGwoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAkaXRlcmF0b3JzKTtcbiAgaGlkZSgkVHlwZWRBcnJheVByb3RvdHlwZSQsIElURVJBVE9SLCAkaXRlcmF0b3JzLnZhbHVlcyk7XG4gIHJlZGVmaW5lQWxsKCRUeXBlZEFycmF5UHJvdG90eXBlJCwge1xuICAgIHNsaWNlOiAkc2xpY2UsXG4gICAgc2V0OiAkc2V0LFxuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7IC8qIG5vb3AgKi8gfSxcbiAgICB0b1N0cmluZzogYXJyYXlUb1N0cmluZyxcbiAgICB0b0xvY2FsZVN0cmluZzogJHRvTG9jYWxlU3RyaW5nXG4gIH0pO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnVmZmVyJywgJ2InKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J5dGVPZmZzZXQnLCAnbycpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnl0ZUxlbmd0aCcsICdsJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdsZW5ndGgnLCAnZScpO1xuICBkUCgkVHlwZWRBcnJheVByb3RvdHlwZSQsIFRBRywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpc1tUWVBFRF9BUlJBWV07IH1cbiAgfSk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1zdGF0ZW1lbnRzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgQllURVMsIHdyYXBwZXIsIENMQU1QRUQpIHtcbiAgICBDTEFNUEVEID0gISFDTEFNUEVEO1xuICAgIHZhciBOQU1FID0gS0VZICsgKENMQU1QRUQgPyAnQ2xhbXBlZCcgOiAnJykgKyAnQXJyYXknO1xuICAgIHZhciBHRVRURVIgPSAnZ2V0JyArIEtFWTtcbiAgICB2YXIgU0VUVEVSID0gJ3NldCcgKyBLRVk7XG4gICAgdmFyIFR5cGVkQXJyYXkgPSBnbG9iYWxbTkFNRV07XG4gICAgdmFyIEJhc2UgPSBUeXBlZEFycmF5IHx8IHt9O1xuICAgIHZhciBUQUMgPSBUeXBlZEFycmF5ICYmIGdldFByb3RvdHlwZU9mKFR5cGVkQXJyYXkpO1xuICAgIHZhciBGT1JDRUQgPSAhVHlwZWRBcnJheSB8fCAhJHR5cGVkLkFCVjtcbiAgICB2YXIgTyA9IHt9O1xuICAgIHZhciBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheSAmJiBUeXBlZEFycmF5W1BST1RPVFlQRV07XG4gICAgdmFyIGdldHRlciA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCkge1xuICAgICAgdmFyIGRhdGEgPSB0aGF0Ll9kO1xuICAgICAgcmV0dXJuIGRhdGEudltHRVRURVJdKGluZGV4ICogQllURVMgKyBkYXRhLm8sIExJVFRMRV9FTkRJQU4pO1xuICAgIH07XG4gICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhhdC5fZDtcbiAgICAgIGlmIChDTEFNUEVEKSB2YWx1ZSA9ICh2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUpKSA8IDAgPyAwIDogdmFsdWUgPiAweGZmID8gMHhmZiA6IHZhbHVlICYgMHhmZjtcbiAgICAgIGRhdGEudltTRVRURVJdKGluZGV4ICogQllURVMgKyBkYXRhLm8sIHZhbHVlLCBMSVRUTEVfRU5ESUFOKTtcbiAgICB9O1xuICAgIHZhciBhZGRFbGVtZW50ID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4KSB7XG4gICAgICBkUCh0aGF0LCBpbmRleCwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0dGVyKHRoaXMsIGluZGV4KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gc2V0dGVyKHRoaXMsIGluZGV4LCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKEZPUkNFRCkge1xuICAgICAgVHlwZWRBcnJheSA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGRhdGEsICRvZmZzZXQsICRsZW5ndGgpIHtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGF0LCBUeXBlZEFycmF5LCBOQU1FLCAnX2QnKTtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgIHZhciBidWZmZXIsIGJ5dGVMZW5ndGgsIGxlbmd0aCwga2xhc3M7XG4gICAgICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgICAgICBsZW5ndGggPSB0b0luZGV4KGRhdGEpO1xuICAgICAgICAgIGJ5dGVMZW5ndGggPSBsZW5ndGggKiBCWVRFUztcbiAgICAgICAgICBidWZmZXIgPSBuZXcgJEFycmF5QnVmZmVyKGJ5dGVMZW5ndGgpO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiAkQXJyYXlCdWZmZXIgfHwgKGtsYXNzID0gY2xhc3NvZihkYXRhKSkgPT0gQVJSQVlfQlVGRkVSIHx8IGtsYXNzID09IFNIQVJFRF9CVUZGRVIpIHtcbiAgICAgICAgICBidWZmZXIgPSBkYXRhO1xuICAgICAgICAgIG9mZnNldCA9IHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKTtcbiAgICAgICAgICB2YXIgJGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICBpZiAoJGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoJGxlbiAlIEJZVEVTKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gJGxlbiAtIG9mZnNldDtcbiAgICAgICAgICAgIGlmIChieXRlTGVuZ3RoIDwgMCkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gdG9MZW5ndGgoJGxlbmd0aCkgKiBCWVRFUztcbiAgICAgICAgICAgIGlmIChieXRlTGVuZ3RoICsgb2Zmc2V0ID4gJGxlbikgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGggPSBieXRlTGVuZ3RoIC8gQllURVM7XG4gICAgICAgIH0gZWxzZSBpZiAoVFlQRURfQVJSQVkgaW4gZGF0YSkge1xuICAgICAgICAgIHJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gJGZyb20uY2FsbChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBoaWRlKHRoYXQsICdfZCcsIHtcbiAgICAgICAgICBiOiBidWZmZXIsXG4gICAgICAgICAgbzogb2Zmc2V0LFxuICAgICAgICAgIGw6IGJ5dGVMZW5ndGgsXG4gICAgICAgICAgZTogbGVuZ3RoLFxuICAgICAgICAgIHY6IG5ldyAkRGF0YVZpZXcoYnVmZmVyKVxuICAgICAgICB9KTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSBhZGRFbGVtZW50KHRoYXQsIGluZGV4KyspO1xuICAgICAgfSk7XG4gICAgICBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheVtQUk9UT1RZUEVdID0gY3JlYXRlKCRUeXBlZEFycmF5UHJvdG90eXBlJCk7XG4gICAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIFR5cGVkQXJyYXkpO1xuICAgIH0gZWxzZSBpZiAoIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIFR5cGVkQXJyYXkoMSk7XG4gICAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIG5ldyBUeXBlZEFycmF5KC0xKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICB9KSB8fCAhJGl0ZXJEZXRlY3QoZnVuY3Rpb24gKGl0ZXIpIHtcbiAgICAgIG5ldyBUeXBlZEFycmF5KCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICBuZXcgVHlwZWRBcnJheShudWxsKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIG5ldyBUeXBlZEFycmF5KDEuNSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICBuZXcgVHlwZWRBcnJheShpdGVyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICB9LCB0cnVlKSkge1xuICAgICAgVHlwZWRBcnJheSA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGRhdGEsICRvZmZzZXQsICRsZW5ndGgpIHtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGF0LCBUeXBlZEFycmF5LCBOQU1FKTtcbiAgICAgICAgdmFyIGtsYXNzO1xuICAgICAgICAvLyBgd3NgIG1vZHVsZSBidWcsIHRlbXBvcmFyaWx5IHJlbW92ZSB2YWxpZGF0aW9uIGxlbmd0aCBmb3IgVWludDhBcnJheVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9wdWxsLzY0NVxuICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSByZXR1cm4gbmV3IEJhc2UodG9JbmRleChkYXRhKSk7XG4gICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgJEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoZGF0YSkpID09IEFSUkFZX0JVRkZFUiB8fCBrbGFzcyA9PSBTSEFSRURfQlVGRkVSKSB7XG4gICAgICAgICAgcmV0dXJuICRsZW5ndGggIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBuZXcgQmFzZShkYXRhLCB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUyksICRsZW5ndGgpXG4gICAgICAgICAgICA6ICRvZmZzZXQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IG5ldyBCYXNlKGRhdGEsIHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKSlcbiAgICAgICAgICAgICAgOiBuZXcgQmFzZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVFlQRURfQVJSQVkgaW4gZGF0YSkgcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICByZXR1cm4gJGZyb20uY2FsbChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgIH0pO1xuICAgICAgYXJyYXlGb3JFYWNoKFRBQyAhPT0gRnVuY3Rpb24ucHJvdG90eXBlID8gZ09QTihCYXNlKS5jb25jYXQoZ09QTihUQUMpKSA6IGdPUE4oQmFzZSksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIFR5cGVkQXJyYXkpKSBoaWRlKFR5cGVkQXJyYXksIGtleSwgQmFzZVtrZXldKTtcbiAgICAgIH0pO1xuICAgICAgVHlwZWRBcnJheVtQUk9UT1RZUEVdID0gVHlwZWRBcnJheVByb3RvdHlwZTtcbiAgICAgIGlmICghTElCUkFSWSkgVHlwZWRBcnJheVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFR5cGVkQXJyYXk7XG4gICAgfVxuICAgIHZhciAkbmF0aXZlSXRlcmF0b3IgPSBUeXBlZEFycmF5UHJvdG90eXBlW0lURVJBVE9SXTtcbiAgICB2YXIgQ09SUkVDVF9JVEVSX05BTUUgPSAhISRuYXRpdmVJdGVyYXRvclxuICAgICAgJiYgKCRuYXRpdmVJdGVyYXRvci5uYW1lID09ICd2YWx1ZXMnIHx8ICRuYXRpdmVJdGVyYXRvci5uYW1lID09IHVuZGVmaW5lZCk7XG4gICAgdmFyICRpdGVyYXRvciA9ICRpdGVyYXRvcnMudmFsdWVzO1xuICAgIGhpZGUoVHlwZWRBcnJheSwgVFlQRURfQ09OU1RSVUNUT1IsIHRydWUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgVFlQRURfQVJSQVksIE5BTUUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgVklFVywgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBERUZfQ09OU1RSVUNUT1IsIFR5cGVkQXJyYXkpO1xuXG4gICAgaWYgKENMQU1QRUQgPyBuZXcgVHlwZWRBcnJheSgxKVtUQUddICE9IE5BTUUgOiAhKFRBRyBpbiBUeXBlZEFycmF5UHJvdG90eXBlKSkge1xuICAgICAgZFAoVHlwZWRBcnJheVByb3RvdHlwZSwgVEFHLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTkFNRTsgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgT1tOQU1FXSA9IFR5cGVkQXJyYXk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChUeXBlZEFycmF5ICE9IEJhc2UpLCBPKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5TLCBOQU1FLCB7XG4gICAgICBCWVRFU19QRVJfRUxFTUVOVDogQllURVNcbiAgICB9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkgeyBCYXNlLm9mLmNhbGwoVHlwZWRBcnJheSwgMSk7IH0pLCBOQU1FLCB7XG4gICAgICBmcm9tOiAkZnJvbSxcbiAgICAgIG9mOiAkb2ZcbiAgICB9KTtcblxuICAgIGlmICghKEJZVEVTX1BFUl9FTEVNRU5UIGluIFR5cGVkQXJyYXlQcm90b3R5cGUpKSBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIEJZVEVTX1BFUl9FTEVNRU5ULCBCWVRFUyk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCwgTkFNRSwgcHJvdG8pO1xuXG4gICAgc2V0U3BlY2llcyhOQU1FKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogRk9SQ0VEX1NFVCwgTkFNRSwgeyBzZXQ6ICRzZXQgfSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFDT1JSRUNUX0lURVJfTkFNRSwgTkFNRSwgJGl0ZXJhdG9ycyk7XG5cbiAgICBpZiAoIUxJQlJBUlkgJiYgVHlwZWRBcnJheVByb3RvdHlwZS50b1N0cmluZyAhPSBhcnJheVRvU3RyaW5nKSBUeXBlZEFycmF5UHJvdG90eXBlLnRvU3RyaW5nID0gYXJyYXlUb1N0cmluZztcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgbmV3IFR5cGVkQXJyYXkoMSkuc2xpY2UoKTtcbiAgICB9KSwgTkFNRSwgeyBzbGljZTogJHNsaWNlIH0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFsxLCAyXS50b0xvY2FsZVN0cmluZygpICE9IG5ldyBUeXBlZEFycmF5KFsxLCAyXSkudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgVHlwZWRBcnJheVByb3RvdHlwZS50b0xvY2FsZVN0cmluZy5jYWxsKFsxLCAyXSk7XG4gICAgfSkpLCBOQU1FLCB7IHRvTG9jYWxlU3RyaW5nOiAkdG9Mb2NhbGVTdHJpbmcgfSk7XG5cbiAgICBJdGVyYXRvcnNbTkFNRV0gPSBDT1JSRUNUX0lURVJfTkFNRSA/ICRuYXRpdmVJdGVyYXRvciA6ICRpdGVyYXRvcjtcbiAgICBpZiAoIUxJQlJBUlkgJiYgIUNPUlJFQ1RfSVRFUl9OQU1FKSBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIElURVJBVE9SLCAkaXRlcmF0b3IpO1xuICB9O1xufSBlbHNlIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICR0eXBlZCA9IHJlcXVpcmUoJy4vX3R5cGVkJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0luZGV4ID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKTtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBhcnJheUZpbGwgPSByZXF1aXJlKCcuL19hcnJheS1maWxsJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG52YXIgREFUQV9WSUVXID0gJ0RhdGFWaWV3JztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBXUk9OR19MRU5HVEggPSAnV3JvbmcgbGVuZ3RoISc7XG52YXIgV1JPTkdfSU5ERVggPSAnV3JvbmcgaW5kZXghJztcbnZhciAkQXJyYXlCdWZmZXIgPSBnbG9iYWxbQVJSQVlfQlVGRkVSXTtcbnZhciAkRGF0YVZpZXcgPSBnbG9iYWxbREFUQV9WSUVXXTtcbnZhciBNYXRoID0gZ2xvYmFsLk1hdGg7XG52YXIgUmFuZ2VFcnJvciA9IGdsb2JhbC5SYW5nZUVycm9yO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvdy1yZXN0cmljdGVkLW5hbWVzXG52YXIgSW5maW5pdHkgPSBnbG9iYWwuSW5maW5pdHk7XG52YXIgQmFzZUJ1ZmZlciA9ICRBcnJheUJ1ZmZlcjtcbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBwb3cgPSBNYXRoLnBvdztcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgbG9nID0gTWF0aC5sb2c7XG52YXIgTE4yID0gTWF0aC5MTjI7XG52YXIgQlVGRkVSID0gJ2J1ZmZlcic7XG52YXIgQllURV9MRU5HVEggPSAnYnl0ZUxlbmd0aCc7XG52YXIgQllURV9PRkZTRVQgPSAnYnl0ZU9mZnNldCc7XG52YXIgJEJVRkZFUiA9IERFU0NSSVBUT1JTID8gJ19iJyA6IEJVRkZFUjtcbnZhciAkTEVOR1RIID0gREVTQ1JJUFRPUlMgPyAnX2wnIDogQllURV9MRU5HVEg7XG52YXIgJE9GRlNFVCA9IERFU0NSSVBUT1JTID8gJ19vJyA6IEJZVEVfT0ZGU0VUO1xuXG4vLyBJRUVFNzU0IGNvbnZlcnNpb25zIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvaWVlZTc1NFxuZnVuY3Rpb24gcGFja0lFRUU3NTQodmFsdWUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KG5CeXRlcyk7XG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgcnQgPSBtTGVuID09PSAyMyA/IHBvdygyLCAtMjQpIC0gcG93KDIsIC03NykgOiAwO1xuICB2YXIgaSA9IDA7XG4gIHZhciBzID0gdmFsdWUgPCAwIHx8IHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDAgPyAxIDogMDtcbiAgdmFyIGUsIG0sIGM7XG4gIHZhbHVlID0gYWJzKHZhbHVlKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICBpZiAodmFsdWUgIT0gdmFsdWUgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIG0gPSB2YWx1ZSAhPSB2YWx1ZSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBmbG9vcihsb2codmFsdWUpIC8gTE4yKTtcbiAgICBpZiAodmFsdWUgKiAoYyA9IHBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBwb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogcG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogcG93KDIsIGVCaWFzIC0gMSkgKiBwb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW2krK10gPSBtICYgMjU1LCBtIC89IDI1NiwgbUxlbiAtPSA4KTtcbiAgZSA9IGUgPDwgbUxlbiB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbaSsrXSA9IGUgJiAyNTUsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuICBidWZmZXJbLS1pXSB8PSBzICogMTI4O1xuICByZXR1cm4gYnVmZmVyO1xufVxuZnVuY3Rpb24gdW5wYWNrSUVFRTc1NChidWZmZXIsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIG5CaXRzID0gZUxlbiAtIDc7XG4gIHZhciBpID0gbkJ5dGVzIC0gMTtcbiAgdmFyIHMgPSBidWZmZXJbaS0tXTtcbiAgdmFyIGUgPSBzICYgMTI3O1xuICB2YXIgbTtcbiAgcyA+Pj0gNztcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbaV0sIGktLSwgbkJpdHMgLT0gOCk7XG4gIG0gPSBlICYgKDEgPDwgLW5CaXRzKSAtIDE7XG4gIGUgPj49IC1uQml0cztcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbaV0sIGktLSwgbkJpdHMgLT0gOCk7XG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiBzID8gLUluZmluaXR5IDogSW5maW5pdHk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBwb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfSByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIHBvdygyLCBlIC0gbUxlbik7XG59XG5cbmZ1bmN0aW9uIHVucGFja0kzMihieXRlcykge1xuICByZXR1cm4gYnl0ZXNbM10gPDwgMjQgfCBieXRlc1syXSA8PCAxNiB8IGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXTtcbn1cbmZ1bmN0aW9uIHBhY2tJOChpdCkge1xuICByZXR1cm4gW2l0ICYgMHhmZl07XG59XG5mdW5jdGlvbiBwYWNrSTE2KGl0KSB7XG4gIHJldHVybiBbaXQgJiAweGZmLCBpdCA+PiA4ICYgMHhmZl07XG59XG5mdW5jdGlvbiBwYWNrSTMyKGl0KSB7XG4gIHJldHVybiBbaXQgJiAweGZmLCBpdCA+PiA4ICYgMHhmZiwgaXQgPj4gMTYgJiAweGZmLCBpdCA+PiAyNCAmIDB4ZmZdO1xufVxuZnVuY3Rpb24gcGFja0Y2NChpdCkge1xuICByZXR1cm4gcGFja0lFRUU3NTQoaXQsIDUyLCA4KTtcbn1cbmZ1bmN0aW9uIHBhY2tGMzIoaXQpIHtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KGl0LCAyMywgNCk7XG59XG5cbmZ1bmN0aW9uIGFkZEdldHRlcihDLCBrZXksIGludGVybmFsKSB7XG4gIGRQKENbUFJPVE9UWVBFXSwga2V5LCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpc1tpbnRlcm5hbF07IH0gfSk7XG59XG5cbmZ1bmN0aW9uIGdldCh2aWV3LCBieXRlcywgaW5kZXgsIGlzTGl0dGxlRW5kaWFuKSB7XG4gIHZhciBudW1JbmRleCA9ICtpbmRleDtcbiAgdmFyIGludEluZGV4ID0gdG9JbmRleChudW1JbmRleCk7XG4gIGlmIChpbnRJbmRleCArIGJ5dGVzID4gdmlld1skTEVOR1RIXSkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG4gIHZhciBzdG9yZSA9IHZpZXdbJEJVRkZFUl0uX2I7XG4gIHZhciBzdGFydCA9IGludEluZGV4ICsgdmlld1skT0ZGU0VUXTtcbiAgdmFyIHBhY2sgPSBzdG9yZS5zbGljZShzdGFydCwgc3RhcnQgKyBieXRlcyk7XG4gIHJldHVybiBpc0xpdHRsZUVuZGlhbiA/IHBhY2sgOiBwYWNrLnJldmVyc2UoKTtcbn1cbmZ1bmN0aW9uIHNldCh2aWV3LCBieXRlcywgaW5kZXgsIGNvbnZlcnNpb24sIHZhbHVlLCBpc0xpdHRsZUVuZGlhbikge1xuICB2YXIgbnVtSW5kZXggPSAraW5kZXg7XG4gIHZhciBpbnRJbmRleCA9IHRvSW5kZXgobnVtSW5kZXgpO1xuICBpZiAoaW50SW5kZXggKyBieXRlcyA+IHZpZXdbJExFTkdUSF0pIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgc3RvcmUgPSB2aWV3WyRCVUZGRVJdLl9iO1xuICB2YXIgc3RhcnQgPSBpbnRJbmRleCArIHZpZXdbJE9GRlNFVF07XG4gIHZhciBwYWNrID0gY29udmVyc2lvbigrdmFsdWUpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzOyBpKyspIHN0b3JlW3N0YXJ0ICsgaV0gPSBwYWNrW2lzTGl0dGxlRW5kaWFuID8gaSA6IGJ5dGVzIC0gaSAtIDFdO1xufVxuXG5pZiAoISR0eXBlZC5BQlYpIHtcbiAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSB0b0luZGV4KGxlbmd0aCk7XG4gICAgdGhpcy5fYiA9IGFycmF5RmlsbC5jYWxsKG5ldyBBcnJheShieXRlTGVuZ3RoKSwgMCk7XG4gICAgdGhpc1skTEVOR1RIXSA9IGJ5dGVMZW5ndGg7XG4gIH07XG5cbiAgJERhdGFWaWV3ID0gZnVuY3Rpb24gRGF0YVZpZXcoYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkRGF0YVZpZXcsIERBVEFfVklFVyk7XG4gICAgYW5JbnN0YW5jZShidWZmZXIsICRBcnJheUJ1ZmZlciwgREFUQV9WSUVXKTtcbiAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYnVmZmVyWyRMRU5HVEhdO1xuICAgIHZhciBvZmZzZXQgPSB0b0ludGVnZXIoYnl0ZU9mZnNldCk7XG4gICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gYnVmZmVyTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBvZmZzZXQhJyk7XG4gICAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPT09IHVuZGVmaW5lZCA/IGJ1ZmZlckxlbmd0aCAtIG9mZnNldCA6IHRvTGVuZ3RoKGJ5dGVMZW5ndGgpO1xuICAgIGlmIChvZmZzZXQgKyBieXRlTGVuZ3RoID4gYnVmZmVyTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgdGhpc1skQlVGRkVSXSA9IGJ1ZmZlcjtcbiAgICB0aGlzWyRPRkZTRVRdID0gb2Zmc2V0O1xuICAgIHRoaXNbJExFTkdUSF0gPSBieXRlTGVuZ3RoO1xuICB9O1xuXG4gIGlmIChERVNDUklQVE9SUykge1xuICAgIGFkZEdldHRlcigkQXJyYXlCdWZmZXIsIEJZVEVfTEVOR1RILCAnX2wnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCVUZGRVIsICdfYicpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJZVEVfTEVOR1RILCAnX2wnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCWVRFX09GRlNFVCwgJ19vJyk7XG4gIH1cblxuICByZWRlZmluZUFsbCgkRGF0YVZpZXdbUFJPVE9UWVBFXSwge1xuICAgIGdldEludDg6IGZ1bmN0aW9uIGdldEludDgoYnl0ZU9mZnNldCkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXSA8PCAyNCA+PiAyNDtcbiAgICB9LFxuICAgIGdldFVpbnQ4OiBmdW5jdGlvbiBnZXRVaW50OChieXRlT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MTY6IGZ1bmN0aW9uIGdldEludDE2KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHZhciBieXRlcyA9IGdldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pO1xuICAgICAgcmV0dXJuIChieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF0pIDw8IDE2ID4+IDE2O1xuICAgIH0sXG4gICAgZ2V0VWludDE2OiBmdW5jdGlvbiBnZXRVaW50MTYoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSk7XG4gICAgICByZXR1cm4gYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MzI6IGZ1bmN0aW9uIGdldEludDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJMzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSkpO1xuICAgIH0sXG4gICAgZ2V0VWludDMyOiBmdW5jdGlvbiBnZXRVaW50MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0kzMihnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSkgPj4+IDA7XG4gICAgfSxcbiAgICBnZXRGbG9hdDMyOiBmdW5jdGlvbiBnZXRGbG9hdDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCAyMywgNCk7XG4gICAgfSxcbiAgICBnZXRGbG9hdDY0OiBmdW5jdGlvbiBnZXRGbG9hdDY0KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCA1MiwgOCk7XG4gICAgfSxcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0k4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSTgsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldEludDE2OiBmdW5jdGlvbiBzZXRJbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJMTYsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0VWludDE2OiBmdW5jdGlvbiBzZXRVaW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSTE2LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEludDMyOiBmdW5jdGlvbiBzZXRJbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tJMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0VWludDMyOiBmdW5jdGlvbiBzZXRVaW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSTMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEZsb2F0MzI6IGZ1bmN0aW9uIHNldEZsb2F0MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrRjMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEZsb2F0NjQ6IGZ1bmN0aW9uIHNldEZsb2F0NjQoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBwYWNrRjY0LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgaWYgKCFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgJEFycmF5QnVmZmVyKDEpO1xuICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoLTEpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICB9KSB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3ICRBcnJheUJ1ZmZlcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoMS41KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBuZXcgJEFycmF5QnVmZmVyKE5hTik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgcmV0dXJuICRBcnJheUJ1ZmZlci5uYW1lICE9IEFSUkFZX0JVRkZFUjtcbiAgfSkpIHtcbiAgICAkQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiBBcnJheUJ1ZmZlcihsZW5ndGgpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhpcywgJEFycmF5QnVmZmVyKTtcbiAgICAgIHJldHVybiBuZXcgQmFzZUJ1ZmZlcih0b0luZGV4KGxlbmd0aCkpO1xuICAgIH07XG4gICAgdmFyIEFycmF5QnVmZmVyUHJvdG8gPSAkQXJyYXlCdWZmZXJbUFJPVE9UWVBFXSA9IEJhc2VCdWZmZXJbUFJPVE9UWVBFXTtcbiAgICBmb3IgKHZhciBrZXlzID0gZ09QTihCYXNlQnVmZmVyKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOykge1xuICAgICAgaWYgKCEoKGtleSA9IGtleXNbaisrXSkgaW4gJEFycmF5QnVmZmVyKSkgaGlkZSgkQXJyYXlCdWZmZXIsIGtleSwgQmFzZUJ1ZmZlcltrZXldKTtcbiAgICB9XG4gICAgaWYgKCFMSUJSQVJZKSBBcnJheUJ1ZmZlclByb3RvLmNvbnN0cnVjdG9yID0gJEFycmF5QnVmZmVyO1xuICB9XG4gIC8vIGlPUyBTYWZhcmkgNy54IGJ1Z1xuICB2YXIgdmlldyA9IG5ldyAkRGF0YVZpZXcobmV3ICRBcnJheUJ1ZmZlcigyKSk7XG4gIHZhciAkc2V0SW50OCA9ICREYXRhVmlld1tQUk9UT1RZUEVdLnNldEludDg7XG4gIHZpZXcuc2V0SW50OCgwLCAyMTQ3NDgzNjQ4KTtcbiAgdmlldy5zZXRJbnQ4KDEsIDIxNDc0ODM2NDkpO1xuICBpZiAodmlldy5nZXRJbnQ4KDApIHx8ICF2aWV3LmdldEludDgoMSkpIHJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEVdLCB7XG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgJHNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgICRzZXRJbnQ4LmNhbGwodGhpcywgYnl0ZU9mZnNldCwgdmFsdWUgPDwgMjQgPj4gMjQpO1xuICAgIH1cbiAgfSwgdHJ1ZSk7XG59XG5zZXRUb1N0cmluZ1RhZygkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG5zZXRUb1N0cmluZ1RhZygkRGF0YVZpZXcsIERBVEFfVklFVyk7XG5oaWRlKCREYXRhVmlld1tQUk9UT1RZUEVdLCAkdHlwZWQuVklFVywgdHJ1ZSk7XG5leHBvcnRzW0FSUkFZX0JVRkZFUl0gPSAkQXJyYXlCdWZmZXI7XG5leHBvcnRzW0RBVEFfVklFV10gPSAkRGF0YVZpZXc7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciBUWVBFRCA9IHVpZCgndHlwZWRfYXJyYXknKTtcbnZhciBWSUVXID0gdWlkKCd2aWV3Jyk7XG52YXIgQUJWID0gISEoZ2xvYmFsLkFycmF5QnVmZmVyICYmIGdsb2JhbC5EYXRhVmlldyk7XG52YXIgQ09OU1RSID0gQUJWO1xudmFyIGkgPSAwO1xudmFyIGwgPSA5O1xudmFyIFR5cGVkO1xuXG52YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9ycyA9IChcbiAgJ0ludDhBcnJheSxVaW50OEFycmF5LFVpbnQ4Q2xhbXBlZEFycmF5LEludDE2QXJyYXksVWludDE2QXJyYXksSW50MzJBcnJheSxVaW50MzJBcnJheSxGbG9hdDMyQXJyYXksRmxvYXQ2NEFycmF5J1xuKS5zcGxpdCgnLCcpO1xuXG53aGlsZSAoaSA8IGwpIHtcbiAgaWYgKFR5cGVkID0gZ2xvYmFsW1R5cGVkQXJyYXlDb25zdHJ1Y3RvcnNbaSsrXV0pIHtcbiAgICBoaWRlKFR5cGVkLnByb3RvdHlwZSwgVFlQRUQsIHRydWUpO1xuICAgIGhpZGUoVHlwZWQucHJvdG90eXBlLCBWSUVXLCB0cnVlKTtcbiAgfSBlbHNlIENPTlNUUiA9IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQUJWOiBBQlYsXG4gIENPTlNUUjogQ09OU1RSLFxuICBUWVBFRDogVFlQRUQsXG4gIFZJRVc6IFZJRVdcbn07XG4iLCJ2YXIgaWQgPSAwO1xudmFyIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBuYXZpZ2F0b3IgPSBnbG9iYWwubmF2aWdhdG9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgVFlQRSkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSB8fCBpdC5fdCAhPT0gVFlQRSkgdGhyb3cgVHlwZUVycm9yKCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcbiAgaWYgKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpIGRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHsgdmFsdWU6IHdrc0V4dC5mKG5hbWUpIH0pO1xufTtcbiIsImV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX3drcycpO1xuIiwidmFyIHN0b3JlID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbDtcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vYmVuamFtaW5nci9SZXhFeHAuZXNjYXBlXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRyZSA9IHJlcXVpcmUoJy4vX3JlcGxhY2VyJykoL1tcXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVnRXhwJywgeyBlc2NhcGU6IGZ1bmN0aW9uIGVzY2FwZShpdCkgeyByZXR1cm4gJHJlKGl0KTsgfSB9KTtcbiIsIi8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHsgY29weVdpdGhpbjogcmVxdWlyZSgnLi9fYXJyYXktY29weS13aXRoaW4nKSB9KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2NvcHlXaXRoaW4nKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGV2ZXJ5ID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDQpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uZXZlcnksIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy41IC8gMTUuNC40LjE2IEFycmF5LnByb3RvdHlwZS5ldmVyeShjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBldmVyeTogZnVuY3Rpb24gZXZlcnkoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJGV2ZXJ5KHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuIiwiLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5JywgeyBmaWxsOiByZXF1aXJlKCcuL19hcnJheS1maWxsJykgfSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdmaWxsJyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRmaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMik7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5maWx0ZXIsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy43IC8gMTUuNC40LjIwIEFycmF5LnByb3RvdHlwZS5maWx0ZXIoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJGZpbHRlcih0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy45IEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgocHJlZGljYXRlLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZmluZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg2KTtcbnZhciBLRVkgPSAnZmluZEluZGV4JztcbnZhciBmb3JjZWQgPSB0cnVlO1xuLy8gU2hvdWxkbid0IHNraXAgaG9sZXNcbmlmIChLRVkgaW4gW10pIEFycmF5KDEpW0tFWV0oZnVuY3Rpb24gKCkgeyBmb3JjZWQgPSBmYWxzZTsgfSk7XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZvcmNlZCwgJ0FycmF5Jywge1xuICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChjYWxsYmFja2ZuIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqLykge1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoS0VZKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy44IEFycmF5LnByb3RvdHlwZS5maW5kKHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGZpbmQgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNSk7XG52YXIgS0VZID0gJ2ZpbmQnO1xudmFyIGZvcmNlZCA9IHRydWU7XG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYgKEtFWSBpbiBbXSkgQXJyYXkoMSlbS0VZXShmdW5jdGlvbiAoKSB7IGZvcmNlZCA9IGZhbHNlOyB9KTtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZm9yY2VkLCAnQXJyYXknLCB7XG4gIGZpbmQ6IGZ1bmN0aW9uIGZpbmQoY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICByZXR1cm4gJGZpbmQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKEtFWSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRmb3JFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApO1xudmFyIFNUUklDVCA9IHJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5mb3JFYWNoLCB0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhU1RSSUNULCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xMCAvIDE1LjQuNC4xOCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRmb3JFYWNoKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKTtcbnZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG52YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbiAoaXRlcikgeyBBcnJheS5mcm9tKGl0ZXIpOyB9KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlIC8qICwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQgKi8pIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KGFycmF5TGlrZSk7XG4gICAgdmFyIEMgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5O1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbWFwZm4gPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgaXRlckZuID0gZ2V0SXRlckZuKE8pO1xuICAgIHZhciBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYgKG1hcHBpbmcpIG1hcGZuID0gY3R4KG1hcGZuLCBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCwgMik7XG4gICAgLy8gaWYgb2JqZWN0IGlzbid0IGl0ZXJhYmxlIG9yIGl0J3MgYXJyYXkgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIHNpbXBsZSBjYXNlXG4gICAgaWYgKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyKGl0ZXJGbikpKSB7XG4gICAgICBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHJlc3VsdCA9IG5ldyBDKCk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gY2FsbChpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICAgIGZvciAocmVzdWx0ID0gbmV3IEMobGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcbnZhciAkbmF0aXZlID0gW10uaW5kZXhPZjtcbnZhciBORUdBVElWRV9aRVJPID0gISEkbmF0aXZlICYmIDEgLyBbMV0uaW5kZXhPZigxLCAtMCkgPCAwO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChORUdBVElWRV9aRVJPIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJG5hdGl2ZSkpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xMSAvIDE1LjQuNC4xNCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZihzZWFyY2hFbGVtZW50IFssIGZyb21JbmRleF0pXG4gIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCA9IDAgKi8pIHtcbiAgICByZXR1cm4gTkVHQVRJVkVfWkVST1xuICAgICAgLy8gY29udmVydCAtMCB0byArMFxuICAgICAgPyAkbmF0aXZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgMFxuICAgICAgOiAkaW5kZXhPZih0aGlzLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcbiIsIi8vIDIyLjEuMi4yIC8gMTUuNC4zLjIgQXJyYXkuaXNBcnJheShhcmcpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ0FycmF5JywgeyBpc0FycmF5OiByZXF1aXJlKCcuL19pcy1hcnJheScpIH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKTtcbnZhciBzdGVwID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIga2luZCA9IHRoaXMuX2s7XG4gIHZhciBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYgKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKSB7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUuam9pbihzZXBhcmF0b3IpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBhcnJheUpvaW4gPSBbXS5qb2luO1xuXG4vLyBmYWxsYmFjayBmb3Igbm90IGFycmF5LWxpa2Ugc3RyaW5nc1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAocmVxdWlyZSgnLi9faW9iamVjdCcpICE9IE9iamVjdCB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKGFycmF5Sm9pbikpLCAnQXJyYXknLCB7XG4gIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKSB7XG4gICAgcmV0dXJuIGFycmF5Sm9pbi5jYWxsKHRvSU9iamVjdCh0aGlzKSwgc2VwYXJhdG9yID09PSB1bmRlZmluZWQgPyAnLCcgOiBzZXBhcmF0b3IpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyICRuYXRpdmUgPSBbXS5sYXN0SW5kZXhPZjtcbnZhciBORUdBVElWRV9aRVJPID0gISEkbmF0aXZlICYmIDEgLyBbMV0ubGFzdEluZGV4T2YoMSwgLTApIDwgMDtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoTkVHQVRJVkVfWkVSTyB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRuYXRpdmUpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTQgLyAxNS40LjQuMTUgQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgWywgZnJvbUluZGV4XSlcbiAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggPSBAWyotMV0gKi8pIHtcbiAgICAvLyBjb252ZXJ0IC0wIHRvICswXG4gICAgaWYgKE5FR0FUSVZFX1pFUk8pIHJldHVybiAkbmF0aXZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgMDtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCh0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSBpbmRleCA9IE1hdGgubWluKGluZGV4LCB0b0ludGVnZXIoYXJndW1lbnRzWzFdKSk7XG4gICAgaWYgKGluZGV4IDwgMCkgaW5kZXggPSBsZW5ndGggKyBpbmRleDtcbiAgICBmb3IgKDtpbmRleCA+PSAwOyBpbmRleC0tKSBpZiAoaW5kZXggaW4gTykgaWYgKE9baW5kZXhdID09PSBzZWFyY2hFbGVtZW50KSByZXR1cm4gaW5kZXggfHwgMDtcbiAgICByZXR1cm4gLTE7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkbWFwID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDEpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10ubWFwLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTUgLyAxNS40LjQuMTkgQXJyYXkucHJvdG90eXBlLm1hcChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBtYXA6IGZ1bmN0aW9uIG1hcChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkbWFwKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xuXG4vLyBXZWJLaXQgQXJyYXkub2YgaXNuJ3QgZ2VuZXJpY1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gIShBcnJheS5vZi5jYWxsKEYpIGluc3RhbmNlb2YgRik7XG59KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMyBBcnJheS5vZiggLi4uaXRlbXMpXG4gIG9mOiBmdW5jdGlvbiBvZigvKiAuLi5hcmdzICovKSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyAodHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheSkoYUxlbik7XG4gICAgd2hpbGUgKGFMZW4gPiBpbmRleCkgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICByZXN1bHQubGVuZ3RoID0gYUxlbjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5LXJlZHVjZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10ucmVkdWNlUmlnaHQsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xOSAvIDE1LjQuNC4yMiBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQoY2FsbGJhY2tmbiBbLCBpbml0aWFsVmFsdWVdKVxuICByZWR1Y2VSaWdodDogZnVuY3Rpb24gcmVkdWNlUmlnaHQoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykge1xuICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3VtZW50c1sxXSwgdHJ1ZSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXktcmVkdWNlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5yZWR1Y2UsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xOCAvIDE1LjQuNC4yMSBBcnJheS5wcm90b3R5cGUucmVkdWNlKGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSlcbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykge1xuICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3VtZW50c1sxXSwgZmFsc2UpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgaHRtbCA9IHJlcXVpcmUoJy4vX2h0bWwnKTtcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgYXJyYXlTbGljZSA9IFtdLnNsaWNlO1xuXG4vLyBmYWxsYmFjayBmb3Igbm90IGFycmF5LWxpa2UgRVMzIHN0cmluZ3MgYW5kIERPTSBvYmplY3RzXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICBpZiAoaHRtbCkgYXJyYXlTbGljZS5jYWxsKGh0bWwpO1xufSksICdBcnJheScsIHtcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKGJlZ2luLCBlbmQpIHtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgodGhpcy5sZW5ndGgpO1xuICAgIHZhciBrbGFzcyA9IGNvZih0aGlzKTtcbiAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IGVuZDtcbiAgICBpZiAoa2xhc3MgPT0gJ0FycmF5JykgcmV0dXJuIGFycmF5U2xpY2UuY2FsbCh0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICB2YXIgc3RhcnQgPSB0b0Fic29sdXRlSW5kZXgoYmVnaW4sIGxlbik7XG4gICAgdmFyIHVwVG8gPSB0b0Fic29sdXRlSW5kZXgoZW5kLCBsZW4pO1xuICAgIHZhciBzaXplID0gdG9MZW5ndGgodXBUbyAtIHN0YXJ0KTtcbiAgICB2YXIgY2xvbmVkID0gbmV3IEFycmF5KHNpemUpO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKDsgaSA8IHNpemU7IGkrKykgY2xvbmVkW2ldID0ga2xhc3MgPT0gJ1N0cmluZydcbiAgICAgID8gdGhpcy5jaGFyQXQoc3RhcnQgKyBpKVxuICAgICAgOiB0aGlzW3N0YXJ0ICsgaV07XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRzb21lID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDMpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uc29tZSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjIzIC8gMTUuNC40LjE3IEFycmF5LnByb3RvdHlwZS5zb21lKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJHNvbWUodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciAkc29ydCA9IFtdLnNvcnQ7XG52YXIgdGVzdCA9IFsxLCAyLCAzXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBJRTgtXG4gIHRlc3Quc29ydCh1bmRlZmluZWQpO1xufSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gVjggYnVnXG4gIHRlc3Quc29ydChudWxsKTtcbiAgLy8gT2xkIFdlYktpdFxufSkgfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKSgkc29ydCkpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4yNSBBcnJheS5wcm90b3R5cGUuc29ydChjb21wYXJlZm4pXG4gIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZWZuKSB7XG4gICAgcmV0dXJuIGNvbXBhcmVmbiA9PT0gdW5kZWZpbmVkXG4gICAgICA/ICRzb3J0LmNhbGwodG9PYmplY3QodGhpcykpXG4gICAgICA6ICRzb3J0LmNhbGwodG9PYmplY3QodGhpcyksIGFGdW5jdGlvbihjb21wYXJlZm4pKTtcbiAgfVxufSk7XG4iLCJyZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKCdBcnJheScpO1xuIiwiLy8gMjAuMy4zLjEgLyAxNS45LjQuNCBEYXRlLm5vdygpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ0RhdGUnLCB7IG5vdzogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7IH0gfSk7XG4iLCIvLyAyMC4zLjQuMzYgLyAxNS45LjUuNDMgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0lTT1N0cmluZyA9IHJlcXVpcmUoJy4vX2RhdGUtdG8taXNvLXN0cmluZycpO1xuXG4vLyBQaGFudG9tSlMgLyBvbGQgV2ViS2l0IGhhcyBhIGJyb2tlbiBpbXBsZW1lbnRhdGlvbnNcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nICE9PSB0b0lTT1N0cmluZyksICdEYXRlJywge1xuICB0b0lTT1N0cmluZzogdG9JU09TdHJpbmdcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgRGF0ZShOYU4pLnRvSlNPTigpICE9PSBudWxsXG4gICAgfHwgRGF0ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoeyB0b0lTT1N0cmluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gMTsgfSB9KSAhPT0gMTtcbn0pLCAnRGF0ZScsIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKGtleSkge1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIHB2ID0gdG9QcmltaXRpdmUoTyk7XG4gICAgcmV0dXJuIHR5cGVvZiBwdiA9PSAnbnVtYmVyJyAmJiAhaXNGaW5pdGUocHYpID8gbnVsbCA6IE8udG9JU09TdHJpbmcoKTtcbiAgfVxufSk7XG4iLCJ2YXIgVE9fUFJJTUlUSVZFID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvUHJpbWl0aXZlJyk7XG52YXIgcHJvdG8gPSBEYXRlLnByb3RvdHlwZTtcblxuaWYgKCEoVE9fUFJJTUlUSVZFIGluIHByb3RvKSkgcmVxdWlyZSgnLi9faGlkZScpKHByb3RvLCBUT19QUklNSVRJVkUsIHJlcXVpcmUoJy4vX2RhdGUtdG8tcHJpbWl0aXZlJykpO1xuIiwidmFyIERhdGVQcm90byA9IERhdGUucHJvdG90eXBlO1xudmFyIElOVkFMSURfREFURSA9ICdJbnZhbGlkIERhdGUnO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgJHRvU3RyaW5nID0gRGF0ZVByb3RvW1RPX1NUUklOR107XG52YXIgZ2V0VGltZSA9IERhdGVQcm90by5nZXRUaW1lO1xuaWYgKG5ldyBEYXRlKE5hTikgKyAnJyAhPSBJTlZBTElEX0RBVEUpIHtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShEYXRlUHJvdG8sIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIHZhbHVlID0gZ2V0VGltZS5jYWxsKHRoaXMpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gJHRvU3RyaW5nLmNhbGwodGhpcykgOiBJTlZBTElEX0RBVEU7XG4gIH0pO1xufVxuIiwiLy8gMTkuMi4zLjIgLyAxNS4zLjQuNSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCh0aGlzQXJnLCBhcmdzLi4uKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdGdW5jdGlvbicsIHsgYmluZDogcmVxdWlyZSgnLi9fYmluZCcpIH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgSEFTX0lOU1RBTkNFID0gcmVxdWlyZSgnLi9fd2tzJykoJ2hhc0luc3RhbmNlJyk7XG52YXIgRnVuY3Rpb25Qcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbi8vIDE5LjIuMy42IEZ1bmN0aW9uLnByb3RvdHlwZVtAQGhhc0luc3RhbmNlXShWKVxuaWYgKCEoSEFTX0lOU1RBTkNFIGluIEZ1bmN0aW9uUHJvdG8pKSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mKEZ1bmN0aW9uUHJvdG8sIEhBU19JTlNUQU5DRSwgeyB2YWx1ZTogZnVuY3Rpb24gKE8pIHtcbiAgaWYgKHR5cGVvZiB0aGlzICE9ICdmdW5jdGlvbicgfHwgIWlzT2JqZWN0KE8pKSByZXR1cm4gZmFsc2U7XG4gIGlmICghaXNPYmplY3QodGhpcy5wcm90b3R5cGUpKSByZXR1cm4gTyBpbnN0YW5jZW9mIHRoaXM7XG4gIC8vIGZvciBlbnZpcm9ubWVudCB3L28gbmF0aXZlIGBAQGhhc0luc3RhbmNlYCBsb2dpYyBlbm91Z2ggYGluc3RhbmNlb2ZgLCBidXQgYWRkIHRoaXM6XG4gIHdoaWxlIChPID0gZ2V0UHJvdG90eXBlT2YoTykpIGlmICh0aGlzLnByb3RvdHlwZSA9PT0gTykgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn0gfSk7XG4iLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIEZQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBuYW1lUkUgPSAvXlxccypmdW5jdGlvbiAoW14gKF0qKS87XG52YXIgTkFNRSA9ICduYW1lJztcblxuLy8gMTkuMi40LjIgbmFtZVxuTkFNRSBpbiBGUHJvdG8gfHwgcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiBkUChGUHJvdG8sIE5BTUUsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuICgnJyArIHRoaXMpLm1hdGNoKG5hbWVSRSlbMV07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBNQVAgPSAnTWFwJztcblxuLy8gMjMuMSBNYXAgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoTUFQLCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBNYXAoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4xLjMuNiBNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIHZhciBlbnRyeSA9IHN0cm9uZy5nZXRFbnRyeSh2YWxpZGF0ZSh0aGlzLCBNQVApLCBrZXkpO1xuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52O1xuICB9LFxuICAvLyAyMy4xLjMuOSBNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodmFsaWRhdGUodGhpcywgTUFQKSwga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcsIHRydWUpO1xuIiwiLy8gMjAuMi4yLjMgTWF0aC5hY29zaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBsb2cxcCA9IHJlcXVpcmUoJy4vX21hdGgtbG9nMXAnKTtcbnZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xudmFyICRhY29zaCA9IE1hdGguYWNvc2g7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYWNvc2hcbiAgLy8gVjggYnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzUwOVxuICAmJiBNYXRoLmZsb29yKCRhY29zaChOdW1iZXIuTUFYX1ZBTFVFKSkgPT0gNzEwXG4gIC8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hY29zaChJbmZpbml0eSkgLT4gTmFOXG4gICYmICRhY29zaChJbmZpbml0eSkgPT0gSW5maW5pdHlcbiksICdNYXRoJywge1xuICBhY29zaDogZnVuY3Rpb24gYWNvc2goeCkge1xuICAgIHJldHVybiAoeCA9ICt4KSA8IDEgPyBOYU4gOiB4ID4gOTQ5MDYyNjUuNjI0MjUxNTZcbiAgICAgID8gTWF0aC5sb2coeCkgKyBNYXRoLkxOMlxuICAgICAgOiBsb2cxcCh4IC0gMSArIHNxcnQoeCAtIDEpICogc3FydCh4ICsgMSkpO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi41IE1hdGguYXNpbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGFzaW5oID0gTWF0aC5hc2luaDtcblxuZnVuY3Rpb24gYXNpbmgoeCkge1xuICByZXR1cm4gIWlzRmluaXRlKHggPSAreCkgfHwgeCA9PSAwID8geCA6IHggPCAwID8gLWFzaW5oKC14KSA6IE1hdGgubG9nKHggKyBNYXRoLnNxcnQoeCAqIHggKyAxKSk7XG59XG5cbi8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hc2luaCgwKSAtPiAtMFxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKCRhc2luaCAmJiAxIC8gJGFzaW5oKDApID4gMCksICdNYXRoJywgeyBhc2luaDogYXNpbmggfSk7XG4iLCIvLyAyMC4yLjIuNyBNYXRoLmF0YW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRhdGFuaCA9IE1hdGguYXRhbmg7XG5cbi8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hdGFuaCgtMCkgLT4gMFxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKCRhdGFuaCAmJiAxIC8gJGF0YW5oKC0wKSA8IDApLCAnTWF0aCcsIHtcbiAgYXRhbmg6IGZ1bmN0aW9uIGF0YW5oKHgpIHtcbiAgICByZXR1cm4gKHggPSAreCkgPT0gMCA/IHggOiBNYXRoLmxvZygoMSArIHgpIC8gKDEgLSB4KSkgLyAyO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi45IE1hdGguY2JydCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBzaWduID0gcmVxdWlyZSgnLi9fbWF0aC1zaWduJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY2JydDogZnVuY3Rpb24gY2JydCh4KSB7XG4gICAgcmV0dXJuIHNpZ24oeCA9ICt4KSAqIE1hdGgucG93KE1hdGguYWJzKHgpLCAxIC8gMyk7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjExIE1hdGguY2x6MzIoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY2x6MzI6IGZ1bmN0aW9uIGNsejMyKHgpIHtcbiAgICByZXR1cm4gKHggPj4+PSAwKSA/IDMxIC0gTWF0aC5mbG9vcihNYXRoLmxvZyh4ICsgMC41KSAqIE1hdGguTE9HMkUpIDogMzI7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjEyIE1hdGguY29zaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBleHAgPSBNYXRoLmV4cDtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjb3NoOiBmdW5jdGlvbiBjb3NoKHgpIHtcbiAgICByZXR1cm4gKGV4cCh4ID0gK3gpICsgZXhwKC14KSkgLyAyO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4xNCBNYXRoLmV4cG0xKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRleHBtMSA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoJGV4cG0xICE9IE1hdGguZXhwbTEpLCAnTWF0aCcsIHsgZXhwbTE6ICRleHBtMSB9KTtcbiIsIi8vIDIwLjIuMi4xNiBNYXRoLmZyb3VuZCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBmcm91bmQ6IHJlcXVpcmUoJy4vX21hdGgtZnJvdW5kJykgfSk7XG4iLCIvLyAyMC4yLjIuMTcgTWF0aC5oeXBvdChbdmFsdWUxWywgdmFsdWUyWywg4oCmIF1dXSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYWJzID0gTWF0aC5hYnM7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaHlwb3Q6IGZ1bmN0aW9uIGh5cG90KHZhbHVlMSwgdmFsdWUyKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgc3VtID0gMDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBsYXJnID0gMDtcbiAgICB2YXIgYXJnLCBkaXY7XG4gICAgd2hpbGUgKGkgPCBhTGVuKSB7XG4gICAgICBhcmcgPSBhYnMoYXJndW1lbnRzW2krK10pO1xuICAgICAgaWYgKGxhcmcgPCBhcmcpIHtcbiAgICAgICAgZGl2ID0gbGFyZyAvIGFyZztcbiAgICAgICAgc3VtID0gc3VtICogZGl2ICogZGl2ICsgMTtcbiAgICAgICAgbGFyZyA9IGFyZztcbiAgICAgIH0gZWxzZSBpZiAoYXJnID4gMCkge1xuICAgICAgICBkaXYgPSBhcmcgLyBsYXJnO1xuICAgICAgICBzdW0gKz0gZGl2ICogZGl2O1xuICAgICAgfSBlbHNlIHN1bSArPSBhcmc7XG4gICAgfVxuICAgIHJldHVybiBsYXJnID09PSBJbmZpbml0eSA/IEluZmluaXR5IDogbGFyZyAqIE1hdGguc3FydChzdW0pO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4xOCBNYXRoLmltdWwoeCwgeSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGltdWwgPSBNYXRoLmltdWw7XG5cbi8vIHNvbWUgV2ViS2l0IHZlcnNpb25zIGZhaWxzIHdpdGggYmlnIG51bWJlcnMsIHNvbWUgaGFzIHdyb25nIGFyaXR5XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJGltdWwoMHhmZmZmZmZmZiwgNSkgIT0gLTUgfHwgJGltdWwubGVuZ3RoICE9IDI7XG59KSwgJ01hdGgnLCB7XG4gIGltdWw6IGZ1bmN0aW9uIGltdWwoeCwgeSkge1xuICAgIHZhciBVSU5UMTYgPSAweGZmZmY7XG4gICAgdmFyIHhuID0gK3g7XG4gICAgdmFyIHluID0gK3k7XG4gICAgdmFyIHhsID0gVUlOVDE2ICYgeG47XG4gICAgdmFyIHlsID0gVUlOVDE2ICYgeW47XG4gICAgcmV0dXJuIDAgfCB4bCAqIHlsICsgKChVSU5UMTYgJiB4biA+Pj4gMTYpICogeWwgKyB4bCAqIChVSU5UMTYgJiB5biA+Pj4gMTYpIDw8IDE2ID4+PiAwKTtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMjEgTWF0aC5sb2cxMCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBsb2cxMDogZnVuY3Rpb24gbG9nMTAoeCkge1xuICAgIHJldHVybiBNYXRoLmxvZyh4KSAqIE1hdGguTE9HMTBFO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4yMCBNYXRoLmxvZzFwKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IGxvZzFwOiByZXF1aXJlKCcuL19tYXRoLWxvZzFwJykgfSk7XG4iLCIvLyAyMC4yLjIuMjIgTWF0aC5sb2cyKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGxvZzI6IGZ1bmN0aW9uIGxvZzIoeCkge1xuICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4yO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHsgc2lnbjogcmVxdWlyZSgnLi9fbWF0aC1zaWduJykgfSk7XG4iLCIvLyAyMC4yLjIuMzAgTWF0aC5zaW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGV4cG0xID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpO1xudmFyIGV4cCA9IE1hdGguZXhwO1xuXG4vLyBWOCBuZWFyIENocm9taXVtIDM4IGhhcyBhIHByb2JsZW0gd2l0aCB2ZXJ5IHNtYWxsIG51bWJlcnNcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhTWF0aC5zaW5oKC0yZS0xNykgIT0gLTJlLTE3O1xufSksICdNYXRoJywge1xuICBzaW5oOiBmdW5jdGlvbiBzaW5oKHgpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoeCA9ICt4KSA8IDFcbiAgICAgID8gKGV4cG0xKHgpIC0gZXhwbTEoLXgpKSAvIDJcbiAgICAgIDogKGV4cCh4IC0gMSkgLSBleHAoLXggLSAxKSkgKiAoTWF0aC5FIC8gMik7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjMzIE1hdGgudGFuaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBleHBtMSA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKTtcbnZhciBleHAgPSBNYXRoLmV4cDtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICB0YW5oOiBmdW5jdGlvbiB0YW5oKHgpIHtcbiAgICB2YXIgYSA9IGV4cG0xKHggPSAreCk7XG4gICAgdmFyIGIgPSBleHBtMSgteCk7XG4gICAgcmV0dXJuIGEgPT0gSW5maW5pdHkgPyAxIDogYiA9PSBJbmZpbml0eSA/IC0xIDogKGEgLSBiKSAvIChleHAoeCkgKyBleHAoLXgpKTtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMzQgTWF0aC50cnVuYyh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICB0cnVuYzogZnVuY3Rpb24gdHJ1bmMoaXQpIHtcbiAgICByZXR1cm4gKGl0ID4gMCA/IE1hdGguZmxvb3IgOiBNYXRoLmNlaWwpKGl0KTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciAkdHJpbSA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbTtcbnZhciBOVU1CRVIgPSAnTnVtYmVyJztcbnZhciAkTnVtYmVyID0gZ2xvYmFsW05VTUJFUl07XG52YXIgQmFzZSA9ICROdW1iZXI7XG52YXIgcHJvdG8gPSAkTnVtYmVyLnByb3RvdHlwZTtcbi8vIE9wZXJhIH4xMiBoYXMgYnJva2VuIE9iamVjdCN0b1N0cmluZ1xudmFyIEJST0tFTl9DT0YgPSBjb2YocmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpKHByb3RvKSkgPT0gTlVNQkVSO1xudmFyIFRSSU0gPSAndHJpbScgaW4gU3RyaW5nLnByb3RvdHlwZTtcblxuLy8gNy4xLjMgVG9OdW1iZXIoYXJndW1lbnQpXG52YXIgdG9OdW1iZXIgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIGl0ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsIGZhbHNlKTtcbiAgaWYgKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyAmJiBpdC5sZW5ndGggPiAyKSB7XG4gICAgaXQgPSBUUklNID8gaXQudHJpbSgpIDogJHRyaW0oaXQsIDMpO1xuICAgIHZhciBmaXJzdCA9IGl0LmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIHRoaXJkLCByYWRpeCwgbWF4Q29kZTtcbiAgICBpZiAoZmlyc3QgPT09IDQzIHx8IGZpcnN0ID09PSA0NSkge1xuICAgICAgdGhpcmQgPSBpdC5jaGFyQ29kZUF0KDIpO1xuICAgICAgaWYgKHRoaXJkID09PSA4OCB8fCB0aGlyZCA9PT0gMTIwKSByZXR1cm4gTmFOOyAvLyBOdW1iZXIoJysweDEnKSBzaG91bGQgYmUgTmFOLCBvbGQgVjggZml4XG4gICAgfSBlbHNlIGlmIChmaXJzdCA9PT0gNDgpIHtcbiAgICAgIHN3aXRjaCAoaXQuY2hhckNvZGVBdCgxKSkge1xuICAgICAgICBjYXNlIDY2OiBjYXNlIDk4OiByYWRpeCA9IDI7IG1heENvZGUgPSA0OTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgL14wYlswMV0rJC9pXG4gICAgICAgIGNhc2UgNzk6IGNhc2UgMTExOiByYWRpeCA9IDg7IG1heENvZGUgPSA1NTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgL14wb1swLTddKyQvaVxuICAgICAgICBkZWZhdWx0OiByZXR1cm4gK2l0O1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgZGlnaXRzID0gaXQuc2xpY2UoMiksIGkgPSAwLCBsID0gZGlnaXRzLmxlbmd0aCwgY29kZTsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb2RlID0gZGlnaXRzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIC8vIHBhcnNlSW50IHBhcnNlcyBhIHN0cmluZyB0byBhIGZpcnN0IHVuYXZhaWxhYmxlIHN5bWJvbFxuICAgICAgICAvLyBidXQgVG9OdW1iZXIgc2hvdWxkIHJldHVybiBOYU4gaWYgYSBzdHJpbmcgY29udGFpbnMgdW5hdmFpbGFibGUgc3ltYm9sc1xuICAgICAgICBpZiAoY29kZSA8IDQ4IHx8IGNvZGUgPiBtYXhDb2RlKSByZXR1cm4gTmFOO1xuICAgICAgfSByZXR1cm4gcGFyc2VJbnQoZGlnaXRzLCByYWRpeCk7XG4gICAgfVxuICB9IHJldHVybiAraXQ7XG59O1xuXG5pZiAoISROdW1iZXIoJyAwbzEnKSB8fCAhJE51bWJlcignMGIxJykgfHwgJE51bWJlcignKzB4MScpKSB7XG4gICROdW1iZXIgPSBmdW5jdGlvbiBOdW1iZXIodmFsdWUpIHtcbiAgICB2YXIgaXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMSA/IDAgOiB2YWx1ZTtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgcmV0dXJuIHRoYXQgaW5zdGFuY2VvZiAkTnVtYmVyXG4gICAgICAvLyBjaGVjayBvbiAxLi5jb25zdHJ1Y3Rvcihmb28pIGNhc2VcbiAgICAgICYmIChCUk9LRU5fQ09GID8gZmFpbHMoZnVuY3Rpb24gKCkgeyBwcm90by52YWx1ZU9mLmNhbGwodGhhdCk7IH0pIDogY29mKHRoYXQpICE9IE5VTUJFUilcbiAgICAgICAgPyBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSh0b051bWJlcihpdCkpLCB0aGF0LCAkTnVtYmVyKSA6IHRvTnVtYmVyKGl0KTtcbiAgfTtcbiAgZm9yICh2YXIga2V5cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BOKEJhc2UpIDogKFxuICAgIC8vIEVTMzpcbiAgICAnTUFYX1ZBTFVFLE1JTl9WQUxVRSxOYU4sTkVHQVRJVkVfSU5GSU5JVFksUE9TSVRJVkVfSU5GSU5JVFksJyArXG4gICAgLy8gRVM2IChpbiBjYXNlLCBpZiBtb2R1bGVzIHdpdGggRVM2IE51bWJlciBzdGF0aWNzIHJlcXVpcmVkIGJlZm9yZSk6XG4gICAgJ0VQU0lMT04saXNGaW5pdGUsaXNJbnRlZ2VyLGlzTmFOLGlzU2FmZUludGVnZXIsTUFYX1NBRkVfSU5URUdFUiwnICtcbiAgICAnTUlOX1NBRkVfSU5URUdFUixwYXJzZUZsb2F0LHBhcnNlSW50LGlzSW50ZWdlcidcbiAgKS5zcGxpdCgnLCcpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7IGorKykge1xuICAgIGlmIChoYXMoQmFzZSwga2V5ID0ga2V5c1tqXSkgJiYgIWhhcygkTnVtYmVyLCBrZXkpKSB7XG4gICAgICBkUCgkTnVtYmVyLCBrZXksIGdPUEQoQmFzZSwga2V5KSk7XG4gICAgfVxuICB9XG4gICROdW1iZXIucHJvdG90eXBlID0gcHJvdG87XG4gIHByb3RvLmNvbnN0cnVjdG9yID0gJE51bWJlcjtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShnbG9iYWwsIE5VTUJFUiwgJE51bWJlcik7XG59XG4iLCIvLyAyMC4xLjIuMSBOdW1iZXIuRVBTSUxPTlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7IEVQU0lMT046IE1hdGgucG93KDIsIC01MikgfSk7XG4iLCIvLyAyMC4xLjIuMiBOdW1iZXIuaXNGaW5pdGUobnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBfaXNGaW5pdGUgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5pc0Zpbml0ZTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzRmluaXRlOiBmdW5jdGlvbiBpc0Zpbml0ZShpdCkge1xuICAgIHJldHVybiB0eXBlb2YgaXQgPT0gJ251bWJlcicgJiYgX2lzRmluaXRlKGl0KTtcbiAgfVxufSk7XG4iLCIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywgeyBpc0ludGVnZXI6IHJlcXVpcmUoJy4vX2lzLWludGVnZXInKSB9KTtcbiIsIi8vIDIwLjEuMi40IE51bWJlci5pc05hTihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNOYU46IGZ1bmN0aW9uIGlzTmFOKG51bWJlcikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICByZXR1cm4gbnVtYmVyICE9IG51bWJlcjtcbiAgfVxufSk7XG4iLCIvLyAyMC4xLjIuNSBOdW1iZXIuaXNTYWZlSW50ZWdlcihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJy4vX2lzLWludGVnZXInKTtcbnZhciBhYnMgPSBNYXRoLmFicztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzU2FmZUludGVnZXI6IGZ1bmN0aW9uIGlzU2FmZUludGVnZXIobnVtYmVyKSB7XG4gICAgcmV0dXJuIGlzSW50ZWdlcihudW1iZXIpICYmIGFicyhudW1iZXIpIDw9IDB4MWZmZmZmZmZmZmZmZmY7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMS4yLjYgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywgeyBNQVhfU0FGRV9JTlRFR0VSOiAweDFmZmZmZmZmZmZmZmZmIH0pO1xuIiwiLy8gMjAuMS4yLjEwIE51bWJlci5NSU5fU0FGRV9JTlRFR0VSXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHsgTUlOX1NBRkVfSU5URUdFUjogLTB4MWZmZmZmZmZmZmZmZmYgfSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRwYXJzZUZsb2F0ID0gcmVxdWlyZSgnLi9fcGFyc2UtZmxvYXQnKTtcbi8vIDIwLjEuMi4xMiBOdW1iZXIucGFyc2VGbG9hdChzdHJpbmcpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChOdW1iZXIucGFyc2VGbG9hdCAhPSAkcGFyc2VGbG9hdCksICdOdW1iZXInLCB7IHBhcnNlRmxvYXQ6ICRwYXJzZUZsb2F0IH0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19wYXJzZS1pbnQnKTtcbi8vIDIwLjEuMi4xMyBOdW1iZXIucGFyc2VJbnQoc3RyaW5nLCByYWRpeClcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE51bWJlci5wYXJzZUludCAhPSAkcGFyc2VJbnQpLCAnTnVtYmVyJywgeyBwYXJzZUludDogJHBhcnNlSW50IH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgYU51bWJlclZhbHVlID0gcmVxdWlyZSgnLi9fYS1udW1iZXItdmFsdWUnKTtcbnZhciByZXBlYXQgPSByZXF1aXJlKCcuL19zdHJpbmctcmVwZWF0Jyk7XG52YXIgJHRvRml4ZWQgPSAxLjAudG9GaXhlZDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgZGF0YSA9IFswLCAwLCAwLCAwLCAwLCAwXTtcbnZhciBFUlJPUiA9ICdOdW1iZXIudG9GaXhlZDogaW5jb3JyZWN0IGludm9jYXRpb24hJztcbnZhciBaRVJPID0gJzAnO1xuXG52YXIgbXVsdGlwbHkgPSBmdW5jdGlvbiAobiwgYykge1xuICB2YXIgaSA9IC0xO1xuICB2YXIgYzIgPSBjO1xuICB3aGlsZSAoKytpIDwgNikge1xuICAgIGMyICs9IG4gKiBkYXRhW2ldO1xuICAgIGRhdGFbaV0gPSBjMiAlIDFlNztcbiAgICBjMiA9IGZsb29yKGMyIC8gMWU3KTtcbiAgfVxufTtcbnZhciBkaXZpZGUgPSBmdW5jdGlvbiAobikge1xuICB2YXIgaSA9IDY7XG4gIHZhciBjID0gMDtcbiAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgYyArPSBkYXRhW2ldO1xuICAgIGRhdGFbaV0gPSBmbG9vcihjIC8gbik7XG4gICAgYyA9IChjICUgbikgKiAxZTc7XG4gIH1cbn07XG52YXIgbnVtVG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpID0gNjtcbiAgdmFyIHMgPSAnJztcbiAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgaWYgKHMgIT09ICcnIHx8IGkgPT09IDAgfHwgZGF0YVtpXSAhPT0gMCkge1xuICAgICAgdmFyIHQgPSBTdHJpbmcoZGF0YVtpXSk7XG4gICAgICBzID0gcyA9PT0gJycgPyB0IDogcyArIHJlcGVhdC5jYWxsKFpFUk8sIDcgLSB0Lmxlbmd0aCkgKyB0O1xuICAgIH1cbiAgfSByZXR1cm4gcztcbn07XG52YXIgcG93ID0gZnVuY3Rpb24gKHgsIG4sIGFjYykge1xuICByZXR1cm4gbiA9PT0gMCA/IGFjYyA6IG4gJSAyID09PSAxID8gcG93KHgsIG4gLSAxLCBhY2MgKiB4KSA6IHBvdyh4ICogeCwgbiAvIDIsIGFjYyk7XG59O1xudmFyIGxvZyA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBuID0gMDtcbiAgdmFyIHgyID0geDtcbiAgd2hpbGUgKHgyID49IDQwOTYpIHtcbiAgICBuICs9IDEyO1xuICAgIHgyIC89IDQwOTY7XG4gIH1cbiAgd2hpbGUgKHgyID49IDIpIHtcbiAgICBuICs9IDE7XG4gICAgeDIgLz0gMjtcbiAgfSByZXR1cm4gbjtcbn07XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKCEhJHRvRml4ZWQgJiYgKFxuICAwLjAwMDA4LnRvRml4ZWQoMykgIT09ICcwLjAwMCcgfHxcbiAgMC45LnRvRml4ZWQoMCkgIT09ICcxJyB8fFxuICAxLjI1NS50b0ZpeGVkKDIpICE9PSAnMS4yNScgfHxcbiAgMTAwMDAwMDAwMDAwMDAwMDEyOC4wLnRvRml4ZWQoMCkgIT09ICcxMDAwMDAwMDAwMDAwMDAwMTI4J1xuKSB8fCAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIC8vIFY4IH4gQW5kcm9pZCA0LjMtXG4gICR0b0ZpeGVkLmNhbGwoe30pO1xufSkpLCAnTnVtYmVyJywge1xuICB0b0ZpeGVkOiBmdW5jdGlvbiB0b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKSB7XG4gICAgdmFyIHggPSBhTnVtYmVyVmFsdWUodGhpcywgRVJST1IpO1xuICAgIHZhciBmID0gdG9JbnRlZ2VyKGZyYWN0aW9uRGlnaXRzKTtcbiAgICB2YXIgcyA9ICcnO1xuICAgIHZhciBtID0gWkVSTztcbiAgICB2YXIgZSwgeiwgaiwgaztcbiAgICBpZiAoZiA8IDAgfHwgZiA+IDIwKSB0aHJvdyBSYW5nZUVycm9yKEVSUk9SKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKHggIT0geCkgcmV0dXJuICdOYU4nO1xuICAgIGlmICh4IDw9IC0xZTIxIHx8IHggPj0gMWUyMSkgcmV0dXJuIFN0cmluZyh4KTtcbiAgICBpZiAoeCA8IDApIHtcbiAgICAgIHMgPSAnLSc7XG4gICAgICB4ID0gLXg7XG4gICAgfVxuICAgIGlmICh4ID4gMWUtMjEpIHtcbiAgICAgIGUgPSBsb2coeCAqIHBvdygyLCA2OSwgMSkpIC0gNjk7XG4gICAgICB6ID0gZSA8IDAgPyB4ICogcG93KDIsIC1lLCAxKSA6IHggLyBwb3coMiwgZSwgMSk7XG4gICAgICB6ICo9IDB4MTAwMDAwMDAwMDAwMDA7XG4gICAgICBlID0gNTIgLSBlO1xuICAgICAgaWYgKGUgPiAwKSB7XG4gICAgICAgIG11bHRpcGx5KDAsIHopO1xuICAgICAgICBqID0gZjtcbiAgICAgICAgd2hpbGUgKGogPj0gNykge1xuICAgICAgICAgIG11bHRpcGx5KDFlNywgMCk7XG4gICAgICAgICAgaiAtPSA3O1xuICAgICAgICB9XG4gICAgICAgIG11bHRpcGx5KHBvdygxMCwgaiwgMSksIDApO1xuICAgICAgICBqID0gZSAtIDE7XG4gICAgICAgIHdoaWxlIChqID49IDIzKSB7XG4gICAgICAgICAgZGl2aWRlKDEgPDwgMjMpO1xuICAgICAgICAgIGogLT0gMjM7XG4gICAgICAgIH1cbiAgICAgICAgZGl2aWRlKDEgPDwgaik7XG4gICAgICAgIG11bHRpcGx5KDEsIDEpO1xuICAgICAgICBkaXZpZGUoMik7XG4gICAgICAgIG0gPSBudW1Ub1N0cmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXVsdGlwbHkoMCwgeik7XG4gICAgICAgIG11bHRpcGx5KDEgPDwgLWUsIDApO1xuICAgICAgICBtID0gbnVtVG9TdHJpbmcoKSArIHJlcGVhdC5jYWxsKFpFUk8sIGYpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZiA+IDApIHtcbiAgICAgIGsgPSBtLmxlbmd0aDtcbiAgICAgIG0gPSBzICsgKGsgPD0gZiA/ICcwLicgKyByZXBlYXQuY2FsbChaRVJPLCBmIC0gaykgKyBtIDogbS5zbGljZSgwLCBrIC0gZikgKyAnLicgKyBtLnNsaWNlKGsgLSBmKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBzICsgbTtcbiAgICB9IHJldHVybiBtO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBhTnVtYmVyVmFsdWUgPSByZXF1aXJlKCcuL19hLW51bWJlci12YWx1ZScpO1xudmFyICR0b1ByZWNpc2lvbiA9IDEuMC50b1ByZWNpc2lvbjtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gSUU3LVxuICByZXR1cm4gJHRvUHJlY2lzaW9uLmNhbGwoMSwgdW5kZWZpbmVkKSAhPT0gJzEnO1xufSkgfHwgISRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIFY4IH4gQW5kcm9pZCA0LjMtXG4gICR0b1ByZWNpc2lvbi5jYWxsKHt9KTtcbn0pKSwgJ051bWJlcicsIHtcbiAgdG9QcmVjaXNpb246IGZ1bmN0aW9uIHRvUHJlY2lzaW9uKHByZWNpc2lvbikge1xuICAgIHZhciB0aGF0ID0gYU51bWJlclZhbHVlKHRoaXMsICdOdW1iZXIjdG9QcmVjaXNpb246IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xuICAgIHJldHVybiBwcmVjaXNpb24gPT09IHVuZGVmaW5lZCA/ICR0b1ByZWNpc2lvbi5jYWxsKHRoYXQpIDogJHRvUHJlY2lzaW9uLmNhbGwodGhhdCwgcHJlY2lzaW9uKTtcbiAgfVxufSk7XG4iLCIvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7IGFzc2lnbjogcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpIH0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IGNyZWF0ZTogcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpIH0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi4zIC8gMTUuMi4zLjcgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7IGRlZmluZVByb3BlcnRpZXM6IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKSB9KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHsgZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYgfSk7XG4iLCIvLyAxOS4xLjIuNSBPYmplY3QuZnJlZXplKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2ZyZWV6ZScsIGZ1bmN0aW9uICgkZnJlZXplKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmcmVlemUoaXQpIHtcbiAgICByZXR1cm4gJGZyZWV6ZSAmJiBpc09iamVjdChpdCkgPyAkZnJlZXplKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0b0lPYmplY3QoaXQpLCBrZXkpO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eU5hbWVzJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0JykuZjtcbn0pO1xuIiwiLy8gMTkuMS4yLjkgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciAkZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0UHJvdG90eXBlT2YnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihpdCkge1xuICAgIHJldHVybiAkZ2V0UHJvdG90eXBlT2YodG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjExIE9iamVjdC5pc0V4dGVuc2libGUoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzRXh0ZW5zaWJsZScsIGZ1bmN0aW9uICgkaXNFeHRlbnNpYmxlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpc0V4dGVuc2libGUoaXQpIHtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzRXh0ZW5zaWJsZSA/ICRpc0V4dGVuc2libGUoaXQpIDogdHJ1ZSA6IGZhbHNlO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuMTIgT2JqZWN0LmlzRnJvemVuKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc0Zyb3plbicsIGZ1bmN0aW9uICgkaXNGcm96ZW4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzRnJvemVuKGl0KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc0Zyb3plbiA/ICRpc0Zyb3plbihpdCkgOiBmYWxzZSA6IHRydWU7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMi4xMyBPYmplY3QuaXNTZWFsZWQoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzU2VhbGVkJywgZnVuY3Rpb24gKCRpc1NlYWxlZCkge1xuICByZXR1cm4gZnVuY3Rpb24gaXNTZWFsZWQoaXQpIHtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzU2VhbGVkID8gJGlzU2VhbGVkKGl0KSA6IGZhbHNlIDogdHJ1ZTtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4zLjEwIE9iamVjdC5pcyh2YWx1ZTEsIHZhbHVlMilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHsgaXM6IHJlcXVpcmUoJy4vX3NhbWUtdmFsdWUnKSB9KTtcbiIsIi8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyhPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2tleXMnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBrZXlzKGl0KSB7XG4gICAgcmV0dXJuICRrZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMi4xNSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJykub25GcmVlemU7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgncHJldmVudEV4dGVuc2lvbnMnLCBmdW5jdGlvbiAoJHByZXZlbnRFeHRlbnNpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyhpdCkge1xuICAgIHJldHVybiAkcHJldmVudEV4dGVuc2lvbnMgJiYgaXNPYmplY3QoaXQpID8gJHByZXZlbnRFeHRlbnNpb25zKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuMTcgT2JqZWN0LnNlYWwoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJykub25GcmVlemU7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnc2VhbCcsIGZ1bmN0aW9uICgkc2VhbCkge1xuICByZXR1cm4gZnVuY3Rpb24gc2VhbChpdCkge1xuICAgIHJldHVybiAkc2VhbCAmJiBpc09iamVjdChpdCkgPyAkc2VhbChtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHsgc2V0UHJvdG90eXBlT2Y6IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldCB9KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgdGVzdCA9IHt9O1xudGVzdFtyZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKV0gPSAneic7XG5pZiAodGVzdCArICcnICE9ICdbb2JqZWN0IHpdJykge1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKE9iamVjdC5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcbiAgfSwgdHJ1ZSk7XG59XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRwYXJzZUZsb2F0ID0gcmVxdWlyZSgnLi9fcGFyc2UtZmxvYXQnKTtcbi8vIDE4LjIuNCBwYXJzZUZsb2F0KHN0cmluZylcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5GICogKHBhcnNlRmxvYXQgIT0gJHBhcnNlRmxvYXQpLCB7IHBhcnNlRmxvYXQ6ICRwYXJzZUZsb2F0IH0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19wYXJzZS1pbnQnKTtcbi8vIDE4LjIuNSBwYXJzZUludChzdHJpbmcsIHJhZGl4KVxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkYgKiAocGFyc2VJbnQgIT0gJHBhcnNlSW50KSwgeyBwYXJzZUludDogJHBhcnNlSW50IH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXQ7XG52YXIgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcbnZhciBwZXJmb3JtID0gcmVxdWlyZSgnLi9fcGVyZm9ybScpO1xudmFyIHByb21pc2VSZXNvbHZlID0gcmVxdWlyZSgnLi9fcHJvbWlzZS1yZXNvbHZlJyk7XG52YXIgUFJPTUlTRSA9ICdQcm9taXNlJztcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciAkUHJvbWlzZSA9IGdsb2JhbFtQUk9NSVNFXTtcbnZhciBpc05vZGUgPSBjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJztcbnZhciBlbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBJbnRlcm5hbCwgbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5LCBPd25Qcm9taXNlQ2FwYWJpbGl0eSwgV3JhcHBlcjtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmY7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgLy8gY29ycmVjdCBzdWJjbGFzc2luZyB3aXRoIEBAc3BlY2llcyBzdXBwb3J0XG4gICAgdmFyIHByb21pc2UgPSAkUHJvbWlzZS5yZXNvbHZlKDEpO1xuICAgIHZhciBGYWtlUHJvbWlzZSA9IChwcm9taXNlLmNvbnN0cnVjdG9yID0ge30pW3JlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyldID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgICAgIGV4ZWMoZW1wdHksIGVtcHR5KTtcbiAgICB9O1xuICAgIC8vIHVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgICByZXR1cm4gKGlzTm9kZSB8fCB0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50ID09ICdmdW5jdGlvbicpICYmIHByb21pc2UudGhlbihlbXB0eSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIChwcm9taXNlLCBpc1JlamVjdCkge1xuICBpZiAocHJvbWlzZS5fbikgcmV0dXJuO1xuICBwcm9taXNlLl9uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYztcbiAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciBvayA9IHByb21pc2UuX3MgPT0gMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uIChyZWFjdGlvbikge1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbDtcbiAgICAgIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTtcbiAgICAgIHZhciByZWplY3QgPSByZWFjdGlvbi5yZWplY3Q7XG4gICAgICB2YXIgZG9tYWluID0gcmVhY3Rpb24uZG9tYWluO1xuICAgICAgdmFyIHJlc3VsdCwgdGhlbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgaWYgKHByb21pc2UuX2ggPT0gMikgb25IYW5kbGVVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgICAgICAgICBwcm9taXNlLl9oID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhbmRsZXIgPT09IHRydWUpIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRvbWFpbikgZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2UpIHtcbiAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoID4gaSkgcnVuKGNoYWluW2krK10pOyAvLyB2YXJpYWJsZSBsZW5ndGggLSBjYW4ndCB1c2UgZm9yRWFjaFxuICAgIHByb21pc2UuX2MgPSBbXTtcbiAgICBwcm9taXNlLl9uID0gZmFsc2U7XG4gICAgaWYgKGlzUmVqZWN0ICYmICFwcm9taXNlLl9oKSBvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XG4gICAgdmFyIHVuaGFuZGxlZCA9IGlzVW5oYW5kbGVkKHByb21pc2UpO1xuICAgIHZhciByZXN1bHQsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgaWYgKHVuaGFuZGxlZCkge1xuICAgICAgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKSB7XG4gICAgICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogdmFsdWUgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgcHJvbWlzZS5faCA9IGlzTm9kZSB8fCBpc1VuaGFuZGxlZChwcm9taXNlKSA/IDIgOiAxO1xuICAgIH0gcHJvbWlzZS5fYSA9IHVuZGVmaW5lZDtcbiAgICBpZiAodW5oYW5kbGVkICYmIHJlc3VsdC5lKSB0aHJvdyByZXN1bHQudjtcbiAgfSk7XG59O1xudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgcmV0dXJuIHByb21pc2UuX2ggIT09IDEgJiYgKHByb21pc2UuX2EgfHwgcHJvbWlzZS5fYykubGVuZ3RoID09PSAwO1xufTtcbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFuZGxlcjtcbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBnbG9iYWwub25yZWplY3Rpb25oYW5kbGVkKSB7XG4gICAgICBoYW5kbGVyKHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiBwcm9taXNlLl92IH0pO1xuICAgIH1cbiAgfSk7XG59O1xudmFyICRyZWplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmICghcHJvbWlzZS5fYSkgcHJvbWlzZS5fYSA9IHByb21pc2UuX2Muc2xpY2UoKTtcbiAgbm90aWZ5KHByb21pc2UsIHRydWUpO1xufTtcbnZhciAkcmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIHZhciB0aGVuO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHRyeSB7XG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICBpZiAodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKSB7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHsgX3c6IHByb21pc2UsIF9kOiBmYWxzZSB9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgJHJlamVjdC5jYWxsKHdyYXBwZXIsIGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICAgICAgcHJvbWlzZS5fcyA9IDE7XG4gICAgICBub3RpZnkocHJvbWlzZSwgZmFsc2UpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgICRyZWplY3QuY2FsbCh7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmICghVVNFX05BVElWRSkge1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICAkUHJvbWlzZSA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAkcmVqZWN0LmNhbGwodGhpcywgZXJyKTtcbiAgICB9XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICB0aGlzLl9jID0gW107ICAgICAgICAgICAgIC8vIDwtIGF3YWl0aW5nIHJlYWN0aW9uc1xuICAgIHRoaXMuX2EgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gY2hlY2tlZCBpbiBpc1VuaGFuZGxlZCByZWFjdGlvbnNcbiAgICB0aGlzLl9zID0gMDsgICAgICAgICAgICAgIC8vIDwtIHN0YXRlXG4gICAgdGhpcy5fZCA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBkb25lXG4gICAgdGhpcy5fdiA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSB2YWx1ZVxuICAgIHRoaXMuX2ggPSAwOyAgICAgICAgICAgICAgLy8gPC0gcmVqZWN0aW9uIHN0YXRlLCAwIC0gZGVmYXVsdCwgMSAtIGhhbmRsZWQsIDIgLSB1bmhhbmRsZWRcbiAgICB0aGlzLl9uID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIG5vdGlmeVxuICB9O1xuICBJbnRlcm5hbC5wcm90b3R5cGUgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKSgkUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgIHZhciByZWFjdGlvbiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkUHJvbWlzZSkpO1xuICAgICAgcmVhY3Rpb24ub2sgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICAgIHJlYWN0aW9uLmZhaWwgPSB0eXBlb2Ygb25SZWplY3RlZCA9PSAnZnVuY3Rpb24nICYmIG9uUmVqZWN0ZWQ7XG4gICAgICByZWFjdGlvbi5kb21haW4gPSBpc05vZGUgPyBwcm9jZXNzLmRvbWFpbiA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2MucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fYSkgdGhpcy5fYS5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLl9zKSBub3RpZnkodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICB9KTtcbiAgT3duUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgSW50ZXJuYWwoKTtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMucmVzb2x2ZSA9IGN0eCgkcmVzb2x2ZSwgcHJvbWlzZSwgMSk7XG4gICAgdGhpcy5yZWplY3QgPSBjdHgoJHJlamVjdCwgcHJvbWlzZSwgMSk7XG4gIH07XG4gIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmYgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uIChDKSB7XG4gICAgcmV0dXJuIEMgPT09ICRQcm9taXNlIHx8IEMgPT09IFdyYXBwZXJcbiAgICAgID8gbmV3IE93blByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICA6IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBQcm9taXNlOiAkUHJvbWlzZSB9KTtcbnJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJykoJFByb21pc2UsIFBST01JU0UpO1xucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKShQUk9NSVNFKTtcbldyYXBwZXIgPSByZXF1aXJlKCcuL19jb3JlJylbUFJPTUlTRV07XG5cbi8vIHN0YXRpY3NcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjUgUHJvbWlzZS5yZWplY3QocilcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3Qocikge1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcyk7XG4gICAgdmFyICQkcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgJCRyZWplY3Qocik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChMSUJSQVJZIHx8ICFVU0VfTkFUSVZFKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNiBQcm9taXNlLnJlc29sdmUoeClcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKExJQlJBUlkgJiYgdGhpcyA9PT0gV3JhcHBlciA/ICRQcm9taXNlIDogdGhpcywgeCk7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKFVTRV9OQVRJVkUgJiYgcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbiAoaXRlcikge1xuICAkUHJvbWlzZS5hbGwoaXRlcilbJ2NhdGNoJ10oZW1wdHkpO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IDE7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHZhciAkaW5kZXggPSBpbmRleCsrO1xuICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZSkgcmVqZWN0KHJlc3VsdC52KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjEgUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgckFwcGx5ID0gKHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3QgfHwge30pLmFwcGx5O1xudmFyIGZBcHBseSA9IEZ1bmN0aW9uLmFwcGx5O1xuLy8gTVMgRWRnZSBhcmd1bWVudHNMaXN0IGFyZ3VtZW50IGlzIG9wdGlvbmFsXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgckFwcGx5KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG59KSwgJ1JlZmxlY3QnLCB7XG4gIGFwcGx5OiBmdW5jdGlvbiBhcHBseSh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdCkge1xuICAgIHZhciBUID0gYUZ1bmN0aW9uKHRhcmdldCk7XG4gICAgdmFyIEwgPSBhbk9iamVjdChhcmd1bWVudHNMaXN0KTtcbiAgICByZXR1cm4gckFwcGx5ID8gckFwcGx5KFQsIHRoaXNBcmd1bWVudCwgTCkgOiBmQXBwbHkuY2FsbChULCB0aGlzQXJndW1lbnQsIEwpO1xuICB9XG59KTtcbiIsIi8vIDI2LjEuMiBSZWZsZWN0LmNvbnN0cnVjdCh0YXJnZXQsIGFyZ3VtZW50c0xpc3QgWywgbmV3VGFyZ2V0XSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuL19iaW5kJyk7XG52YXIgckNvbnN0cnVjdCA9IChyZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0IHx8IHt9KS5jb25zdHJ1Y3Q7XG5cbi8vIE1TIEVkZ2Ugc3VwcG9ydHMgb25seSAyIGFyZ3VtZW50cyBhbmQgYXJndW1lbnRzTGlzdCBhcmd1bWVudCBpcyBvcHRpb25hbFxuLy8gRkYgTmlnaHRseSBzZXRzIHRoaXJkIGFyZ3VtZW50IGFzIGBuZXcudGFyZ2V0YCwgYnV0IGRvZXMgbm90IGNyZWF0ZSBgdGhpc2AgZnJvbSBpdFxudmFyIE5FV19UQVJHRVRfQlVHID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiAhKHJDb25zdHJ1Y3QoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCBbXSwgRikgaW5zdGFuY2VvZiBGKTtcbn0pO1xudmFyIEFSR1NfQlVHID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgckNvbnN0cnVjdChmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE5FV19UQVJHRVRfQlVHIHx8IEFSR1NfQlVHKSwgJ1JlZmxlY3QnLCB7XG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gY29uc3RydWN0KFRhcmdldCwgYXJncyAvKiAsIG5ld1RhcmdldCAqLykge1xuICAgIGFGdW5jdGlvbihUYXJnZXQpO1xuICAgIGFuT2JqZWN0KGFyZ3MpO1xuICAgIHZhciBuZXdUYXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IFRhcmdldCA6IGFGdW5jdGlvbihhcmd1bWVudHNbMl0pO1xuICAgIGlmIChBUkdTX0JVRyAmJiAhTkVXX1RBUkdFVF9CVUcpIHJldHVybiByQ29uc3RydWN0KFRhcmdldCwgYXJncywgbmV3VGFyZ2V0KTtcbiAgICBpZiAoVGFyZ2V0ID09IG5ld1RhcmdldCkge1xuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBvcHRpbWl6YXRpb24gZm9yIDAtNCBhcmd1bWVudHNcbiAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IFRhcmdldCgpO1xuICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0pO1xuICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgfVxuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBsb3Qgb2YgYXJndW1lbnRzIGNhc2VcbiAgICAgIHZhciAkYXJncyA9IFtudWxsXTtcbiAgICAgICRhcmdzLnB1c2guYXBwbHkoJGFyZ3MsIGFyZ3MpO1xuICAgICAgcmV0dXJuIG5ldyAoYmluZC5hcHBseShUYXJnZXQsICRhcmdzKSkoKTtcbiAgICB9XG4gICAgLy8gd2l0aCBhbHRlcmVkIG5ld1RhcmdldCwgbm90IHN1cHBvcnQgYnVpbHQtaW4gY29uc3RydWN0b3JzXG4gICAgdmFyIHByb3RvID0gbmV3VGFyZ2V0LnByb3RvdHlwZTtcbiAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGUoaXNPYmplY3QocHJvdG8pID8gcHJvdG8gOiBPYmplY3QucHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gRnVuY3Rpb24uYXBwbHkuY2FsbChUYXJnZXQsIGluc3RhbmNlLCBhcmdzKTtcbiAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IGluc3RhbmNlO1xuICB9XG59KTtcbiIsIi8vIDI2LjEuMyBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpXG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG4vLyBNUyBFZGdlIGhhcyBicm9rZW4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSAtIHRocm93aW5nIGluc3RlYWQgb2YgcmV0dXJuaW5nIGZhbHNlXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShkUC5mKHt9LCAxLCB7IHZhbHVlOiAxIH0pLCAxLCB7IHZhbHVlOiAyIH0pO1xufSksICdSZWZsZWN0Jywge1xuICBkZWZpbmVQcm9wZXJ0eTogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcykge1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgcHJvcGVydHlLZXkgPSB0b1ByaW1pdGl2ZShwcm9wZXJ0eUtleSwgdHJ1ZSk7XG4gICAgYW5PYmplY3QoYXR0cmlidXRlcyk7XG4gICAgdHJ5IHtcbiAgICAgIGRQLmYodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcbiIsIi8vIDI2LjEuNCBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBkZWxldGVQcm9wZXJ0eTogZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIHZhciBkZXNjID0gZ09QRChhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gICAgcmV0dXJuIGRlc2MgJiYgIWRlc2MuY29uZmlndXJhYmxlID8gZmFsc2UgOiBkZWxldGUgdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyNi4xLjUgUmVmbGVjdC5lbnVtZXJhdGUodGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIEVudW1lcmF0ZSA9IGZ1bmN0aW9uIChpdGVyYXRlZCkge1xuICB0aGlzLl90ID0gYW5PYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB2YXIga2V5cyA9IHRoaXMuX2sgPSBbXTsgICAgICAvLyBrZXlzXG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIGl0ZXJhdGVkKSBrZXlzLnB1c2goa2V5KTtcbn07XG5yZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpKEVudW1lcmF0ZSwgJ09iamVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSB0aGlzO1xuICB2YXIga2V5cyA9IHRoYXQuX2s7XG4gIHZhciBrZXk7XG4gIGRvIHtcbiAgICBpZiAodGhhdC5faSA+PSBrZXlzLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9IHdoaWxlICghKChrZXkgPSBrZXlzW3RoYXQuX2krK10pIGluIHRoYXQuX3QpKTtcbiAgcmV0dXJuIHsgdmFsdWU6IGtleSwgZG9uZTogZmFsc2UgfTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGVudW1lcmF0ZTogZnVuY3Rpb24gZW51bWVyYXRlKHRhcmdldCkge1xuICAgIHJldHVybiBuZXcgRW51bWVyYXRlKHRhcmdldCk7XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS43IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIHJldHVybiBnT1BELmYoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuICB9XG59KTtcbiIsIi8vIDI2LjEuOCBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZ2V0UHJvdG8gPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSB7XG4gICAgcmV0dXJuIGdldFByb3RvKGFuT2JqZWN0KHRhcmdldCkpO1xuICB9XG59KTtcbiIsIi8vIDI2LjEuNiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3BlcnR5S2V5IFssIHJlY2VpdmVyXSlcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG5mdW5jdGlvbiBnZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSAvKiAsIHJlY2VpdmVyICovKSB7XG4gIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogYXJndW1lbnRzWzJdO1xuICB2YXIgZGVzYywgcHJvdG87XG4gIGlmIChhbk9iamVjdCh0YXJnZXQpID09PSByZWNlaXZlcikgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eUtleV07XG4gIGlmIChkZXNjID0gZ09QRC5mKHRhcmdldCwgcHJvcGVydHlLZXkpKSByZXR1cm4gaGFzKGRlc2MsICd2YWx1ZScpXG4gICAgPyBkZXNjLnZhbHVlXG4gICAgOiBkZXNjLmdldCAhPT0gdW5kZWZpbmVkXG4gICAgICA/IGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgaWYgKGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSkpIHJldHVybiBnZXQocHJvdG8sIHByb3BlcnR5S2V5LCByZWNlaXZlcik7XG59XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHsgZ2V0OiBnZXQgfSk7XG4iLCIvLyAyNi4xLjkgUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wZXJ0eUtleSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgaGFzOiBmdW5jdGlvbiBoYXModGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIHJldHVybiBwcm9wZXJ0eUtleSBpbiB0YXJnZXQ7XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS4xMCBSZWZsZWN0LmlzRXh0ZW5zaWJsZSh0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgJGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgaXNFeHRlbnNpYmxlOiBmdW5jdGlvbiBpc0V4dGVuc2libGUodGFyZ2V0KSB7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICByZXR1cm4gJGlzRXh0ZW5zaWJsZSA/ICRpc0V4dGVuc2libGUodGFyZ2V0KSA6IHRydWU7XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS4xMSBSZWZsZWN0Lm93bktleXModGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0JywgeyBvd25LZXlzOiByZXF1aXJlKCcuL19vd24ta2V5cycpIH0pO1xuIiwiLy8gMjYuMS4xMiBSZWZsZWN0LnByZXZlbnRFeHRlbnNpb25zKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciAkcHJldmVudEV4dGVuc2lvbnMgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnM7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgcHJldmVudEV4dGVuc2lvbnM6IGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCkge1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICgkcHJldmVudEV4dGVuc2lvbnMpICRwcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7XG4iLCIvLyAyNi4xLjE0IFJlZmxlY3Quc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgc2V0UHJvdG8gPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKTtcblxuaWYgKHNldFByb3RvKSAkZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIHNldFByb3RvdHlwZU9mOiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKSB7XG4gICAgc2V0UHJvdG8uY2hlY2sodGFyZ2V0LCBwcm90byk7XG4gICAgdHJ5IHtcbiAgICAgIHNldFByb3RvLnNldCh0YXJnZXQsIHByb3RvKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS4xMyBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWIFssIHJlY2VpdmVyXSlcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxuZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHlLZXksIFYgLyogLCByZWNlaXZlciAqLykge1xuICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgNCA/IHRhcmdldCA6IGFyZ3VtZW50c1szXTtcbiAgdmFyIG93bkRlc2MgPSBnT1BELmYoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuICB2YXIgZXhpc3RpbmdEZXNjcmlwdG9yLCBwcm90bztcbiAgaWYgKCFvd25EZXNjKSB7XG4gICAgaWYgKGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSkpIHtcbiAgICAgIHJldHVybiBzZXQocHJvdG8sIHByb3BlcnR5S2V5LCBWLCByZWNlaXZlcik7XG4gICAgfVxuICAgIG93bkRlc2MgPSBjcmVhdGVEZXNjKDApO1xuICB9XG4gIGlmIChoYXMob3duRGVzYywgJ3ZhbHVlJykpIHtcbiAgICBpZiAob3duRGVzYy53cml0YWJsZSA9PT0gZmFsc2UgfHwgIWlzT2JqZWN0KHJlY2VpdmVyKSkgcmV0dXJuIGZhbHNlO1xuICAgIGV4aXN0aW5nRGVzY3JpcHRvciA9IGdPUEQuZihyZWNlaXZlciwgcHJvcGVydHlLZXkpIHx8IGNyZWF0ZURlc2MoMCk7XG4gICAgZXhpc3RpbmdEZXNjcmlwdG9yLnZhbHVlID0gVjtcbiAgICBkUC5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSwgZXhpc3RpbmdEZXNjcmlwdG9yKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gb3duRGVzYy5zZXQgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogKG93bkRlc2Muc2V0LmNhbGwocmVjZWl2ZXIsIFYpLCB0cnVlKTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0JywgeyBzZXQ6IHNldCB9KTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKTtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbnZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpO1xudmFyICRmbGFncyA9IHJlcXVpcmUoJy4vX2ZsYWdzJyk7XG52YXIgJFJlZ0V4cCA9IGdsb2JhbC5SZWdFeHA7XG52YXIgQmFzZSA9ICRSZWdFeHA7XG52YXIgcHJvdG8gPSAkUmVnRXhwLnByb3RvdHlwZTtcbnZhciByZTEgPSAvYS9nO1xudmFyIHJlMiA9IC9hL2c7XG4vLyBcIm5ld1wiIGNyZWF0ZXMgYSBuZXcgb2JqZWN0LCBvbGQgd2Via2l0IGJ1Z2d5IGhlcmVcbnZhciBDT1JSRUNUX05FVyA9IG5ldyAkUmVnRXhwKHJlMSkgIT09IHJlMTtcblxuaWYgKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgKCFDT1JSRUNUX05FVyB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmUyW3JlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpXSA9IGZhbHNlO1xuICAvLyBSZWdFeHAgY29uc3RydWN0b3IgY2FuIGFsdGVyIGZsYWdzIGFuZCBJc1JlZ0V4cCB3b3JrcyBjb3JyZWN0IHdpdGggQEBtYXRjaFxuICByZXR1cm4gJFJlZ0V4cChyZTEpICE9IHJlMSB8fCAkUmVnRXhwKHJlMikgPT0gcmUyIHx8ICRSZWdFeHAocmUxLCAnaScpICE9ICcvYS9pJztcbn0pKSkge1xuICAkUmVnRXhwID0gZnVuY3Rpb24gUmVnRXhwKHAsIGYpIHtcbiAgICB2YXIgdGlSRSA9IHRoaXMgaW5zdGFuY2VvZiAkUmVnRXhwO1xuICAgIHZhciBwaVJFID0gaXNSZWdFeHAocCk7XG4gICAgdmFyIGZpVSA9IGYgPT09IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gIXRpUkUgJiYgcGlSRSAmJiBwLmNvbnN0cnVjdG9yID09PSAkUmVnRXhwICYmIGZpVSA/IHBcbiAgICAgIDogaW5oZXJpdElmUmVxdWlyZWQoQ09SUkVDVF9ORVdcbiAgICAgICAgPyBuZXcgQmFzZShwaVJFICYmICFmaVUgPyBwLnNvdXJjZSA6IHAsIGYpXG4gICAgICAgIDogQmFzZSgocGlSRSA9IHAgaW5zdGFuY2VvZiAkUmVnRXhwKSA/IHAuc291cmNlIDogcCwgcGlSRSAmJiBmaVUgPyAkZmxhZ3MuY2FsbChwKSA6IGYpXG4gICAgICAsIHRpUkUgPyB0aGlzIDogcHJvdG8sICRSZWdFeHApO1xuICB9O1xuICB2YXIgcHJveHkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAga2V5IGluICRSZWdFeHAgfHwgZFAoJFJlZ0V4cCwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJhc2Vba2V5XTsgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKGl0KSB7IEJhc2Vba2V5XSA9IGl0OyB9XG4gICAgfSk7XG4gIH07XG4gIGZvciAodmFyIGtleXMgPSBnT1BOKEJhc2UpLCBpID0gMDsga2V5cy5sZW5ndGggPiBpOykgcHJveHkoa2V5c1tpKytdKTtcbiAgcHJvdG8uY29uc3RydWN0b3IgPSAkUmVnRXhwO1xuICAkUmVnRXhwLnByb3RvdHlwZSA9IHByb3RvO1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKGdsb2JhbCwgJ1JlZ0V4cCcsICRSZWdFeHApO1xufVxuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKCdSZWdFeHAnKTtcbiIsIi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzKClcbmlmIChyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmIC8uL2cuZmxhZ3MgIT0gJ2cnKSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mKFJlZ0V4cC5wcm90b3R5cGUsICdmbGFncycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IHJlcXVpcmUoJy4vX2ZsYWdzJylcbn0pO1xuIiwiLy8gQEBtYXRjaCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdtYXRjaCcsIDEsIGZ1bmN0aW9uIChkZWZpbmVkLCBNQVRDSCwgJG1hdGNoKSB7XG4gIC8vIDIxLjEuMy4xMSBTdHJpbmcucHJvdG90eXBlLm1hdGNoKHJlZ2V4cClcbiAgcmV0dXJuIFtmdW5jdGlvbiBtYXRjaChyZWdleHApIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgIHZhciBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbTUFUQ0hdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW01BVENIXShTdHJpbmcoTykpO1xuICB9LCAkbWF0Y2hdO1xufSk7XG4iLCIvLyBAQHJlcGxhY2UgbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgncmVwbGFjZScsIDIsIGZ1bmN0aW9uIChkZWZpbmVkLCBSRVBMQUNFLCAkcmVwbGFjZSkge1xuICAvLyAyMS4xLjMuMTQgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpXG4gIHJldHVybiBbZnVuY3Rpb24gcmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICB2YXIgZm4gPSBzZWFyY2hWYWx1ZSA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZWFyY2hWYWx1ZVtSRVBMQUNFXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZFxuICAgICAgPyBmbi5jYWxsKHNlYXJjaFZhbHVlLCBPLCByZXBsYWNlVmFsdWUpXG4gICAgICA6ICRyZXBsYWNlLmNhbGwoU3RyaW5nKE8pLCBzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKTtcbiAgfSwgJHJlcGxhY2VdO1xufSk7XG4iLCIvLyBAQHNlYXJjaCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdzZWFyY2gnLCAxLCBmdW5jdGlvbiAoZGVmaW5lZCwgU0VBUkNILCAkc2VhcmNoKSB7XG4gIC8vIDIxLjEuMy4xNSBTdHJpbmcucHJvdG90eXBlLnNlYXJjaChyZWdleHApXG4gIHJldHVybiBbZnVuY3Rpb24gc2VhcmNoKHJlZ2V4cCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgTyA9IGRlZmluZWQodGhpcyk7XG4gICAgdmFyIGZuID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtTRUFSQ0hdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW1NFQVJDSF0oU3RyaW5nKE8pKTtcbiAgfSwgJHNlYXJjaF07XG59KTtcbiIsIi8vIEBAc3BsaXQgbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnc3BsaXQnLCAyLCBmdW5jdGlvbiAoZGVmaW5lZCwgU1BMSVQsICRzcGxpdCkge1xuICAndXNlIHN0cmljdCc7XG4gIHZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpO1xuICB2YXIgX3NwbGl0ID0gJHNwbGl0O1xuICB2YXIgJHB1c2ggPSBbXS5wdXNoO1xuICB2YXIgJFNQTElUID0gJ3NwbGl0JztcbiAgdmFyIExFTkdUSCA9ICdsZW5ndGgnO1xuICB2YXIgTEFTVF9JTkRFWCA9ICdsYXN0SW5kZXgnO1xuICBpZiAoXG4gICAgJ2FiYmMnWyRTUExJVF0oLyhiKSovKVsxXSA9PSAnYycgfHxcbiAgICAndGVzdCdbJFNQTElUXSgvKD86KS8sIC0xKVtMRU5HVEhdICE9IDQgfHxcbiAgICAnYWInWyRTUExJVF0oLyg/OmFiKSovKVtMRU5HVEhdICE9IDIgfHxcbiAgICAnLidbJFNQTElUXSgvKC4/KSguPykvKVtMRU5HVEhdICE9IDQgfHxcbiAgICAnLidbJFNQTElUXSgvKCkoKS8pW0xFTkdUSF0gPiAxIHx8XG4gICAgJydbJFNQTElUXSgvLj8vKVtMRU5HVEhdXG4gICkge1xuICAgIHZhciBOUENHID0gLygpPz8vLmV4ZWMoJycpWzFdID09PSB1bmRlZmluZWQ7IC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwXG4gICAgLy8gYmFzZWQgb24gZXM1LXNoaW0gaW1wbGVtZW50YXRpb24sIG5lZWQgdG8gcmV3b3JrIGl0XG4gICAgJHNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHZhciBzdHJpbmcgPSBTdHJpbmcodGhpcyk7XG4gICAgICBpZiAoc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDApIHJldHVybiBbXTtcbiAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICBpZiAoIWlzUmVnRXhwKHNlcGFyYXRvcikpIHJldHVybiBfc3BsaXQuY2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgdmFyIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IubXVsdGlsaW5lID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IudW5pY29kZSA/ICd1JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnN0aWNreSA/ICd5JyA6ICcnKTtcbiAgICAgIHZhciBsYXN0TGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBzcGxpdExpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IDQyOTQ5NjcyOTUgOiBsaW1pdCA+Pj4gMDtcbiAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICB2YXIgc2VwYXJhdG9yQ29weSA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xuICAgICAgdmFyIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGgsIGk7XG4gICAgICAvLyBEb2Vzbid0IG5lZWQgZmxhZ3MgZ3ksIGJ1dCB0aGV5IGRvbid0IGh1cnRcbiAgICAgIGlmICghTlBDRykgc2VwYXJhdG9yMiA9IG5ldyBSZWdFeHAoJ14nICsgc2VwYXJhdG9yQ29weS5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIGZsYWdzKTtcbiAgICAgIHdoaWxlIChtYXRjaCA9IHNlcGFyYXRvckNvcHkuZXhlYyhzdHJpbmcpKSB7XG4gICAgICAgIC8vIGBzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleGAgaXMgbm90IHJlbGlhYmxlIGNyb3NzLWJyb3dzZXJcbiAgICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXVtMRU5HVEhdO1xuICAgICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvciBOUENHXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvb3AtZnVuY1xuICAgICAgICAgIGlmICghTlBDRyAmJiBtYXRjaFtMRU5HVEhdID4gMSkgbWF0Y2hbMF0ucmVwbGFjZShzZXBhcmF0b3IyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzW0xFTkdUSF0gLSAyOyBpKyspIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCkgbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKG1hdGNoW0xFTkdUSF0gPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nW0xFTkdUSF0pICRwdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXVtMRU5HVEhdO1xuICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgaWYgKG91dHB1dFtMRU5HVEhdID49IHNwbGl0TGltaXQpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXBhcmF0b3JDb3B5W0xBU1RfSU5ERVhdID09PSBtYXRjaC5pbmRleCkgc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXSsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICB9XG4gICAgICBpZiAobGFzdExhc3RJbmRleCA9PT0gc3RyaW5nW0xFTkdUSF0pIHtcbiAgICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvckNvcHkudGVzdCgnJykpIG91dHB1dC5wdXNoKCcnKTtcbiAgICAgIH0gZWxzZSBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCkpO1xuICAgICAgcmV0dXJuIG91dHB1dFtMRU5HVEhdID4gc3BsaXRMaW1pdCA/IG91dHB1dC5zbGljZSgwLCBzcGxpdExpbWl0KSA6IG91dHB1dDtcbiAgICB9O1xuICAvLyBDaGFrcmEsIFY4XG4gIH0gZWxzZSBpZiAoJzAnWyRTUExJVF0odW5kZWZpbmVkLCAwKVtMRU5HVEhdKSB7XG4gICAgJHNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHJldHVybiBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCAmJiBsaW1pdCA9PT0gMCA/IFtdIDogX3NwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfTtcbiAgfVxuICAvLyAyMS4xLjMuMTcgU3RyaW5nLnByb3RvdHlwZS5zcGxpdChzZXBhcmF0b3IsIGxpbWl0KVxuICByZXR1cm4gW2Z1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICB2YXIgTyA9IGRlZmluZWQodGhpcyk7XG4gICAgdmFyIGZuID0gc2VwYXJhdG9yID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlcGFyYXRvcltTUExJVF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHNlcGFyYXRvciwgTywgbGltaXQpIDogJHNwbGl0LmNhbGwoU3RyaW5nKE8pLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgfSwgJHNwbGl0XTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xucmVxdWlyZSgnLi9lczYucmVnZXhwLmZsYWdzJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciAkZmxhZ3MgPSByZXF1aXJlKCcuL19mbGFncycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyICR0b1N0cmluZyA9IC8uL1tUT19TVFJJTkddO1xuXG52YXIgZGVmaW5lID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoUmVnRXhwLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmbiwgdHJ1ZSk7XG59O1xuXG4vLyAyMS4yLjUuMTQgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZygpXG5pZiAocmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7IHJldHVybiAkdG9TdHJpbmcuY2FsbCh7IHNvdXJjZTogJ2EnLCBmbGFnczogJ2InIH0pICE9ICcvYS9iJzsgfSkpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciBSID0gYW5PYmplY3QodGhpcyk7XG4gICAgcmV0dXJuICcvJy5jb25jYXQoUi5zb3VyY2UsICcvJyxcbiAgICAgICdmbGFncycgaW4gUiA/IFIuZmxhZ3MgOiAhREVTQ1JJUFRPUlMgJiYgUiBpbnN0YW5jZW9mIFJlZ0V4cCA/ICRmbGFncy5jYWxsKFIpIDogdW5kZWZpbmVkKTtcbiAgfSk7XG4vLyBGRjQ0LSBSZWdFeHAjdG9TdHJpbmcgaGFzIGEgd3JvbmcgbmFtZVxufSBlbHNlIGlmICgkdG9TdHJpbmcubmFtZSAhPSBUT19TVFJJTkcpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbiAgfSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBTRVQgPSAnU2V0JztcblxuLy8gMjMuMiBTZXQgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoU0VULCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4yLjMuMSBTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih2YWxpZGF0ZSh0aGlzLCBTRVQpLCB2YWx1ZSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlLCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZyk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4yIFN0cmluZy5wcm90b3R5cGUuYW5jaG9yKG5hbWUpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdhbmNob3InLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gYW5jaG9yKG5hbWUpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYScsICduYW1lJywgbmFtZSk7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjMgU3RyaW5nLnByb3RvdHlwZS5iaWcoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYmlnJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJpZygpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYmlnJywgJycsICcnKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNCBTdHJpbmcucHJvdG90eXBlLmJsaW5rKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JsaW5rJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJsaW5rKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdibGluaycsICcnLCAnJyk7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjUgU3RyaW5nLnByb3RvdHlwZS5ib2xkKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JvbGQnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gYm9sZCgpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYicsICcnLCAnJyk7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykoZmFsc2UpO1xuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy4zIFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXQocG9zKVxuICBjb2RlUG9pbnRBdDogZnVuY3Rpb24gY29kZVBvaW50QXQocG9zKSB7XG4gICAgcmV0dXJuICRhdCh0aGlzLCBwb3MpO1xuICB9XG59KTtcbiIsIi8vIDIxLjEuMy42IFN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGgoc2VhcmNoU3RyaW5nIFssIGVuZFBvc2l0aW9uXSlcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBjb250ZXh0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKTtcbnZhciBFTkRTX1dJVEggPSAnZW5kc1dpdGgnO1xudmFyICRlbmRzV2l0aCA9ICcnW0VORFNfV0lUSF07XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoRU5EU19XSVRIKSwgJ1N0cmluZycsIHtcbiAgZW5kc1dpdGg6IGZ1bmN0aW9uIGVuZHNXaXRoKHNlYXJjaFN0cmluZyAvKiAsIGVuZFBvc2l0aW9uID0gQGxlbmd0aCAqLykge1xuICAgIHZhciB0aGF0ID0gY29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIEVORFNfV0lUSCk7XG4gICAgdmFyIGVuZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIGxlbiA9IHRvTGVuZ3RoKHRoYXQubGVuZ3RoKTtcbiAgICB2YXIgZW5kID0gZW5kUG9zaXRpb24gPT09IHVuZGVmaW5lZCA/IGxlbiA6IE1hdGgubWluKHRvTGVuZ3RoKGVuZFBvc2l0aW9uKSwgbGVuKTtcbiAgICB2YXIgc2VhcmNoID0gU3RyaW5nKHNlYXJjaFN0cmluZyk7XG4gICAgcmV0dXJuICRlbmRzV2l0aFxuICAgICAgPyAkZW5kc1dpdGguY2FsbCh0aGF0LCBzZWFyY2gsIGVuZClcbiAgICAgIDogdGhhdC5zbGljZShlbmQgLSBzZWFyY2gubGVuZ3RoLCBlbmQpID09PSBzZWFyY2g7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNiBTdHJpbmcucHJvdG90eXBlLmZpeGVkKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZpeGVkJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZpeGVkKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICd0dCcsICcnLCAnJyk7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjcgU3RyaW5nLnByb3RvdHlwZS5mb250Y29sb3IoY29sb3IpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdmb250Y29sb3InLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gZm9udGNvbG9yKGNvbG9yKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2ZvbnQnLCAnY29sb3InLCBjb2xvcik7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjggU3RyaW5nLnByb3RvdHlwZS5mb250c2l6ZShzaXplKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnZm9udHNpemUnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gZm9udHNpemUoc2l6ZSkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdmb250JywgJ3NpemUnLCBzaXplKTtcbiAgfTtcbn0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG52YXIgJGZyb21Db2RlUG9pbnQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludDtcblxuLy8gbGVuZ3RoIHNob3VsZCBiZSAxLCBvbGQgRkYgcHJvYmxlbVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoISEkZnJvbUNvZGVQb2ludCAmJiAkZnJvbUNvZGVQb2ludC5sZW5ndGggIT0gMSksICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMi4yIFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmNvZGVQb2ludHMpXG4gIGZyb21Db2RlUG9pbnQ6IGZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoeCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGNvZGU7XG4gICAgd2hpbGUgKGFMZW4gPiBpKSB7XG4gICAgICBjb2RlID0gK2FyZ3VtZW50c1tpKytdO1xuICAgICAgaWYgKHRvQWJzb2x1dGVJbmRleChjb2RlLCAweDEwZmZmZikgIT09IGNvZGUpIHRocm93IFJhbmdlRXJyb3IoY29kZSArICcgaXMgbm90IGEgdmFsaWQgY29kZSBwb2ludCcpO1xuICAgICAgcmVzLnB1c2goY29kZSA8IDB4MTAwMDBcbiAgICAgICAgPyBmcm9tQ2hhckNvZGUoY29kZSlcbiAgICAgICAgOiBmcm9tQ2hhckNvZGUoKChjb2RlIC09IDB4MTAwMDApID4+IDEwKSArIDB4ZDgwMCwgY29kZSAlIDB4NDAwICsgMHhkYzAwKVxuICAgICAgKTtcbiAgICB9IHJldHVybiByZXMuam9pbignJyk7XG4gIH1cbn0pO1xuIiwiLy8gMjEuMS4zLjcgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcyhzZWFyY2hTdHJpbmcsIHBvc2l0aW9uID0gMClcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY29udGV4dCA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0Jyk7XG52YXIgSU5DTFVERVMgPSAnaW5jbHVkZXMnO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKElOQ0xVREVTKSwgJ1N0cmluZycsIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaFN0cmluZyAvKiAsIHBvc2l0aW9uID0gMCAqLykge1xuICAgIHJldHVybiAhIX5jb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgSU5DTFVERVMpXG4gICAgICAuaW5kZXhPZihzZWFyY2hTdHJpbmcsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy45IFN0cmluZy5wcm90b3R5cGUuaXRhbGljcygpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdpdGFsaWNzJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGl0YWxpY3MoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2knLCAnJywgJycpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIgaW5kZXggPSB0aGlzLl9pO1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBPLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4geyB2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjEwIFN0cmluZy5wcm90b3R5cGUubGluayh1cmwpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdsaW5rJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGxpbmsodXJsKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2EnLCAnaHJlZicsIHVybCk7XG4gIH07XG59KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjIuNCBTdHJpbmcucmF3KGNhbGxTaXRlLCAuLi5zdWJzdGl0dXRpb25zKVxuICByYXc6IGZ1bmN0aW9uIHJhdyhjYWxsU2l0ZSkge1xuICAgIHZhciB0cGwgPSB0b0lPYmplY3QoY2FsbFNpdGUucmF3KTtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgodHBsLmxlbmd0aCk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGxlbiA+IGkpIHtcbiAgICAgIHJlcy5wdXNoKFN0cmluZyh0cGxbaSsrXSkpO1xuICAgICAgaWYgKGkgPCBhTGVuKSByZXMucHVzaChTdHJpbmcoYXJndW1lbnRzW2ldKSk7XG4gICAgfSByZXR1cm4gcmVzLmpvaW4oJycpO1xuICB9XG59KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuMTMgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQoY291bnQpXG4gIHJlcGVhdDogcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpXG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjExIFN0cmluZy5wcm90b3R5cGUuc21hbGwoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc21hbGwnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gc21hbGwoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3NtYWxsJywgJycsICcnKTtcbiAgfTtcbn0pO1xuIiwiLy8gMjEuMS4zLjE4IFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgWywgcG9zaXRpb24gXSlcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBjb250ZXh0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKTtcbnZhciBTVEFSVFNfV0lUSCA9ICdzdGFydHNXaXRoJztcbnZhciAkc3RhcnRzV2l0aCA9ICcnW1NUQVJUU19XSVRIXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShTVEFSVFNfV0lUSCksICdTdHJpbmcnLCB7XG4gIHN0YXJ0c1dpdGg6IGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nIC8qICwgcG9zaXRpb24gPSAwICovKSB7XG4gICAgdmFyIHRoYXQgPSBjb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgU1RBUlRTX1dJVEgpO1xuICAgIHZhciBpbmRleCA9IHRvTGVuZ3RoKE1hdGgubWluKGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCB0aGF0Lmxlbmd0aCkpO1xuICAgIHZhciBzZWFyY2ggPSBTdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICByZXR1cm4gJHN0YXJ0c1dpdGhcbiAgICAgID8gJHN0YXJ0c1dpdGguY2FsbCh0aGF0LCBzZWFyY2gsIGluZGV4KVxuICAgICAgOiB0aGF0LnNsaWNlKGluZGV4LCBpbmRleCArIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTIgU3RyaW5nLnByb3RvdHlwZS5zdHJpa2UoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc3RyaWtlJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN0cmlrZSgpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc3RyaWtlJywgJycsICcnKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTMgU3RyaW5nLnByb3RvdHlwZS5zdWIoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc3ViJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN1YigpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc3ViJywgJycsICcnKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTQgU3RyaW5nLnByb3RvdHlwZS5zdXAoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc3VwJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN1cCgpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc3VwJywgJycsICcnKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjEuMS4zLjI1IFN0cmluZy5wcm90b3R5cGUudHJpbSgpXG5yZXF1aXJlKCcuL19zdHJpbmctdHJpbScpKCd0cmltJywgZnVuY3Rpb24gKCR0cmltKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltKCkge1xuICAgIHJldHVybiAkdHJpbSh0aGlzLCAzKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIE1FVEEgPSByZXF1aXJlKCcuL19tZXRhJykuS0VZO1xudmFyICRmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciB3a3NEZWZpbmUgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJyk7XG52YXIgZW51bUtleXMgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBfY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGdPUE5FeHQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKTtcbnZhciAkR09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgJERQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUEQgPSAkR09QRC5mO1xudmFyIGRQID0gJERQLmY7XG52YXIgZ09QTiA9IGdPUE5FeHQuZjtcbnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciAkSlNPTiA9IGdsb2JhbC5KU09OO1xudmFyIF9zdHJpbmdpZnkgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgSElEREVOID0gd2tzKCdfaGlkZGVuJyk7XG52YXIgVE9fUFJJTUlUSVZFID0gd2tzKCd0b1ByaW1pdGl2ZScpO1xudmFyIGlzRW51bSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKTtcbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT1BTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciBVU0VfTkFUSVZFID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcbnZhciBRT2JqZWN0ID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZFAodGhpcywgJ2EnLCB7IHZhbHVlOiA3IH0pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24gKGl0LCBrZXksIEQpIHtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmIChwcm90b0Rlc2MpIGRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xuICBkUChpdCwga2V5LCBEKTtcbiAgaWYgKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pIGRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFA7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24gKHRhZykge1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCkge1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvKSAkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuICBhbk9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEQpO1xuICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgICBpZiAoIUQuZW51bWVyYWJsZSkge1xuICAgICAgaWYgKCFoYXMoaXQsIEhJRERFTikpIGRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSBpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHsgZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSkgfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gZFAoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCkge1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSk7XG4gIHZhciBpID0gMDtcbiAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGwgPiBpKSAkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKSB7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KSB7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmICh0aGlzID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICBpdCA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybjtcbiAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpO1xuICBpZiAoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKSBELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHZhciBuYW1lcyA9IGdPUE4odG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmICghaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4gJiYga2V5ICE9IE1FVEEpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICB2YXIgSVNfT1AgPSBpdCA9PT0gT2JqZWN0UHJvdG87XG4gIHZhciBuYW1lcyA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSkgcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpIHRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8pICRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmIChoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKSB0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmIChERVNDUklQVE9SUyAmJiBzZXR0ZXIpIHNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldCB9KTtcbiAgICByZXR1cm4gd3JhcCh0YWcpO1xuICB9O1xuICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgPSAkZGVmaW5lUHJvcGVydHk7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZiAoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vX2xpYnJhcnknKSkge1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgd2tzRXh0LmYgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgU3ltYm9sOiAkU3ltYm9sIH0pO1xuXG5mb3IgKHZhciBlczZTeW1ib2xzID0gKFxuICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGogPSAwOyBlczZTeW1ib2xzLmxlbmd0aCA+IGo7KXdrcyhlczZTeW1ib2xzW2orK10pO1xuXG5mb3IgKHZhciB3ZWxsS25vd25TeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgayA9IDA7IHdlbGxLbm93blN5bWJvbHMubGVuZ3RoID4gazspIHdrc0RlZmluZSh3ZWxsS25vd25TeW1ib2xzW2srK10pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkge1xuICAgIGlmICghaXNTeW1ib2woc3ltKSkgdGhyb3cgVHlwZUVycm9yKHN5bSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICAgIGZvciAodmFyIGtleSBpbiBTeW1ib2xSZWdpc3RyeSkgaWYgKFN5bWJvbFJlZ2lzdHJ5W2tleV0gPT09IHN5bSkgcmV0dXJuIGtleTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBTID0gJFN5bWJvbCgpO1xuICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHsgYTogUyB9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xufSkpLCAnSlNPTicsIHtcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpIHtcbiAgICB2YXIgYXJncyA9IFtpdF07XG4gICAgdmFyIGkgPSAxO1xuICAgIHZhciByZXBsYWNlciwgJHJlcGxhY2VyO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICAkcmVwbGFjZXIgPSByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYgKCFpc09iamVjdChyZXBsYWNlcikgJiYgaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpIHJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICAgIGlmICghaXNBcnJheShyZXBsYWNlcikpIHJlcGxhY2VyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgJHJlcGxhY2VyID09ICdmdW5jdGlvbicpIHZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZiAoIWlzU3ltYm9sKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbiAgfVxufSk7XG5cbi8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcbiRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdIHx8IHJlcXVpcmUoJy4vX2hpZGUnKSgkU3ltYm9sW1BST1RPVFlQRV0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEVdLnZhbHVlT2YpO1xuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcbi8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHR5cGVkID0gcmVxdWlyZSgnLi9fdHlwZWQnKTtcbnZhciBidWZmZXIgPSByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIEFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuQXJyYXlCdWZmZXI7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyICRBcnJheUJ1ZmZlciA9IGJ1ZmZlci5BcnJheUJ1ZmZlcjtcbnZhciAkRGF0YVZpZXcgPSBidWZmZXIuRGF0YVZpZXc7XG52YXIgJGlzVmlldyA9ICR0eXBlZC5BQlYgJiYgQXJyYXlCdWZmZXIuaXNWaWV3O1xudmFyICRzbGljZSA9ICRBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2U7XG52YXIgVklFVyA9ICR0eXBlZC5WSUVXO1xudmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEFycmF5QnVmZmVyICE9PSAkQXJyYXlCdWZmZXIpLCB7IEFycmF5QnVmZmVyOiAkQXJyYXlCdWZmZXIgfSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISR0eXBlZC5DT05TVFIsIEFSUkFZX0JVRkZFUiwge1xuICAvLyAyNC4xLjMuMSBBcnJheUJ1ZmZlci5pc1ZpZXcoYXJnKVxuICBpc1ZpZXc6IGZ1bmN0aW9uIGlzVmlldyhpdCkge1xuICAgIHJldHVybiAkaXNWaWV3ICYmICRpc1ZpZXcoaXQpIHx8IGlzT2JqZWN0KGl0KSAmJiBWSUVXIGluIGl0O1xuICB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlUgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICFuZXcgJEFycmF5QnVmZmVyKDIpLnNsaWNlKDEsIHVuZGVmaW5lZCkuYnl0ZUxlbmd0aDtcbn0pLCBBUlJBWV9CVUZGRVIsIHtcbiAgLy8gMjQuMS40LjMgQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgaWYgKCRzbGljZSAhPT0gdW5kZWZpbmVkICYmIGVuZCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJHNsaWNlLmNhbGwoYW5PYmplY3QodGhpcyksIHN0YXJ0KTsgLy8gRkYgZml4XG4gICAgdmFyIGxlbiA9IGFuT2JqZWN0KHRoaXMpLmJ5dGVMZW5ndGg7XG4gICAgdmFyIGZpcnN0ID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW4pO1xuICAgIHZhciBmaW5hbCA9IHRvQWJzb2x1dGVJbmRleChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IGVuZCwgbGVuKTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IChzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJEFycmF5QnVmZmVyKSkodG9MZW5ndGgoZmluYWwgLSBmaXJzdCkpO1xuICAgIHZhciB2aWV3UyA9IG5ldyAkRGF0YVZpZXcodGhpcyk7XG4gICAgdmFyIHZpZXdUID0gbmV3ICREYXRhVmlldyhyZXN1bHQpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgd2hpbGUgKGZpcnN0IDwgZmluYWwpIHtcbiAgICAgIHZpZXdULnNldFVpbnQ4KGluZGV4KyssIHZpZXdTLmdldFVpbnQ4KGZpcnN0KyspKTtcbiAgICB9IHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKEFSUkFZX0JVRkZFUik7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fdHlwZWQnKS5BQlYsIHtcbiAgRGF0YVZpZXc6IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpLkRhdGFWaWV3XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0Zsb2F0MzInLCA0LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gRmxvYXQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0Zsb2F0NjQnLCA4LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gRmxvYXQ2NEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0ludDE2JywgMiwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50MzInLCA0LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gSW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQ4JywgMSwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50MTYnLCAyLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDMyJywgNCwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQ4JywgMSwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQ4QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDgnLCAxLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhDbGFtcGVkQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0sIHRydWUpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGVhY2ggPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMCk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpO1xudmFyIHdlYWsgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXdlYWsnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBXRUFLX01BUCA9ICdXZWFrTWFwJztcbnZhciBnZXRXZWFrID0gbWV0YS5nZXRXZWFrO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IHdlYWsudWZzdG9yZTtcbnZhciB0bXAgPSB7fTtcbnZhciBJbnRlcm5hbE1hcDtcblxudmFyIHdyYXBwZXIgPSBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrTWFwKCkge1xuICAgIHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICB9O1xufTtcblxudmFyIG1ldGhvZHMgPSB7XG4gIC8vIDIzLjMuMy4zIFdlYWtNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh2YWxpZGF0ZSh0aGlzLCBXRUFLX01BUCkpLmdldChrZXkpO1xuICAgICAgcmV0dXJuIGRhdGEgPyBkYXRhW3RoaXMuX2ldIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfSxcbiAgLy8gMjMuMy4zLjUgV2Vha01hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gd2Vhay5kZWYodmFsaWRhdGUodGhpcywgV0VBS19NQVApLCBrZXksIHZhbHVlKTtcbiAgfVxufTtcblxuLy8gMjMuMyBXZWFrTWFwIE9iamVjdHNcbnZhciAkV2Vha01hcCA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFdFQUtfTUFQLCB3cmFwcGVyLCBtZXRob2RzLCB3ZWFrLCB0cnVlLCB0cnVlKTtcblxuLy8gSUUxMSBXZWFrTWFwIGZyb3plbiBrZXlzIGZpeFxuaWYgKGZhaWxzKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyAkV2Vha01hcCgpLnNldCgoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHRtcCksIDcpLmdldCh0bXApICE9IDc7IH0pKSB7XG4gIEludGVybmFsTWFwID0gd2Vhay5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBXRUFLX01BUCk7XG4gIGFzc2lnbihJbnRlcm5hbE1hcC5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICBtZXRhLk5FRUQgPSB0cnVlO1xuICBlYWNoKFsnZGVsZXRlJywgJ2hhcycsICdnZXQnLCAnc2V0J10sIGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcHJvdG8gPSAkV2Vha01hcC5wcm90b3R5cGU7XG4gICAgdmFyIG1ldGhvZCA9IHByb3RvW2tleV07XG4gICAgcmVkZWZpbmUocHJvdG8sIGtleSwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIC8vIHN0b3JlIGZyb3plbiBvYmplY3RzIG9uIGludGVybmFsIHdlYWttYXAgc2hpbVxuICAgICAgaWYgKGlzT2JqZWN0KGEpICYmICFpc0V4dGVuc2libGUoYSkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9mKSB0aGlzLl9mID0gbmV3IEludGVybmFsTWFwKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9mW2tleV0oYSwgYik7XG4gICAgICAgIHJldHVybiBrZXkgPT0gJ3NldCcgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgLy8gc3RvcmUgYWxsIHRoZSByZXN0IG9uIG5hdGl2ZSB3ZWFrbWFwXG4gICAgICB9IHJldHVybiBtZXRob2QuY2FsbCh0aGlzLCBhLCBiKTtcbiAgICB9KTtcbiAgfSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgd2VhayA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24td2VhaycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFdFQUtfU0VUID0gJ1dlYWtTZXQnO1xuXG4vLyAyMy40IFdlYWtTZXQgT2JqZWN0c1xucmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFdFQUtfU0VULCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrU2V0KCkgeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuNC4zLjEgV2Vha1NldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgIHJldHVybiB3ZWFrLmRlZih2YWxpZGF0ZSh0aGlzLCBXRUFLX1NFVCksIHZhbHVlLCB0cnVlKTtcbiAgfVxufSwgd2VhaywgZmFsc2UsIHRydWUpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1mbGF0TWFwLyNzZWMtQXJyYXkucHJvdG90eXBlLmZsYXRNYXBcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZmxhdHRlbkludG9BcnJheSA9IHJlcXVpcmUoJy4vX2ZsYXR0ZW4taW50by1hcnJheScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtcbiAgZmxhdE1hcDogZnVuY3Rpb24gZmxhdE1hcChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIHNvdXJjZUxlbiwgQTtcbiAgICBhRnVuY3Rpb24oY2FsbGJhY2tmbik7XG4gICAgc291cmNlTGVuID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIEEgPSBhcnJheVNwZWNpZXNDcmVhdGUoTywgMCk7XG4gICAgZmxhdHRlbkludG9BcnJheShBLCBPLCBPLCBzb3VyY2VMZW4sIDAsIDEsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gICAgcmV0dXJuIEE7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnZmxhdE1hcCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1mbGF0TWFwLyNzZWMtQXJyYXkucHJvdG90eXBlLmZsYXR0ZW5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZmxhdHRlbkludG9BcnJheSA9IHJlcXVpcmUoJy4vX2ZsYXR0ZW4taW50by1hcnJheScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtcbiAgZmxhdHRlbjogZnVuY3Rpb24gZmxhdHRlbigvKiBkZXB0aEFyZyA9IDEgKi8pIHtcbiAgICB2YXIgZGVwdGhBcmcgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgc291cmNlTGVuID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBBID0gYXJyYXlTcGVjaWVzQ3JlYXRlKE8sIDApO1xuICAgIGZsYXR0ZW5JbnRvQXJyYXkoQSwgTywgTywgc291cmNlTGVuLCAwLCBkZXB0aEFyZyA9PT0gdW5kZWZpbmVkID8gMSA6IHRvSW50ZWdlcihkZXB0aEFyZykpO1xuICAgIHJldHVybiBBO1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2ZsYXR0ZW4nKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L0FycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkaW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoZWwgLyogLCBmcm9tSW5kZXggPSAwICovKSB7XG4gICAgcmV0dXJuICRpbmNsdWRlcyh0aGlzLCBlbCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2luY2x1ZGVzJyk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vcndhbGRyb24vdGMzOS1ub3Rlcy9ibG9iL21hc3Rlci9lczYvMjAxNC0wOS9zZXB0LTI1Lm1kIzUxMC1nbG9iYWxhc2FwLWZvci1lbnF1ZXVpbmctYS1taWNyb3Rhc2tcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKTtcbnZhciBwcm9jZXNzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykucHJvY2VzcztcbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbiRleHBvcnQoJGV4cG9ydC5HLCB7XG4gIGFzYXA6IGZ1bmN0aW9uIGFzYXAoZm4pIHtcbiAgICB2YXIgZG9tYWluID0gaXNOb2RlICYmIHByb2Nlc3MuZG9tYWluO1xuICAgIG1pY3JvdGFzayhkb21haW4gPyBkb21haW4uYmluZChmbikgOiBmbik7XG4gIH1cbn0pO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9wcm9wb3NhbC1pcy1lcnJvclxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdFcnJvcicsIHtcbiAgaXNFcnJvcjogZnVuY3Rpb24gaXNFcnJvcihpdCkge1xuICAgIHJldHVybiBjb2YoaXQpID09PSAnRXJyb3InO1xuICB9XG59KTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWdsb2JhbFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LkcsIHsgZ2xvYmFsOiByZXF1aXJlKCcuL19nbG9iYWwnKSB9KTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLW1hcC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ01hcCcpO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtbWFwLm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdNYXAnKTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnTWFwJywgeyB0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdNYXAnKSB9KTtcbiIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY2xhbXA6IGZ1bmN0aW9uIGNsYW1wKHgsIGxvd2VyLCB1cHBlcikge1xuICAgIHJldHVybiBNYXRoLm1pbih1cHBlciwgTWF0aC5tYXgobG93ZXIsIHgpKTtcbiAgfVxufSk7XG4iLCIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IERFR19QRVJfUkFEOiBNYXRoLlBJIC8gMTgwIH0pO1xuIiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBSQURfUEVSX0RFRyA9IDE4MCAvIE1hdGguUEk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgZGVncmVlczogZnVuY3Rpb24gZGVncmVlcyhyYWRpYW5zKSB7XG4gICAgcmV0dXJuIHJhZGlhbnMgKiBSQURfUEVSX0RFRztcbiAgfVxufSk7XG4iLCIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHNjYWxlID0gcmVxdWlyZSgnLi9fbWF0aC1zY2FsZScpO1xudmFyIGZyb3VuZCA9IHJlcXVpcmUoJy4vX21hdGgtZnJvdW5kJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgZnNjYWxlOiBmdW5jdGlvbiBmc2NhbGUoeCwgaW5Mb3csIGluSGlnaCwgb3V0TG93LCBvdXRIaWdoKSB7XG4gICAgcmV0dXJuIGZyb3VuZChzY2FsZSh4LCBpbkxvdywgaW5IaWdoLCBvdXRMb3csIG91dEhpZ2gpKTtcbiAgfVxufSk7XG4iLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBpYWRkaDogZnVuY3Rpb24gaWFkZGgoeDAsIHgxLCB5MCwgeTEpIHtcbiAgICB2YXIgJHgwID0geDAgPj4+IDA7XG4gICAgdmFyICR4MSA9IHgxID4+PiAwO1xuICAgIHZhciAkeTAgPSB5MCA+Pj4gMDtcbiAgICByZXR1cm4gJHgxICsgKHkxID4+PiAwKSArICgoJHgwICYgJHkwIHwgKCR4MCB8ICR5MCkgJiB+KCR4MCArICR5MCA+Pj4gMCkpID4+PiAzMSkgfCAwO1xuICB9XG59KTtcbiIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGltdWxoOiBmdW5jdGlvbiBpbXVsaCh1LCB2KSB7XG4gICAgdmFyIFVJTlQxNiA9IDB4ZmZmZjtcbiAgICB2YXIgJHUgPSArdTtcbiAgICB2YXIgJHYgPSArdjtcbiAgICB2YXIgdTAgPSAkdSAmIFVJTlQxNjtcbiAgICB2YXIgdjAgPSAkdiAmIFVJTlQxNjtcbiAgICB2YXIgdTEgPSAkdSA+PiAxNjtcbiAgICB2YXIgdjEgPSAkdiA+PiAxNjtcbiAgICB2YXIgdCA9ICh1MSAqIHYwID4+PiAwKSArICh1MCAqIHYwID4+PiAxNik7XG4gICAgcmV0dXJuIHUxICogdjEgKyAodCA+PiAxNikgKyAoKHUwICogdjEgPj4+IDApICsgKHQgJiBVSU5UMTYpID4+IDE2KTtcbiAgfVxufSk7XG4iLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBpc3ViaDogZnVuY3Rpb24gaXN1YmgoeDAsIHgxLCB5MCwgeTEpIHtcbiAgICB2YXIgJHgwID0geDAgPj4+IDA7XG4gICAgdmFyICR4MSA9IHgxID4+PiAwO1xuICAgIHZhciAkeTAgPSB5MCA+Pj4gMDtcbiAgICByZXR1cm4gJHgxIC0gKHkxID4+PiAwKSAtICgofiR4MCAmICR5MCB8IH4oJHgwIF4gJHkwKSAmICR4MCAtICR5MCA+Pj4gMCkgPj4+IDMxKSB8IDA7XG4gIH1cbn0pO1xuIiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBSQURfUEVSX0RFRzogMTgwIC8gTWF0aC5QSSB9KTtcbiIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgREVHX1BFUl9SQUQgPSBNYXRoLlBJIC8gMTgwO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHJhZGlhbnM6IGZ1bmN0aW9uIHJhZGlhbnMoZGVncmVlcykge1xuICAgIHJldHVybiBkZWdyZWVzICogREVHX1BFUl9SQUQ7XG4gIH1cbn0pO1xuIiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBzY2FsZTogcmVxdWlyZSgnLi9fbWF0aC1zY2FsZScpIH0pO1xuIiwiLy8gaHR0cDovL2pmYmFzdGllbi5naXRodWIuaW8vcGFwZXJzL01hdGguc2lnbmJpdC5odG1sXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IHNpZ25iaXQ6IGZ1bmN0aW9uIHNpZ25iaXQoeCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIHJldHVybiAoeCA9ICt4KSAhPSB4ID8geCA6IHggPT0gMCA/IDEgLyB4ID09IEluZmluaXR5IDogeCA+IDA7XG59IH0pO1xuIiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vQnJlbmRhbkVpY2gvNDI5NGQ1YzIxMmE2ZDIyNTQ3MDNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdW11bGg6IGZ1bmN0aW9uIHVtdWxoKHUsIHYpIHtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmO1xuICAgIHZhciAkdSA9ICt1O1xuICAgIHZhciAkdiA9ICt2O1xuICAgIHZhciB1MCA9ICR1ICYgVUlOVDE2O1xuICAgIHZhciB2MCA9ICR2ICYgVUlOVDE2O1xuICAgIHZhciB1MSA9ICR1ID4+PiAxNjtcbiAgICB2YXIgdjEgPSAkdiA+Pj4gMTY7XG4gICAgdmFyIHQgPSAodTEgKiB2MCA+Pj4gMCkgKyAodTAgKiB2MCA+Pj4gMTYpO1xuICAgIHJldHVybiB1MSAqIHYxICsgKHQgPj4+IDE2KSArICgodTAgKiB2MSA+Pj4gMCkgKyAodCAmIFVJTlQxNikgPj4+IDE2KTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuXG4vLyBCLjIuMi4yIE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXyhQLCBnZXR0ZXIpXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19kZWZpbmVHZXR0ZXJfXzogZnVuY3Rpb24gX19kZWZpbmVHZXR0ZXJfXyhQLCBnZXR0ZXIpIHtcbiAgICAkZGVmaW5lUHJvcGVydHkuZih0b09iamVjdCh0aGlzKSwgUCwgeyBnZXQ6IGFGdW5jdGlvbihnZXR0ZXIpLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcblxuLy8gQi4yLjIuMyBPYmplY3QucHJvdG90eXBlLl9fZGVmaW5lU2V0dGVyX18oUCwgc2V0dGVyKVxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fZGVmaW5lU2V0dGVyX186IGZ1bmN0aW9uIF9fZGVmaW5lU2V0dGVyX18oUCwgc2V0dGVyKSB7XG4gICAgJGRlZmluZVByb3BlcnR5LmYodG9PYmplY3QodGhpcyksIFAsIHsgc2V0OiBhRnVuY3Rpb24oc2V0dGVyKSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICB9XG59KTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC12YWx1ZXMtZW50cmllc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZW50cmllcyA9IHJlcXVpcmUoJy4vX29iamVjdC10by1hcnJheScpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgZW50cmllczogZnVuY3Rpb24gZW50cmllcyhpdCkge1xuICAgIHJldHVybiAkZW50cmllcyhpdCk7XG4gIH1cbn0pO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvcnNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgb3duS2V5cyA9IHJlcXVpcmUoJy4vX293bi1rZXlzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iamVjdCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gICAgdmFyIGdldERlc2MgPSBnT1BELmY7XG4gICAgdmFyIGtleXMgPSBvd25LZXlzKE8pO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleSwgZGVzYztcbiAgICB3aGlsZSAoa2V5cy5sZW5ndGggPiBpKSB7XG4gICAgICBkZXNjID0gZ2V0RGVzYyhPLCBrZXkgPSBrZXlzW2krK10pO1xuICAgICAgaWYgKGRlc2MgIT09IHVuZGVmaW5lZCkgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBrZXksIGRlc2MpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxuLy8gQi4yLjIuNCBPYmplY3QucHJvdG90eXBlLl9fbG9va3VwR2V0dGVyX18oUClcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2xvb2t1cEdldHRlcl9fOiBmdW5jdGlvbiBfX2xvb2t1cEdldHRlcl9fKFApIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBLID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gICAgdmFyIEQ7XG4gICAgZG8ge1xuICAgICAgaWYgKEQgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgSykpIHJldHVybiBELmdldDtcbiAgICB9IHdoaWxlIChPID0gZ2V0UHJvdG90eXBlT2YoTykpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxuLy8gQi4yLjIuNSBPYmplY3QucHJvdG90eXBlLl9fbG9va3VwU2V0dGVyX18oUClcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2xvb2t1cFNldHRlcl9fOiBmdW5jdGlvbiBfX2xvb2t1cFNldHRlcl9fKFApIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBLID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gICAgdmFyIEQ7XG4gICAgZG8ge1xuICAgICAgaWYgKEQgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgSykpIHJldHVybiBELnNldDtcbiAgICB9IHdoaWxlIChPID0gZ2V0UHJvdG90eXBlT2YoTykpO1xuICB9XG59KTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC12YWx1ZXMtZW50cmllc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkdmFsdWVzID0gcmVxdWlyZSgnLi9fb2JqZWN0LXRvLWFycmF5JykoZmFsc2UpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoaXQpIHtcbiAgICByZXR1cm4gJHZhbHVlcyhpdCk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3plbnBhcnNpbmcvZXMtb2JzZXJ2YWJsZVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIG1pY3JvdGFzayA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKCk7XG52YXIgT0JTRVJWQUJMRSA9IHJlcXVpcmUoJy4vX3drcycpKCdvYnNlcnZhYmxlJyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgUkVUVVJOID0gZm9yT2YuUkVUVVJOO1xuXG52YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmbiA9PSBudWxsID8gdW5kZWZpbmVkIDogYUZ1bmN0aW9uKGZuKTtcbn07XG5cbnZhciBjbGVhbnVwU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICB2YXIgY2xlYW51cCA9IHN1YnNjcmlwdGlvbi5fYztcbiAgaWYgKGNsZWFudXApIHtcbiAgICBzdWJzY3JpcHRpb24uX2MgPSB1bmRlZmluZWQ7XG4gICAgY2xlYW51cCgpO1xuICB9XG59O1xuXG52YXIgc3Vic2NyaXB0aW9uQ2xvc2VkID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICByZXR1cm4gc3Vic2NyaXB0aW9uLl9vID09PSB1bmRlZmluZWQ7XG59O1xuXG52YXIgY2xvc2VTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gIGlmICghc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpIHtcbiAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICB9XG59O1xuXG52YXIgU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKG9ic2VydmVyLCBzdWJzY3JpYmVyKSB7XG4gIGFuT2JqZWN0KG9ic2VydmVyKTtcbiAgdGhpcy5fYyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fbyA9IG9ic2VydmVyO1xuICBvYnNlcnZlciA9IG5ldyBTdWJzY3JpcHRpb25PYnNlcnZlcih0aGlzKTtcbiAgdHJ5IHtcbiAgICB2YXIgY2xlYW51cCA9IHN1YnNjcmliZXIob2JzZXJ2ZXIpO1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSBjbGVhbnVwO1xuICAgIGlmIChjbGVhbnVwICE9IG51bGwpIHtcbiAgICAgIGlmICh0eXBlb2YgY2xlYW51cC51bnN1YnNjcmliZSA9PT0gJ2Z1bmN0aW9uJykgY2xlYW51cCA9IGZ1bmN0aW9uICgpIHsgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7IH07XG4gICAgICBlbHNlIGFGdW5jdGlvbihjbGVhbnVwKTtcbiAgICAgIHRoaXMuX2MgPSBjbGVhbnVwO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgIHJldHVybjtcbiAgfSBpZiAoc3Vic2NyaXB0aW9uQ2xvc2VkKHRoaXMpKSBjbGVhbnVwU3Vic2NyaXB0aW9uKHRoaXMpO1xufTtcblxuU3Vic2NyaXB0aW9uLnByb3RvdHlwZSA9IHJlZGVmaW5lQWxsKHt9LCB7XG4gIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHsgY2xvc2VTdWJzY3JpcHRpb24odGhpcyk7IH1cbn0pO1xuXG52YXIgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gIHRoaXMuX3MgPSBzdWJzY3JpcHRpb247XG59O1xuXG5TdWJzY3JpcHRpb25PYnNlcnZlci5wcm90b3R5cGUgPSByZWRlZmluZUFsbCh7fSwge1xuICBuZXh0OiBmdW5jdGlvbiBuZXh0KHZhbHVlKSB7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XG4gICAgaWYgKCFzdWJzY3JpcHRpb25DbG9zZWQoc3Vic2NyaXB0aW9uKSkge1xuICAgICAgdmFyIG9ic2VydmVyID0gc3Vic2NyaXB0aW9uLl9vO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIubmV4dCk7XG4gICAgICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG9ic2VydmVyLCB2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2xvc2VTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBlcnJvcjogZnVuY3Rpb24gZXJyb3IodmFsdWUpIHtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fcztcbiAgICBpZiAoc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpIHRocm93IHZhbHVlO1xuICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fbztcbiAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLmVycm9yKTtcbiAgICAgIGlmICghbSkgdGhyb3cgdmFsdWU7XG4gICAgICB2YWx1ZSA9IG0uY2FsbChvYnNlcnZlciwgdmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUodmFsdWUpIHtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fcztcbiAgICBpZiAoIXN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKSB7XG4gICAgICB2YXIgb2JzZXJ2ZXIgPSBzdWJzY3JpcHRpb24uX287XG4gICAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbSA9IGdldE1ldGhvZChvYnNlcnZlci5jb21wbGV0ZSk7XG4gICAgICAgIHZhbHVlID0gbSA/IG0uY2FsbChvYnNlcnZlciwgdmFsdWUpIDogdW5kZWZpbmVkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9IGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn0pO1xuXG52YXIgJE9ic2VydmFibGUgPSBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZXIpIHtcbiAgYW5JbnN0YW5jZSh0aGlzLCAkT2JzZXJ2YWJsZSwgJ09ic2VydmFibGUnLCAnX2YnKS5fZiA9IGFGdW5jdGlvbihzdWJzY3JpYmVyKTtcbn07XG5cbnJlZGVmaW5lQWxsKCRPYnNlcnZhYmxlLnByb3RvdHlwZSwge1xuICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcikge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uKG9ic2VydmVyLCB0aGlzLl9mKTtcbiAgfSxcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChmbikge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICByZXR1cm4gbmV3IChjb3JlLlByb21pc2UgfHwgZ2xvYmFsLlByb21pc2UpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGFGdW5jdGlvbihmbik7XG4gICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhhdC5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHZhbHVlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiByZWplY3QsXG4gICAgICAgIGNvbXBsZXRlOiByZXNvbHZlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbnJlZGVmaW5lQWxsKCRPYnNlcnZhYmxlLCB7XG4gIGZyb206IGZ1bmN0aW9uIGZyb20oeCkge1xuICAgIHZhciBDID0gdHlwZW9mIHRoaXMgPT09ICdmdW5jdGlvbicgPyB0aGlzIDogJE9ic2VydmFibGU7XG4gICAgdmFyIG1ldGhvZCA9IGdldE1ldGhvZChhbk9iamVjdCh4KVtPQlNFUlZBQkxFXSk7XG4gICAgaWYgKG1ldGhvZCkge1xuICAgICAgdmFyIG9ic2VydmFibGUgPSBhbk9iamVjdChtZXRob2QuY2FsbCh4KSk7XG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZS5jb25zdHJ1Y3RvciA9PT0gQyA/IG9ic2VydmFibGUgOiBuZXcgQyhmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGUuc3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmb3JPZih4LCBmYWxzZSwgZnVuY3Rpb24gKGl0KSB7XG4gICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoaXQpO1xuICAgICAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuIFJFVFVSTjtcbiAgICAgICAgICAgIH0pID09PSBSRVRVUk4pIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZG9uZSkgdGhyb3cgZTtcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyBkb25lID0gdHJ1ZTsgfTtcbiAgICB9KTtcbiAgfSxcbiAgb2Y6IGZ1bmN0aW9uIG9mKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aCwgaXRlbXMgPSBuZXcgQXJyYXkobCk7IGkgPCBsOykgaXRlbXNbaV0gPSBhcmd1bWVudHNbaSsrXTtcbiAgICByZXR1cm4gbmV3ICh0eXBlb2YgdGhpcyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiAkT2JzZXJ2YWJsZSkoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpdGVtcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChpdGVtc1tqXSk7XG4gICAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgIH0gb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyBkb25lID0gdHJ1ZTsgfTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbmhpZGUoJE9ic2VydmFibGUucHJvdG90eXBlLCBPQlNFUlZBQkxFLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxuJGV4cG9ydCgkZXhwb3J0LkcsIHsgT2JzZXJ2YWJsZTogJE9ic2VydmFibGUgfSk7XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ09ic2VydmFibGUnKTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByb21pc2UtZmluYWxseVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmUoJy4vX3Byb21pc2UtcmVzb2x2ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ1Byb21pc2UnLCB7ICdmaW5hbGx5JzogZnVuY3Rpb24gKG9uRmluYWxseSkge1xuICB2YXIgQyA9IHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBjb3JlLlByb21pc2UgfHwgZ2xvYmFsLlByb21pc2UpO1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBvbkZpbmFsbHkgPT0gJ2Z1bmN0aW9uJztcbiAgcmV0dXJuIHRoaXMudGhlbihcbiAgICBpc0Z1bmN0aW9uID8gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShDLCBvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB4OyB9KTtcbiAgICB9IDogb25GaW5hbGx5LFxuICAgIGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgdGhyb3cgZTsgfSk7XG4gICAgfSA6IG9uRmluYWxseVxuICApO1xufSB9KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByb21pc2UtdHJ5XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xudmFyIHBlcmZvcm0gPSByZXF1aXJlKCcuL19wZXJmb3JtJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUHJvbWlzZScsIHsgJ3RyeSc6IGZ1bmN0aW9uIChjYWxsYmFja2ZuKSB7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYodGhpcyk7XG4gIHZhciByZXN1bHQgPSBwZXJmb3JtKGNhbGxiYWNrZm4pO1xuICAocmVzdWx0LmUgPyBwcm9taXNlQ2FwYWJpbGl0eS5yZWplY3QgOiBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlKShyZXN1bHQudik7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufSB9KTtcbiIsInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG52YXIgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSA9IG1ldGFkYXRhLnNldDtcblxubWV0YWRhdGEuZXhwKHsgZGVmaW5lTWV0YWRhdGE6IGZ1bmN0aW9uIGRlZmluZU1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCB0YXJnZXQsIHRhcmdldEtleSkge1xuICBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCBhbk9iamVjdCh0YXJnZXQpLCB0b01ldGFLZXkodGFyZ2V0S2V5KSk7XG59IH0pO1xuIiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcbnZhciBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwID0gbWV0YWRhdGEubWFwO1xudmFyIHN0b3JlID0gbWV0YWRhdGEuc3RvcmU7XG5cbm1ldGFkYXRhLmV4cCh7IGRlbGV0ZU1ldGFkYXRhOiBmdW5jdGlvbiBkZWxldGVNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qICwgdGFyZ2V0S2V5ICovKSB7XG4gIHZhciB0YXJnZXRLZXkgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pO1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKGFuT2JqZWN0KHRhcmdldCksIHRhcmdldEtleSwgZmFsc2UpO1xuICBpZiAobWV0YWRhdGFNYXAgPT09IHVuZGVmaW5lZCB8fCAhbWV0YWRhdGFNYXBbJ2RlbGV0ZSddKG1ldGFkYXRhS2V5KSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobWV0YWRhdGFNYXAuc2l6ZSkgcmV0dXJuIHRydWU7XG4gIHZhciB0YXJnZXRNZXRhZGF0YSA9IHN0b3JlLmdldCh0YXJnZXQpO1xuICB0YXJnZXRNZXRhZGF0YVsnZGVsZXRlJ10odGFyZ2V0S2V5KTtcbiAgcmV0dXJuICEhdGFyZ2V0TWV0YWRhdGEuc2l6ZSB8fCBzdG9yZVsnZGVsZXRlJ10odGFyZ2V0KTtcbn0gfSk7XG4iLCJ2YXIgU2V0ID0gcmVxdWlyZSgnLi9lczYuc2V0Jyk7XG52YXIgZnJvbSA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKTtcbnZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyA9IG1ldGFkYXRhLmtleXM7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xuXG52YXIgb3JkaW5hcnlNZXRhZGF0YUtleXMgPSBmdW5jdGlvbiAoTywgUCkge1xuICB2YXIgb0tleXMgPSBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhPLCBQKTtcbiAgdmFyIHBhcmVudCA9IGdldFByb3RvdHlwZU9mKE8pO1xuICBpZiAocGFyZW50ID09PSBudWxsKSByZXR1cm4gb0tleXM7XG4gIHZhciBwS2V5cyA9IG9yZGluYXJ5TWV0YWRhdGFLZXlzKHBhcmVudCwgUCk7XG4gIHJldHVybiBwS2V5cy5sZW5ndGggPyBvS2V5cy5sZW5ndGggPyBmcm9tKG5ldyBTZXQob0tleXMuY29uY2F0KHBLZXlzKSkpIDogcEtleXMgOiBvS2V5cztcbn07XG5cbm1ldGFkYXRhLmV4cCh7IGdldE1ldGFkYXRhS2V5czogZnVuY3Rpb24gZ2V0TWV0YWRhdGFLZXlzKHRhcmdldCAvKiAsIHRhcmdldEtleSAqLykge1xuICByZXR1cm4gb3JkaW5hcnlNZXRhZGF0YUtleXMoYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDIgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzFdKSk7XG59IH0pO1xuIiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5oYXM7XG52YXIgb3JkaW5hcnlHZXRPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmdldDtcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG5cbnZhciBvcmRpbmFyeUdldE1ldGFkYXRhID0gZnVuY3Rpb24gKE1ldGFkYXRhS2V5LCBPLCBQKSB7XG4gIHZhciBoYXNPd24gPSBvcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgaWYgKGhhc093bikgcmV0dXJuIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICB2YXIgcGFyZW50ID0gZ2V0UHJvdG90eXBlT2YoTyk7XG4gIHJldHVybiBwYXJlbnQgIT09IG51bGwgPyBvcmRpbmFyeUdldE1ldGFkYXRhKE1ldGFkYXRhS2V5LCBwYXJlbnQsIFApIDogdW5kZWZpbmVkO1xufTtcblxubWV0YWRhdGEuZXhwKHsgZ2V0TWV0YWRhdGE6IGZ1bmN0aW9uIGdldE1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyogLCB0YXJnZXRLZXkgKi8pIHtcbiAgcmV0dXJuIG9yZGluYXJ5R2V0TWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufSB9KTtcbiIsInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyA9IG1ldGFkYXRhLmtleXM7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xuXG5tZXRhZGF0YS5leHAoeyBnZXRPd25NZXRhZGF0YUtleXM6IGZ1bmN0aW9uIGdldE93bk1ldGFkYXRhS2V5cyh0YXJnZXQgLyogLCB0YXJnZXRLZXkgKi8pIHtcbiAgcmV0dXJuIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1sxXSkpO1xufSB9KTtcbiIsInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBvcmRpbmFyeUdldE93bk1ldGFkYXRhID0gbWV0YWRhdGEuZ2V0O1xudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcblxubWV0YWRhdGEuZXhwKHsgZ2V0T3duTWV0YWRhdGE6IGZ1bmN0aW9uIGdldE93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyogLCB0YXJnZXRLZXkgKi8pIHtcbiAgcmV0dXJuIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldClcbiAgICAsIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufSB9KTtcbiIsInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gbWV0YWRhdGEuaGFzO1xudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcblxudmFyIG9yZGluYXJ5SGFzTWV0YWRhdGEgPSBmdW5jdGlvbiAoTWV0YWRhdGFLZXksIE8sIFApIHtcbiAgdmFyIGhhc093biA9IG9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICBpZiAoaGFzT3duKSByZXR1cm4gdHJ1ZTtcbiAgdmFyIHBhcmVudCA9IGdldFByb3RvdHlwZU9mKE8pO1xuICByZXR1cm4gcGFyZW50ICE9PSBudWxsID8gb3JkaW5hcnlIYXNNZXRhZGF0YShNZXRhZGF0YUtleSwgcGFyZW50LCBQKSA6IGZhbHNlO1xufTtcblxubWV0YWRhdGEuZXhwKHsgaGFzTWV0YWRhdGE6IGZ1bmN0aW9uIGhhc01ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyogLCB0YXJnZXRLZXkgKi8pIHtcbiAgcmV0dXJuIG9yZGluYXJ5SGFzTWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufSB9KTtcbiIsInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gbWV0YWRhdGEuaGFzO1xudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcblxubWV0YWRhdGEuZXhwKHsgaGFzT3duTWV0YWRhdGE6IGZ1bmN0aW9uIGhhc093bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyogLCB0YXJnZXRLZXkgKi8pIHtcbiAgcmV0dXJuIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldClcbiAgICAsIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufSB9KTtcbiIsInZhciAkbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIHRvTWV0YUtleSA9ICRtZXRhZGF0YS5rZXk7XG52YXIgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSA9ICRtZXRhZGF0YS5zZXQ7XG5cbiRtZXRhZGF0YS5leHAoeyBtZXRhZGF0YTogZnVuY3Rpb24gbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGRlY29yYXRvcih0YXJnZXQsIHRhcmdldEtleSkge1xuICAgIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEoXG4gICAgICBtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSxcbiAgICAgICh0YXJnZXRLZXkgIT09IHVuZGVmaW5lZCA/IGFuT2JqZWN0IDogYUZ1bmN0aW9uKSh0YXJnZXQpLFxuICAgICAgdG9NZXRhS2V5KHRhcmdldEtleSlcbiAgICApO1xuICB9O1xufSB9KTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXNldC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ1NldCcpO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtc2V0Lm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdTZXQnKTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnU2V0JywgeyB0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdTZXQnKSB9KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5wcm90b3R5cGUuYXRcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBhdDogZnVuY3Rpb24gYXQocG9zKSB7XG4gICAgcmV0dXJuICRhdCh0aGlzLCBwb3MpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vU3RyaW5nLnByb3RvdHlwZS5tYXRjaEFsbC9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJyk7XG52YXIgZ2V0RmxhZ3MgPSByZXF1aXJlKCcuL19mbGFncycpO1xudmFyIFJlZ0V4cFByb3RvID0gUmVnRXhwLnByb3RvdHlwZTtcblxudmFyICRSZWdFeHBTdHJpbmdJdGVyYXRvciA9IGZ1bmN0aW9uIChyZWdleHAsIHN0cmluZykge1xuICB0aGlzLl9yID0gcmVnZXhwO1xuICB0aGlzLl9zID0gc3RyaW5nO1xufTtcblxucmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKSgkUmVnRXhwU3RyaW5nSXRlcmF0b3IsICdSZWdFeHAgU3RyaW5nJywgZnVuY3Rpb24gbmV4dCgpIHtcbiAgdmFyIG1hdGNoID0gdGhpcy5fci5leGVjKHRoaXMuX3MpO1xuICByZXR1cm4geyB2YWx1ZTogbWF0Y2gsIGRvbmU6IG1hdGNoID09PSBudWxsIH07XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIG1hdGNoQWxsOiBmdW5jdGlvbiBtYXRjaEFsbChyZWdleHApIHtcbiAgICBkZWZpbmVkKHRoaXMpO1xuICAgIGlmICghaXNSZWdFeHAocmVnZXhwKSkgdGhyb3cgVHlwZUVycm9yKHJlZ2V4cCArICcgaXMgbm90IGEgcmVnZXhwIScpO1xuICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuICAgIHZhciBmbGFncyA9ICdmbGFncycgaW4gUmVnRXhwUHJvdG8gPyBTdHJpbmcocmVnZXhwLmZsYWdzKSA6IGdldEZsYWdzLmNhbGwocmVnZXhwKTtcbiAgICB2YXIgcnggPSBuZXcgUmVnRXhwKHJlZ2V4cC5zb3VyY2UsIH5mbGFncy5pbmRleE9mKCdnJykgPyBmbGFncyA6ICdnJyArIGZsYWdzKTtcbiAgICByeC5sYXN0SW5kZXggPSB0b0xlbmd0aChyZWdleHAubGFzdEluZGV4KTtcbiAgICByZXR1cm4gbmV3ICRSZWdFeHBTdHJpbmdJdGVyYXRvcihyeCwgUyk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHBhZCA9IHJlcXVpcmUoJy4vX3N0cmluZy1wYWQnKTtcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuL191c2VyLWFnZW50Jyk7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8yODBcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogL1ZlcnNpb25cXC8xMFxcLlxcZCsoXFwuXFxkKyk/IFNhZmFyaVxcLy8udGVzdCh1c2VyQWdlbnQpLCAnU3RyaW5nJywge1xuICBwYWRFbmQ6IGZ1bmN0aW9uIHBhZEVuZChtYXhMZW5ndGggLyogLCBmaWxsU3RyaW5nID0gJyAnICovKSB7XG4gICAgcmV0dXJuICRwYWQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgZmFsc2UpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRwYWQgPSByZXF1aXJlKCcuL19zdHJpbmctcGFkJyk7XG52YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi9fdXNlci1hZ2VudCcpO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMjgwXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIC9WZXJzaW9uXFwvMTBcXC5cXGQrKFxcLlxcZCspPyBTYWZhcmlcXC8vLnRlc3QodXNlckFnZW50KSwgJ1N0cmluZycsIHtcbiAgcGFkU3RhcnQ6IGZ1bmN0aW9uIHBhZFN0YXJ0KG1heExlbmd0aCAvKiAsIGZpbGxTdHJpbmcgPSAnICcgKi8pIHtcbiAgICByZXR1cm4gJHBhZCh0aGlzLCBtYXhMZW5ndGgsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCB0cnVlKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2VibWFya2JhZ2UvZWNtYXNjcmlwdC1zdHJpbmctbGVmdC1yaWdodC10cmltXG5yZXF1aXJlKCcuL19zdHJpbmctdHJpbScpKCd0cmltTGVmdCcsIGZ1bmN0aW9uICgkdHJpbSkge1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbUxlZnQoKSB7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDEpO1xuICB9O1xufSwgJ3RyaW1TdGFydCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NlYm1hcmtiYWdlL2VjbWFzY3JpcHQtc3RyaW5nLWxlZnQtcmlnaHQtdHJpbVxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbVJpZ2h0JywgZnVuY3Rpb24gKCR0cmltKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltUmlnaHQoKSB7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDIpO1xuICB9O1xufSwgJ3RyaW1FbmQnKTtcbiIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnYXN5bmNJdGVyYXRvcicpO1xuIiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdvYnNlcnZhYmxlJyk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1nbG9iYWxcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnU3lzdGVtJywgeyBnbG9iYWw6IHJlcXVpcmUoJy4vX2dsb2JhbCcpIH0pO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtd2Vha21hcC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ1dlYWtNYXAnKTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXdlYWttYXAub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ1dlYWtNYXAnKTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXdlYWtzZXQuZnJvbVxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tZnJvbScpKCdXZWFrU2V0Jyk7XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy13ZWFrc2V0Lm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdXZWFrU2V0Jyk7XG4iLCJ2YXIgJGl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgSVRFUkFUT1IgPSB3a3MoJ2l0ZXJhdG9yJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHdrcygndG9TdHJpbmdUYWcnKTtcbnZhciBBcnJheVZhbHVlcyA9IEl0ZXJhdG9ycy5BcnJheTtcblxudmFyIERPTUl0ZXJhYmxlcyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiBmYWxzZSxcbiAgQ1NTVmFsdWVMaXN0OiBmYWxzZSxcbiAgQ2xpZW50UmVjdExpc3Q6IGZhbHNlLFxuICBET01SZWN0TGlzdDogZmFsc2UsXG4gIERPTVN0cmluZ0xpc3Q6IGZhbHNlLFxuICBET01Ub2tlbkxpc3Q6IHRydWUsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiBmYWxzZSxcbiAgRmlsZUxpc3Q6IGZhbHNlLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogZmFsc2UsXG4gIEhUTUxDb2xsZWN0aW9uOiBmYWxzZSxcbiAgSFRNTEZvcm1FbGVtZW50OiBmYWxzZSxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IGZhbHNlLFxuICBNZWRpYUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBNaW1lVHlwZUFycmF5OiBmYWxzZSxcbiAgTmFtZWROb2RlTWFwOiBmYWxzZSxcbiAgTm9kZUxpc3Q6IHRydWUsXG4gIFBhaW50UmVxdWVzdExpc3Q6IGZhbHNlLFxuICBQbHVnaW46IGZhbHNlLFxuICBQbHVnaW5BcnJheTogZmFsc2UsXG4gIFNWR0xlbmd0aExpc3Q6IGZhbHNlLFxuICBTVkdOdW1iZXJMaXN0OiBmYWxzZSxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IGZhbHNlLFxuICBTVkdQb2ludExpc3Q6IGZhbHNlLFxuICBTVkdTdHJpbmdMaXN0OiBmYWxzZSxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogZmFsc2UsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IGZhbHNlLFxuICBTdHlsZVNoZWV0TGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIFRleHRUcmFja0N1ZUxpc3Q6IGZhbHNlLFxuICBUZXh0VHJhY2tMaXN0OiBmYWxzZSxcbiAgVG91Y2hMaXN0OiBmYWxzZVxufTtcblxuZm9yICh2YXIgY29sbGVjdGlvbnMgPSBnZXRLZXlzKERPTUl0ZXJhYmxlcyksIGkgPSAwOyBpIDwgY29sbGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIE5BTUUgPSBjb2xsZWN0aW9uc1tpXTtcbiAgdmFyIGV4cGxpY2l0ID0gRE9NSXRlcmFibGVzW05BTUVdO1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIGtleTtcbiAgaWYgKHByb3RvKSB7XG4gICAgaWYgKCFwcm90b1tJVEVSQVRPUl0pIGhpZGUocHJvdG8sIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgaWYgKCFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gICAgSXRlcmF0b3JzW05BTUVdID0gQXJyYXlWYWx1ZXM7XG4gICAgaWYgKGV4cGxpY2l0KSBmb3IgKGtleSBpbiAkaXRlcmF0b3JzKSBpZiAoIXByb3RvW2tleV0pIHJlZGVmaW5lKHByb3RvLCBrZXksICRpdGVyYXRvcnNba2V5XSwgdHJ1ZSk7XG4gIH1cbn1cbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHRhc2sgPSByZXF1aXJlKCcuL190YXNrJyk7XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiwge1xuICBzZXRJbW1lZGlhdGU6ICR0YXNrLnNldCxcbiAgY2xlYXJJbW1lZGlhdGU6ICR0YXNrLmNsZWFyXG59KTtcbiIsIi8vIGllOS0gc2V0VGltZW91dCAmIHNldEludGVydmFsIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBmaXhcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi9fdXNlci1hZ2VudCcpO1xudmFyIHNsaWNlID0gW10uc2xpY2U7XG52YXIgTVNJRSA9IC9NU0lFIC5cXC4vLnRlc3QodXNlckFnZW50KTsgLy8gPC0gZGlydHkgaWU5LSBjaGVja1xudmFyIHdyYXAgPSBmdW5jdGlvbiAoc2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZm4sIHRpbWUgLyogLCAuLi5hcmdzICovKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICAgIHZhciBhcmdzID0gYm91bmRBcmdzID8gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpIDogZmFsc2U7XG4gICAgcmV0dXJuIHNldChib3VuZEFyZ3MgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICAgICh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pKS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IDogZm4sIHRpbWUpO1xuICB9O1xufTtcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5CICsgJGV4cG9ydC5GICogTVNJRSwge1xuICBzZXRUaW1lb3V0OiB3cmFwKGdsb2JhbC5zZXRUaW1lb3V0KSxcbiAgc2V0SW50ZXJ2YWw6IHdyYXAoZ2xvYmFsLnNldEludGVydmFsKVxufSk7XG4iLCJyZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN5bWJvbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0aWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Quc2VhbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QucHJldmVudC1leHRlbnNpb25zJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1mcm96ZW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzLXNlYWxlZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmJpbmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5oYXMtaW5zdGFuY2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucGFyc2UtaW50Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnBhcnNlLWZsb2F0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3RvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIudG8tZml4ZWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnRvLXByZWNpc2lvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuZXBzaWxvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtZmluaXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1uYW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLXNhZmUtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIubWluLXNhZmUtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtZmxvYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWludCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmFjb3NoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguYXNpbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5hdGFuaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmNicnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jbHozMicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmNvc2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5leHBtMScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmZyb3VuZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmh5cG90Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguaW11bCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmxvZzEwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgubG9nMXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5sb2cyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguc2lnbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnNpbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC50YW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgudHJ1bmMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZyb20tY29kZS1wb2ludCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcucmF3Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy50cmltJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuY29kZS1wb2ludC1hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZW5kcy13aXRoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5pbmNsdWRlcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcucmVwZWF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdGFydHMtd2l0aCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYW5jaG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5iaWcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmJsaW5rJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5ib2xkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5maXhlZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udGNvbG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRhbGljcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcubGluaycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc21hbGwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN0cmlrZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3ViJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS5ub3cnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8taXNvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLXByaW1pdGl2ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5pcy1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5mcm9tJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lm9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmpvaW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc2xpY2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc29ydCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5mb3ItZWFjaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5tYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmlsdGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNvbWUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZXZlcnknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS1yaWdodCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5pbmRleC1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5sYXN0LWluZGV4LW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmNvcHktd2l0aGluJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbGwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmluZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maW5kLWluZGV4Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNwZWNpZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLmNvbnN0cnVjdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLmZsYWdzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5tYXRjaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAucmVwbGFjZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuc2VhcmNoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5wcm9taXNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYud2Vhay1tYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYud2Vhay1zZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuYXJyYXktYnVmZmVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmRhdGEtdmlldycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5pbnQ4LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWNsYW1wZWQtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuaW50MTYtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDE2LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmludDMyLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQzMi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDMyLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0NjQtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5hcHBseScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmNvbnN0cnVjdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlZmluZS1wcm9wZXJ0eScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlbGV0ZS1wcm9wZXJ0eScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmVudW1lcmF0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5oYXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5pcy1leHRlbnNpYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3Qub3duLWtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5wcmV2ZW50LWV4dGVuc2lvbnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5zZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFycmF5LmZsYXQtbWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFycmF5LmZsYXR0ZW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLmF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtc3RhcnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1lbmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tbGVmdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1yaWdodCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcubWF0Y2gtYWxsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QudmFsdWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtZ2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtc2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtZ2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtc2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hcC50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnNldC50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hcC5vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zZXQub2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcud2Vhay1tYXAub2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcud2Vhay1zZXQub2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWFwLmZyb20nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc2V0LmZyb20nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcud2Vhay1tYXAuZnJvbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy53ZWFrLXNldC5mcm9tJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lmdsb2JhbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zeXN0ZW0uZ2xvYmFsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmVycm9yLmlzLWVycm9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguY2xhbXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5kZWctcGVyLXJhZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmRlZ3JlZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5mc2NhbGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5pYWRkaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmlzdWJoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguaW11bGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5yYWQtcGVyLWRlZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLnJhZGlhbnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5zY2FsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLnVtdWxoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguc2lnbmJpdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5wcm9taXNlLmZpbmFsbHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucHJvbWlzZS50cnknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5kZWZpbmUtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5kZWxldGUtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEta2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLWtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtb3duLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QubWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuYXNhcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYnNlcnZhYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLnRpbWVycycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi5pbW1lZGlhdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbW9kdWxlcy9fY29yZScpO1xuIiwiZnVuY3Rpb24gc3RyaW5naWZ5IChvYmosIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdmFyIGluZGVudCA9IEpTT04uc3RyaW5naWZ5KFsxXSwgbnVsbCwgZ2V0KG9wdGlvbnMsICdpbmRlbnQnLCAyKSkuc2xpY2UoMiwgLTMpXG4gIHZhciBhZGRNYXJnaW4gPSBnZXQob3B0aW9ucywgJ21hcmdpbnMnLCBmYWxzZSlcbiAgdmFyIG1heExlbmd0aCA9IChpbmRlbnQgPT09ICcnID8gSW5maW5pdHkgOiBnZXQob3B0aW9ucywgJ21heExlbmd0aCcsIDgwKSlcblxuICByZXR1cm4gKGZ1bmN0aW9uIF9zdHJpbmdpZnkgKG9iaiwgY3VycmVudEluZGVudCwgcmVzZXJ2ZWQpIHtcbiAgICBpZiAob2JqICYmIHR5cGVvZiBvYmoudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvYmogPSBvYmoudG9KU09OKClcbiAgICB9XG5cbiAgICB2YXIgc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkob2JqKVxuXG4gICAgaWYgKHN0cmluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gc3RyaW5nXG4gICAgfVxuXG4gICAgdmFyIGxlbmd0aCA9IG1heExlbmd0aCAtIGN1cnJlbnRJbmRlbnQubGVuZ3RoIC0gcmVzZXJ2ZWRcblxuICAgIGlmIChzdHJpbmcubGVuZ3RoIDw9IGxlbmd0aCkge1xuICAgICAgdmFyIHByZXR0aWZpZWQgPSBwcmV0dGlmeShzdHJpbmcsIGFkZE1hcmdpbilcbiAgICAgIGlmIChwcmV0dGlmaWVkLmxlbmd0aCA8PSBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHByZXR0aWZpZWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmV4dEluZGVudCA9IGN1cnJlbnRJbmRlbnQgKyBpbmRlbnRcbiAgICAgIHZhciBpdGVtcyA9IFtdXG4gICAgICB2YXIgZGVsaW1pdGVyc1xuICAgICAgdmFyIGNvbW1hID0gZnVuY3Rpb24gKGFycmF5LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gKGluZGV4ID09PSBhcnJheS5sZW5ndGggLSAxID8gMCA6IDEpXG4gICAgICB9XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IG9iai5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKFxuICAgICAgICAgICAgX3N0cmluZ2lmeShvYmpbaW5kZXhdLCBuZXh0SW5kZW50LCBjb21tYShvYmosIGluZGV4KSkgfHwgJ251bGwnXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGRlbGltaXRlcnMgPSAnW10nXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSwgaW5kZXgsIGFycmF5KSB7XG4gICAgICAgICAgdmFyIGtleVBhcnQgPSBKU09OLnN0cmluZ2lmeShrZXkpICsgJzogJ1xuICAgICAgICAgIHZhciB2YWx1ZSA9IF9zdHJpbmdpZnkob2JqW2tleV0sIG5leHRJbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlQYXJ0Lmxlbmd0aCArIGNvbW1hKGFycmF5LCBpbmRleCkpXG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goa2V5UGFydCArIHZhbHVlKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgZGVsaW1pdGVycyA9ICd7fSdcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBkZWxpbWl0ZXJzWzBdLFxuICAgICAgICAgIGluZGVudCArIGl0ZW1zLmpvaW4oJyxcXG4nICsgbmV4dEluZGVudCksXG4gICAgICAgICAgZGVsaW1pdGVyc1sxXVxuICAgICAgICBdLmpvaW4oJ1xcbicgKyBjdXJyZW50SW5kZW50KVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmdcbiAgfShvYmosICcnLCAwKSlcbn1cblxuLy8gTm90ZTogVGhpcyByZWdleCBtYXRjaGVzIGV2ZW4gaW52YWxpZCBKU09OIHN0cmluZ3MsIGJ1dCBzaW5jZSB3ZeKAmXJlXG4vLyB3b3JraW5nIG9uIHRoZSBvdXRwdXQgb2YgYEpTT04uc3RyaW5naWZ5YCB3ZSBrbm93IHRoYXQgb25seSB2YWxpZCBzdHJpbmdzXG4vLyBhcmUgcHJlc2VudCAodW5sZXNzIHRoZSB1c2VyIHN1cHBsaWVkIGEgd2VpcmQgYG9wdGlvbnMuaW5kZW50YCBidXQgaW5cbi8vIHRoYXQgY2FzZSB3ZSBkb27igJl0IGNhcmUgc2luY2UgdGhlIG91dHB1dCB3b3VsZCBiZSBpbnZhbGlkIGFueXdheSkuXG52YXIgc3RyaW5nT3JDaGFyID0gLyhcIig/OlteXFxcXFwiXXxcXFxcLikqXCIpfFs6LFxcXVt9e10vZ1xuXG5mdW5jdGlvbiBwcmV0dGlmeSAoc3RyaW5nLCBhZGRNYXJnaW4pIHtcbiAgdmFyIG0gPSBhZGRNYXJnaW4gPyAnICcgOiAnJ1xuICB2YXIgdG9rZW5zID0ge1xuICAgICd7JzogJ3snICsgbSxcbiAgICAnWyc6ICdbJyArIG0sXG4gICAgJ30nOiBtICsgJ30nLFxuICAgICddJzogbSArICddJyxcbiAgICAnLCc6ICcsICcsXG4gICAgJzonOiAnOiAnXG4gIH1cbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHN0cmluZ09yQ2hhciwgZnVuY3Rpb24gKG1hdGNoLCBzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nID8gbWF0Y2ggOiB0b2tlbnNbbWF0Y2hdXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGdldCAob3B0aW9ucywgbmFtZSwgZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiAobmFtZSBpbiBvcHRpb25zID8gb3B0aW9uc1tuYW1lXSA6IGRlZmF1bHRWYWx1ZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdpZnlcbiIsIi8qKlxuICogVGhlIERvdWJseUxpbmtlZExpc3QgY2xhc3MgcHJvdmlkZXMgdGhlIG1haW4gZnVuY3Rpb25hbGl0eSBvZiBhIGRvdWJseSBsaW5rZWQgbGlzdC5cbiAqXG4gKiBAY2xhc3MgRG91Ymx5TGlua2VkTGlzdFxuICovXG52YXIgRG91Ymx5TGlua2VkTGlzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRG91Ymx5TGlua2VkTGlzdCgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvdW50IG9mIGVsZW1lbnRzIGluIGxpc3RcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IF9sZW5ndGhcbiAgICAgICAgICogQHR5cGUgbnVtYmVyXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogSXRlcmF0aW9uIHBvaW50ZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IF9rZXlcbiAgICAgICAgICogQHR5cGUgbnVtYmVyXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9rZXkgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIGhlYWQoZmlyc3QpIGVsZW1lbnQgaW4gbGlzdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgX2hlYWRcbiAgICAgICAgICogQHR5cGUgRG91Ymx5TGlua2VkTGlzdE5vZGVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hlYWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIHRhaWwobGFzdCkgZWxlbWVudCBpbiBsaXN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfdGFpbFxuICAgICAgICAgKiBAdHlwZSBEb3VibHlMaW5rZWRMaXN0Tm9kZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdGFpbCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gaXRlcmF0ZWQgZWxlbWVudCBpbiBsaXN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfY3VycmVudFxuICAgICAgICAgKiBAdHlwZSBEb3VibHlMaW5rZWRMaXN0Tm9kZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydCBhIG5ldyB2YWx1ZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGFkZFxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggd2hlcmUgdGhlIG5ldyB2YWx1ZSBpcyB0byBiZSBpbnNlcnRlZC5cbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIGluZGV4LlxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk91dCBvZiBib3VuZHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIHdoaWxlIChpIDwgaW5kZXgpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudC52YWx1ZSA9IHZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUG9wcyBhIG5vZGUgZnJvbSB0aGUgZW5kIG9mIHRoZSBkb3VibHkgbGlua2VkIGxpc3RcbiAgICAgKlxuICAgICAqIEBtZXRob2QgcG9wXG4gICAgICogQHJldHVybiBhbnkgIFRoZSB2YWx1ZSBvZiB0aGUgcG9wcGVkIG5vZGUuXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwb3AgZnJvbSBhbiBlbXB0eSBkYXRhIHN0cnVjdHVyZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl90YWlsLnZhbHVlO1xuICAgICAgICB0aGlzLl90YWlsID0gdGhpcy5fdGFpbC5wcmV2O1xuICAgICAgICBpZiAodGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3RhaWwubmV4dDtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwubmV4dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGVuZ3RoLS07XG4gICAgICAgIGlmICh0aGlzLl9sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9oZWFkO1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2hpZnRzIGEgbm9kZSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRvdWJseSBsaW5rZWQgbGlzdFxuICAgICAqXG4gICAgICogQG1ldGhvZCBzaGlmdFxuICAgICAqIEByZXR1cm4gYW55ICBUaGUgdmFsdWUgb2YgdGhlIHNoaWZ0ZWQgbm9kZS5cbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgc2hpZnQgZnJvbSBhbiBlbXB0eSBkYXRhIHN0cnVjdHVyZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9oZWFkLnZhbHVlO1xuICAgICAgICB0aGlzLl9oZWFkID0gdGhpcy5faGVhZC5uZXh0O1xuICAgICAgICBpZiAodGhpcy5faGVhZCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2hlYWQucHJldjtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQucHJldiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGVuZ3RoLS07XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhbiBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIGRvdWJseSBsaW5rZWQgbGlzdFxuICAgICAqXG4gICAgICogQG1ldGhvZCBwdXNoXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBwdXNoLlxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gYWxsb2NhdGUgbmV3IG5vZGVcbiAgICAgICAgdmFyIG5vZGUgPSB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBwcmV2OiB0aGlzLl90YWlsLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5fbGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gdGhpcy5fdGFpbCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90YWlsLm5leHQgPSBub2RlO1xuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IHRoaXMuX3RhaWwubmV4dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sZW5ndGgrKztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByZXBlbmRzIHRoZSBkb3VibHkgbGlua2VkIGxpc3Qgd2l0aCBhbiBlbGVtZW50XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHVuc2hpZnRcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHVuc2hpZnQuXG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBhbGxvY2F0ZSBuZXcgbm9kZVxuICAgICAgICB2YXIgbm9kZSA9IHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHByZXY6IG51bGwsXG4gICAgICAgICAgICBuZXh0OiB0aGlzLl9oZWFkXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLl9sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSB0aGlzLl90YWlsID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQucHJldiA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gdGhpcy5faGVhZC5wcmV2O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xlbmd0aCsrO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGVla3MgYXQgdGhlIG5vZGUgZnJvbSB0aGUgZW5kIG9mIHRoZSBkb3VibHkgbGlua2VkIGxpc3RcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9wXG4gICAgICogQHJldHVybiBhbnkgIFRoZSB2YWx1ZSBvZiB0aGUgbGFzdCBub2RlLlxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLnRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RhaWwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGFpbC52YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBlZWtzIGF0IHRoZSBub2RlIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgZG91Ymx5IGxpbmtlZCBsaXN0XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGJvdHRvbVxuICAgICAqIEByZXR1cm4gYW55ICBUaGUgdmFsdWUgb2YgdGhlIGZpcnN0IG5vZGUuXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUuYm90dG9tID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5faGVhZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWFkLnZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ291bnRzIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGRvdWJseSBsaW5rZWQgbGlzdFxuICAgICAqXG4gICAgICogQG1ldGhvZCBjb3VudFxuICAgICAqIEByZXR1cm4gbnVtYmVyIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGRvdWJseSBsaW5rZWQgbGlzdC5cbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBkb3VibHkgbGlua2VkIGxpc3QgaXMgZW1wdHlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgaXNFbXB0eVxuICAgICAqIEByZXR1cm4gYm9vbGVhbiB3aGV0aGVyIHRoZSBkb3VibHkgbGlua2VkIGxpc3QgaXMgZW1wdHkuXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9sZW5ndGggPT09IDApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV3aW5kIGl0ZXJhdG9yIGJhY2sgdG8gdGhlIHN0YXJ0XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHJld2luZFxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLnJld2luZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fa2V5ID0gMDtcbiAgICAgICAgdGhpcy5fY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gY3VycmVudCBsaXN0IGVudHJ5XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGN1cnJlbnRcbiAgICAgKiBAcmV0dXJuIGFueSAgVGhlIGN1cnJlbnQgbm9kZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnQudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gY3VycmVudCBub2RlIGluZGV4XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGtleVxuICAgICAqIEByZXR1cm4gYW55ICBUaGUgY3VycmVudCBub2RlIGluZGV4LlxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLmtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1vdmUgdG8gbmV4dCBlbnRyeVxuICAgICAqXG4gICAgICogQG1ldGhvZCBuZXh0XG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudCA9IHRoaXMuX2N1cnJlbnQubmV4dDtcbiAgICAgICAgdGhpcy5fa2V5Kys7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNb3ZlIHRvIHByZXZpb3VzIGVudHJ5XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHByZXZcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fY3VycmVudC5wcmV2O1xuICAgICAgICB0aGlzLl9rZXktLTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGRvdWJseSBsaW5rZWQgbGlzdCBjb250YWlucyBtb3JlIG5vZGVzXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHZhbGlkXG4gICAgICogQHJldHVybiBib29sZWFuIHRydWUgaWYgdGhlIGRvdWJseSBsaW5rZWQgbGlzdCBjb250YWlucyBhbnkgbW9yZSBub2RlcywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLnZhbGlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2tleSA+PSAwICYmIHRoaXMuX2tleSA8IHRoaXMuX2xlbmd0aCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeHBvcnQgdGhlIGxpc3QgdG8gYXJyYXlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9BcnJheVxuICAgICAqIEByZXR1cm4gQXJyYXkgICBUaGUgZXhwb3J0ZWQgYXJyYXlcbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGlzdCA9IFtdO1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICBsaXN0LnB1c2goY3VycmVudC52YWx1ZSk7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgbGlzdCB0byBzdHJpbmdcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9TdHJpbmdcbiAgICAgKiBAcmV0dXJuIHN0cmluZyAgIFRoZSBzZXJpYWxpemVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwie1wiICsgdGhpcy50b0FycmF5KCkuam9pbihcIi0+XCIpICsgXCJ9XCI7XG4gICAgfTtcbiAgICByZXR1cm4gRG91Ymx5TGlua2VkTGlzdDtcbn0pKCk7XG5tb2R1bGUuZXhwb3J0cyA9IERvdWJseUxpbmtlZExpc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Eb3VibHlMaW5rZWRMaXN0LmpzLm1hcCIsIi8qKlxuICogVGhlIEhlYXAgY2xhc3MgcHJvdmlkZXMgdGhlIG1haW4gZnVuY3Rpb25hbGl0eSBvZiBhIEhlYXAuXG4gKlxuICogQGNsYXNzIEhlYXBcbiAqL1xudmFyIEhlYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhlYXAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCaW5hcnkgdHJlZSBzdG9yYWdlIGFycmF5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfdHJlZVxuICAgICAgICAgKiBAdHlwZSBBcnJheVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdHJlZSA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogSGVhcCB0eXBlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfdHlwZVxuICAgICAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3R5cGUgPSBIZWFwLk1BWDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0ZXJhdGlvbiBwb2ludGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfa2V5XG4gICAgICAgICAqIEB0eXBlIG51bWJlclxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fa2V5ID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGluZGV4IG9mIGxlZnQgY2hpbGQgZWxlbWVudCBpbiBiaW5hcnkgdHJlZSBzdG9yZWQgaW4gYXJyYXlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2NoaWxkXG4gICAgICogQHBhcmFtIG5cbiAgICAgKiBAcmV0dXJuIG51bWJlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUuX2NoaWxkID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIDIgKiBuICsgMTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBpbmRleCBvZiBwYXJlbnQgZWxlbWVudCBpbiBiaW5hcnkgdHJlZSBzdG9yZWQgaW4gYXJyYXlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3BhcmVudFxuICAgICAqIEBwYXJhbSBuXG4gICAgICogQHJldHVybiBudW1iZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLl9wYXJlbnQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICAvL2NvbnNvbGUubG9nKCduPScsIG4sIE1hdGguZmxvb3IobiAvIDIpKTtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobiAvIDIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3dhcCAyIGVsZW1lbnRzIGluIGJpbmFyeSB0cmVlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9zd2FwXG4gICAgICogQHBhcmFtIGZpcnN0XG4gICAgICogQHBhcmFtIHNlY29uZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUuX3N3YXAgPSBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICB2YXIgc3dhcCA9IHRoaXMuX3RyZWVbZmlyc3RdO1xuICAgICAgICB0aGlzLl90cmVlW2ZpcnN0XSA9IHRoaXMuX3RyZWVbc2Vjb25kXTtcbiAgICAgICAgdGhpcy5fdHJlZVtzZWNvbmRdID0gc3dhcDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNpZnQgZWxlbWVudHMgaW4gYmluYXJ5IHRyZWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3NpZnRVcFxuICAgICAqIEBwYXJhbSBpXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5fc2lmdFVwID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgd2hpbGUgKGkgPiAwKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50KGkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFyZSh0aGlzLl90cmVlW2ldLCB0aGlzLl90cmVlW3BhcmVudF0pICogdGhpcy5fdHlwZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zd2FwKGksIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgaSA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTaWZ0IGRvd24gZWxlbWVudHMgaW4gYmluYXJ5IHRyZWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3NpZnREb3duXG4gICAgICogQHBhcmFtIGlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLl9zaWZ0RG93biA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5fdHJlZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy5fY2hpbGQoaSk7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIGlmICgobGVmdCA8IHRoaXMuX3RyZWUubGVuZ3RoKSAmJiAocmlnaHQgPCB0aGlzLl90cmVlLmxlbmd0aCkgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5jb21wYXJlKHRoaXMuX3RyZWVbaV0sIHRoaXMuX3RyZWVbbGVmdF0pICogdGhpcy5fdHlwZSA8IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wYXJlKHRoaXMuX3RyZWVbaV0sIHRoaXMuX3RyZWVbcmlnaHRdKSAqIHRoaXMuX3R5cGUgPCAwKSkge1xuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIDIgY2hpbGRyZW4gYW5kIG9uZSBvZiB0aGVtIG11c3QgYmUgc3dhcHBlZFxuICAgICAgICAgICAgICAgIC8vIGdldCBjb3JyZWN0IGVsZW1lbnQgdG8gc2lmdCBkb3duXG4gICAgICAgICAgICAgICAgdmFyIHNpZnQgPSBsZWZ0O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhcmUodGhpcy5fdHJlZVtsZWZ0XSwgdGhpcy5fdHJlZVtyaWdodF0pICogdGhpcy5fdHlwZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2lmdCA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9zd2FwKGksIHNpZnQpO1xuICAgICAgICAgICAgICAgIGkgPSBzaWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGVmdCA8IHRoaXMuX3RyZWUubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wYXJlKHRoaXMuX3RyZWVbaV0sIHRoaXMuX3RyZWVbbGVmdF0pICogdGhpcy5fdHlwZSA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IG9uZSBjaGlsZCBleGlzdHNcbiAgICAgICAgICAgICAgICB0aGlzLl9zd2FwKGksIGxlZnQpO1xuICAgICAgICAgICAgICAgIGkgPSBsZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIGEgbm9kZSBmcm9tIHRvcCBvZiB0aGUgaGVhcCBhbmQgc2lmdCB1cFxuICAgICAqXG4gICAgICogQG1ldGhvZCBleHRyYWN0XG4gICAgICogQHJldHVybiBhbnkgVGhlIHZhbHVlIG9mIHRoZSBleHRyYWN0ZWQgbm9kZS5cbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fdHJlZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGV4dHJhY3QgZnJvbSBhbiBlbXB0eSBkYXRhIHN0cnVjdHVyZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXh0cmFjdGVkID0gdGhpcy5fdHJlZVswXTtcbiAgICAgICAgaWYgKHRoaXMuX3RyZWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLl90cmVlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90cmVlWzBdID0gdGhpcy5fdHJlZS5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuX3NpZnREb3duKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRyYWN0ZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIGVsZW1lbnQgaW4gdGhlIGhlYXAgYnkgc2lmdGluZyBpdCB1cFxuICAgICAqXG4gICAgICogQG1ldGhvZCBpbnNlcnRcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdHJlZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgdGhpcy5fc2lmdFVwKHRoaXMuX3RyZWUubGVuZ3RoIC0gMSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQZWVrcyBhdCB0aGUgbm9kZSBmcm9tIHRoZSB0b3Agb2YgdGhlIGhlYXBcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9wXG4gICAgICogQHJldHVybiBhbnkgVGhlIHZhbHVlIG9mIHRoZSBub2RlIG9uIHRoZSB0b3AuXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUudG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fdHJlZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHBlZWsgYXQgYW4gZW1wdHkgaGVhcFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdHJlZVswXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvdW50cyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBoZWFwXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGNvdW50XG4gICAgICogQHJldHVybiBudW1iZXIgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaGVhcC5cbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWUubGVuZ3RoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGhlYXAgaXMgZW1wdHlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgaXNFbXB0eVxuICAgICAqIEByZXR1cm4gYm9vbGVhbiB3aGV0aGVyIHRoZSBoZWFwIGlzIGVtcHR5LlxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fdHJlZS5sZW5ndGggPT09IDApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV3aW5kIGl0ZXJhdG9yIGJhY2sgdG8gdGhlIHN0YXJ0IChuby1vcClcbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmV3aW5kXG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUucmV3aW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9rZXkgPSAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGN1cnJlbnQgbm9kZSBwb2ludGVkIGJ5IHRoZSBpdGVyYXRvclxuICAgICAqXG4gICAgICogQG1ldGhvZCBjdXJyZW50XG4gICAgICogQHJldHVybiBhbnkgVGhlIGN1cnJlbnQgbm9kZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJlZVt0aGlzLl9rZXldO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGN1cnJlbnQgbm9kZSBpbmRleFxuICAgICAqXG4gICAgICogQG1ldGhvZCBrZXlcbiAgICAgKiBAcmV0dXJuIGFueSBUaGUgY3VycmVudCBub2RlIGluZGV4LlxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLmtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1vdmUgdG8gdGhlIG5leHQgbm9kZVxuICAgICAqXG4gICAgICogQG1ldGhvZCBuZXh0XG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fa2V5Kys7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNb3ZlIHRvIHByZXZpb3VzIGVudHJ5XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHByZXZcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9rZXktLTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGhlYXAgY29udGFpbnMgbW9yZSBub2Rlc1xuICAgICAqXG4gICAgICogQG1ldGhvZCB2YWxpZFxuICAgICAqIEByZXR1cm4gYm9vbGVhbiB0cnVlIGlmIHRoZSBoZWFwIGNvbnRhaW5zIGFueSBtb3JlIG5vZGVzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUudmFsaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fa2V5ID49IDAgJiYgdGhpcy5fa2V5IDwgdGhpcy5fdHJlZS5sZW5ndGgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcGFyZSBlbGVtZW50cyBpbiBvcmRlciB0byBwbGFjZSB0aGVtIGNvcnJlY3RseSBpbiB0aGUgaGVhcCB3aGlsZSBzaWZ0aW5nIHVwLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBjb21wYXJlXG4gICAgICogQHBhcmFtIGZpcnN0IFRoZSB2YWx1ZSBvZiB0aGUgZmlyc3Qgbm9kZSBiZWluZyBjb21wYXJlZC5cbiAgICAgKiBAcGFyYW0gc2Vjb25kIFRoZSB2YWx1ZSBvZiB0aGUgc2Vjb25kIG5vZGUgYmVpbmcgY29tcGFyZWQuXG4gICAgICogQHJldHVybiBudW1iZXIgUmVzdWx0IG9mIHRoZSBjb21wYXJpc29uLCBwb3NpdGl2ZSBpbnRlZ2VyIGlmIGZpcnN0IGlzIGdyZWF0ZXIgdGhhbiBzZWNvbmQsIDAgaWYgdGhleSBhcmUgZXF1YWwsIG5lZ2F0aXZlIGludGVnZXIgb3RoZXJ3aXNlLlxuICAgICAqIEhhdmluZyBtdWx0aXBsZSBlbGVtZW50cyB3aXRoIHRoZSBzYW1lIHZhbHVlIGluIGEgSGVhcCBpcyBub3QgcmVjb21tZW5kZWQuIFRoZXkgd2lsbCBlbmQgdXAgaW4gYW4gYXJiaXRyYXJ5IHJlbGF0aXZlIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICBpZiAoZmlyc3QgPiBzZWNvbmQpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpcnN0ID09IHNlY29uZCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFZpc3VhbGx5IGRpc3BsYXkgaGVhcCB0cmVlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9kaXNwbGF5Tm9kZVxuICAgICAqIEBwYXJhbSBub2RlXG4gICAgICogQHBhcmFtIHByZWZpeFxuICAgICAqIEBwYXJhbSBsYXN0XG4gICAgICogQHJldHVybiBTdHJpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLl9kaXNwbGF5Tm9kZSA9IGZ1bmN0aW9uIChub2RlLCBwcmVmaXgsIGxhc3QpIHtcbiAgICAgICAgaWYgKHByZWZpeCA9PT0gdm9pZCAwKSB7IHByZWZpeCA9ICcnOyB9XG4gICAgICAgIGlmIChsYXN0ID09PSB2b2lkIDApIHsgbGFzdCA9IHRydWU7IH1cbiAgICAgICAgdmFyIGxpbmUgPSBwcmVmaXg7XG4gICAgICAgIC8vIGdldCBjaGlsZCBpbmRleGVzXG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5fY2hpbGQobm9kZSk7XG4gICAgICAgIHZhciByaWdodCA9IGxlZnQgKyAxO1xuICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgbGluZSArPSAocHJlZml4ID8gJ+KUlOKUgCcgOiAnICAnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxpbmUgKz0gJ+KUnOKUgCc7XG4gICAgICAgIH1cbiAgICAgICAgbGluZSArPSB0aGlzLl90cmVlW25vZGVdO1xuICAgICAgICBwcmVmaXggKz0gKGxhc3QgPyAnICAnIDogJ+KUgiAnKTtcbiAgICAgICAgaWYgKGxlZnQgPCB0aGlzLl90cmVlLmxlbmd0aCkge1xuICAgICAgICAgICAgbGluZSArPSAnXFxuJyArIHRoaXMuX2Rpc3BsYXlOb2RlKGxlZnQsIHByZWZpeCwgKHRoaXMuX3RyZWVbcmlnaHRdID09IHVuZGVmaW5lZCA/IHRydWUgOiBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyaWdodCA8IHRoaXMuX3RyZWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBsaW5lICs9ICdcXG4nICsgdGhpcy5fZGlzcGxheU5vZGUocmlnaHQsIHByZWZpeCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBoZWFwIHRvIHN0cmluZ1xuICAgICAqXG4gICAgICogQG1ldGhvZCB0b1N0cmluZ1xuICAgICAqIEByZXR1cm4gc3RyaW5nICAgVGhlIHNlcmlhbGl6ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBzdGFydCB3aXRoIHJvb3QgYW5kIHJlY3Vyc2l2ZWx5IGdvZXMgdG8gZWFjaCBub2RlXG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwbGF5Tm9kZSgwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGhlYXAgdG8gYXJyYXlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9BcnJheVxuICAgICAqIEByZXR1cm4gQXJyYXkgICBUaGUgc2VyaWFsaXplZCBhcnJheS5cbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJlZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1heCBoZWFwIGZsYWdcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBNQVhcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgSGVhcC5NQVggPSAxO1xuICAgIC8qKlxuICAgICAqIE1pbiBoZWFwIGZsYWdcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBNSU5cbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgSGVhcC5NSU4gPSAtMTtcbiAgICByZXR1cm4gSGVhcDtcbn0pKCk7XG5tb2R1bGUuZXhwb3J0cyA9IEhlYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IZWFwLmpzLm1hcCIsInZhciBfX2V4dGVuZHMgPSB0aGlzLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlO1xuICAgIGQucHJvdG90eXBlID0gbmV3IF9fKCk7XG59O1xudmFyIEhlYXAgPSByZXF1aXJlKCcuL0hlYXAnKTtcbi8qKlxuICogVGhlIE1heEhlYXAgY2xhc3MgcHJvdmlkZXMgdGhlIG1haW4gZnVuY3Rpb25hbGl0eSBvZiBhIGhlYXAsIGtlZXBpbmcgdGhlIG1heGltdW0gb24gdGhlIHRvcC5cbiAqXG4gKiBAY2xhc3MgTWF4SGVhcFxuICogQGV4dGVuZHMgSGVhcFxuICovXG52YXIgTWF4SGVhcCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1heEhlYXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWF4SGVhcCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX3R5cGUgPSBIZWFwLk1BWDtcbiAgICB9XG4gICAgcmV0dXJuIE1heEhlYXA7XG59KShIZWFwKTtcbm1vZHVsZS5leHBvcnRzID0gTWF4SGVhcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1heEhlYXAuanMubWFwIiwidmFyIF9fZXh0ZW5kcyA9IHRoaXMuX19leHRlbmRzIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGU7XG4gICAgZC5wcm90b3R5cGUgPSBuZXcgX18oKTtcbn07XG52YXIgSGVhcCA9IHJlcXVpcmUoJy4vSGVhcCcpO1xuLyoqXG4gKiBUaGUgTWluSGVhcCBjbGFzcyBwcm92aWRlcyB0aGUgbWFpbiBmdW5jdGlvbmFsaXR5IG9mIGEgaGVhcCwga2VlcGluZyB0aGUgbWluaW11bSBvbiB0aGUgdG9wLlxuICpcbiAqIEBjbGFzcyBNaW5IZWFwXG4gKiBAZXh0ZW5kcyBIZWFwXG4gKi9cbnZhciBNaW5IZWFwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWluSGVhcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNaW5IZWFwKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fdHlwZSA9IEhlYXAuTUlOO1xuICAgIH1cbiAgICByZXR1cm4gTWluSGVhcDtcbn0pKEhlYXApO1xubW9kdWxlLmV4cG9ydHMgPSBNaW5IZWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWluSGVhcC5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBIZWFwID0gcmVxdWlyZSgnLi9IZWFwJyk7XG4vKipcbiAqIFRoZSBQcmlvcml0eVF1ZXVlIGNsYXNzIHByb3ZpZGVzIHRoZSBtYWluIGZ1bmN0aW9uYWxpdHkgb2YgYW4gcHJpb3JpdGl6ZWQgcXVldWUsIGltcGxlbWVudGVkIHVzaW5nIGEgbWF4IGhlYXAuXG4gKlxuICogQGNsYXNzIFByaW9yaXR5UXVldWVcbiAqIEBleHRlbmRzIEhlYXBcbiAqL1xudmFyIFByaW9yaXR5UXVldWUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQcmlvcml0eVF1ZXVlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByaW9yaXR5UXVldWUoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl90eXBlID0gSGVhcC5NQVg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZWxlbWVudCB0byB0aGUgcXVldWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZW5xdWV1ZVxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gZW5xdWV1ZS5cbiAgICAgKiBAcGFyYW0gcHJpb3JpdHkgVGhlIHByaW9yaXR5IG9mIHZhbHVlLlxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbiAodmFsdWUsIHByaW9yaXR5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc2VydChuZXcgUHJpb3JpdHlRdWV1ZU5vZGUodmFsdWUsIHByaW9yaXR5KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXF1ZXVlcyBhIG5vZGUgZnJvbSB0aGUgcXVldWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVxdWV1ZVxuICAgICAqIEByZXR1cm4gYW55ICBUaGUgdmFsdWUgb2YgdGhlIGRlcXVldWVkIG5vZGUuXG4gICAgICovXG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZGVxdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFjdCgpLnZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGVla3MgYXQgdGhlIG5vZGUgZnJvbSB0aGUgdG9wIG9mIHRoZSBoZWFwXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHRvcFxuICAgICAqIEByZXR1cm4gYW55IFRoZSB2YWx1ZSBvZiB0aGUgbm9kZSBvbiB0aGUgdG9wLlxuICAgICAqL1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLnRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUudG9wLmNhbGwodGhpcykudmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wYXJlIGVsZW1lbnRzIGluIG9yZGVyIHRvIHBsYWNlIHRoZW0gY29ycmVjdGx5IGluIHRoZSBoZWFwIHdoaWxlIHNpZnRpbmcgdXAuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGNvbXBhcmVcbiAgICAgKiBAcGFyYW0gZmlyc3QgVGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBub2RlIGJlaW5nIGNvbXBhcmVkLlxuICAgICAqIEBwYXJhbSBzZWNvbmQgVGhlIHZhbHVlIG9mIHRoZSBzZWNvbmQgbm9kZSBiZWluZyBjb21wYXJlZC5cbiAgICAgKiBAcmV0dXJuIG51bWJlciBSZXN1bHQgb2YgdGhlIGNvbXBhcmlzb24sIHBvc2l0aXZlIGludGVnZXIgaWYgZmlyc3QgaXMgZ3JlYXRlciB0aGFuIHNlY29uZCwgMCBpZiB0aGV5IGFyZSBlcXVhbCwgbmVnYXRpdmUgaW50ZWdlciBvdGhlcndpc2UuXG4gICAgICogSGF2aW5nIG11bHRpcGxlIGVsZW1lbnRzIHdpdGggdGhlIHNhbWUgdmFsdWUgaW4gYSBIZWFwIGlzIG5vdCByZWNvbW1lbmRlZC4gVGhleSB3aWxsIGVuZCB1cCBpbiBhbiBhcmJpdHJhcnkgcmVsYXRpdmUgcG9zaXRpb24uXG4gICAgICovXG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgIGlmIChmaXJzdC5wcmlvcml0eSA+IHNlY29uZC5wcmlvcml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmlyc3QucHJpb3JpdHkgPT0gc2Vjb25kLnByaW9yaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFByaW9yaXR5UXVldWU7XG59KShIZWFwKTtcbi8qKlxuICogUHJpb3JpdHlRdWV1ZSBOb2RlXG4gKlxuICogQGNsYXNzIFByaW9yaXR5UXVldWVOb2RlXG4gKi9cbnZhciBQcmlvcml0eVF1ZXVlTm9kZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKlxuICAgICAqIEBtZXRob2QgY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gcHJpb3JpdHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQcmlvcml0eVF1ZXVlTm9kZSh2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIG5vZGUgdG8gc3RyaW5nXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHRvU3RyaW5nXG4gICAgICogQHJldHVybiBzdHJpbmcgICBUaGUgc2VyaWFsaXplZCBzdHJpbmcuXG4gICAgICovXG4gICAgUHJpb3JpdHlRdWV1ZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSArIFwiIFtcIiArIHRoaXMucHJpb3JpdHkgKyBcIl1cIjtcbiAgICB9O1xuICAgIHJldHVybiBQcmlvcml0eVF1ZXVlTm9kZTtcbn0pKCk7XG5tb2R1bGUuZXhwb3J0cyA9IFByaW9yaXR5UXVldWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qcmlvcml0eVF1ZXVlLmpzLm1hcCIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIERvdWJseUxpbmtlZExpc3QgPSByZXF1aXJlKCcuL0RvdWJseUxpbmtlZExpc3QnKTtcbi8qKlxuICogVGhlIFF1ZXVlIGNsYXNzIHByb3ZpZGVzIHRoZSBtYWluIGZ1bmN0aW9uYWxpdHkgb2YgYSBxdWV1ZSBpbXBsZW1lbnRlZCB1c2luZyBhIGRvdWJseSBsaW5rZWQgbGlzdC5cbiAqXG4gKiBAY2xhc3MgUXVldWVcbiAqIEBleHRlbmRzIERvdWJseUxpbmtlZExpc3RcbiAqL1xudmFyIFF1ZXVlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUXVldWUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUXVldWUoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGVsZW1lbnQgdG8gdGhlIHF1ZXVlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGVucXVldWVcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGVucXVldWUuXG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgUXVldWUucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaCh2YWx1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXF1ZXVlcyBhIG5vZGUgZnJvbSB0aGUgcXVldWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVxdWV1ZVxuICAgICAqIEByZXR1cm4gYW55ICBUaGUgdmFsdWUgb2YgdGhlIGRlcXVldWVkIG5vZGUuXG4gICAgICovXG4gICAgUXVldWUucHJvdG90eXBlLmRlcXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoaWZ0KCk7XG4gICAgfTtcbiAgICByZXR1cm4gUXVldWU7XG59KShEb3VibHlMaW5rZWRMaXN0KTtcbm1vZHVsZS5leHBvcnRzID0gUXVldWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1RdWV1ZS5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBEb3VibHlMaW5rZWRMaXN0ID0gcmVxdWlyZSgnLi9Eb3VibHlMaW5rZWRMaXN0Jyk7XG4vKipcbiAqIFRoZSBTdGFjayBjbGFzcyBwcm92aWRlcyB0aGUgbWFpbiBmdW5jdGlvbmFsaXR5IG9mIGEgc3RhY2sgaW1wbGVtZW50ZWQgdXNpbmcgYSBkb3VibHkgbGlua2VkIGxpc3QuXG4gKlxuICogQGNsYXNzIFN0YWNrXG4gKiBAZXh0ZW5kcyBEb3VibHlMaW5rZWRMaXN0XG4gKi9cbnZhciBTdGFjayA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0YWNrLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN0YWNrKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0YWNrO1xufSkoRG91Ymx5TGlua2VkTGlzdCk7XG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RhY2suanMubWFwIiwiLyoqXG4gKiBTVExcbiAqIEB0eXBlIHt7RG91Ymx5TGlua2VkTGlzdDogZXhwb3J0cywgU3RhY2s6IGV4cG9ydHMsIFF1ZXVlOiBleHBvcnRzLCBIZWFwOiBleHBvcnRzLCBNYXhIZWFwOiBleHBvcnRzLCBNaW5IZWFwOiBleHBvcnRzLCBQcmlvcml0eVF1ZXVlOiBleHBvcnRzfX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG5cdERvdWJseUxpbmtlZExpc3Q6IHJlcXVpcmUoJy4vRGF0YXN0cnVjdHVyZXMvRG91Ymx5TGlua2VkTGlzdCcpLFxuXHRTdGFjazogcmVxdWlyZSgnLi9EYXRhc3RydWN0dXJlcy9TdGFjaycpLFxuXHRRdWV1ZTogcmVxdWlyZSgnLi9EYXRhc3RydWN0dXJlcy9RdWV1ZScpLFxuXHRIZWFwOiByZXF1aXJlKCcuL0RhdGFzdHJ1Y3R1cmVzL0hlYXAnKSxcblx0TWF4SGVhcDogcmVxdWlyZSgnLi9EYXRhc3RydWN0dXJlcy9NYXhIZWFwJyksXG5cdE1pbkhlYXA6IHJlcXVpcmUoJy4vRGF0YXN0cnVjdHVyZXMvTWluSGVhcCcpLFxuXHRQcmlvcml0eVF1ZXVlOiByZXF1aXJlKCcuL0RhdGFzdHJ1Y3R1cmVzL1ByaW9yaXR5UXVldWUnKVxufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gaW1wb3J0IHRoZSBiYWJlbCBwb2x5ZmlsbCB0aGF0IGFsbG93cyB1c2FnZSBvZiBnZW5lcmF0b3JzXG5pbXBvcnQgXCJiYWJlbC1wb2x5ZmlsbFwiO1xuXG4vLyBpbXBvcnQgdGhlIG1haW4gY2xhc3NcbmltcG9ydCBDYW52YXMgZnJvbSAnLi9tb2R1bGVzL0NhbnZhcyc7XG5cbi8qKlxuICogV2hlbiB0aGUgZG9jdW1lbnQgaXMgcmVhZHksIGluaXRpYWxpemUgdGhlIGFwcGxpY2F0aW9uXG4gKi9cbiQoKCkgPT4ge1xuICAgIG5ldyBDYW52YXMoXCIjY2FudmFzXCIsIDEwKTtcbn0pO1xuIiwiLy8gZWRpdG9yIGVsZW1lbnRzIChnYXRlcywgd2lyZXMuLi4pXG5pbXBvcnQgKiBhcyBlZGl0b3JFbGVtZW50cyBmcm9tICcuL2VkaXRvckVsZW1lbnRzJ1xuXG4vLyBzdmcgZWxlbWVudHNcbmltcG9ydCB7UGF0dGVybiwgUmVjdGFuZ2xlLCBQb2x5TGluZVBvaW50LCBQb2x5TGluZVBvaW50cywgUG9seUxpbmV9IGZyb20gJy4vc3ZnT2JqZWN0cydcblxuLy8gbmV0d29yayBsb2dpYyBhbmQgc2ltdWxhdGlvblxuaW1wb3J0IExvZ2ljIGZyb20gJy4vTG9naWMnXG5pbXBvcnQgU2ltdWxhdGlvbiBmcm9tICcuL1NpbXVsYXRpb24nXG5cbi8vIHVpIHN0dWZmXG5pbXBvcnQgQ29udGV4dE1lbnUgZnJvbSAnLi91aS9Db250ZXh0TWVudSdcbmltcG9ydCBGbG9hdGluZ01lbnUgZnJvbSAnLi91aS9GbG9hdGluZ01lbnUnXG5pbXBvcnQgVHV0b3JpYWwgZnJvbSAnLi91aS9UdXRvcmlhbCdcbmltcG9ydCBNZXNzYWdlcyBmcm9tICcuL3VpL01lc3NhZ2VzJ1xuaW1wb3J0IFZpZXdCb3ggZnJvbSAnLi91aS9WaWV3Qm94J1xuXG4vLyBtb3VzZSBzY3JvbGwgZXZlbnQgbGlzdGVyZXIgZm9yIHVpLCBtYW5oYXR0YW4gZGlzdGFuY2UgZm9yIGltcG9ydERhdGFcbmltcG9ydCB7YWRkTW91c2VTY3JvbGxFdmVudExpc3RlbmVyLCBtYW5oYXR0YW5EaXN0YW5jZX0gZnJvbSAnLi9vdGhlci9oZWxwZXJGdW5jdGlvbnMnXG5cbi8vIHVzZWQgaW4gaW1wb3J0RGF0YVxuLy8gbm90ZTogaW1wb3J0ZWQgZnJvbSBhIG5vZGUgbW9kdWxlXG5pbXBvcnQge1ByaW9yaXR5UXVldWV9IGZyb20gJ2xpYnN0bCdcblxuY29uc3QgY3RybEtleSA9IDE3LFxuICAgIGNtZEtleSA9IDkxO1xuXG4vKiogQG1vZHVsZSBDYW52YXMgKi9cbi8qKlxuICogTWFpbiBjbGFzcyBvZiB0aGUgYXBwbGljYXRpb24uIEl0IHJlcHJlc2VudHMgYW4gaW5zdGFuY2Ugb2YgdGhlIHdob2xlIGVkaXRvciBhbmQgaG9sZHNcbiAqIHJlZmVyZW5jZXMgdG8gYWxsIGl0cyBlbGVtZW50cy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FudmFzIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSBTdmcgY2xhc3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2FudmFzICAgcXVlcnkgc2VsZWN0b3Igb2YgdGhlIFNWRyBlbGVtZW50LCB0aGF0IHdpbGwgY29udGFpbiBhbGwgU1ZHIGNvbnRlbnQgb2YgdGhlIGFwcGxpY2F0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdyaWRTaXplIGluaXRpYWwgc2l6ZSBvZiB0aGUgZ3JpZCBpbiBTVkcgcGl4ZWxzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2FudmFzLCBncmlkU2l6ZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogalF1ZXJ5IGVsZW1lbnQgZm9yIHRoZSBTVkcgZG9jdW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuJHN2ZyA9ICQoY2FudmFzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogc3BhY2UgYmV0d2VlbiBncmlkIGxpbmVzIGluIFNWRyBwaXhlbHNcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JpZFNpemUgPSBncmlkU2l6ZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXJyYXkgb2YgYWxsIGJveGVzIChpbnN0YW5jZXMgb2Ygb2JqZWN0cyBkZXJpdmVkIGZyb20gZWRpdG9yRWxlbWVudHMuQm94KSB1c2VkIG9uIENhbnZhc1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJveGVzID0gW107IC8vIHN0b3JlcyBhbGwgYm94ZXNcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXJyYXkgb2YgYWxsIHdpcmVzIChpbnN0YW5jZXMgb2YgZWRpdG9yRWxlbWVudHMuV2lyZSkgdXNlZCBvbiBDYW52YXNcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53aXJlcyA9IFtdOyAvLyBzdG9yZXMgYWxsIHdpcmVzXG5cbiAgICAgICAgLy8gVE9ETyBkb2N1bWVudCB0aGlzXG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBuZXcgTWVzc2FnZXMoKTtcblxuICAgICAgICB0aGlzLnNpbXVsYXRpb25FbmFibGVkID0gdHJ1ZVxuICAgICAgICB0aGlzLnNpbXVsYXRpb24gPSBuZXcgU2ltdWxhdGlvbih0aGlzKTsgLy8gZHVtbXksIHdpbGwgYmUgb3ZlcndyaXR0ZW4gb24gc3RhcnROZXdTaW11bGF0aW9uXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRpc3RhbmNlIGZyb20gdGhlIGxlZnQgdG9wIGNvcm5lciB0byB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgaW1wb3J0ZWQgbmV0d29ya1xuICAgICAgICAgKiBhbmQgZGlzdGFuY2UgZnJvbSB0aGUgbGVmdCB0b3AgY29ybmVyIHRvIHRoZSBpbXBvcnRlZCBibGFjayBib3ggX2luIGdyaWQgcGl4ZWxzX1xuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sZWZ0VG9wUGFkZGluZyA9IDQ7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBkZWZzIGVsZW1lbnQsIHVzZWQgZm9yIHBhdHRlcm5zXG4gICAgICAgIHRoaXMuJGRlZnMgPSAkKFwiPGRlZnM+XCIpO1xuICAgICAgICB0aGlzLiRzdmcucHJlcGVuZCh0aGlzLiRkZWZzKTtcblxuICAgICAgICAvLyBCQUNLR1JPVU5EIFBBVFRFUk5cbiAgICAgICAgbGV0IHBhdHRlcm4gPSBuZXcgUGF0dGVybihcImdyaWRcIiwgdGhpcy5ncmlkU2l6ZSwgdGhpcy5ncmlkU2l6ZSk7XG5cbiAgICAgICAgbGV0IHBhdHRlcm5Qb2ludHMgPSBuZXcgUG9seUxpbmVQb2ludHMoKS5hcHBlbmQobmV3IFBvbHlMaW5lUG9pbnQoMCwgMCkpLmFwcGVuZChuZXcgUG9seUxpbmVQb2ludCh0aGlzLmdyaWRTaXplLCAwKSkuYXBwZW5kKG5ldyBQb2x5TGluZVBvaW50KHRoaXMuZ3JpZFNpemUsIHRoaXMuZ3JpZFNpemUpKTtcblxuICAgICAgICBwYXR0ZXJuLmFkZENoaWxkKG5ldyBQb2x5TGluZShwYXR0ZXJuUG9pbnRzLCAyLCBcIiNjMmMzZTRcIikpO1xuICAgICAgICB0aGlzLmFkZFBhdHRlcm4ocGF0dGVybi5nZXQoKSk7XG5cbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID0gbmV3IFJlY3RhbmdsZSgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgXCJ1cmwoI2dyaWQpXCIsIFwibm9uZVwiKTtcbiAgICAgICAgdGhpcy5hcHBlbmRKUXVlcnlPYmplY3QodGhpcy5iYWNrZ3JvdW5kLmdldCgpKTtcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG5cbiAgICAgICAgLy8gc2V0IHRoZSB2aWV3Ym94IGZvciBmdXR1cmUgem9vbWluZyBhbmQgbW92aW5nIG9mIHRoZSBjYW52YXNcbiAgICAgICAgdGhpcy4kc3ZnLmF0dHIoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCAneE1pbllNaW4gc2xpY2UnKVxuICAgICAgICB0aGlzLnZpZXdib3ggPSBuZXcgVmlld0JveCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodClcbiAgICAgICAgdGhpcy5hcHBseVZpZXdib3goKVxuXG4gICAgICAgIC8vIENPTlNUUlVDVCBDT05URVhUIE1FTlVcbiAgICAgICAgdGhpcy5jb250ZXh0TWVudSA9IG5ldyBDb250ZXh0TWVudSh0aGlzKTtcblxuICAgICAgICAvLyBDT05TVFJVQ1QgRkxPQVRJTkcgTUVOVVxuICAgICAgICB0aGlzLmZsb2F0aW5nTWVudSA9IG5ldyBGbG9hdGluZ01lbnUodGhpcyk7XG5cbiAgICAgICAgbGV0IHRhcmdldDtcblxuICAgICAgICAvLyBBTEwgRVZFTlQgQ0FMTEJBQ0tTXG4gICAgICAgIHRoaXMuJHN2Zy5vbignbW91c2Vkb3duJywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5nZXRSZWFsVGFyZ2V0KGV2ZW50LnRhcmdldCk7XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIHByb3BhZ2F0ZSBtb3VzZWRvd24gdG8gdGhlIHJlYWwgdGFyZ2V0XG4gICAgICAgICAgICAgICAgdGFyZ2V0Lm9uTW91c2VEb3duKGV2ZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbW91c2Vkb3duIGhhcHBlbmVkIGRpcmVjdGx5IG9uIHRoZSBzdmdcbiAgICAgICAgICAgICAgICB0aGlzLm9uTW91c2VEb3duKGV2ZW50KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmhpZGVDb250ZXh0TWVudSgpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSkub24oJ21vdXNlbW92ZScsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5vbk1vdXNlTW92ZShldmVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG1vdXNlbW92ZSBoYXBwZW5lZCBkaXJlY3RseSBvbiB0aGUgc3ZnXG4gICAgICAgICAgICAgICAgdGhpcy5vbk1vdXNlTW92ZShldmVudClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSkub24oJ21vdXNldXAnLCBldmVudCA9PiB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQub25Nb3VzZVVwKGV2ZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbW91c2V1cCBoYXBwZW5lZCBkaXJlY3RseSBvbiB0aGUgc3ZnXG4gICAgICAgICAgICAgICAgdGhpcy5vbk1vdXNlVXAoZXZlbnQpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRhcmdldCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSkub24oXCJjb250ZXh0bWVudVwiLCBldmVudCA9PiB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlDb250ZXh0TWVudShldmVudC5wYWdlWCwgZXZlbnQucGFnZVksIHRoaXMuZ2V0UmVhbEpRdWVyeVRhcmdldChldmVudC50YXJnZXQpKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pXG5cbiAgICAgICAgJChkb2N1bWVudCkub24oJ2tleWRvd24nLCBldmVudCA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uS2V5RG93bihldmVudCk7XG4gICAgICAgIH0pLm9uKFwia2V5dXBcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbktleVVwKGV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSB2aWV3Ym94IG9uIHdpbmRvdyByZXNpemVcbiAgICAgICAgJCh3aW5kb3cpLm9uKCdyZXNpemUnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZpZXdib3gubmV3RGltZW5zaW9ucyh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLmFwcGx5Vmlld2JveCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBhZGRNb3VzZVNjcm9sbEV2ZW50TGlzdGVuZXIoY2FudmFzLCBldmVudCA9PiB7XG4gICAgICAgICAgICAvLyB6b29tIG9ubHkgaWYgdGhlIGN0cmwga2V5IGlzIG5vdCBwcmVzc2VkXG4gICAgICAgICAgICBpZiAoIWV2ZW50LmN0cmxLZXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnpvb20gKz0gZXZlbnQuZGVsdGEgKiAwLjE7XG5cbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgJCh3aW5kb3cpLm9uKCdrZXlkb3duJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhY3Rpb25zID0ge1xuICAgICAgICAgICAgICAgICcrJzogMC4xLFxuICAgICAgICAgICAgICAgICctJzogLTAuMVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWN0aW9uc1tldmVudC5rZXldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy56b29tICs9IGFjdGlvbnNbZXZlbnQua2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICAvKipcbiAgICAgICAgICogcHJvcGVydHkgY29udGFpbmluZyBhbiBpbnN0YW5jZSBvZiBbVHV0b3JpYWxdKC4vbW9kdWxlLVR1dG9yaWFsLmh0bWwpLCBpZiB0aGVyZSBpcyBhbnlcbiAgICAgICAgICogQHR5cGUge1R1dG9yaWFsfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50dXRvcmlhbDtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgdXNlciB2aXNpdHMgZm9yIHRoZSBmaXJzdCB0aW1lLCBpZiBzbywgc3RhcnQgdGhlIHR1dG9yaWFsXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWxvY2FsU3RvcmFnZS51c2VySGFzVmlzaXRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRUdXRvcmlhbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHdpZHRoIG9mIHRoZSBtYWluIFNWRyBlbGVtZW50XG4gICAgICogQHJldHVybiB7bnVtYmVyfSB3aWR0aCBvZiB0aGUgU1ZHIGVsZW1lbnQgaW4gcGl4ZWxzXG4gICAgICovXG4gICAgZ2V0IHdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kc3ZnLndpZHRoKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGhlaWdodCBvZiB0aGUgbWFpbiBTVkcgZWxlbWVudFxuICAgICAqIEByZXR1cm4ge251bWJlcn0gaGVpZ2h0IG9mIHRoZSBTVkcgZWxlbWVudCBpbiBwaXhlbHNcbiAgICAgKi9cbiAgICBnZXQgaGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kc3ZnLmhlaWdodCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhbGwga2V5ZG93biBldmVudHMgdGhhdCBhcmUgY29ubmVjdGVkIHRvIENhbnZhc1xuICAgICAqIEBwYXJhbSAge2pxdWVyeS5LZXlib2FyZEV2ZW50fSBldmVudCBLZXlib2FyZEV2ZW50IGdlbmVyYXRlZCBieSBhIGxpc3RlbmVyXG4gICAgICovXG4gICAgb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBjdHJsS2V5IHx8IGV2ZW50LmtleUNvZGUgPT09IGNtZEtleSkge1xuICAgICAgICAgICAgdGhpcy4kc3ZnLmFkZENsYXNzKCdncmFiYmFibGUnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgYWxsIGtleXVwIGV2ZW50cyB0aGF0IGFyZSBjb25uZWN0ZWQgdG8gQ2FudmFzXG4gICAgICogQHBhcmFtICB7anF1ZXJ5LktleWJvYXJkRXZlbnR9IGV2ZW50IEtleWJvYXJkRXZlbnQgZ2VuZXJhdGVkIGJ5IGEgbGlzdGVuZXJcbiAgICAgKi9cbiAgICBvbktleVVwKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBjdHJsS2V5IHx8IGV2ZW50LmtleUNvZGUgPT09IGNtZEtleSkge1xuICAgICAgICAgICAgdGhpcy4kc3ZnLnJlbW92ZUNsYXNzKCdncmFiYmFibGUnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgYWxsIG1vdXNlZG93biBldmVudHMgdGhhdCBhcmUgaGFwcGVuaW5nIGRpcmVjdGx5IG9uIHRoZSBDYW52YXNcbiAgICAgKiBAcGFyYW0gIHtqcXVlcnkuTW91c2VFdmVudH0gZXZlbnQgTW91c2VFdmVudCBnZW5lcmF0ZWQgYnkgYSBsaXN0ZW5lclxuICAgICAqL1xuICAgIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICAgIC8vIGFueSBjbGljayBvbiBjYW52YXMgY2FuY2VscyB0aGUgd2lyZSBjcmVhdGlvblxuICAgICAgICB0aGlzLmNhbmNlbFdpcmVDcmVhdGlvbigpO1xuXG4gICAgICAgIC8vIG1pZGRsZSBtb3VzZSBvciBsZWZ0IG1vdXNlICsgY3RybCBtb3ZlcyB0aGUgY2FudmFzXG4gICAgICAgIGlmIChldmVudC53aGljaCA9PT0gMiB8fCAoZXZlbnQud2hpY2ggPT09IDEgJiYgZXZlbnQuY3RybEtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuJHN2Zy5hZGRDbGFzcygnZ3JhYmJlZCcpO1xuICAgICAgICAgICAgdGhpcy5tb3ZlQ2FudmFzID0ge1xuICAgICAgICAgICAgICAgIGxlZnQ6IGV2ZW50LnBhZ2VYLFxuICAgICAgICAgICAgICAgIHRvcDogZXZlbnQucGFnZVlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgYWxsIG1vdXNlbW92ZSBldmVudHMgdGhhdCBhcmUgaGFwcGVuaW5nIGRpcmVjdGx5IG9uIHRoZSBDYW52YXNcbiAgICAgKiBAcGFyYW0gIHtqcXVlcnkuTW91c2VFdmVudH0gZXZlbnQgTW91c2VFdmVudCBnZW5lcmF0ZWQgYnkgYSBsaXN0ZW5lclxuICAgICAqL1xuICAgIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm1vdmVDYW52YXMpIHtcbiAgICAgICAgICAgIGxldCBsZWZ0ID0gZXZlbnQucGFnZVggLSB0aGlzLm1vdmVDYW52YXMubGVmdFxuICAgICAgICAgICAgbGV0IHRvcCA9IGV2ZW50LnBhZ2VZIC0gdGhpcy5tb3ZlQ2FudmFzLnRvcFxuXG4gICAgICAgICAgICB0aGlzLnZpZXdib3gubGVmdFNoaWZ0ICs9IGxlZnRcbiAgICAgICAgICAgIHRoaXMudmlld2JveC50b3BTaGlmdCArPSB0b3BcbiAgICAgICAgICAgIHRoaXMuYXBwbHlWaWV3Ym94KClcblxuICAgICAgICAgICAgdGhpcy5tb3ZlQ2FudmFzID0ge1xuICAgICAgICAgICAgICAgIGxlZnQ6IGV2ZW50LnBhZ2VYLFxuICAgICAgICAgICAgICAgIHRvcDogZXZlbnQucGFnZVlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgYWxsIG1vdXNldXAgZXZlbnRzIHRoYXQgYXJlIGhhcHBlbmluZyBkaXJlY3RseSBvbiB0aGUgQ2FudmFzXG4gICAgICovXG4gICAgb25Nb3VzZVVwKCkge1xuICAgICAgICBpZiAodGhpcy5tb3ZlQ2FudmFzKSB7XG4gICAgICAgICAgICB0aGlzLiRzdmcucmVtb3ZlQ2xhc3MoJ2dyYWJiZWQnKTtcbiAgICAgICAgICAgIHRoaXMubW92ZUNhbnZhcyA9IHVuZGVmaW5lZFxuXG4gICAgICAgICAgICAvLyBpZiB0dXRvcmlhbCBleGlzdHMsIGNhbGwgdHV0b3JpYWwgY2FsbGJhY2tcbiAgICAgICAgICAgIGlmICh0aGlzLnR1dG9yaWFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50dXRvcmlhbC5vbkNhbnZhc01vdmVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZpZXdCb3ggYXR0cmlidXRlIG9mIHRoZSBTVkcgZWxlbWVudCBhbmQgc2l6ZSBhbmQgcG9zaXRpb24gYXR0cmlidXRlc1xuICAgICAqIG9mIHRoZSByZWN0YW5nbGUgd2l0aCB0aGUgYmFja2dyb3VuZCBncmlkIHRvIG1hdGNoIHRoZSB2YWx1ZXMgaW4gdGhpcy52aWV3Ym94XG4gICAgICovXG4gICAgYXBwbHlWaWV3Ym94KCkge1xuICAgICAgICAvLyBhZGp1c3QgYmFja2dyb3VuZFxuICAgICAgICB0aGlzLmJhY2tncm91bmQuYWRkQXR0cih7eDogdGhpcy52aWV3Ym94LmxlZnQsIHk6IHRoaXMudmlld2JveC50b3AsIHdpZHRoOiB0aGlzLnZpZXdib3gud2lkdGgsIGhlaWdodDogdGhpcy52aWV3Ym94LmhlaWdodH0pXG5cbiAgICAgICAgLy8gc2V0IHRoZSB2aWV3Qm94IGF0dHJpYnV0ZVxuICAgICAgICB0aGlzLiRzdmcuYXR0cigndmlld0JveCcsIHRoaXMudmlld2JveC5zdHIpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHpvb20gbXVsdGlwbGllciBvZiB0aGUgY2FudmFzXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCB6b29tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3Ym94Lnpvb21cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHpvb20gbXVsdGlwbGllciBvZiB0aGUgY2FudmFzLlxuICAgICAqIEkgc2V0cyB0aGUgdmlld2JveCB6b29tIGFuZCB0aGVuIGFwcGxpZXMgdGhlIG5ldyB2YWx1ZSBieSBjYWxsaW5nIHRoaXMuYXBwbHlWaWV3Ym94KClcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlIHNldCB0aGUgem9vbSB0byB0aGlzIHZhbHVlXG4gICAgICovXG4gICAgc2V0IHpvb20odmFsdWUpIHtcbiAgICAgICAgdGhpcy52aWV3Ym94Lnpvb20gPSB2YWx1ZVxuICAgICAgICB0aGlzLmFwcGx5Vmlld2JveCgpXG5cbiAgICAgICAgLy8gaWYgdHV0b3JpYWwgZXhpc3RzLCBjYWxsIHR1dG9yaWFsIGNhbGxiYWNrXG4gICAgICAgIGlmICh0aGlzLnR1dG9yaWFsKSB7XG4gICAgICAgICAgICB0aGlzLnR1dG9yaWFsLm9uQ2FudmFzWm9vbWVkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzdGFydCB0aGUgdHV0b3JpYWxcbiAgICAgKi9cbiAgICBzdGFydFR1dG9yaWFsKCkge1xuICAgICAgICAvLyBpbnN0YW50aWF0ZSB0aGUgdHV0b3JpYWxcbiAgICAgICAgdGhpcy50dXRvcmlhbCA9IG5ldyBUdXRvcmlhbCh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBzZXQgdXNlckhhc1Zpc2l0ZWQgdG8gdHJ1ZSB3aGVuIHVzZXIgY2xvc2VzIChvciBmaW5pc2hlcykgdGhlIHR1dG9yaWFsXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UudXNlckhhc1Zpc2l0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyB1bnNldCB0aGUgdGhpcy50dXRvcmlhbCBwcm9wZXJ0eVxuICAgICAgICAgICAgdGhpcy50dXRvcmlhbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc3RhcnQgdGhlIHR1dG9yaWFsXG4gICAgICAgIHRoaXMudHV0b3JpYWwuc3RhcnQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhbiBvYmplY3QgY29udGFpbmluZyBleHBvcnQgZGF0YSBmb3IgdGhlIENhbnZhcyBhbmQgYWxsIGVsZW1lbnRzLlxuICAgICAqIERhdGEgZnJvbSB0aGlzIGZ1bmN0aW9uIHNob3VsZCBjb3ZlciBhbGwgaW1wb3J0YW50IGluZm9ybWF0aW9uIG5lZWRlZCB0byBpbXBvcnQgdGhlXG4gICAgICogbmV0d29yayBpbiBhIGRpZmZlcmVudCBzZXNzaW9uLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgaW5mb21yYXRpb24gYWJvdXQgdGhlIG5ldHdvcmtcbiAgICAgKi9cbiAgICBnZXQgZXhwb3J0RGF0YSgpIHtcbiAgICAgICAgdGhpcy5leHBvcnRXaXJlSWRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZXhwb3J0V2lyZUlkID0gMDtcblxuICAgICAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgICAgIGJveGVzOiBbXVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoY29uc3QgYm94IG9mIHRoaXMuYm94ZXMpIHtcbiAgICAgICAgICAgIGRhdGEuYm94ZXMucHVzaChib3guZXhwb3J0RGF0YSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3JlYXRlIGEgbG9naWMgbmV0d29yayBmcm9tIHRoZSBkYXRhIHByb3ZpZGVkXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBkYXRhIG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBpbXBvcnRlZCBuZXR3b3JrXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBbeF0gIGhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGxlZnQgdG9wIGNvcm5lciBvZiB0aGUgbmV0d29yayBpbiBncmlkIHBpeGVsc1xuICAgICAqIEBwYXJhbSAge251bWJlcn0gW3ldICB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgbGVmdCB0b3AgY29ybmVyIG9mIHRoZSBuZXR3b3JrIGluIGdyaWQgcGl4ZWxzXG4gICAgICovXG4gICAgaW1wb3J0RGF0YShkYXRhLCB4LCB5KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIGxldCB3YXJuaW5ncyA9IFtdO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGUgeCBvciB5IGlzIHVuZGVmaW5lZCwgc2V0IGl0IHRvIGxlZnRUb3BQYWRkaW5nIGluc3RlYWRcbiAgICAgICAgICAgIC8vIChjYW5ub3QgdXNlIHggfHwgbGVmdFRvcFBhZGRpbmcgYmVjYXVzZSBvZiAwKVxuICAgICAgICAgICAgeCA9IHggIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8geFxuICAgICAgICAgICAgICAgIDogdGhpcy5sZWZ0VG9wUGFkZGluZ1xuICAgICAgICAgICAgeSA9IHkgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8geVxuICAgICAgICAgICAgICAgIDogdGhpcy5sZWZ0VG9wUGFkZGluZ1xuXG4gICAgICAgICAgICB0aGlzLnNpbXVsYXRpb25FbmFibGVkID0gZmFsc2VcblxuICAgICAgICAgICAgLy8gbGlzdCBvZiB3aXJlcyB0byBiZSBhZGRlZFxuICAgICAgICAgICAgbGV0IG5ld1dpcmVzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBsZWZ0bW9zdCBhbmQgdG9wbW9zdCBjb29yZGluYXRlIG9mIGFueSBib3gsIHNhdmUgdGhlbSB0byBsZWZ0VG9wQ29ybmVyXG4gICAgICAgICAgICBsZXQgbGVmdFRvcENvcm5lciA9IHtcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgYm94RGF0YSBvZiBkYXRhLmJveGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJveERhdGEudHJhbnNmb3JtICYmIGJveERhdGEudHJhbnNmb3JtLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdHJhbnNmb3JtSW5mbyBvZiBib3hEYXRhLnRyYW5zZm9ybS5pdGVtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybUluZm8ubmFtZSA9PT0gXCJ0cmFuc2xhdGVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0VG9wQ29ybmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRUb3BDb3JuZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBNYXRoLm1pbihsZWZ0VG9wQ29ybmVyLngsIHRyYW5zZm9ybUluZm8uYXJnc1swXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBNYXRoLm1pbihsZWZ0VG9wQ29ybmVyLnksIHRyYW5zZm9ybUluZm8uYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRUb3BDb3JuZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiB0cmFuc2Zvcm1JbmZvLmFyZ3NbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB0cmFuc2Zvcm1JbmZvLmFyZ3NbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChsZXQgYm94RGF0YSBvZiBkYXRhLmJveGVzKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFwcGluZyBvZiBkYXRhQm94Lm5hbWUgb2YgdGhlIG9iamVjdHMgdGhhdCBoYXZlIGNhdGVnb3J5IFwib3RoZXJcIlxuICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyTWFwID0ge1xuICAgICAgICAgICAgICAgICAgICBcImlucHV0XCI6ICgpID0+IHRoaXMubmV3SW5wdXQoMCwgMCwgYm94RGF0YS5pc09uLCBmYWxzZSksXG4gICAgICAgICAgICAgICAgICAgIFwib3V0cHV0XCI6ICgpID0+IHRoaXMubmV3T3V0cHV0KDAsIDAsIGZhbHNlKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG1hcHBpbmcgb2YgZGF0YUJveC5jYXRlZ29yeVxuICAgICAgICAgICAgICAgIGNvbnN0IGJveE1hcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgXCJnYXRlXCI6ICgpID0+IHRoaXMubmV3R2F0ZShib3hEYXRhLm5hbWUsIDAsIDAsIGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgXCJibGFja2JveFwiOiAoKSA9PiB0aGlzLm5ld0JsYWNrYm94KGJveERhdGEuaW5wdXRzLCBib3hEYXRhLm91dHB1dHMsIGJveERhdGEudGFibGUsIGJveERhdGEubmFtZSwgMCwgMCwgZmFsc2UpLFxuICAgICAgICAgICAgICAgICAgICBcIm90aGVyXCI6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYm94RGF0YS5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGBUaGlzIG5ldHdvcmsgY29udGFpbnMgYSBib3ggd2l0aG91dCBhIG5hbWUuYFxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW90aGVyTWFwW2JveERhdGEubmFtZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgYFRoaXMgbmV0d29yayBjb250YWlucyB1bmtub3duIGJveCBuYW1lcy4gKCR7Ym94RGF0YS5uYW1lfSlgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvdGhlck1hcFtib3hEYXRhLm5hbWVdKClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGNyZWF0ZUJveCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFib3hEYXRhLmNhdGVnb3J5KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgYFRoaXMgbmV0d29yayBhIGJveCB3aXRob3V0IGEgY2F0ZWdvcnkuYDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWJveE1hcFtib3hEYXRhLmNhdGVnb3J5XSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGBUaGlzIG5ldHdvcmsgY29udGFpbnMgdW5rbm93biBib3ggY2F0ZWdvcmllcy4gKCR7Ym94RGF0YS5jYXRlZ29yeX0pYDtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm94TWFwW2JveERhdGEuY2F0ZWdvcnldKClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgYm94O1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYm94ID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuaW5ncy5wdXNoKGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChib3gpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvY2Nlc3MgYm94IHRyYW5zZm9ybXMgKHRyYW5zbGF0aW9uIGFuZCByb3RhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRyYW5zZm9ybSA9IG5ldyBlZGl0b3JFbGVtZW50cy5UcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJvdGF0aW9uQ291bnQgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybUl0ZW1NYXAgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInRyYW5zbGF0ZVwiOiAoYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5zZXRUcmFuc2xhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbMF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gbGVmdFRvcENvcm5lci54IC8vIG1ha2UgaXQgdGhlIHJlbGF0aXZlIGRpc3RhbmNlIGZyb20gdGhlIGxlZnRtb3N0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgeCAvLyBhcHBseSB0aGUgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1sxXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBsZWZ0VG9wQ29ybmVyLnkgLy8gbWFrZSBpdCB0aGUgcmVsYXRpdmUgZGlzdGFuY2UgZnJvbSB0aGUgdG9wbW9zdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIHkgLy8gYXBwbHkgdGhlIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJyb3RhdGVcIjogKGFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3RhdGlvbkNvdW50ID0gYXJnc1swXSAlIDM2MCAvIDkwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJveERhdGEudHJhbnNmb3JtICYmIGJveERhdGEudHJhbnNmb3JtLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRyYW5zZm9ybUl0ZW0gb2YgYm94RGF0YS50cmFuc2Zvcm0uaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7bmFtZSwgYXJnc30gPSB0cmFuc2Zvcm1JdGVtO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzLnB1c2goYFRoaXMgbmV0d29yayBjb250YWlucyB1bm5hbWVkIHRyYW5zZm9ybSBwcm9wZXJ0aWVzLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRyYW5zZm9ybUl0ZW1NYXBbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZ3MucHVzaChgVGhpcyBuZXR3b3JrIGNvbnRhaW5zIHVua25vd24gdHJhbnNmb3JtIHByb3BlcnRpZXMuICgke3RyYW5zZm9ybUl0ZW0ubmFtZX0pYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUl0ZW1NYXBbbmFtZV0oYXJncylcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS50b1NWR1BpeGVscyh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgYm94LnNldFRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm90YXRpb25Db3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3gucm90YXRlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGFsbCB3aXJlcyB0byB0aGUgbGlzdCBvZiB3aXJlcyB0byBiZSBhZGRlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoYm94RGF0YS5jb25uZWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb25uZWN0aW9uIG9mIGJveERhdGEuY29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGFydGlmaWNpYWwgd2lyZSBpZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3aXJlSWQgPSBjb25uZWN0aW9uLndpcmVJZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhc3MgdGhlIHZhbHVlcyBnb3QgZnJvbSBqc29uIGludG8gYSB2YXJpYWJsZSB0aGF0IHdpbGwgYmUgYWRkZWQgaW50byB0aGUgbWFwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogY29ubmVjdGlvbi5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm94SWQ6IGJveC5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIHZhbHVlIHRvIHRoZSBtYXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3V2lyZXMuaGFzKHdpcmVJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgYWxyZWFkeSBpcyBhIHdpcmUgd2l0aCB0aGlzIGlkIGluIHRoZSBtYXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgdmFsdWUgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkgb2YgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtYXBWYWx1ZSA9IG5ld1dpcmVzLmdldCh3aXJlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBWYWx1ZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3V2lyZXMuc2V0KHdpcmVJZCwgbWFwVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIHdpcmUgd2l0aCB0aGlzIGlkIGluIHRoZSBtYXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSB3aXJlIGFuZCBzZXQgdGhlIHZhbHVlIHRvIGJlIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdXaXJlcy5zZXQod2lyZUlkLCBbdmFsdWVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlZnJlc2ggdGhlIFNWRyBkb2N1bWVudCAobmVlZGVkIGZvciB3aXJpbmcpXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcblxuICAgICAgICAgICAgLy8gd2l0aCBhbGwgYm94ZXMgYWRkZWQsIHdlIGNhbiBub3cgY29ubmVjdCB0aGVtIHdpdGggd2lyZXNcblxuICAgICAgICAgICAgLy8gcHJpb3JpdHkgcXVldWUgZm9yIHRoZSBuZXcgd2lyZXMsIHByaW9yaXR5IGJlaW5nICgxIC8gbWFuaGF0dGFuRGlzdGFuY2UpIGJldHdlZW4gdGhlIGNvbmVuY3RvcnMsIGhpZ2hlciBpcyBiZXR0ZXJcbiAgICAgICAgICAgIGxldCB3aXJlUXVldWUgPSBuZXcgUHJpb3JpdHlRdWV1ZSgpO1xuXG4gICAgICAgICAgICAvLyBnZXQgYWxsIGlkcyBmb3IgbGFsIHRoZVxuICAgICAgICAgICAgZm9yIChjb25zdCB3aXJlSW5mbyBvZiBuZXdXaXJlcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGxldCBjb25uZWN0b3JJZHMgPSBbXTtcblxuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhbiBhcnJheSBbY29ubmVjdG9yMUlkLCBjb25uZWN0b3IySWRdXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB7Ym94SWQsIGluZGV4fVxuICAgICAgICAgICAgICAgIG9mIHdpcmVJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rvcklkcy5wdXNoKHRoaXMuZ2V0Qm94QnlJZChib3hJZCkuY29ubmVjdG9yc1tpbmRleF0uaWQpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGFuZCBhcnJheSBbe3gsIHl9LCB7eCwgeX1dIGNvbnRhaW5pbmcgcG9zaXRpb25zIGZvciBjb25uZWN0b3JzIDEgYW5kIDJcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0b3JzUG9zaXRpb25zID0gY29ubmVjdG9ySWRzLm1hcChjb25uZWN0b3JJZCA9PiB0aGlzLmdldENvbm5lY3RvclBvc2l0aW9uKHRoaXMuZ2V0Q29ubmVjdG9yQnlJZChjb25uZWN0b3JJZCksIHRydWUpKVxuXG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3RvcnNQb3NpdGlvbnMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB3aXJlID0gdGhpcy5uZXdXaXJlKC4uLmNvbm5lY3RvcklkcywgZmFsc2UsIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIG1hbmhhdHRhbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZXNlIHR3byBjb25uZWN0b3JzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gbWFuaGF0dGFuRGlzdGFuY2UoLi4uY29ubmVjdG9yc1Bvc2l0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGNvbm5lY3RvcmlkcyB0byB0aGUgcHJpb3JpdHkgcXVldWVcbiAgICAgICAgICAgICAgICAgICAgd2lyZVF1ZXVlLmVucXVldWUod2lyZSwgMSAvIGRpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3YXJuaW5ncy5wdXNoKGBGb3VuZCBhIHdpcmUgdGhhdCBkb2VzIG5vdCBoYXZlIHR3byBlbmRpbmdzLiAoSXQgaGFkICR7Y29ubmVjdG9yc1Bvc2l0aW9ucy5sZW5ndGh9IGluc3RlYWQuKWApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAod2luZG93Lldvcmtlcikge1xuICAgICAgICAgICAgICAgIGxldCB3aXJlUG9pbnRzID0gW107XG4gICAgICAgICAgICAgICAgbGV0IHdpcmVSZWZlcmVuY2VzID0gW107XG5cbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHRoZSBxdWV1ZSB0byBhbiBhcnJheSAodGhpcyBpcyBuZWVkZWQgYnkgdGhlIHdlYiB3b3JrZXIpXG4gICAgICAgICAgICAgICAgd2hpbGUgKCF3aXJlUXVldWUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdpcmUgPSB3aXJlUXVldWUuZGVxdWV1ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCB3aXJlU3RhcnQgPSB0aGlzLmdldENvbm5lY3RvclBvc2l0aW9uKHdpcmUuY29ubmVjdGlvbi5mcm9tLmNvbm5lY3RvciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB3aXJlRW5kID0gdGhpcy5nZXRDb25uZWN0b3JQb3NpdGlvbih3aXJlLmNvbm5lY3Rpb24udG8uY29ubmVjdG9yLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICB3aXJlUG9pbnRzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHdpcmVTdGFydC54IC8gdGhpcy5ncmlkU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB3aXJlU3RhcnQueSAvIHRoaXMuZ3JpZFNpemVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiB3aXJlRW5kLnggLyB0aGlzLmdyaWRTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHdpcmVFbmQueSAvIHRoaXMuZ3JpZFNpemVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSlcblxuICAgICAgICAgICAgICAgICAgICB3aXJlUmVmZXJlbmNlcy5wdXNoKHdpcmUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFtyb3V0ZVdvcmtlckZpbGVOYW1lXSByZXBsYWNlZCBpbiB0aGUgYnVpbGQgcHJvY2VzcyAoZGVmaW5lZCBpbiBndWxwZmlsZSkgZGVwZW5kaW5nIG9uIGRldmVsIC8gcHJvZCBidWlsZFxuICAgICAgICAgICAgICAgIGxldCBteVdvcmtlciA9IG5ldyBXb3JrZXIoXCJqcy9bcm91dGVXb3JrZXJGaWxlTmFtZV1cIik7XG5cbiAgICAgICAgICAgICAgICBsZXQgbG9hZGluZ01lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VzLm5ld0xvYWRpbmdNZXNzYWdlKFwibG9va2luZyBmb3IgdGhlIGJlc3Qgd2lyaW5n4oCmXCIpO1xuXG4gICAgICAgICAgICAgICAgbXlXb3JrZXIub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHtwYXRoc30gPSBldmVudC5kYXRhXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGUgd2lyZVJlZmVyZW5jZXMgYW5kIHBhdGhzIHN5bmNocm9ub3VzbHlcbiAgICAgICAgICAgICAgICAgICAgd2lyZVJlZmVyZW5jZXMuZm9yRWFjaCgod2lyZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aXJlLnNldFdpcmVQYXRoKHdpcmUucGF0aFRvUG9seUxpbmUocGF0aHNba2V5XSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB3aXJlLnVwZGF0ZVdpcmVTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lyZS5nZW5lcmF0ZUluY29udmVuaWVudE5vZGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZ01lc3NhZ2UuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIHdpcmVzOiB3aXJlUG9pbnRzLFxuICAgICAgICAgICAgICAgICAgICBub25Sb3V0YWJsZU5vZGVzOiB0aGlzLmdldE5vblJvdXRhYmxlTm9kZXMoKSxcbiAgICAgICAgICAgICAgICAgICAgaW5jb252ZW5pZW50Tm9kZXM6IHRoaXMuZ2V0SW5jb252ZW5pZW50Tm9kZXMoKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG15V29ya2VyLnBvc3RNZXNzYWdlKG1lc3NhZ2UpXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd2ViIHdvcmtlciBpcyBub3Qgc3VwcG9ydGVkOiB1c2UgYW4gaW50ZXJ2YWwgdG8gbWFrZSB0aGUgaW1wb3J0IGEgYml0IHNsb3dlclxuICAgICAgICAgICAgICAgIC8vIGJ5IGRpdmlkaW5nIGl0IGludG8gY2h1bmtzLCBzbyB0aGUgYnJvd3NlciB3aW5kb3cgaXMgbm90IGVudGlyZWx5IGZyb3plbiB3aGVuIHRoZSB3aXJpbmcgaXMgaGFwcGVuaW5nXG5cbiAgICAgICAgICAgICAgICBjb25zdCB3aXJlc1RvQmVSb3V0ZWRBdE9uY2UgPSAxMDtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWxheUJldHdlZW5JdGVyYXRpb25zID0gMjAwO1xuXG4gICAgICAgICAgICAgICAgLy8gYWRkIHdpcmVzIGluIHRoZSBvcmRlciBmcm9tIHNob3J0IHRvIGxvbmdcbiAgICAgICAgICAgICAgICBsZXQgd2lyZVBsYWNpbmdJbnRlcnZhbCA9IHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghd2lyZVF1ZXVlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aXJlc1RvQmVSb3V0ZWRBdE9uY2U7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aXJlUXVldWUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdpcmUgPSB3aXJlUXVldWUuZGVxdWV1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpcmUucm91dGVXaXJlKHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXJlLnVwZGF0ZVdpcmVTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJmaW5pc2hlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwod2lyZVBsYWNpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBkZWxheUJldHdlZW5JdGVyYXRpb25zKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZWZyZXNoIHRoZSBTVkcgZG9jdW1lbnRcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuXG4gICAgICAgICAgICB0aGlzLnNpbXVsYXRpb25FbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgcmVzb2x2ZSh3YXJuaW5ncylcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHVzZXIgY2xpY2tzIG9uIGEgY29ubmVjdG9yLCByZW1lbWJlciBpdCB1bnRpbCB0aGV5IGNsaWNrIG9uIHNvbWUgb3RoZXIgY29ubmVjdG9yLlxuICAgICAqIFRoYW4gY2FsbCBuZXdXaXJlIHdpdGggdGhlIGxhc3QgdHdvIGNvbm5lY3RvcnMgaWRzIGFzIGFyZ3VtZW50cy5cbiAgICAgKiBWaXN1YWxpemUgdGhlIHByb2Nlc3MgYnkgZGlzcGxheWluZyBhIGdyZXkgd2lyZSBiZXR3ZWVuIHRoZSBmaXJzdCBjb25lbmN0b3IgYW5kIHRoZSBtb3VzZSBwb2ludGVyLlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gY29ubmVjdG9ySWQgaWQgb2YgdGhlIGNvbm5lY3RvciB0aGF0IHRoZSB1c2VyIGNsaWNrZWQgb25cbiAgICAgKi9cbiAgICB3aXJlQ3JlYXRpb25IZWxwZXIoY29ubmVjdG9ySWQsIG1vdXNlUG9zaXRpb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLndpcmVDcmVhdGlvbikge1xuICAgICAgICAgICAgdGhpcy53aXJlQ3JlYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgZnJvbUlkOiBjb25uZWN0b3JJZFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlDcmVhdGVkV2lyZShtb3VzZVBvc2l0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndpcmVDcmVhdGlvbi5mcm9tSWQgIT09IGNvbm5lY3RvcklkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlQ3JlYXRlZFdpcmUoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMubmV3V2lyZSh0aGlzLndpcmVDcmVhdGlvbi5mcm9tSWQsIGNvbm5lY3RvcklkKTtcblxuICAgICAgICAgICAgICAgIHRoaXMud2lyZUNyZWF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGVscGVyIGZvciB3aXJlQ3JlYXRpb25IZWxwZXIgdGhhdCBkaXNwbGF5cyBhIGdyZXkgd2lyZSBiZXR3ZWVuIHRoZSBmaXJzdCBjb25uZWN0b3IgYW5kIHRoZSBzcGVjaWZpZWQgbW91c2VQb3NpdGlvblxuICAgICAqIEBwYXJhbSAge09iamVjdH0gbW91c2VQb3NpdGlvbiBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvb3JkaW5hdGVzIGluIFNWRyBwaXhlbHNcbiAgICAgKi9cbiAgICBkaXNwbGF5Q3JlYXRlZFdpcmUobW91c2VQb3NpdGlvbikge1xuICAgICAgICB0aGlzLndpcmVDcmVhdGlvbi50ZW1wV2lyZSA9IG5ldyBlZGl0b3JFbGVtZW50cy5IZWxwZXJXaXJlKHRoaXMsIHRoaXMud2lyZUNyZWF0aW9uLmZyb21JZCwgbW91c2VQb3NpdGlvbik7XG5cbiAgICAgICAgJCh3aW5kb3cpLm9uKCdtb3VzZW1vdmUud2lyZUNyZWF0aW9uJywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgZXZlbnQgPSB0aGlzLnZpZXdib3gudHJhbnNmb3JtRXZlbnQoZXZlbnQpXG5cbiAgICAgICAgICAgIG1vdXNlUG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeDogZXZlbnQucGFnZVgsXG4gICAgICAgICAgICAgICAgeTogZXZlbnQucGFnZVlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy53aXJlQ3JlYXRpb24udGVtcFdpcmUudXBkYXRlTW91c2VQb3NpdGlvbihtb3VzZVBvc2l0aW9uKTtcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLmFwcGVuZEVsZW1lbnQodGhpcy53aXJlQ3JlYXRpb24udGVtcFdpcmUpO1xuICAgICAgICB0aGlzLm1vdmVUb0JhY2tCeUlkKHRoaXMud2lyZUNyZWF0aW9uLnRlbXBXaXJlLmlkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBoZWxwZXIgZm9yIHdpcmVDcmVhdGlvbkhlbHBlciB0aGF0IGhpZGVzIHRoZSB0ZW1wb3Jhcnkgd2lyZSB3aGVuIHdpcmUgY3JlYXRpb24gaXMgZG9uZVxuICAgICAqL1xuICAgIGhpZGVDcmVhdGVkV2lyZSgpIHtcbiAgICAgICAgJCh3aW5kb3cpLm9mZignbW91c2Vtb3ZlLndpcmVDcmVhdGlvbicpO1xuXG4gICAgICAgIHRoaXMud2lyZUNyZWF0aW9uLnRlbXBXaXJlLmdldCgpLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLndpcmVDcmVhdGlvbi50ZW1wV2lyZSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBoZWxwZXIgZm9yIHdpcmVDcmVhdGlvbkhlbHBlciB0aGF0IGNhbmNlbHMgdGhlIHdpcmUgY3JlYXRpb24gcHJvY2Vzc1xuICAgICAqL1xuICAgIGNhbmNlbFdpcmVDcmVhdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMud2lyZUNyZWF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGVDcmVhdGVkV2lyZSgpO1xuICAgICAgICAgICAgdGhpcy53aXJlQ3JlYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW4gYSBsb2dpYyBzaW11bGF0aW9uIGZyb20gdGhlIHN0YXJ0aW5nQ29ubmVjdG9yLlxuICAgICAqIFRoaXMgcmVmcmVzaGVzIHRoZSBzdGF0ZXMgb2YgYWxsIGVsZW1lbnRzIGluIHRoZSBuZXR3b3JrIHdob3NlIGlucHV0cyBhcmVcbiAgICAgKiBkaXJlY3RseSAob3IgYnkgdHJhbnNpdGlvbikgY29ubmVjdGVkIHRvIHN0YXJ0aW5nQ29ubmVjdG9yJ3Mgb3V0cHV0XG4gICAgICogQHBhcmFtICB7T3V0cHV0Q29ubmVjdG9yfSBzdGFydGluZ0Nvbm5lY3RvciBydW4gc2ltdWxhdGlvbiBmcm9tIHRoaXMgb3V0cHV0IGNvbm5lY3RvclxuICAgICAqIEBwYXJhbSAge0xvZ2ljLnN0YXRlfSBzdGF0ZSBuZXcgc3RhdGUgb2YgdGhlIHN0YXJ0aW5nQ29ubmVjdG9yXG4gICAgICovXG4gICAgc3RhcnROZXdTaW11bGF0aW9uKHN0YXJ0aW5nQ29ubmVjdG9yLCBzdGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5zaW11bGF0aW9uRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5zaW11bGF0aW9uID0gbmV3IFNpbXVsYXRpb24odGhpcylcbiAgICAgICAgICAgIHRoaXMuc2ltdWxhdGlvbi5ub3RpZnlDaGFuZ2Uoc3RhcnRpbmdDb25uZWN0b3IuaWQsIHN0YXRlKVxuICAgICAgICAgICAgdGhpcy5zaW11bGF0aW9uLnJ1bigpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgZ2F0ZSBvbiB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgbmFtZSAgICAgICAgICAgdHlwZSBvZiB0aGUgZ2F0ZSAoYW5kLCBvciAuLi4pXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSAgeCAgICAgICAgICAgICAgaG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgZ2F0ZSBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSAgeSAgICAgICAgICAgICAgdmVydGljYWwgcG9zaXRpb24gb2YgdGhlIGdhdGUgaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IFtyZWZyZXNoPXRydWVdIGlmIHRydWUsIHRoaXMucmVmcmVzaCgpIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGFkZGluZyB0aGUgZ2F0ZVxuICAgICAqIEByZXR1cm4ge2VkaXRvckVsZW1lbnRzLkdhdGV9ICAgIGluc3RhbmNlIG9mIEdhdGUgdGhhdCBoYXMgYmVlbiBuZXdseSBhZGRlZFxuICAgICAqL1xuICAgIG5ld0dhdGUobmFtZSwgeCwgeSwgcmVmcmVzaCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV3Qm94KHgsIHksIG5ldyBlZGl0b3JFbGVtZW50cy5HYXRlKHRoaXMsIG5hbWUsIHgsIHkpLCByZWZyZXNoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gaW5wdXQgYm94IG9uIHRoZSBzcGVjaWZpZWQgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4ICAgICAgICAgICAgICBob3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBnYXRlIGluIFNWRyBwaXhlbHNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5ICAgICAgICAgICAgICB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgZ2F0ZSBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtICB7Ym9vbGVhbn0gW2lzT249ZmFsc2VdICAgc3RhdGUgb2YgdGhlIGlucHV0IGJveCAoZGVmYXVsdCBpcyBmYWxzZSAob2ZmKSlcbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSBbcmVmcmVzaD10cnVlXSBpZiB0cnVlLCB0aGlzLnJlZnJlc2goKSB3aWxsIGJlIGNhbGxlZCBhZnRlciBhZGRpbmcgdGhlIGlucHV0IGJveFxuICAgICAqIEByZXR1cm4ge2VkaXRvckVsZW1lbnRzLklucHV0Qm94fSAgICBpbnN0YW5jZSBvZiB0aGUgSW5wdXRCb3ggdGhhdCBoYXMgYmVlbiBuZXdseSBhZGRlZFxuICAgICAqL1xuICAgIG5ld0lucHV0KHgsIHksIGlzT24gPSBmYWxzZSwgcmVmcmVzaCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV3Qm94KHgsIHksIG5ldyBlZGl0b3JFbGVtZW50cy5JbnB1dEJveCh0aGlzLCBpc09uKSwgcmVmcmVzaCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIG91dHB1dCBib3ggb24gdGhlIHNwZWNpZmllZCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSAge251bWJlcn0gIHggICAgICAgICAgICAgIGhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGdhdGUgaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkgICAgICAgICAgICAgIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBnYXRlIGluIFNWRyBwaXhlbHNcbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSBbcmVmcmVzaD10cnVlXSBpZiB0cnVlLCB0aGlzLnJlZnJlc2goKSB3aWxsIGJlIGNhbGxlZCBhZnRlciBhZGRpbmcgdGhlIG91dHB1dCBib3hcbiAgICAgKiBAcmV0dXJuIHtlZGl0b3JFbGVtZW50cy5JbnB1dEJveH0gICAgaW5zdGFuY2Ugb2YgdGhlIE91dHB1dEJveCB0aGF0IGhhcyBiZWVuIG5ld2x5IGFkZGVkXG4gICAgICovXG4gICAgbmV3T3V0cHV0KHgsIHksIHJlZnJlc2ggPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld0JveCh4LCB5LCBuZXcgZWRpdG9yRWxlbWVudHMuT3V0cHV0Qm94KHRoaXMpLCByZWZyZXNoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBuZXcgQm94IHRvIHRoZSBDYW52YXNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4ICAgICAgICAgICAgICBob3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBib3ggaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkgICAgICAgICAgICAgIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBib3ggaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSAge2VkaXRvckVsZW1lbnRzLkJveH0gIG9iamVjdCAgICAgICAgIGluc3RhbmNlIG9mIGFuIG9iamVjdCBkZXJpdmVkIGZyb20gdGhlIGVkaXRvckVsZW1lbnRzLkJveCBjbGFzc1xuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IFtyZWZyZXNoPXRydWVdIGlmIHRydWUsIHRoaXMucmVmcmVzaCgpIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGFkZGluZyB0aGUgYm94XG4gICAgICogQHJldHVybiB7ZWRpdG9yRWxlbWVudHMuQm94fSAgICAgICAgICAgICAgICAgcmV0dXJuIHRoZSBpbnN0YW5jZSBvZiB0aGUgbmV3bHkgYWRkZWQgb2JqZWN0XG4gICAgICovXG4gICAgbmV3Qm94KHgsIHksIG9iamVjdCwgcmVmcmVzaCA9IHRydWUpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5ib3hlcy5sZW5ndGg7XG5cbiAgICAgICAgdGhpcy5ib3hlc1tpbmRleF0gPSBvYmplY3Q7XG5cbiAgICAgICAgLy8gdHJhbnNsYXRlIHRoZSBnYXRlIGlmIHggYW5kIHkgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAgICAgIGlmICh4ICYmIHkpIHtcbiAgICAgICAgICAgIGxldCB0ciA9IG5ldyBlZGl0b3JFbGVtZW50cy5UcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIHRyLnNldFRyYW5zbGF0ZSh4LCB5KTtcblxuICAgICAgICAgICAgdGhpcy5ib3hlc1tpbmRleF0uc3ZnT2JqLmFkZEF0dHIoe1widHJhbnNmb3JtXCI6IHRyLmdldCgpfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFwcGVuZEVsZW1lbnQodGhpcy5ib3hlc1tpbmRleF0sIHJlZnJlc2gpO1xuXG4gICAgICAgIC8vIGlmIHR1dG9yaWFsIGV4aXN0cywgY2FsbCB0dXRvcmlhbCBjYWxsYmFja1xuICAgICAgICBpZiAodGhpcy50dXRvcmlhbCkge1xuICAgICAgICAgICAgdGhpcy50dXRvcmlhbC5vbkVsZW1lbnRBZGRlZCh0aGlzLmJveGVzW2luZGV4XS5uYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmJveGVzW2luZGV4XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBib3ggZnJvbSBDYW52YXMgYmFzZWQgb24gdGhlIHByb3ZpZGVkIElEXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJveElkIGlkIG9mIHRoZSBib3ggdGhhdCBzaG91bGQgYmUgcmVtb3ZlZFxuICAgICAqL1xuICAgIHJlbW92ZUJveChib3hJZCkge1xuICAgICAgICBsZXQgJGdhdGUgPSAkKFwiI1wiICsgYm94SWQpO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIGdhdGUgaW4gc3ZnJ3MgbGlzdCBvZiBnYXRlc1xuICAgICAgICBsZXQgZ2F0ZUluZGV4ID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYm94ZXNbaV0uc3ZnT2JqLmlkID09PSBib3hJZCkge1xuICAgICAgICAgICAgICAgIGdhdGVJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2F0ZUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBhbGwgd2lyZXMgY29ubmVjdGVkIHRvIHRoaXMgZ2F0ZVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJveGVzW2dhdGVJbmRleF0uY29ubmVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlV2lyZXNCeUNvbm5lY3RvcklkKHRoaXMuYm94ZXNbZ2F0ZUluZGV4XS5jb25uZWN0b3JzW2ldLmlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBnYXRlXG4gICAgICAgICAgICB0aGlzLmJveGVzLnNwbGljZShnYXRlSW5kZXgsIDEpO1xuICAgICAgICAgICAgJGdhdGUucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIC8vIGlmIHR1dG9yaWFsIGV4aXN0cywgY2FsbCB0dXRvcmlhbCBjYWxsYmFja1xuICAgICAgICAgICAgaWYgKHRoaXMudHV0b3JpYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnR1dG9yaWFsLm9uRWxlbWVudFJlbW92ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUcnlpbmcgdG8gcmVtb3ZlIGFuIG5vbmV4aXN0aW5nIGJveC4gQm94IGlkOlwiLCBib3hJZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGJveGVzIGZyb20gdGhlIGNhbnZhc1xuICAgICAqL1xuICAgIGNsZWFuQ2FudmFzKCkge1xuICAgICAgICAvLyBjYW5ub3Qgc2ltcGx5IGl0ZXJhdGUgdGhyb3VnaCB0aGUgYXJyYXkgYmVjYXVzZSByZW1vdmVCb3ggd29ya3Mgd2l0aCBpdFxuXG4gICAgICAgIC8vIGNyZWF0ZSBhbiBhcnJheSBvZiBpZHNcbiAgICAgICAgY29uc3QgaWRzID0gdGhpcy5ib3hlcy5tYXAoYm94ID0+IGJveC5pZCk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBib3hlcyBieSB0aGVpciBpZHNcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBpZHMpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQm94KGlkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyB3aXJlIGNvbm5lY3RpbmcgdGhlIHByb3ZpZGVkIGNvbm5lY3RvcnNcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBmcm9tSWQgICAgICAgICBpZCBvZiB0aGUgY29ubmVjdG9yIHRoYXQgdGhlIHdpcmUgaXMgYXR0YWNoZWQgdG9cbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICB0b0lkICAgICAgICAgICBpZCBvZiB0aGUgY29ubmVjdG9yIHRoYXQgdGhlIHdpcmUgaXMgYXR0YWNoZWQgdG9cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBbcmVmcmVzaD10cnVlXSBpZiByZWZyZXNoIGlzIHNldCB0byB0cnVlLCB0aGUgU1ZHIGRvY3VtZW50IHdpbGwgYmUgcmVsb2FkZWQgYWZ0ZXIgYWRkaW5nIHRoZSB3aXJlXG4gICAgICogQHJldHVybiB7ZWRpdG9yRWxlbWVudHMuV2lyZX0gICAgaW5zdGFuY2Ugb2YgZWRpdG9yRWxlbWVudHMuV2lyZSB0aGF0IGhhcyBiZWVuIGFkZGVkIHRvIHRoZSBDYW52YXNcbiAgICAgKi9cbiAgICBuZXdXaXJlKGZyb21JZCwgdG9JZCwgcmVmcmVzaCA9IHRydWUsIHJvdXRlID0gdHJ1ZSkge1xuICAgICAgICAvLyB3aXJlIG11c3QgY29ubmVjdCB0d28gZGlzdGluY3QgY29ubmVjdG9yc1xuICAgICAgICBpZiAoZnJvbUlkID09PSB0b0lkKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuXG4gICAgICAgIGxldCBjb25uZWN0b3JzID0gW3RoaXMuZ2V0Q29ubmVjdG9yQnlJZChmcm9tSWQpLCB0aGlzLmdldENvbm5lY3RvckJ5SWQodG9JZCldXG5cbiAgICAgICAgLy8gaW5wdXQgY29ubmVjdG9ycyBjYW4gYmUgY29ubmVjdGVkIHRvIG9uZSB3aXJlIG1heFxuICAgICAgICBjb25uZWN0b3JzLmZvckVhY2goY29ubiA9PiB7XG4gICAgICAgICAgICBpZiAoY29ubi5pc0lucHV0Q29ubmVjdG9yKVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlV2lyZXNCeUNvbm5lY3RvcklkKGNvbm4uaWQpXG4gICAgICAgIH0pXG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMud2lyZXMubGVuZ3RoO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLndpcmVzW2luZGV4XSA9IG5ldyBlZGl0b3JFbGVtZW50cy5XaXJlKHRoaXMsIGZyb21JZCwgdG9JZCwgcmVmcmVzaCwgcm91dGUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VzLm5ld0Vycm9yTWVzc2FnZShlKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25uZWN0b3JzLmZvckVhY2goY29ubiA9PiB7XG4gICAgICAgICAgICBjb25uLmFkZFdpcmVJZCh0aGlzLndpcmVzW2luZGV4XS5zdmdPYmouaWQpO1xuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMuYXBwZW5kRWxlbWVudCh0aGlzLndpcmVzW2luZGV4XSwgcmVmcmVzaCk7XG4gICAgICAgIHRoaXMubW92ZVRvQmFja0J5SWQodGhpcy53aXJlc1tpbmRleF0uc3ZnT2JqLmlkKTtcblxuICAgICAgICBpZiAocmVmcmVzaClcbiAgICAgICAgICAgIHRoaXMud2lyZXNbaW5kZXhdLnVwZGF0ZVdpcmVTdGF0ZSgpXG5cbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZXNbaW5kZXhdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHNwZWNpZmllZCBjb25uZWN0b3JcbiAgICAgKiBAcGFyYW0gIHtDb25uZWN0b3J9ICBjb25uZWN0b3IgICAgICBpbnN0YW5jZSBvZiB7QGxpbmsgQ29ubmVjdG9yfVxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IFtzbmFwVG9HcmlkPXRydWVdIGlmIHRydWUsIHRoZSBjb25uZWN0b3IgcG9zaXRpb24gd2lsbCBiZSBzbmFwcGVkIHRvIHRoZSBncmlkXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgcG9pbnQgLSBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWBcbiAgICAgKi9cbiAgICBnZXRDb25uZWN0b3JQb3NpdGlvbihjb25uZWN0b3IsIHNuYXBUb0dyaWQgPSB0cnVlKSB7XG4gICAgICAgIC8vIGNvbm5lY3Rvci5zdmdPYmouaWQgaGFzIHRvIGJlIGNhbGxlZCwgZWxzZSB0aGUgZ2V0Q29vcmRpbmF0ZXMgZG9lcyBub3Qgd29yayBvbiB0aGUgZmlyc3QgY2FsbCBpbiBGaXJlZm94IDU1XG4gICAgICAgIGNvbnN0IGR1bW15ID0gY29ubmVjdG9yLnN2Z09iai5pZDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gICAgICAgIGxldCAkY29ubmVjdG9yID0gY29ubmVjdG9yLnN2Z09iai4kZWw7XG5cbiAgICAgICAgbGV0IHBvc2l0aW9uID0gJGNvbm5lY3Rvci5wb3NpdGlvbigpO1xuXG4gICAgICAgIHBvc2l0aW9uLmxlZnQgPSB0aGlzLnZpZXdib3gudHJhbnNmb3JtWChwb3NpdGlvbi5sZWZ0KVxuICAgICAgICBwb3NpdGlvbi50b3AgPSB0aGlzLnZpZXdib3gudHJhbnNmb3JtWShwb3NpdGlvbi50b3ApXG5cbiAgICAgICAgbGV0IHdpZHRoID0gJGNvbm5lY3Rvci5hdHRyKFwid2lkdGhcIik7XG4gICAgICAgIGxldCBoZWlnaHQgPSAkY29ubmVjdG9yLmF0dHIoXCJoZWlnaHRcIik7XG5cbiAgICAgICAgbGV0IHggPSBwb3NpdGlvbi5sZWZ0ICsgd2lkdGggLyAyO1xuICAgICAgICBsZXQgeSA9IHBvc2l0aW9uLnRvcCArIGhlaWdodCAvIDI7XG4gICAgICAgIGlmIChzbmFwVG9HcmlkKSB7XG4gICAgICAgICAgICB4ID0gdGhpcy5zbmFwVG9HcmlkKHgpO1xuICAgICAgICAgICAgeSA9IHRoaXMuc25hcFRvR3JpZCh5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7eDogeCwgeTogeX07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3JlYXRlcyBhIG5ldyBibGFja2JveFxuICAgICAqIEBwYXJhbSAge251bWJlcn0geCAgICAgICBob3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBibGFja2JveCBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB5ICAgICAgIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBnYXRlIGluIFNWRyBwaXhlbHNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGlucHV0cyAgbnVtYmVyIG9mIGlucHV0IHBpbnMgb2YgdGhpcyBibGFja2JveFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gb3V0cHV0cyBudW1iZXIgb2Ygb3V0cHV0IHBpbnMgb2YgdGhpcyBibGFja2JveFxuICAgICAqIEBwYXJhbSAge0FycmF5fSB0YWJsZSAgIEFycmF5IG9mIGFycmF5cywgZWFjaCBpbm5lciBhcnJheSBjb250YWlucyBsaXN0IG9mIFtMb2dpYy5zdGF0ZV0oLi9tb2R1bGUtTG9naWMuaHRtbCMuc3RhdGUpcyxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCBkZXNjcmliZSB0aGUgY29tYmluYXRpb24gb2YgaW5wdXQgcGluIGFuZCBvdXRwdXQgcGluIHN0YXRlcyBpbiB0aGUgb3JkZXIgZnJvbSB0aGUgdG9wIHRvIGJvdHRvbSBmb3IgYm90aCBpbnB1dCBhbmQgb3V0cHV0IGNvbm5lY3RvcnMuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIElmIHdlIGhhZCBhbiBBTkQgYXJyYXkgYXMgYSBibGFja2JveCwgb25lIG9mIHRoZSBzdGF0ZXMgY291bGQgYmUgYFtMb2dpYy5zdGF0ZS5vbiwgTG9naWMuc3RhdGUub2ZmLCBMb2dpYy5zdGF0ZS5vZmZdYFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB3aGljaCBtZWFucyB0aGF0IGlmIHRoZSBmaXJzdCBpbnB1dCBjb25uZWN0b3IgaXMgaW4gdGhlIGBvbmAgc3RhdGUgYW5kIHRoZSBzZWNvbmQgY29ubmVjdG9yIGlzIGluIHRoZSBgb2ZmYCBzdGF0ZSxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHN0YXRlIG9mIHRoZSBvdXRwdXQgY29ubmVjdG9yIHdpbGwgYmUgYG9mZmAuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBhcnJheSBjYW4gYmUgZGVzY3JpYmVkIGFzIGBbc3RhdGUgZm9yIGlucHV0IGNvbm4gMSwgc3RhdGUgZm9yIGlucHV0IGNvbm4gMiwgLi4uLCBzdGF0ZSBmb3Igb3V0cHV0IGNvbm4gMSwgc3RhdGUgZm9yIG91dHB1dCBjb25uIDIgLi4uXWAuXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgbmFtZSAgIGEgbmFtZSB0aGF0IHdpbGwgYmUgZGlzcGxheWVkIG9uIHRoZSBibGFja2JveFxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IFtyZWZyZXNoPXRydWVdIGlmIHRydWUsIHRoaXMucmVmcmVzaCgpIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGFkZGluZyB0aGUgZ2F0ZVxuICAgICAqXG4gICAgICogQHJldHVybiB7ZWRpdG9yRWxlbWVudHMuQmxhY2tib3h9IGluc3RhbmNlIG9mIHtAbGluayBCbGFja2JveH0gdGhhdCBoYXMgYmVlbiBhZGRlZCB0byB0aGUgW0NhbnZhc10oLi9tb2R1bGUtQ2FudmFzLmh0bWwpXG4gICAgICovXG4gICAgbmV3QmxhY2tib3goaW5wdXRzLCBvdXRwdXRzLCB0YWJsZSwgbmFtZSwgeCwgeSwgcmVmcmVzaCA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmJveGVzLmxlbmd0aDtcblxuICAgICAgICB0aGlzLmJveGVzW2luZGV4XSA9IG5ldyBlZGl0b3JFbGVtZW50cy5CbGFja2JveCh0aGlzLCBpbnB1dHMsIG91dHB1dHMsICguLi5pbnB1dFN0YXRlcykgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIHRhYmxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZUlucHV0U3RhdGVzID0gbGluZS5zbGljZSgwLCBpbnB1dHMpO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgZXZlcnkgaW5wdXQgc3RhdGUgbWF0Y2hlcyB0aGUgY29ycmVzcG9uZGluZyBpbnB1dCBzdGF0ZSBpbiB0aGlzIGxpbmUgb2YgdGhlIHRydXRoIHRhYmxlXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0U3RhdGVzLmV2ZXJ5KCh2YWx1ZSwgaW5kZXgpID0+IHZhbHVlID09PSBsaW5lSW5wdXRTdGF0ZXNbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gdGhlIHJlc3Qgb2YgdGhlIGxpbmUgYXMgb3V0cHV0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5lLnNsaWNlKGlucHV0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgbm90aGluZyBtYXRjaGVzLCBzZXQgYWxsIG91dHB1dHMgdG8gdW5kZWZpbmVkXG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgQXJyYXkob3V0cHV0cyksICgpID0+IExvZ2ljLnN0YXRlLnVua25vd24pXG4gICAgICAgIH0sIG5hbWUpO1xuXG4gICAgICAgIGlmICh4ICYmIHkpIHtcbiAgICAgICAgICAgIGxldCB0ciA9IG5ldyBlZGl0b3JFbGVtZW50cy5UcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIHRyLnNldFRyYW5zbGF0ZSh4LCB5KTtcblxuICAgICAgICAgICAgdGhpcy5ib3hlc1tpbmRleF0uc3ZnT2JqLmFkZEF0dHIoe1widHJhbnNmb3JtXCI6IHRyLmdldCgpfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFwcGVuZEVsZW1lbnQodGhpcy5ib3hlc1tpbmRleF0sIHJlZnJlc2gpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmJveGVzW2luZGV4XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBjb3JyZWN0IGluc3RhbmNlIG9mIGVkaXRvckVsZW1lbnRzLldpcmUgaW4gdGhlIENhbnZhcycgd2lyZXMgYnkgdGhlIHByb3ZpZGVkIGlkXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB3aXJlSWQgaWQgb2YgdGhlIHdpcmVcbiAgICAgKiBAcmV0dXJuIHtlZGl0b3JFbGVtZW50cy5XaXJlfSBpbnN0YW5jZSBvZiB0aGUgd2lyZVxuICAgICAqL1xuICAgIGdldFdpcmVCeUlkKHdpcmVJZCkge1xuICAgICAgICBmb3IgKGNvbnN0IHdpcmUgb2YgdGhpcy53aXJlcykge1xuICAgICAgICAgICAgaWYgKHdpcmUuc3ZnT2JqLmlkID09PSB3aXJlSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2lyZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgYWxsIHdpcmVzIHRoYXQgYXJlIGNvbm5lY3RlZCB0byB0aGUgc3BlY2lmaWVkIGNvbm5lY3RvclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gY29ubmVjdG9ySWQgaWQgb2YgdGhlIGNvbm5lY3RvclxuICAgICAqIEByZXR1cm4ge1NldH0gc2V0IG9mIElEJ3Mgb2YgdGhlIHdpcmVzIGNvbm5lY3RlZCB0byB0aGlzIGNvbm5lY3RvclxuICAgICAqL1xuICAgIGdldFdpcmVzQnlDb25uZWN0b3JJZChjb25uZWN0b3JJZCkge1xuICAgICAgICBsZXQgY29ubmVjdG9yID0gdGhpcy5nZXRDb25uZWN0b3JCeUlkKGNvbm5lY3RvcklkKTtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rvci53aXJlSWRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB3aXJlIHRoYXQgaGFzIHRoZSBwcm92aWRlZCBJRFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gd2lyZUlkIElEIG9mIHRoZSB3aXJlIHRoYXQgc2hvdWxkIGJlIHJlbW92ZWRcbiAgICAgKi9cbiAgICByZW1vdmVXaXJlQnlJZCh3aXJlSWQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLndpcmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy53aXJlc1tpXS5zdmdPYmouaWQgPT09IHdpcmVJZCkge1xuXG4gICAgICAgICAgICAgICAgbGV0IHtjb25uZWN0b3JzfSA9IHRoaXMud2lyZXNbaV07XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb25uZWN0b3Igb2YgY29ubmVjdG9ycykge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3IucmVtb3ZlV2lyZUlkQW5kVXBkYXRlKHdpcmVJZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgc2ltdWxhdGlvbiBmcm9tIHRoZSBpbnB1dCBjb25uZWN0b3IgdG9cbiAgICAgICAgICAgICAgICAvLyByZWZyZXNoIHRoZSBuZXR3b3JrIGFmdGVyIHRoaXMgd2lyZVxuXG4gICAgICAgICAgICAgICAgbGV0IGlucHV0Q29ubmVjdG9yID0gdGhpcy53aXJlc1tpXS5jb25uZWN0aW9uLnRvLmNvbm5lY3RvcjtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0TmV3U2ltdWxhdGlvbihpbnB1dENvbm5lY3RvciwgaW5wdXRDb25uZWN0b3Iuc3RhdGUpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy53aXJlc1tpXS5zdmdPYmouJGVsLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMud2lyZXMuc3BsaWNlKGksIDEpO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIHdpcmVzIHRoYXQgYXJlIGNvbm5lY3RlZCB0byB0aGUgY29ubmVjdG9yIHByb3ZpZGVkIGJ5IGl0cyBJRFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gY29ubmVjdG9ySWQgSUQgb2YgdGhlIGNvbm5lY3RvclxuICAgICAqL1xuICAgIHJlbW92ZVdpcmVzQnlDb25uZWN0b3JJZChjb25uZWN0b3JJZCkge1xuICAgICAgICBsZXQgY29ubmVjdG9yID0gdGhpcy5nZXRDb25uZWN0b3JCeUlkKGNvbm5lY3RvcklkKTtcblxuICAgICAgICBjb25uZWN0b3Iud2lyZUlkcy5mb3JFYWNoKHdpcmVJZCA9PiB7XG4gICAgICAgICAgICBsZXQgd2lyZSA9IHRoaXMuZ2V0V2lyZUJ5SWQod2lyZUlkKTtcblxuICAgICAgICAgICAgbGV0IHtmcm9tLCB0b30gPSB3aXJlLmNvbm5lY3Rpb247XG5cbiAgICAgICAgICAgIC8vIGdldCB0aGUgb3RoZXIgY29ubmVjdG9yIHRoYXQgaXMgdGhlIHdpcmUgY29ubmVjdGVkIHRvXG4gICAgICAgICAgICBsZXQgb3RoZXJDb25uZWN0b3IgPSBjb25uZWN0b3JJZCA9PT0gZnJvbS5pZFxuICAgICAgICAgICAgICAgID8gdG8uY29ubmVjdG9yXG4gICAgICAgICAgICAgICAgOiBmcm9tLmNvbm5lY3RvcjtcblxuICAgICAgICAgICAgLy8gZGVsZXRlIHRoZSB3aXJlIHJlY29yZCBmcm9tIHRoZSBvdGhlciBjb25uZWN0b3JcbiAgICAgICAgICAgIG90aGVyQ29ubmVjdG9yLndpcmVJZHMuZGVsZXRlKHdpcmVJZCk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgd2lyZSByZXByZXNlbnRhdGlvbiB1c2luZyBqUXVlcnlcbiAgICAgICAgICAgICQoXCIjXCIgKyB3aXJlSWQpLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAvLyBpZiBvdGhlckNvbm5lY3RvciBpcyBhbiBpbnB1dCBjb25uZWN0b3IsIHNldCBpdHMgc3RhdGUgdG8gdW5rbm93blxuICAgICAgICAgICAgaWYgKG90aGVyQ29ubmVjdG9yLmlzSW5wdXRDb25uZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBvdGhlckNvbm5lY3Rvci5zZXRTdGF0ZShMb2dpYy5zdGF0ZS51bmtub3duKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnROZXdTaW11bGF0aW9uKG90aGVyQ29ubmVjdG9yLCBMb2dpYy5zdGF0ZS51bmtub3duKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjbGVhciB0aGUgbGlzdCBvZiB3aXJlIElkc1xuICAgICAgICBjb25uZWN0b3Iud2lyZUlkcy5jbGVhcigpO1xuICAgICAgICAvLyBpZiBjb25uZWN0b3IgaXMgYW4gaW5wdXQgY29ubmVjdG9yLCBzZXQgaXRzIHN0YXRlIHRvIHVua25vd25cbiAgICAgICAgaWYgKGNvbm5lY3Rvci5pc0lucHV0Q29ubmVjdG9yKSB7XG4gICAgICAgICAgICBjb25uZWN0b3Iuc2V0U3RhdGUoTG9naWMuc3RhdGUudW5rbm93bilcbiAgICAgICAgICAgIHRoaXMuc3RhcnROZXdTaW11bGF0aW9uKGNvbm5lY3RvciwgTG9naWMuc3RhdGUudW5rbm93bilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGNvcnJlY3QgaW5zdGFuY2Ugb2YgZWRpdG9yRWxlbWVudHMuQm94IGluIHRoZSBDYW52YXMnIGJveGVzIGJ5IHRoZSBwcm92aWRlZCBpZFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gYm94SWQgaWQgb2YgdGhlIGJveFxuICAgICAqIEByZXR1cm4ge2VkaXRvckVsZW1lbnRzLkJveH0gaW5zdGFuY2Ugb2YgdGhlIGJveFxuICAgICAqL1xuICAgIGdldEJveEJ5SWQoYm94SWQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJveGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ib3hlc1tpXS5zdmdPYmouaWQgPT09IGJveElkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm94ZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBjb3JyZWN0IGluc3RhbmNlIG9mIGVkaXRvckVsZW1lbnRzLkJveCBpbiB0aGUgQ2FudmFzJyBib3hlcyBieSBJRCBvZiBhIGNvbm5lY3RvciB0aGF0IGJlbG9uZ3MgdG8gdGhpcyBib3hcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGJveElkIGlkIG9mIHRoZSBjb25uZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtlZGl0b3JFbGVtZW50cy5Cb3h9IGluc3RhbmNlIG9mIHRoZSBib3hcbiAgICAgKi9cbiAgICBnZXRCb3hCeUNvbm5lY3RvcklkKGNvbm5lY3RvcklkKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYm94ZXNbaV0uZ2V0Q29ubmVjdG9yQnlJZChjb25uZWN0b3JJZCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJveGVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgaW5zdGFuY2Ugb2YgYSBjb25uZWN0b3IgYmFzZWQgb24gaXQncyBJRCAoYW5kIGFsc28gb24gYW4gaW5zdGFuY2Ugb2YgZWRpdG9yRWxlbWVudHMuV2lyZSBpZiBwcm92aWRlZClcbiAgICAgKlxuICAgICAqIFRoZSB3aXJlIHZhcmlhYmxlIGlzIHVzZWQgYXMgaGV1cmlzdGljOiBXaGVuIHdlIGtub3cgdGhlIHdpcmUsIHdlIGhhdmUgdG8gY2hlY2sgb25seVxuICAgICAqIHR3byBnYXRlcyBpbnN0ZWFkIG9mIGFsbCBvZiB0aGVtXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBjb25uZWN0b3JJZCBpZCBvZiB0aGUgY29ubmVjdG9yXG4gICAgICogQHBhcmFtICB7ZWRpdG9yRWxlbWVudHMuV2lyZX0gW3dpcmVdICAgICAgaW5zdGFuY2Ugb2YgdGhlIFdpcmUgdGhhdCBpcyBjb25uZWN0ZWQgdG8gdGhpcyBjb25uZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtlZGl0b3JFbGVtZW50cy5Db25uZWN0b3J9ICAgICAgICBpbnN0YW5jZSBvZiB0aGUgY29ubmVjdG9yXG4gICAgICovXG4gICAgZ2V0Q29ubmVjdG9yQnlJZChjb25uZWN0b3JJZCwgd2lyZSA9IHVuZGVmaW5lZCkge1xuXG4gICAgICAgIGlmICh3aXJlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHdlIGtub3cgdGhlIHdpcmUgLS0gd2UgY2FuIGNoZWNrIG9ubHkgZ2F0ZXMgYXQgdGhlIGVuZHMgb2YgdGhpcyB3aXJlXG4gICAgICAgICAgICBjb25zdCB7ZnJvbSwgdG99ID0gd2lyZS5jb25uZWN0aW9uO1xuXG4gICAgICAgICAgICBpZiAoZnJvbS5pZCA9PT0gY29ubmVjdG9ySWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb20uY29ubmVjdG9yO1xuXG4gICAgICAgICAgICBpZiAodG8uaWQgPT09IGNvbm5lY3RvcklkKVxuICAgICAgICAgICAgICAgIHJldHVybiB0by5jb25uZWN0b3I7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSBkbyBub3Qga25vdyB0aGUgd2lyZSAtLSB3ZSBoYXZlIHRvIGNoZWNrIGFsbCBnYXRlc1xuICAgICAgICAgICAgZm9yIChjb25zdCBib3ggb2YgdGhpcy5ib3hlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RvciA9IGJveC5nZXRDb25uZWN0b3JCeUlkKGNvbm5lY3RvcklkKVxuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3RvclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBnZXRXaXJlQW5jaG9yQnlJZChhbmNob3JJZCkge1xuICAgICAgICBmb3IgKGNvbnN0IHdpcmUgb2YgdGhpcy53aXJlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBhbmNob3Igb2Ygd2lyZS5hbmNob3JzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFuY2hvci5pZD09PWFuY2hvcklkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhbmNob3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsb2dpY2FsIGpRdWVyeSB0YXJnZXQgYmFzZWQgb24gdGhlIGZhY3R1YWwgalF1ZXJ5IHRhcmdldC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBvYmplY3QsIHRoYXQgdXNlciBpbnRlcmFjdGVkIHdpdGgsIGlzIG5vdCBhIGNvbm5lY3RvciBhbmQgaXMgaW4gYSBncm91cCxcbiAgICAgKiByZXR1cm4gdGhlIGdyb3VwIGpRdWVyeSBvYmplY3QgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgalF1ZXJ5IG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHt0YXJnZXR9IHRhcmdldCBqUXVlcnkgdGFyZ2V0IG9mIHRoZSBvYmplY3QgdXNlciBpbnRlcmFjdGVkIHdpdGhcbiAgICAgKiBAcmV0dXJuIHt0YXJnZXR9ICAgICAgICBqUXVlcnkgdGFyZ2V0IG9mIHRoZSBvYmplY3QgdXNlciB3YW50ZWQgdG8gaW50ZXJhY3Qgd2l0aFxuICAgICAqL1xuICAgIGdldFJlYWxKUXVlcnlUYXJnZXQodGFyZ2V0KSB7XG4gICAgICAgIGxldCAkdGFyZ2V0ID0gJCh0YXJnZXQpO1xuICAgICAgICBpZiAoISR0YXJnZXQuaGFzQ2xhc3MoXCJjb25uZWN0b3JcIikgJiYgJHRhcmdldC5wYXJlbnRzKCdnJykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgJHRhcmdldCA9ICR0YXJnZXQucGFyZW50KCk7XG4gICAgICAgICAgICB3aGlsZSAoJHRhcmdldC5wcm9wKFwidGFnTmFtZVwiKSAhPT0gXCJHXCIgJiYgJHRhcmdldC5wcm9wKFwidGFnTmFtZVwiKSAhPT0gXCJnXCIpIHtcbiAgICAgICAgICAgICAgICAkdGFyZ2V0ID0gJHRhcmdldC5wYXJlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHRhcmdldDtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIHRoZSBlZGl0b3JFbGVtZW50IHRoYXQgdXNlciBpbnRlcmFjdGVkIHdpdGgsIHRoZSBcInRhcmdldFwiIGFyZ3VtZW50IGlzIGEgalF1ZXJ5IGVsZW1lbnRcbiAgICAvKipcbiAgICAgKiBHZXQgaW5zdGFuY2Ugb2Ygc29tZSBvYmplY3QgZnJvbSBlZGl0b3JFbGVtZW50IGJhc2VkIG9uIHRoZSBqUXVlcnkgdGFyZ2V0XG4gICAgICogQHBhcmFtICB7dGFyZ2V0fSB0YXJnZXQgalF1ZXJ5IHRhcmdldCB0aGF0IHVzZXIgaW50ZXJhY3RlZCB3aXRoXG4gICAgICogQHJldHVybiB7ZWRpdG9yRWxlbWVudHMuTmV0d29ya0VsZW1lbnR9IGluc3RhbmNlIG9mIGFuIG9iamVjdCBkZXJpdmVkIGZyb20gZWRpdG9yRWxlbWVudHMuTmV0d29ya0VsZW1lbnQgdGhhdCB0aGUgdXNlciBpbnRlcmFjdGVkIHdpdGhcbiAgICAgKi9cbiAgICBnZXRSZWFsVGFyZ2V0KHRhcmdldCkge1xuICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBldmVudHkgc2UgbXVzZWppIHpwcmFjb3ZhdCB0YWR5LCBwcm90b3plIHYgU1ZHIHNlIGV2ZW50eSBuZXByb3BhZ3VqaVxuICAgICAgICBsZXQgJHRhcmdldCA9ICQodGFyZ2V0KTtcblxuICAgICAgICBpZiAoJHRhcmdldC5oYXNDbGFzcyhcImNvbm5lY3RvclwiKSkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBhIGNvbm5lY3RvciwgZG9uJ3QgdHJhdmVyc2UgZ3JvdXBzXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb25uZWN0b3JCeUlkKCR0YXJnZXQuYXR0cignaWQnKSk7XG4gICAgICAgIH0gZWxzZSBpZigkdGFyZ2V0Lmhhc0NsYXNzKFwid2lyZUFuY2hvclwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V2lyZUFuY2hvckJ5SWQoJHRhcmdldC5hdHRyKCdpZCcpKTtcbiAgICAgICAgfSBlbHNlIGlmICgkdGFyZ2V0LnBhcmVudHMoJ2cnKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGVsZW1lbnQgaXMgaW4gYSBncm91cCBhbmQgaXQgaXMgbm90IGEgY29ubmVjdG9yXG5cbiAgICAgICAgICAgIC8vIHRyYXZlcnNpbmcgdXAgdGhlIERPTSB0cmVlIHVudGlsIHdlIGZpbmQgdGhlIGNsb3Nlc3QgZ3JvdXBcbiAgICAgICAgICAgIGxldCAkcGFyZW50R3JvdXAgPSAkdGFyZ2V0LnBhcmVudCgpO1xuICAgICAgICAgICAgd2hpbGUgKCRwYXJlbnRHcm91cC5wcm9wKFwidGFnTmFtZVwiKSAhPT0gXCJHXCIgJiYgJHBhcmVudEdyb3VwLnByb3AoXCJ0YWdOYW1lXCIpICE9PSBcImdcIikge1xuICAgICAgICAgICAgICAgICRwYXJlbnRHcm91cCA9ICRwYXJlbnRHcm91cC5wYXJlbnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdHJ5IHRvIG1hdGNoIHRoZSBqUXVlcnkgZWxlbWVudCB0byB0aGUgbG9naWNhbCBlbGVtZW50IHVzaW5nIERPTSBjbGFzc2VzXG5cbiAgICAgICAgICAgIGlmICgkcGFyZW50R3JvdXAuaGFzQ2xhc3MoXCJib3hcIikpIHtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgYm94XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Qm94QnlJZCgkcGFyZW50R3JvdXAuYXR0cignaWQnKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCRwYXJlbnRHcm91cC5oYXNDbGFzcyhcIndpcmVcIikpIHtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgd2lyZVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFdpcmVCeUlkKCRwYXJlbnRHcm91cC5hdHRyKCdpZCcpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZm91bmQgYSBncm91cCB0aGF0IGNvbnRhaW5zIHRoZSB0YXJnZXQsIGJ1dCB0aGlzIGdyb3VwIGRvZXMgbm90IG1hdGNoIGFueSBrbm93biBlbGVtZW50IHR5cGVzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgZG9lcyBub3QgbWF0Y2ggYW55IGtub3duIGVsZW1lbnQgdHlwZXNcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gZWxlbWVudCB0byB0aGUgQ2FudmFzXG4gICAgICogQHBhcmFtICB7ZWRpdG9yRWxlbWVudHMuTmV0d29ya0VsZW1lbnR9ICBlbGVtZW50IEVsZW1lbnQgdGhhdCB3aWxsIGJlIGFkZGVkIG9uIHRoZSBDYW52YXNcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBbcmVmcmVzaD10cnVlXSBpZiB0cnVlLCB0aGUgU1ZHIGRvY3VtZW50IHdpbGwgYmUgcmVsb2FkZWQgYWZ0ZXIgYWRkaW5nIHRoaXMgZWxlbWVudFxuICAgICAqL1xuICAgIGFwcGVuZEVsZW1lbnQoZWxlbWVudCwgcmVmcmVzaCA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRKUXVlcnlPYmplY3QoZWxlbWVudC5nZXQoKSwgcmVmcmVzaCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwZW5kIGEgalF1ZXJ5IGVsZW1lbnQgdG8gdGhlIFNWRyBkb2N1bWVudCAoaGVscGVyIGZvciB0aGlzLmFwcGVuZEVsZW1lbnQpXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgb2JqZWN0ICAgICAgICAgalF1ZXJ5IGVsZW1lbnQgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBTVkcgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBbcmVmcmVzaD10cnVlXSBpZiB0cnVlLCB0aGUgU1ZHIGRvY3VtZW50IHdpbGwgYmUgcmVsb2FkZWQgYWZ0ZXIgYWRkaW5nIHRoaXMgZWxlbWVudFxuICAgICAqL1xuICAgIGFwcGVuZEpRdWVyeU9iamVjdChvYmplY3QsIHJlZnJlc2ggPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuJHN2Zy5hcHBlbmQob2JqZWN0KTtcbiAgICAgICAgaWYgKHJlZnJlc2gpXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgbmV3IHBhdHRlcm4gdG8gdGhlIGRlZmluaXRpb25zIGVsZW1lbnQgaW4gdGhlIFNWRyBkb2N1bWVudFxuICAgICAqIEBwYXJhbSB7c3ZnT2JqLlBhdHRlcm59IHBhdHRlcm4gcGF0dGVybiB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIDxkZXZzPiBlbGVtZW50IGluIHRoZSBTVkcgZG9jdW1lbnRcbiAgICAgKi9cbiAgICBhZGRQYXR0ZXJuKHBhdHRlcm4pIHtcbiAgICAgICAgdGhpcy4kZGVmcy5hcHBlbmQocGF0dGVybik7XG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbG9hZCB0aGUgU1ZHIGRvY3VtZW50IChuZWVkZWQgdG8gZGlzcGxheSBhIG5ld2x5IGFwcGVuZGVkIGpRdWVyeSBvYmplY3QpXG4gICAgICovXG4gICAgcmVmcmVzaCgpIHtcbiAgICAgICAgdGhpcy4kc3ZnLmh0bWwodGhpcy4kc3ZnLmh0bWwoKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiU1ZHIGRvY3VtZW50IGhhcyBiZWVuIHJlbG9hZGVkLlwiKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc3BsYXkgdGhlIGNvbnRleHQgbWVudSBvbiB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB4ICAgICAgIGhvcml6b250YWwgcG9zaXRpb24gaW4gQ1NTIHBpeGVsc1xuICAgICAqIEBwYXJhbSAge251bWJlcn0geSAgICAgICB2ZXJ0aWNhbCBwb3NpdGlvbiBpbiBDU1MgcGl4ZWxzXG4gICAgICogQHBhcmFtICB7alF1ZXJ5LmVsZW1lbnR9ICR0YXJnZXQgdGhlIGl0ZW0gdXNlciBjbGlja2VkIG9uICh1c2VkIHRvIGRpc3BsYXkgXCJyZW1vdmUgdGhpcyBlbGVtZW50XCItdHlwZSBpdGVtcyBpbiB0aGUgbWVudSlcbiAgICAgKi9cbiAgICBkaXNwbGF5Q29udGV4dE1lbnUoeCwgeSwgJHRhcmdldCkge1xuICAgICAgICB0aGlzLmNvbnRleHRNZW51LmRpc3BsYXkoeCwgeSwgJHRhcmdldCk7XG5cbiAgICAgICAgLy8gaWYgdHV0b3JpYWwgZXhpc3RzLCBjYWxsIHR1dG9yaWFsIGNhbGxiYWNrXG4gICAgICAgIGlmICh0aGlzLnR1dG9yaWFsKSB7XG4gICAgICAgICAgICB0aGlzLnR1dG9yaWFsLm9uQ29udGV4dE1lbnVPcGVuZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGhpZGUgdGhlIGNvbnRleHQgbWVudVxuICAgICAqL1xuICAgIGhpZGVDb250ZXh0TWVudSgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0TWVudS5oaWRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc25hcCBhIHZhbHVlIHRvIGEgZ3JpZFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdmFsdWUgdmFsdWUgaW4gU1ZHIHBpeGVsc1xuICAgICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgdGhlIHZhbHVlIHJvdW5kZWQgdG8gdGhlIGNsb3Nlc3QgbnVtYmVyIGRpdmlzaWJsZSBieSB0aGUgZ3JpZCBzaXplXG4gICAgICovXG4gICAgc25hcFRvR3JpZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAvIHRoaXMuZ3JpZFNpemUpICogdGhpcy5ncmlkU2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0IGdyaWQgcGl4ZWxzIHRvIFNWRyBwaXhlbHNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlIGRpc3RhbmNlIGluIGdyaWQgcGl4ZWxzXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICBkaXN0YW5jZSBpbiBTVkcgcGl4ZWxzXG4gICAgICovXG4gICAgZ3JpZFRvU1ZHKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAqIHRoaXMuZ3JpZFNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29udmVydCBTVkcgcGl4ZWxzIHRvIGdyaWQgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIGRpc3RhbmNlIGluIFNWRyBwaXhlbHNcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgZGlzdGFuY2UgaW4gZ3J1ZCBwaXhlbHNcbiAgICAgKi9cbiAgICBTVkdUb0dyaWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIC8gdGhpcy5ncmlkU2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzdGF0aWMgZnVuY3Rpb24gZm9yIHNuYXBwaW5nIGEgdmFsdWUgdG8gYSBncmlkXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB2YWx1ZSB2YWx1ZSBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBncmlkU2l6ZSBzaXplIG9mIHRoZSBncmlkIGluIFNWRyBwaXhlbHNcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgIHRoZSB2YWx1ZSByb3VuZGVkIHRvIHRoZSBjbG9zZXN0IG51bWJlciBkaXZpc2libGUgYnkgdGhlIGdyaWQgc2l6ZVxuICAgICAqL1xuICAgIHN0YXRpYyBzbmFwVG9HcmlkKHZhbHVlLCBncmlkU2l6ZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAvIGdyaWRTaXplKSAqIGdyaWRTaXplO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG1vdmUgYW4gZWxlbWVudCB0byB0aGUgZnJvbnQgaW4gdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSAge3N0cmluZ30gb2JqSWQgaWQgb2YgdGhlIGVsZW1lbnRcbiAgICAgKi9cbiAgICBtb3ZlVG9Gcm9udEJ5SWQob2JqSWQpIHtcbiAgICAgICAgdGhpcy4kc3ZnLmFwcGVuZCgkKFwiI1wiICsgb2JqSWQpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtb3ZlIGFuIGVsZW1lbnQgdG8gdGhlIGJhY2sgaW4gdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSAge3N0cmluZ30gb2JqSWQgaWQgb2YgdGhlIGVsZW1lbnRcbiAgICAgKi9cbiAgICBtb3ZlVG9CYWNrQnlJZChvYmpJZCkge1xuICAgICAgICAkKFwiI1wiICsgdGhpcy5iYWNrZ3JvdW5kLmlkKS5hZnRlcigkKFwiI1wiICsgb2JqSWQpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgc2V0IG9mIG5vZGVzLCB0aGF0IGNhbm5vdCBiZSB1c2VkIGZvciB3aXJpbmcgYXQgYW55IGNpcmN1bXN0YW5jZXNcbiAgICAgKiBAcmV0dXJuIHtTZXR9IHNldCBvZiBub2RlcyAob2JqZWN0cyBjb250YWluaW5nIHggYW5kIHkgY29vcmRpbmF0ZXMpIHRoYXQgYXJlIG5vdCBzdWl0YWJsZSBmb3Igd2lyaW5nXG4gICAgICovXG4gICAgZ2V0Tm9uUm91dGFibGVOb2RlcygpIHtcbiAgICAgICAgbGV0IGJsb2NrZWROb2RlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLy8gZm9yIGVhY2ggYm94XG4gICAgICAgIGZvciAoY29uc3QgYm94IG9mIHRoaXMuYm94ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZSA9IGJveC5nZXRHcmlkUGl4ZWxUcmFuc2Zvcm0oKS5nZXRUcmFuc2xhdGUoKTtcblxuICAgICAgICAgICAgLy8gZm9yIGVhY2ggaXRlbSBpbiBibG9ja2VkTm9kZXMgKHNldCBvZiBibG9ja2VkIG5vZGVzIHdpdGggY29vcmRpbmF0ZXMgcmVsYXRpdmVcbiAgICAgICAgICAgIC8vIHRvIHRoZSBsZWZ0IHVwcGVyIGNvcm5lciBvZiByZWN0OyB1bml0IHVzZWQgaXMgXCJvbmUgZ3JpZFNpemVcIikgY29udmVydCB0aGUgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgIC8vIHRvIGFic29sdXRlIChtdWx0aXBsZSB3aXRoIGdyaWRTaXplIGFuZCBhZGQgcG9zaXRpb24gb2YgcmVjdCkgYW5kIGFkZCB0aGUgcmVzdWx0IHRvIHRoZSBzZXRcbiAgICAgICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBib3guYmxvY2tlZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgYmxvY2tlZE5vZGVzLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgIHg6IHRyYW5zbGF0ZS54ICsgbm9kZS54LFxuICAgICAgICAgICAgICAgICAgICB5OiB0cmFuc2xhdGUueSArIG5vZGUueVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRk9SIERFQlVHIE9OTFk6IGRpc3BsYXkgdGhlIG5vbiByb3V0YWJsZSBub2Rlc1xuICAgICAgICAvKlxuXG4gICAgICAgIGlmKHRoaXMubm9kZURpc3BsYXkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVjdGFuZ2xlSWQgb2YgdGhpcy5ub2RlRGlzcGxheSkge1xuICAgICAgICAgICAgICAgICQoYCMke3JlY3RhbmdsZUlkfWApLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ub2RlRGlzcGxheSA9IFtdO1xuXG4gICAgICAgIGxldCBmaXJzdCA9IHRydWU7XG5cbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGJsb2NrZWROb2Rlcykge1xuICAgICAgICAgICAgY29uc3QgeCA9IHRoaXMuZ3JpZFRvU1ZHKG5vZGUueCk7XG4gICAgICAgICAgICBjb25zdCB5ID0gdGhpcy5ncmlkVG9TVkcobm9kZS55KTtcblxuICAgICAgICAgICAgY29uc3QgdyA9IDQ7XG4gICAgICAgICAgICBjb25zdCBwID0gdyAvIDI7XG5cbiAgICAgICAgICAgIGNvbnN0IG5vZGVSZWN0YW5nbGUgPSBuZXcgUmVjdGFuZ2xlKHggLSBwLCB5IC0gcCwgdywgdywgZmlyc3QgPyBcImJsdWVcIiA6IFwicmVkXCIsIFwibm9uZVwiKVxuICAgICAgICAgICAgdGhpcy5ub2RlRGlzcGxheS5wdXNoKG5vZGVSZWN0YW5nbGUuaWQpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRFbGVtZW50KG5vZGVSZWN0YW5nbGUsIGZhbHNlKTtcblxuICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xuXG4gICAgICAgICovXG4gICAgICAgIC8vIEVORCBGT1IgREVCVUcgT05MWVxuXG4gICAgICAgIC8vIHJldHVybiB0aGUgc2V0XG4gICAgICAgIHJldHVybiBibG9ja2VkTm9kZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHNldCBvZiBub2RlcywgdGhhdCBhcmUgaW5jb252ZW5pZW50IGZvciB3aXJpbmcsIGJ1dCBjYW4gYmUgdXNlZCwganVzdCBhcmUgbm90IHByZWZlcnJlZFxuICAgICAqIEByZXR1cm4ge1NldH0gc2V0IG9mIG5vZGVzIChvYmplY3RzIGNvbnRhaW5pbmcgeCBhbmQgeSBjb29yZGluYXRlcykgdGhhdCBhcmUgbm90IHByZWZlcnJlZCBmb3Igd2lyaW5nXG4gICAgICovXG4gICAgZ2V0SW5jb252ZW5pZW50Tm9kZXMoaWdub3JlV2lyZUlkKSB7XG4gICAgICAgIGxldCBpbmNvbnZlbmllbnROb2RlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLy8gZm9yIGVhY2ggd2lyZVxuXG4gICAgICAgIGZvciAoY29uc3Qgd2lyZSBvZiB0aGlzLndpcmVzKSB7XG4gICAgICAgICAgICBpZiAoaWdub3JlV2lyZUlkID09PSB1bmRlZmluZWQgfHwgaWdub3JlV2lyZUlkICE9PSB3aXJlLmlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdpcmUuaW5jb252ZW5pZW50Tm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHdpcmUuaW5jb252ZW5pZW50Tm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY29udmVuaWVudE5vZGVzLmFkZChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZPUiBERUJVRyBPTkxZOiBkaXNwbGF5IHRoZSBpbmNvbnZlbmllbnQgbm9kZXNcbiAgICAgICAgLypcblxuICAgICAgICBpZih0aGlzLmluY29udmVuaWVudE5vZGVEaXNwbGF5KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlY3RhbmdsZUlkIG9mIHRoaXMuaW5jb252ZW5pZW50Tm9kZURpc3BsYXkpIHtcbiAgICAgICAgICAgICAgICAkKGAjJHtyZWN0YW5nbGVJZH1gKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5jb252ZW5pZW50Tm9kZURpc3BsYXkgPSBbXTtcblxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgaW5jb252ZW5pZW50Tm9kZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLmdyaWRUb1NWRyhub2RlLngpO1xuICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMuZ3JpZFRvU1ZHKG5vZGUueSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHcgPSA0O1xuICAgICAgICAgICAgY29uc3QgcCA9IHcgLyAyO1xuXG4gICAgICAgICAgICBjb25zdCBub2RlUmVjdGFuZ2xlID0gbmV3IFJlY3RhbmdsZSh4IC0gcCwgeSAtIHAsIHcsIHcsIFwib3JhbmdlXCIsIFwibm9uZVwiKVxuICAgICAgICAgICAgdGhpcy5pbmNvbnZlbmllbnROb2RlRGlzcGxheS5wdXNoKG5vZGVSZWN0YW5nbGUuaWQpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRFbGVtZW50KG5vZGVSZWN0YW5nbGUsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xuXG4gICAgICAgICovXG4gICAgICAgIC8vIEVORCBGT1IgREVCVUcgT05MWVxuXG4gICAgICAgIC8vIHJldHVybiB0aGUgc2V0XG4gICAgICAgIHJldHVybiBpbmNvbnZlbmllbnROb2RlcztcbiAgICB9XG59XG4iLCIvKiogQG1vZHVsZSBMb2dpYyAqL1xuLyoqXG4gKiBkZWZpbml0aW9ucyBvZiBsb2dpYyBzdGF0ZXMgYW5kIGJhc2ljIGxvZ2ljIGZ1bmN0aW9ucyB1c2VkIGluIHRoZSBzaW11bGF0aW9uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvZ2ljIHtcbiAgICAvKipcbiAgICAgKiBFbnVtIGZvciBsb2dpYyBzdGF0ZXMuXG4gICAgICpcbiAgICAgKiBTdGF0ZXM6XG4gICAgICogLSBgdW5rbm93bmBcbiAgICAgKiAtIGBvbmBcbiAgICAgKiAtIGBvZmZgXG4gICAgICogLSBgb3NjaWxsYXRpbmdgXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdW5rbm93bjogMCxcbiAgICAgICAgICAgIG9uOiAxLFxuICAgICAgICAgICAgb2ZmOiAyLFxuICAgICAgICAgICAgb3NjaWxsYXRpbmc6IDNcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGxpc3Qgb2YgYWxsIHN0YXRlcyB0aGF0IGNhbiBiZSB1c2VkIGluIHRoZSBzaW11bGF0aW9uXG4gICAgICpcbiAgICAgKiBUaGlzIGdldHRlciBpdGVyYXRlcyBvdmVyIExvZ2ljLnN0YXRlIGFuZCByZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIHZhbHVlcyBvZiBMb2dpYy5zdGF0ZSdzIG1lbWJlcnNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgc3RhdGljIGdldCBzdGF0ZUxpc3QoKSB7XG4gICAgICAgIGxldCBzdGF0ZXMgPSBbXTtcblxuICAgICAgICAvLyBpdGVyYXRlIG92ZXIgYWxsIGRlZmluZWQgc3RhdGVzIGFuZCBhZGQgdGhlaXIgdmFsdWVzIHRvIHRoZSBzdGF0ZXMgYXJyYXlcbiAgICAgICAgT2JqZWN0LmtleXMoTG9naWMuc3RhdGUpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIHN0YXRlcy5wdXNoKExvZ2ljLnN0YXRlW2tleV0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc3RhdGVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvZ2ljIEFORFxuICAgICAqIEBwYXJhbSAge0xvZ2ljLnN0YXRlfSBhIGZpcnN0IGlucHV0IHN0YXRlXG4gICAgICogQHBhcmFtICB7TG9naWMuc3RhdGV9IGIgc2Vjb25kIGlucHV0IHN0YXRlXG4gICAgICogQHJldHVybiB7TG9naWMuc3RhdGV9ICAgb3V0cHV0IHN0YXRlXG4gICAgICovXG4gICAgc3RhdGljIGFuZChhLCBiKSB7XG4gICAgICAgIHJldHVybiBMb2dpYy5ydW5TeW1tZXRyaWNSdWxlcyhhLCBiLCBbXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUub24sIExvZ2ljLnN0YXRlLm9uLCBMb2dpYy5zdGF0ZS5vbl0sXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUub24sIExvZ2ljLnN0YXRlLm9mZiwgTG9naWMuc3RhdGUub2ZmXSxcbiAgICAgICAgICAgIFtMb2dpYy5zdGF0ZS5vbiwgTG9naWMuc3RhdGUudW5rbm93biwgTG9naWMuc3RhdGUudW5rbm93bl0sXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUub24sIExvZ2ljLnN0YXRlLm9zY2lsbGF0aW5nLCBMb2dpYy5zdGF0ZS5vc2NpbGxhdGluZ10sXG5cbiAgICAgICAgICAgIFtMb2dpYy5zdGF0ZS5vZmYsIExvZ2ljLnN0YXRlLm9mZiwgTG9naWMuc3RhdGUub2ZmXSxcbiAgICAgICAgICAgIFtMb2dpYy5zdGF0ZS5vZmYsIExvZ2ljLnN0YXRlLnVua25vd24sIExvZ2ljLnN0YXRlLm9mZl0sXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUub2ZmLCBMb2dpYy5zdGF0ZS5vc2NpbGxhdGluZywgTG9naWMuc3RhdGUub2ZmXSxcblxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLnVua25vd24sIExvZ2ljLnN0YXRlLnVua25vd24sIExvZ2ljLnN0YXRlLnVua25vd25dLFxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLnVua25vd24sIExvZ2ljLnN0YXRlLm9zY2lsbGF0aW5nLCBMb2dpYy5zdGF0ZS51bmtub3duXSxcblxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLm9zY2lsbGF0aW5nLCBMb2dpYy5zdGF0ZS5vc2NpbGxhdGluZywgTG9naWMuc3RhdGUub3NjaWxsYXRpbmddXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dpYyBOQU5EXG4gICAgICogQHBhcmFtICB7TG9naWMuc3RhdGV9IGEgZmlyc3QgaW5wdXQgc3RhdGVcbiAgICAgKiBAcGFyYW0gIHtMb2dpYy5zdGF0ZX0gYiBzZWNvbmQgaW5wdXQgc3RhdGVcbiAgICAgKiBAcmV0dXJuIHtMb2dpYy5zdGF0ZX0gICBvdXRwdXQgc3RhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgbmFuZChhLCBiKSB7XG4gICAgICAgIHJldHVybiBMb2dpYy5ub3QoTG9naWMuYW5kKGEsIGIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2dpYyBOT1JcbiAgICAgKiBAcGFyYW0gIHtMb2dpYy5zdGF0ZX0gYSBmaXJzdCBpbnB1dCBzdGF0ZVxuICAgICAqIEBwYXJhbSAge0xvZ2ljLnN0YXRlfSBiIHNlY29uZCBpbnB1dCBzdGF0ZVxuICAgICAqIEByZXR1cm4ge0xvZ2ljLnN0YXRlfSAgIG91dHB1dCBzdGF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBub3IoYSwgYikge1xuICAgICAgICByZXR1cm4gTG9naWMubm90KExvZ2ljLm9yKGEsIGIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2dpYyBOT1RcbiAgICAgKiBAcGFyYW0gIHtMb2dpYy5zdGF0ZX0gYSBmaXJzdCBpbnB1dCBzdGF0ZVxuICAgICAqIEByZXR1cm4ge0xvZ2ljLnN0YXRlfSAgIG91dHB1dCBzdGF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBub3QoYSkge1xuICAgICAgICBpZihhID09PSBMb2dpYy5zdGF0ZS5vbikge1xuICAgICAgICAgICAgcmV0dXJuIExvZ2ljLnN0YXRlLm9mZjtcbiAgICAgICAgfSBlbHNlIGlmIChhID09PSBMb2dpYy5zdGF0ZS5vZmYpIHtcbiAgICAgICAgICAgIHJldHVybiBMb2dpYy5zdGF0ZS5vbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9naWMgT1JcbiAgICAgKiBAcGFyYW0gIHtMb2dpYy5zdGF0ZX0gYSBmaXJzdCBpbnB1dCBzdGF0ZVxuICAgICAqIEBwYXJhbSAge0xvZ2ljLnN0YXRlfSBiIHNlY29uZCBpbnB1dCBzdGF0ZVxuICAgICAqIEByZXR1cm4ge0xvZ2ljLnN0YXRlfSAgIG91dHB1dCBzdGF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBvcihhLCBiKSB7XG4gICAgICAgIHJldHVybiBMb2dpYy5ydW5TeW1tZXRyaWNSdWxlcyhhLCBiLCBbXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUub24sIExvZ2ljLnN0YXRlLm9uLCBMb2dpYy5zdGF0ZS5vbl0sXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUub24sIExvZ2ljLnN0YXRlLm9mZiwgTG9naWMuc3RhdGUub25dLFxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLm9uLCBMb2dpYy5zdGF0ZS51bmtub3duLCBMb2dpYy5zdGF0ZS5vbl0sXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUub24sIExvZ2ljLnN0YXRlLm9zY2lsbGF0aW5nLCBMb2dpYy5zdGF0ZS5vbl0sXG5cbiAgICAgICAgICAgIFtMb2dpYy5zdGF0ZS5vZmYsIExvZ2ljLnN0YXRlLm9mZiwgTG9naWMuc3RhdGUub2ZmXSxcbiAgICAgICAgICAgIFtMb2dpYy5zdGF0ZS5vZmYsIExvZ2ljLnN0YXRlLnVua25vd24sIExvZ2ljLnN0YXRlLnVua25vd25dLFxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLm9mZiwgTG9naWMuc3RhdGUub3NjaWxsYXRpbmcsIExvZ2ljLnN0YXRlLm9zY2lsbGF0aW5nXSxcblxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLnVua25vd24sIExvZ2ljLnN0YXRlLnVua25vd24sIExvZ2ljLnN0YXRlLnVua25vd25dLFxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLnVua25vd24sIExvZ2ljLnN0YXRlLm9zY2lsbGF0aW5nLCBMb2dpYy5zdGF0ZS51bmtub3duXSxcblxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLm9zY2lsbGF0aW5nLCBMb2dpYy5zdGF0ZS5vc2NpbGxhdGluZywgTG9naWMuc3RhdGUub3NjaWxsYXRpbmddXG4gICAgICAgIF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvZ2ljIFhOT1JcbiAgICAgKiBAcGFyYW0gIHtMb2dpYy5zdGF0ZX0gYSBmaXJzdCBpbnB1dCBzdGF0ZVxuICAgICAqIEBwYXJhbSAge0xvZ2ljLnN0YXRlfSBiIHNlY29uZCBpbnB1dCBzdGF0ZVxuICAgICAqIEByZXR1cm4ge0xvZ2ljLnN0YXRlfSAgIG91dHB1dCBzdGF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyB4bm9yKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIExvZ2ljLm5vdChMb2dpYy54b3IoYSwgYikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvZ2ljIFhPUlxuICAgICAqIEBwYXJhbSAge0xvZ2ljLnN0YXRlfSBhIGZpcnN0IGlucHV0IHN0YXRlXG4gICAgICogQHBhcmFtICB7TG9naWMuc3RhdGV9IGIgc2Vjb25kIGlucHV0IHN0YXRlXG4gICAgICogQHJldHVybiB7TG9naWMuc3RhdGV9ICAgb3V0cHV0IHN0YXRlXG4gICAgICovXG4gICAgc3RhdGljIHhvcihhLCBiKSB7XG4gICAgICAgIHJldHVybiBMb2dpYy5ydW5TeW1tZXRyaWNSdWxlcyhhLCBiLCBbXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUub24sIExvZ2ljLnN0YXRlLm9uLCBMb2dpYy5zdGF0ZS5vZmZdLFxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLm9uLCBMb2dpYy5zdGF0ZS5vZmYsIExvZ2ljLnN0YXRlLm9uXSxcbiAgICAgICAgICAgIFtMb2dpYy5zdGF0ZS5vbiwgTG9naWMuc3RhdGUudW5rbm93biwgTG9naWMuc3RhdGUudW5rbm93bl0sXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUub24sIExvZ2ljLnN0YXRlLm9zY2lsbGF0aW5nLCBMb2dpYy5zdGF0ZS5vc2NpbGxhdGluZ10sXG5cbiAgICAgICAgICAgIFtMb2dpYy5zdGF0ZS5vZmYsIExvZ2ljLnN0YXRlLm9mZiwgTG9naWMuc3RhdGUub2ZmXSxcbiAgICAgICAgICAgIFtMb2dpYy5zdGF0ZS5vZmYsIExvZ2ljLnN0YXRlLnVua25vd24sIExvZ2ljLnN0YXRlLnVua25vd25dLFxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLm9mZiwgTG9naWMuc3RhdGUub3NjaWxsYXRpbmcsIExvZ2ljLnN0YXRlLm9zY2lsbGF0aW5nXSxcblxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLnVua25vd24sIExvZ2ljLnN0YXRlLnVua25vd24sIExvZ2ljLnN0YXRlLnVua25vd25dLFxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLnVua25vd24sIExvZ2ljLnN0YXRlLm9zY2lsbGF0aW5nLCBMb2dpYy5zdGF0ZS51bmtub3duXSxcblxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLm9zY2lsbGF0aW5nLCBMb2dpYy5zdGF0ZS5vc2NpbGxhdGluZywgTG9naWMuc3RhdGUub3NjaWxsYXRpbmddXG4gICAgICAgIF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBjb3JyZWN0IHJ1bGUgaW4gdGhlIGFycmF5IG9mIHJ1bGVzIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJldHVybiB2YWx1ZS5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGV4cGVjdHMgcnVsZXMgdG8gYmUgc3ltbWV0cmljIChzbyBgYSBSVUxFIGJgIHNob3VsZCByZXR1cm5zIHRoZSBzYW1lIHZhbHVlIGFzIGBiIFJVTEUgYWApLFxuICAgICAqIHdoaWNoIGFsbG93cyB0byBjdXQgZG93biBvbiB0aGUgYHJ1bGVzYCBhcnJheSBxdWl0ZSBhIGJpdFxuICAgICAqIEBwYXJhbSAge0xvZ2ljLnN0YXRlfSBhICAgICBmaXJzdCBpbnB1dCBzdGF0ZVxuICAgICAqIEBwYXJhbSAge0xvZ2ljLnN0YXRlfSBiICAgICBzZWNvbmQgaW5wdXQgc3RhdGVcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcnVsZXMgICAgICAgQXJyYXkgb2YgYXJyYXlzLiBFYWNoIGlubmVyIGFycmF5IHJlcHJlc2VudHMgYSBydWxlIGluIHRoZSBmb3JtYXQgW2lucHV0MSwgaW5wdXQyLCBvdXRwdXRdLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZnVuY3Rpb24gZmluZHMgYW4gYXJyYXksIHdoZXJlIGBhID09PSBpbnB1dDFgIGFuZCBgYiA9PT0gaW5wdXQxYCAob3IgYGEgPT09IGlucHV0MmAgYW5kIGBiID09PSBpbnB1dDFgKVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgcmV0dXJucyBgb3V0cHV0YCBmcm9tIHRoaXMgYXJyYXkuXG4gICAgICogQHJldHVybiB7TG9naWMuc3RhdGV9ICAgICAgIG91dHB1dCBzdGF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBydW5TeW1tZXRyaWNSdWxlcyhhLCBiLCBydWxlcykge1xuICAgICAgICAvLyBpdGVyYXRlIHRocm91Z2ggYWxsIHRoZSBydWxlc1xuICAgICAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgcnVsZXMpIHtcbiAgICAgICAgICAgIGlmICgocnVsZVswXSA9PT0gYSAmJiBydWxlWzFdID09PSBiKSB8fCAocnVsZVswXSA9PT0gYiAmJiBydWxlWzFdID09PSBhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBydWxlWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbm8gcnVsZSBtYXRjaGVzLCB0aGUgb3V0cHV0IHN0YXRlIGlzIHVua25vd25cbiAgICAgICAgcmV0dXJuIExvZ2ljLnN0YXRlLnVua25vd247XG4gICAgfVxufVxuIiwiaW1wb3J0IExvZ2ljIGZyb20gJy4vTG9naWMnXG5cbi8qKlxuICogQG1vZHVsZSBTaW11bGF0aW9uXG4gKi9cblxuXG5jbGFzcyBzdGF0ZUNoYW5nZSB7XG4gICAgY29uc3RydWN0b3IoY29ubmVjdG9ySWQsIHN0YXRlLCB3aG9DYXVzZWRJdCkge1xuICAgICAgICB0aGlzLmNvbm5lY3RvcklkID0gY29ubmVjdG9ySWRcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlXG4gICAgICAgIHRoaXMud2hvQ2F1c2VkSXQgPSB3aG9DYXVzZWRJdFxuICAgIH1cbn1cblxuLyoqXG4gKiBUaGlzIGNsYXNzIHJ1bnMgdGhlIG5ldHdvcmsgc2ltdWxhdGlvbi5cbiAqXG4gKiBfbm90ZTogYWxsIGNvbm5lY3RvcnMgdGhhdCBhcmUgdXNlZCBpbiB0aGlzIGNsYXNzIGFyZSAqKm91dHB1dCBjb25uZWN0b3JzKipfXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNpbXVsYXRpb24ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzfSBwYXJlbnRTVkcgaW5zdGFuY2Ugb2YgW0NhbnZhc10oLi9tb2R1bGUtQ2FudmFzLmh0bWwpXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGFyZW50U1ZHKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpbnN0YW5jZSBvZiBDYW52YXMgdGhpcyBTaW11bGF0aW9uIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHR5cGUge0NhbnZhc31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFyZW50U1ZHID0gcGFyZW50U1ZHXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1hcHMgZWFjaCBhZmZlY3RlZCBvdXRwdXQgY29ubmVjdG9yIHRvIGl0J3MgZGlyZWN0bHkgcHJlY2VlZGluZyBvdXRwdXQgY29ubmVjdG9yc1xuICAgICAgICAgKiBAdHlwZSB7TWFwfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmVkZWNlc3NvcnMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1hcHMgd2F2ZUlkIHRvIGFuIGFycmF5IG9mIGFmZmVjdGVkIG91dHB1dENvbm5lY3RvcnNcbiAgICAgICAgICogQHR5cGUge01hcH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMud2F2ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMud2F2ZSA9IDBcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWFwcyBjeWNsZWQgY29ubmVjdG9yIGlkIHRvIHNldCBvZiBzdGF0ZXMgdGhpcyBjb25uZWN0b3Igd2FzIGluXG4gICAgICAgICAqIEB0eXBlIHtNYXB9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN5Y2xlZENvbm5lY3RvcnMgPSBuZXcgTWFwKClcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IG9mIGN5Y2xlZCBjb25uZWN0b3JzIHRoYXQgaGF2ZSBiZWVuIGFscmVhZHkgcmVzb2x2ZWRcbiAgICAgICAgICogQHR5cGUge1NldH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzb2x2ZWRDeWNsZWRDb25uZWN0b3JzID0gbmV3IFNldCgpXG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBydW4gdGhlIHNpbXVsYXRpb25cbiAgICAgKi9cbiAgICBydW4oKSB7XG4gICAgICAgIHRoaXMud2F2ZSsrO1xuICAgICAgICB3aGlsZSh0aGlzLndhdmVzLmhhcyh0aGlzLndhdmUpKSB7XG4gICAgICAgICAgICB0aGlzLnN0ZXAoKVxuICAgICAgICAgICAgdGhpcy53YXZlcy5kZWxldGUodGhpcy53YXZlKSAvLyBjbGVhbiBvbGQgd2F2ZXMgb24gdGhlIGdvXG4gICAgICAgICAgICB0aGlzLndhdmUrK1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogb25lIHN0ZXAvd2F2ZSBvZiB0aGUgc2ltdWxhdGlvblxuICAgICAqXG4gICAgICogZGV0ZXJtaW5lcyBzdGF0ZXMgb2YgdGhlIGNvbm5lY3RvcnMgaW4gdGhlIGN1cnJlbnQgd2F2ZSwgZGV0ZWN0cyBjeWNsZXNcbiAgICAgKi9cbiAgICBzdGVwKCkge1xuICAgICAgICBmb3IgKGxldCB7Y29ubmVjdG9ySWQsIHN0YXRlLCB3aG9DYXVzZWRJdH0gb2YgdGhpcy53YXZlcy5nZXQodGhpcy53YXZlKSkge1xuICAgICAgICAgICAgLy8gc2tpcCByZXNvbHZlZCBjeWNsZXNcbiAgICAgICAgICAgIGlmKHRoaXMucmVzb2x2ZWRDeWNsZWRDb25uZWN0b3JzLmhhcyhjb25uZWN0b3JJZCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBza2lwIGNvbm5lY3RvciB0aGF0IGFyZSBjeWNsZXNcbiAgICAgICAgICAgIGlmICh0aGlzLmN5Y2xlZENvbm5lY3RvcnMuaGFzKGNvbm5lY3RvcklkKSkge1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgc2V0IG9mIHN0YXRlcyB0aGF0IHRoaXMgY29ubmVjdG9yIGFwcGVhcmVkIGZyb20gdGhlIG1vbWVudCB0aGUgc2lnbmFsIGZpcnN0IGN5Y2xlZFxuICAgICAgICAgICAgICAgIGxldCBzdGF0ZXMgPSB0aGlzLmN5Y2xlZENvbm5lY3RvcnMuZ2V0KGNvbm5lY3RvcklkKVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGNvbm5lY3RvciBhbHJlYWR5IGhhZCB0aGlzIHN0YXRlIGluIHRoaXMgY3ljbGUsIHJlc29sdmUgdGhlIGN5Y2xlXG4gICAgICAgICAgICAgICAgaWYoc3RhdGVzLmhhcyhzdGF0ZSkpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbW9yZSBzdGF0ZXMgaW4gdGhlIHNldCwgdGhlIGNvbm5lY3RvciBpcyBvc2NpbGxhdGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyAoZWxzZSBpdCBrZWVwcyBpdHMgc3RhdGUgYW5kIHdlIGp1c3QgYnJlYWsgdGhlIGN5Y2xlKVxuICAgICAgICAgICAgICAgICAgICBpZihzdGF0ZXMuc2l6ZSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gTG9naWMuc3RhdGUub3NjaWxsYXRpbmdcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIG1hcmsgdGhpcyBjb25uZWN0b3IgYXMgcmVzb2x2ZWRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlZEN5Y2xlZENvbm5lY3RvcnMuYWRkKGNvbm5lY3RvcklkKVxuXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhIG5ldywgdW5zZWVuIHN0YXRlLCBhZGQgaXQgdG8gdGhlIHNldCBhbmQgY29udGludWUgc2ltdWxhdGluZyB0aGUgY3ljbGVcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZXMuYWRkKHN0YXRlKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG1hcCB0aGUgbW9kaWZpZWQgc2V0IG9mIHN0YXRlcyB0byB0aGUgY29ubmVjdG9yXG4gICAgICAgICAgICAgICAgdGhpcy5jeWNsZWRDb25uZWN0b3JzLnNldChjb25uZWN0b3JJZCwgc3RhdGVzKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLndob0NhdXNlZEl0ID0gY29ubmVjdG9ySWRcbiAgICAgICAgICAgIC8qICBwcm9jZXNzIGFsbCBvdXRwdXRDb25uZWN0b3JzIGJ5IHNldHRpbmcgdGhlaXIgc3RhdGVcbiAgICAgICAgICAgICAgICB0aGlzIHdpbGwgdHJpZ2dlciBhIGZvbGxvd2luZyBldmVudCBjaGFpbjpcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0Q29ubmVjdG9yIGNoYW5nZXNcbiAgICAgICAgICAgICAgICAgICAgLT4gYWxsIGNvbm5lY3RlZCB3aXJlcyBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgLT4gYWxsIGlucHV0Q29ubmVjdG9ycyBjb25uZWN0ZWQgdG8gdGhlc2Ugd2lyZXMgY2hhbmdlXG4gICAgICAgICAgICAgICAgICAgIC0+IGFsbCBlbGVtZW50cyB0aGF0IGNvbnRhaW4gdGhlc2UgaW5wdXRDb25uZWN0b3JzIGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAtPiB0aGVzZSBlbGVtZW50cyBjb21wdXRlIHRoZSBuZXcgc3RhdGUgb2YgdGhlaXIgb3V0cHV0IGNvbm5lY3RvcnMgYW5kIGNhbGwgbm90aWZ5Q2hhbmdlKClcbiAgICAgICAgICAgICovXG5cblxuICAgICAgICAgICAgaWYod2hvQ2F1c2VkSXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFByZWRlY2Vzc29yKGNvbm5lY3RvcklkLCB3aG9DYXVzZWRJdClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLmN5Y2xlZENvbm5lY3RvcnMuaGFzKGNvbm5lY3RvcklkKSAmJiB0aGlzLmdldEFsbFByZWRlY2Vzc29ycyhjb25uZWN0b3JJZCkuaGFzKGNvbm5lY3RvcklkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3ljbGVkQ29ubmVjdG9ycy5zZXQoY29ubmVjdG9ySWQsIG5ldyBTZXQoW3N0YXRlXSkpXG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgLy8gcmVmbGVjdCB0aGUgY2hhbmdlcyBpbiBTVkdcbiAgICAgICAgICAgIGxldCBjb25uZWN0b3IgPSB0aGlzLnBhcmVudFNWRy5nZXRDb25uZWN0b3JCeUlkKGNvbm5lY3RvcklkKVxuICAgICAgICAgICAgaWYoY29ubmVjdG9yKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdG9yLnNldFN0YXRlKHN0YXRlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMud2hvQ2F1c2VkSXQgPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtYXJrIGEgcHJlZGVjZXNzb3JDb25uZWN0b3JJZCBhcyBhIHByZWRlY2Vzc29yIG9mIGNvbm5lY3RvcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbm5lY3RvcklkIElEIG9mIGEgY29ubmVjdG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByZWRlY2Vzc29yQ29ubmVjdG9ySWQgcHJlZGVjZXNzb3Igb2YgYGNvbm5lY3RvcklkYFxuICAgICAqL1xuICAgIGFkZFByZWRlY2Vzc29yKGNvbm5lY3RvcklkLCBwcmVkZWNlc3NvckNvbm5lY3RvcklkKSB7XG4gICAgICAgIGlmKCF0aGlzLnByZWRlY2Vzc29ycy5oYXMoY29ubmVjdG9ySWQpKSB7XG4gICAgICAgICAgICB0aGlzLnByZWRlY2Vzc29ycy5zZXQoY29ubmVjdG9ySWQsIG5ldyBTZXQoKSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHJlZGVjZXNzb3JzLmdldChjb25uZWN0b3JJZCkuYWRkKHByZWRlY2Vzc29yQ29ubmVjdG9ySWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHNldCBvZiBhbGwgb3V0cHV0IGNvbm5lY3RvcnMgdGhhdCBhcmUgYmVmb3JlIHRoaXMgb3V0cHV0IGNvbm5lY3RvclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gY29ubmVjdG9ySWQgSUQgb2YgYSBjb25uZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtTZXR9ICAgICAgICAgICAgICAgIHNldCBvZiBjb25uZWN0b3IgaWRzIHRoYXQgYXJlIGJlZm9yZSB0aGlzIG91dHB1dCBjb25uZWN0b3JcbiAgICAgKi9cbiAgICBnZXRBbGxQcmVkZWNlc3NvcnMoY29ubmVjdG9ySWQpIHtcbiAgICAgICAgaWYoIXRoaXMucHJlZGVjZXNzb3JzLmhhcyhjb25uZWN0b3JJZCkpIHtcbiAgICAgICAgICAgIHRoaXMucHJlZGVjZXNzb3JzLnNldChjb25uZWN0b3JJZCwgbmV3IFNldCgpKVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGFsbCA9IG5ldyBTZXQoKVxuXG4gICAgICAgIHRoaXMucHJlZGVjZXNzb3JzLmdldChjb25uZWN0b3JJZCkuZm9yRWFjaChhbGwuYWRkLCBhbGwpO1xuXG4gICAgICAgIGxldCBwcmV2U2l6ZSA9IDBcbiAgICAgICAgbGV0IHNpemUgPSBhbGwuc2l6ZVxuICAgICAgICB3aGlsZShwcmV2U2l6ZSA8IHNpemUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbm5lY3RvciBvZiBhbGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcmVkZWNlc3NvcnMuaGFzKGNvbm5lY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmVkZWNlc3NvcnMuZ2V0KGNvbm5lY3RvcikuZm9yRWFjaChhbGwuYWRkLCBhbGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZTaXplID0gc2l6ZVxuICAgICAgICAgICAgc2l6ZSA9IGFsbC5zaXplXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm90aWZ5IGEgY2hhbmdlIGluIHRoZSBuZXR3b3JrLiBUaGlzIGZ1bmN0aW9uIGFkZHMgdGhlIGNoYW5nZWQgY29ubmVjdG9yIHRvIHRoZSBuZXh0IHdhdmVcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNvbm5lY3RvcklkIElEIG9mIHRoZSBjaGFuZ2VkIGNvbm5lY3RvclxuICAgICAqIEBwYXJhbSAge0xvZ2ljLnN0YXRlfSBzdGF0ZSAgbmV3IFtMb2dpYy5zdGF0ZV0oLi9tb2R1bGUtTG9naWMuaHRtbCMuc3RhdGUpIG9mIHRoZSBjb25uZWN0b3JcbiAgICAgKi9cbiAgICBub3RpZnlDaGFuZ2UoY29ubmVjdG9ySWQsIHN0YXRlKSB7XG4gICAgICAgIGxldCB3YXZlSWQgPSB0aGlzLndhdmUgKyAxXG5cbiAgICAgICAgaWYoIXRoaXMud2F2ZXMuaGFzKHdhdmVJZCkpIHtcbiAgICAgICAgICAgIHRoaXMud2F2ZXMuc2V0KHdhdmVJZCwgW10pXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLndhdmVzLmdldCh3YXZlSWQpLnB1c2gobmV3IHN0YXRlQ2hhbmdlKGNvbm5lY3RvcklkLCBzdGF0ZSwgdGhpcy53aG9DYXVzZWRJdCkpO1xuICAgIH1cbn1cbiIsIi8qKiBAbW9kdWxlIGVkaXRvckVsZW1lbnRzICovXG5cbi8vIHRyYW5zZm9ybVxuZXhwb3J0IHsgZGVmYXVsdCBhcyBUcmFuc2Zvcm0gfSBmcm9tICcuL2VkaXRvckVsZW1lbnRzL1RyYW5zZm9ybSdcblxuLy8gY29ubmVjdG9yc1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBJbnB1dENvbm5lY3Rvcn0gZnJvbSAnLi9lZGl0b3JFbGVtZW50cy9JbnB1dENvbm5lY3RvcidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgT3V0cHV0Q29ubmVjdG9yfSBmcm9tICcuL2VkaXRvckVsZW1lbnRzL091dHB1dENvbm5lY3RvcidcblxuLy8gYm94ZXNcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSW5wdXRCb3h9IGZyb20gJy4vZWRpdG9yRWxlbWVudHMvSW5wdXRCb3gnXG5leHBvcnQgeyBkZWZhdWx0IGFzIE91dHB1dEJveH0gZnJvbSAnLi9lZGl0b3JFbGVtZW50cy9PdXRwdXRCb3gnXG5leHBvcnQgeyBkZWZhdWx0IGFzIEdhdGV9IGZyb20gJy4vZWRpdG9yRWxlbWVudHMvR2F0ZSdcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQmxhY2tib3h9IGZyb20gJy4vZWRpdG9yRWxlbWVudHMvQmxhY2tib3gnXG5cbi8vIGhlbHBlciB3aXJlXG5leHBvcnQgeyBkZWZhdWx0IGFzIEhlbHBlcldpcmV9IGZyb20gJy4vZWRpdG9yRWxlbWVudHMvSGVscGVyV2lyZSdcblxuLy8gd2lyZVxuZXhwb3J0IHsgZGVmYXVsdCBhcyBXaXJlfSBmcm9tICcuL2VkaXRvckVsZW1lbnRzL1dpcmUnXG4iLCJpbXBvcnQge0dyb3VwLCBSZWN0YW5nbGUsIE11bHRpTGluZVRleHQsIFBvbHlMaW5lLCBQb2x5TGluZVBvaW50cywgUG9seUxpbmVQb2ludH0gZnJvbSAnLi4vc3ZnT2JqZWN0cydcbmltcG9ydCBMb2dpYyBmcm9tICcuLi9Mb2dpYydcblxuaW1wb3J0IEJveCBmcm9tICcuL0JveCdcblxuLyoqIEBtb2R1bGUgZWRpdG9yRWxlbWVudHMuQmxhY2tib3ggKi9cblxuLyoqXG4gKiBCbGFja2JveCBpcyBhIGJveCB0aGF0IGlzIGRlZmluZWQgYnkgaXRzIGV2YWx1YXRpb24gZnVuY3Rpb25cbiAqIEBleHRlbmRzIEJveFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCbGFja2JveCBleHRlbmRzIEJveCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDYW52YXN9IHBhcmVudFNWRyAgaW5zdGFuY2Ugb2YgW0NhbnZhc10oLi9tb2R1bGUtQ2FudmFzLmh0bWwpXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlucHV0Q29ubmVjdG9ycyAgbnVtYmVyIG9mIGlucHV0IGNvbm5lY3RvcnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3V0cHV0Q29ubmVjdG9ycyBudW1iZXIgb2Ygb3V0cHV0IGNvbm5lY3RvcnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmFsRnVuY3Rpb24gICBmdW5jdGlvbiB0aGF0IHRha2VzIGBpbnB1dENvbm5lY3RvcnNgIFtMb2dpYy5zdGF0ZV0oLi9tb2R1bGUtTG9naWMuaHRtbCMuc3RhdGUpc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCByZXR1cm5zIGBvdXRwdXRDb25uZWN0b3JzYCBMb2dpYy5zdGF0ZXMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lXSAgICAgICAgbmFtZSB0aGF0IHdpbGwgYmUgZGlzcGxheWVkIG9uIHRoZSBibGFja2JveFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudFNWRywgaW5wdXRDb25uZWN0b3JzLCBvdXRwdXRDb25uZWN0b3JzLCBldmFsRnVuY3Rpb24sIG5hbWUgPSBcIlwiKSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gMTE7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGgubWF4KGlucHV0Q29ubmVjdG9ycywgb3V0cHV0Q29ubmVjdG9ycykgKiAyO1xuXG4gICAgICAgIHN1cGVyKHBhcmVudFNWRywgbmFtZSwgXCJibGFja2JveFwiLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICBjb25zdCBjb25uZWN0b3JQaW5MZW5naHQgPSAyLjUgKiB0aGlzLmdyaWRTaXplO1xuXG4gICAgICAgIC8vIG92ZXJyaWRlIGRlZmF1bHQgc3ZnT2JqIHN0cnVjdHVyZVxuICAgICAgICB0aGlzLnN2Z09iaiA9IG5ldyBHcm91cCgpO1xuXG4gICAgICAgIC8vIHRyYW5zcGFyZW50IGJhY2tncm91bmQgcmVjdGFuZ2xlXG4gICAgICAgIGxldCBoaXRib3ggPSBuZXcgUmVjdGFuZ2xlKDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBcIm5vbmVcIiwgXCJub25lXCIpO1xuICAgICAgICBoaXRib3guJGVsLmFkZENsYXNzKCdyZWN0Jyk7XG5cbiAgICAgICAgdGhpcy5zdmdPYmouYWRkQ2hpbGQoaGl0Ym94KTtcblxuICAgICAgICAvLyBtYWluIHJlY3RhbmdsZVxuICAgICAgICBjb25zdCBib2R5V2lkdGggPSB0aGlzLndpZHRoIC0gMiAqIGNvbm5lY3RvclBpbkxlbmdodDtcblxuICAgICAgICBsZXQgcmVjdGFuZ2xlID0gbmV3IFJlY3RhbmdsZShjb25uZWN0b3JQaW5MZW5naHQsIDAsIGJvZHlXaWR0aCwgdGhpcy5oZWlnaHQsIFwid2hpdGVcIiwgXCJibGFja1wiKTtcbiAgICAgICAgcmVjdGFuZ2xlLmFkZEF0dHIoeydzdHJva2Utd2lkdGgnOiAnMi41J30pO1xuICAgICAgICByZWN0YW5nbGUuJGVsLmFkZENsYXNzKCdyZWN0Jyk7XG5cbiAgICAgICAgdGhpcy5zdmdPYmouYWRkQ2hpbGQocmVjdGFuZ2xlKTtcblxuICAgICAgICAvLyB0ZXh0IGRlc2NyaXB0aW9uIG9mIHRoZSBib3hcbiAgICAgICAgY29uc3QgdGV4dFdpZHRoID0gYm9keVdpZHRoIC0gdGhpcy5ncmlkU2l6ZTtcbiAgICAgICAgY29uc3QgdGV4dEhlaWdodCA9IHRoaXMuaGVpZ2h0IC0gdGhpcy5ncmlkU2l6ZTtcbiAgICAgICAgbGV0IHRleHQgPSBuZXcgTXVsdGlMaW5lVGV4dChcbiAgICAgICAgICAgICh0aGlzLndpZHRoIC0gdGV4dFdpZHRoKSAvIDIsIC8vIGhvcml6b250YWwgY2VudGVyaW5nXG4gICAgICAgICAgICAodGhpcy5oZWlnaHQgLSB0ZXh0SGVpZ2h0KSAvIDIsIC8vIHZlcnRpY2FsIGNlbnRlcmluZ1xuICAgICAgICAgICAgdGV4dFdpZHRoLFxuICAgICAgICAgICAgdGV4dEhlaWdodCxcbiAgICAgICAgICAgIG5hbWUudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgIHRoaXMuZ3JpZFNpemUgKiAxLjJcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5zdmdPYmouYWRkQ2hpbGQodGV4dCk7XG5cbiAgICAgICAgLy8gYWRkIGlucHV0IGNvbm5lY3RvcnNcbiAgICAgICAgZm9yIChsZXQgaSA9IDAgOyBpIDwgaW5wdXRDb25uZWN0b3JzIDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBncmlkUG9zaXRpb24gPSAoaSAqIDIpICsgMTtcbiAgICAgICAgICAgIGNvbnN0IHBpeGVsUG9zaXRpb24gPSBncmlkUG9zaXRpb24gKiB0aGlzLmdyaWRTaXplO1xuXG4gICAgICAgICAgICBsZXQgcGluID0gbmV3IFBvbHlMaW5lKFxuICAgICAgICAgICAgICAgIG5ldyBQb2x5TGluZVBvaW50cyhbXG4gICAgICAgICAgICAgICAgICAgIG5ldyBQb2x5TGluZVBvaW50KDAsIHBpeGVsUG9zaXRpb24pLFxuICAgICAgICAgICAgICAgICAgICBuZXcgUG9seUxpbmVQb2ludChjb25uZWN0b3JQaW5MZW5naHQsIHBpeGVsUG9zaXRpb24pLFxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgXCJibGFja1wiXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIHRoaXMuc3ZnT2JqLmFkZENoaWxkKHBpbik7XG5cbiAgICAgICAgICAgIC8vIGFkZCB0aGUgY29ubmVjdG9yXG4gICAgICAgICAgICB0aGlzLmFkZElucHV0Q29ubmVjdG9yKDAsIGdyaWRQb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgb3V0cHV0IGNvbm5lY3RvcnNcbiAgICAgICAgZm9yIChsZXQgaSA9IDAgOyBpIDwgb3V0cHV0Q29ubmVjdG9ycyA7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgZ3JpZFBvc2l0aW9uID0gKGkgKiAyKSArIDE7XG4gICAgICAgICAgICBjb25zdCBwaXhlbFBvc2l0aW9uID0gZ3JpZFBvc2l0aW9uICogdGhpcy5ncmlkU2l6ZTtcblxuICAgICAgICAgICAgbGV0IHBpbiA9IG5ldyBQb2x5TGluZShcbiAgICAgICAgICAgICAgICBuZXcgUG9seUxpbmVQb2ludHMoW1xuICAgICAgICAgICAgICAgICAgICBuZXcgUG9seUxpbmVQb2ludCh0aGlzLndpZHRoIC0gY29ubmVjdG9yUGluTGVuZ2h0LCBwaXhlbFBvc2l0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFBvbHlMaW5lUG9pbnQodGhpcy53aWR0aCwgcGl4ZWxQb3NpdGlvbiksXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICBcImJsYWNrXCJcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgdGhpcy5zdmdPYmouYWRkQ2hpbGQocGluKTtcblxuICAgICAgICAgICAgdGhpcy5hZGRPdXRwdXRDb25uZWN0b3Iod2lkdGgsIGdyaWRQb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN2Z09iai4kZWwuYWRkQ2xhc3MoXCJib3hcIik7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYGlucHV0Q29ubmVjdG9yc2AgW0xvZ2ljLnN0YXRlXSguL21vZHVsZS1Mb2dpYy5odG1sIy5zdGF0ZSlzXG4gICAgICAgICAqIGFuZCByZXR1cm5zIGBvdXRwdXRDb25uZWN0b3JzYCBMb2dpYy5zdGF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV2YWxGdW5jdGlvbiA9IGV2YWxGdW5jdGlvbjtcblxuICAgICAgICAvLyByZWdlbmVyYXRlIHRoZSBibG9ja2VkIG5vZGVzIGFmdGVyIGFkZGluZyBhbGwgdGhlIGNvbm5lY3RvcnNcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUJsb2NrTm9kZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgZGF0YSBvZiB0aGlzIGJsYWNrYm94IGFzIGEgSlNPTi1yZWFkeSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgZXNzZW50aWFsIGRhdGEgZm9yIHRoaXMgYmxhY2tib3hcbiAgICAgKi9cbiAgICBnZXQgZXhwb3J0RGF0YSgpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBzdXBlci5leHBvcnREYXRhO1xuICAgICAgICBkYXRhLmlucHV0cyA9IHRoaXMuaW5wdXRDb25uZWN0b3JzLmxlbmd0aDtcbiAgICAgICAgZGF0YS5vdXRwdXRzID0gdGhpcy5vdXRwdXRDb25uZWN0b3JzLmxlbmd0aDtcblxuICAgICAgICAvLyBnZW5lcmF0ZSB0aGUgdHJ1dGggdGFibGVcblxuICAgICAgICBkYXRhLnRhYmxlID0gW11cblxuICAgICAgICAvLyBhcnJheSBvZiB0ZXN0ZWQgaW5wdXQgc3RhdGVzXG4gICAgICAgIGNvbnN0IHN0YXRlTGlzdCA9IExvZ2ljLnN0YXRlTGlzdDtcblxuICAgICAgICAvLyByZWN1cnNpdmUgZnVuY3Rpb24gdGhhdCBnZW5lcmF0ZXMgYWxsIHBvc3NpYmxlIGlucHV0c1xuICAgICAgICBjb25zdCBnZXRQZXJtdXRhdGlvbnMgPSAobGVuZ3RoKSA9PiB7XG4gICAgICAgICAgICBsZXQgcGVybXV0YXRpb25zID0gW107XG4gICAgICAgICAgICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdGF0ZSBvZiBzdGF0ZUxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcm11dGF0aW9ucy5wdXNoKFtzdGF0ZV0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBlcm11dGF0aW9ucztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN0YXRlIG9mIHN0YXRlTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGNvbnN0IHBlcm0gb2YgZ2V0UGVybXV0YXRpb25zKGxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVybXV0YXRpb25zLnB1c2goW3N0YXRlLCAuLi5wZXJtXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGVybXV0YXRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2VuZXJhdGUgb3V0cHV0cyBmb3IgYWxsIHRoZSBwb3NzaWJsZSBpbnB1dHNcbiAgICAgICAgZm9yIChjb25zdCBpbnB1dFZhbHVlcyBvZiBnZXRQZXJtdXRhdGlvbnMoZGF0YS5pbnB1dHMpKSB7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXRWYWx1ZXMgPSB0aGlzLmV2YWxGdW5jdGlvbiguLi5pbnB1dFZhbHVlcyk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFuIG91dHB1dCB2YWx1ZSB0aGF0IGlzIG5vdCBMb2dpYy5zdGF0ZS51bmtub3duLCBhZGQgdGhpcyBsaW5lIHRvIHRoZVxuICAgICAgICAgICAgLy8gdHJ1dGh0YWJsZSwgb3RoZXJ3aXNlIGRvbid0IGFkZCBpdCAoaWYgYWxsIG91dHB1dCB2YWx1ZXMgYXJlIExvZ2ljLnN0YXRlLnVua25vd24sXG4gICAgICAgICAgICAvLyB0aGUgaW5wdXQgY29tYmluYXRpb24gZG9lcyBub3QgaGF2ZSB0byBiZSBkZWZpbmVzLCBiZWNhdXNlIExvZ2ljLnN0YXRlLnVua25vd24gaXMgdGhlIGRlZmF1bHQgdmFsdWUpXG4gICAgICAgICAgICBpZiAob3V0cHV0VmFsdWVzLnJlZHVjZSgoYWNjdW11bGF0b3IsIGN1cnJlbnQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW11bGF0b3IgfHwgY3VycmVudCAhPT0gTG9naWMuc3RhdGUudW5rbm93blxuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnRhYmxlLnB1c2goWy4uLmlucHV0VmFsdWVzLCAuLi5vdXRwdXRWYWx1ZXNdKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHJvY2Nlc3MgdGhlIGlucHV0IGNvbm5lY3RvciBzdGF0ZXMgYW5kIHJlZmxlY3QgdGhlbSBpbiB0aGUgb3V0cHV0IGNvbm5lY3RvciBzdGF0ZXMgYWNjb3JkaW5nXG4gICAgICogdG8gdGhlIGxvZ2ljIGRlZmluZWQgYnkgdGhpcy5ldmFsRnVuY3Rpb25cbiAgICAgKi9cbiAgICByZWZyZXNoU3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IGlucHV0U3RhdGVzID0gdGhpcy5pbnB1dENvbm5lY3RvcnMubWFwKGNvbm4gPT4gY29ubi5zdGF0ZSk7XG4gICAgICAgIC8vIGNhbGwgdGhlIGV2YWxGdW5jdGlvbiB0byBnZXQgdGhlIG91dHB1dCBzdGF0ZXNcbiAgICAgICAgY29uc3Qgb3V0cHV0U3RhdGVzID0gdGhpcy5ldmFsRnVuY3Rpb24oLi4uaW5wdXRTdGF0ZXMpO1xuXG4gICAgICAgIC8vIGFwcGx5IHRoZSBvdXRwdXRTdGF0ZXMgdG8gdGhlIG91dHB1dENvbm5lY3RvcnNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRTdGF0ZXMubGVuZ3RoIDsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dENvbm5lY3RvcnNbaV0uc2V0U3RhdGUob3V0cHV0U3RhdGVzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdlbmVyYXRlQmxvY2tOb2RlcygpIHtcbiAgICAgICAgLy8gYWRkIGJsb2NrZWQgbm9kZXMgb24gdGhlIGNvbm5lY3RvcnMgYW5kIGJldHdlZW4gdGhlbSBhcyB3ZWxsXG5cbiAgICAgICAgbGV0IHNwZWNpYWxOb2RlcyA9IFtdXG4gICAgICAgIGZvciAobGV0IGkgPSAxIDsgaSA8IHRoaXMuaW5wdXRDb25uZWN0b3JzLmxlbmd0aCAqIDIgOyArK2kpIHtcbiAgICAgICAgICAgIHNwZWNpYWxOb2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IGlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDEgOyBpIDwgdGhpcy5vdXRwdXRDb25uZWN0b3JzLmxlbmd0aCAqIDIgOyArK2kpIHtcbiAgICAgICAgICAgIHNwZWNpYWxOb2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB4OiB0aGlzLmdyaWRXaWR0aCxcbiAgICAgICAgICAgICAgICB5OiBpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIuZ2VuZXJhdGVCbG9ja05vZGVzKDAsIDEsIDAsIDEsIC4uLnNwZWNpYWxOb2Rlcyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHtHcm91cCwgUmVjdGFuZ2xlLCBTdmdJbWFnZX0gZnJvbSAnLi4vc3ZnT2JqZWN0cydcblxuaW1wb3J0IE5ldHdvcmtFbGVtZW50IGZyb20gJy4vTmV0d29ya0VsZW1lbnQnXG5pbXBvcnQgSW5wdXRDb25uZWN0b3IgZnJvbSAnLi9JbnB1dENvbm5lY3RvcidcbmltcG9ydCBPdXRwdXRDb25uZWN0b3IgZnJvbSAnLi9PdXRwdXRDb25uZWN0b3InXG5pbXBvcnQgVHJhbnNmb3JtIGZyb20gJy4vVHJhbnNmb3JtJ1xuXG4vKiogQG1vZHVsZSBlZGl0b3JFbGVtZW50cy5Cb3ggKi9cblxuLyoqXG4gKiBQYXJlbnQgY2xhc3MgZm9yIGdhdGVzIGFuZCBpbnB1dCBhbmQgb3V0cHV0IGJveGVzLiBEZWZpbmVzIGFsbCB0aGUgZmFjdG9yc1xuICogdGhhdCB0aGUgYm94ZXMgaGF2ZSBpbiBjb21tb24gKHN2Z09iaiBzdHJ1Y3R1cmUsIGRyYWdnYWJpbGl0eSBhbmQgcm90YXRhYmlsaXR5Li4uKVxuICogQGV4dGVuZHMgTmV0d29ya0VsZW1lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQm94IGV4dGVuZHMgTmV0d29ya0VsZW1lbnQge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzfSBwYXJlbnRTVkcgIGluc3RhbmNlIG9mIFtDYW52YXNdKC4vbW9kdWxlLUNhbnZhcy5odG1sKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICAgICAgIG5hbWUgb2YgdGhlIGVsZW1lbnQgKGlucHV0LCBvdXRwdXQsIGFuZCwgb3IsIHhvci4uLilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2F0ZWdvcnkgICB0eXBlIG9mIHRoZSBlbGVtZW50IChpbywgZ2F0ZSlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ3JpZFdpZHRoICB3aWR0aCBvZiB0aGUgZWxlbWVudCBpbiBncmlkIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncmlkSGVpZ2h0IGhlaWdodCBvZiB0aGUgZWxlbWVudCBpbiBncmlkIHBpeGVsc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudFNWRywgbmFtZSwgY2F0ZWdvcnksIGdyaWRXaWR0aCwgZ3JpZEhlaWdodCkge1xuICAgICAgICBzdXBlcihwYXJlbnRTVkcpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzcGVjaWZpZXMgdGhlIGJveCB0eXBlIHdpdGhpbiB0aGUgY2F0ZWdvcnkgKGlucHV0L291dHB1dCBpbiBpbywgYW5kL29yLy4uLiBpbiBnYXRlKVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogc3BlY2lmaWVzIHRoZSBib3ggY2F0ZWdvcnkgKGlvIGZvciBpbnB1dCBvciBvdXRwdXQsIGdhdGUgZm9yIGxvZ2ljIGdhdGVzKVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYXRlZ29yeSA9IGNhdGVnb3J5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzaXplIG9mIHRoZSBncmlkIGluIFNWRyBwaXhlbHNcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JpZFNpemUgPSB0aGlzLnBhcmVudFNWRy5ncmlkU2l6ZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogYXJyYXkgb2YgY29ubmVjdG9ycyBvZiB0aGlzIGJveFxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbm5lY3RvcnMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogc3ZnT2JqIGNvbnRhaW5pbmcgYWxsIFNWRyBkYXRhIHVzZWQgdG8gZGlzcGxheSB0aGlzIGJveFxuICAgICAgICAgKiBAdHlwZSB7c3ZnT2JqfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdmdPYmogPSBuZXcgR3JvdXAoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogd2lkdGggb2YgdGhpcyBlbGVtZW50IGluIFNWRyBwaXhlbHNcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMud2lkdGggPSBncmlkV2lkdGggKiB0aGlzLmdyaWRTaXplO1xuICAgICAgICAvKipcbiAgICAgICAgICogaGVpZ2h0IG9mIHRoaXMgZWxlbWVudCBpbiBTVkcgcGl4ZWxzXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhlaWdodCA9IGdyaWRIZWlnaHQgKiB0aGlzLmdyaWRTaXplO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB3aWR0aCBvZiB0aGlzIGVsZW1lbnQgaW4gZ3JpZCBwaXhlbHNcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JpZFdpZHRoID0gZ3JpZFdpZHRoO1xuICAgICAgICAvKipcbiAgICAgICAgICogaGVpZ2h0IG9mIHRoaXMgZWxlbWVudCBpbiBncmlkIHBpeGVsc1xuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ncmlkSGVpZ2h0ID0gZ3JpZEhlaWdodDtcblxuICAgICAgICAvLyB0cmFuc3BhcmVudCBiYWNrZ3JvdW5kIHJlY3RhbmdsZVxuICAgICAgICBsZXQgcmVjdGFuZ2xlID0gbmV3IFJlY3RhbmdsZSgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgXCJub25lXCIsIFwibm9uZVwiKTtcbiAgICAgICAgcmVjdGFuZ2xlLiRlbC5hZGRDbGFzcygncmVjdCcpO1xuXG4gICAgICAgIHRoaXMuc3ZnT2JqLmFkZENoaWxkKHJlY3RhbmdsZSk7XG5cbiAgICAgICAgLy8gaW1hZ2Ugb2YgdGhlIGVsZW1lbnRcbiAgICAgICAgdGhpcy5pbWFnZSA9IG5ldyBTdmdJbWFnZSgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy51cmwpO1xuICAgICAgICB0aGlzLnN2Z09iai5hZGRDaGlsZCh0aGlzLmltYWdlKTtcblxuICAgICAgICAvLyBhZGQgdHlwZT1cImdhdGVcIiwgdXNlZCBpbiBzcGVjaWFsIGNhbGxiYWNrcyBpbiBjb250ZXh0bWVudVxuICAgICAgICB0aGlzLnN2Z09iai5hZGRBdHRyKHtcInR5cGVcIjogY2F0ZWdvcnl9KTtcblxuICAgICAgICB0aGlzLnN2Z09iai4kZWwuYWRkQ2xhc3MoXCJib3hcIik7XG4gICAgICAgIHRoaXMuc3ZnT2JqLiRlbC5hZGRDbGFzcyhjYXRlZ29yeSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdXJsIG9mIHRoZSBpbWFnZSBkZXBpY3RpbmcgdGhpcyBvYmplY3RcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCB1cmwoKSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBjYXRlZ29yeSA9IHRoaXMuY2F0ZWdvcnkgfHwgXCJcIixcbiAgICAgICAgICAgIG5hbWUgPSB0aGlzLm5hbWUgfHwgXCJcIixcbiAgICAgICAgICAgIHN1ZmZpeCA9IHRoaXMuaW1nU3VmZml4IHx8IFwiXCI7XG5cbiAgICAgICAgcmV0dXJuIGBpbWcvc3ZnLyR7Y2F0ZWdvcnl9LyR7bmFtZX0ke3N1ZmZpeH0uc3ZnYDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgYWxsIGlucHV0IGNvbm5lY3RvcnMgb2YgdGhpcyBib3hcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgb2YgaW5wdXQgY29ubmVjdG9yc1xuICAgICAqL1xuICAgIGdldCBpbnB1dENvbm5lY3RvcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RvcnMuZmlsdGVyKGNvbm4gPT4gY29ubi5pc0lucHV0Q29ubmVjdG9yKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCBhbGwgb3V0cHV0IGNvbm5lY3RvcnMgb2YgdGhpcyBib3hcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgb2Ygb3V0cHV0IGNvbm5lY3RvcnNcbiAgICAgKi9cbiAgICBnZXQgb3V0cHV0Q29ubmVjdG9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdG9ycy5maWx0ZXIoY29ubiA9PiBjb25uLmlzT3V0cHV0Q29ubmVjdG9yKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCBkYXRhIG9mIHRoaXMgYm94IGFzIGEgSlNPTi1yZWFkeSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgZXNzZW50aWFsIGRhdGEgZm9yIHRoaXMgYm94XG4gICAgICovXG4gICAgZ2V0IGV4cG9ydERhdGEoKSB7XG4gICAgICAgIGxldCBjb25uZWN0aW9ucyA9IFtdO1xuXG4gICAgICAgIC8vIGdvIHRocm91Z2ggYWxsIGNvbm5lY3RvcnNcbiAgICAgICAgbGV0IGNvdW50ZXIgPSAwXG4gICAgICAgIGZvciAoY29uc3QgY29ubiBvZiB0aGlzLmNvbm5lY3RvcnMpIHtcbiAgICAgICAgICAgIC8vIGdvIHRocm91Z2ggZWFjaCBpdHMgd2lyZSBpZFxuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGNvbm4ud2lyZUlkcykge1xuICAgICAgICAgICAgICAgIGxldCB0aGlzV2lyZUlkO1xuICAgICAgICAgICAgICAgIGlmKCF0aGlzLnBhcmVudFNWRy5leHBvcnRXaXJlSWRNYXAuaGFzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSB3aXJlIGlkIGlzIG5vdCBpbiB0aGUgbWFwLCBhZGQgaXQgYW5kIGFzc2lnbiBuZXcgYXJiaXRyYXJ5IGlkXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50U1ZHLmV4cG9ydFdpcmVJZE1hcC5zZXQoaXRlbSwgdGhpcy5wYXJlbnRTVkcuZXhwb3J0V2lyZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1dpcmVJZCA9IHRoaXMucGFyZW50U1ZHLmV4cG9ydFdpcmVJZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRTVkcuZXhwb3J0V2lyZUlkKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBnZXQgaWQgZnJvbSB0aGUgbWFwXG4gICAgICAgICAgICAgICAgICAgIHRoaXNXaXJlSWQgPSB0aGlzLnBhcmVudFNWRy5leHBvcnRXaXJlSWRNYXAuZ2V0KGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgLy8gYWRkIHRoaXMgY29ubmVjdGlvbiB0byB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zW2Nvbm5lY3Rpb25zLmxlbmd0aF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBjb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBjb25uLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHdpcmVJZDogdGhpc1dpcmVJZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3VudGVyKytcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBjYXRlZ29yeTogdGhpcy5jYXRlZ29yeSxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5nZXRUcmFuc2Zvcm0odHJ1ZSksXG4gICAgICAgICAgICBjb25uZWN0aW9uczogY29ubmVjdGlvbnNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgc2V0IG9mIG5vZGVzIHRoYXQgYXJlIG5vdCBzdWl0YWJsZSBmb3Igd2lyZSByb3V0aW5nXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbbWFyZ2luVG9wPTBdICAgIHRvcCBtYXJnaW4gb2YgdGhlIGVsZW1lbnQgKGRpc3RhbmNlIGZyb20gdGhlIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgYWxzbyBibG9ja2VkKVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW21hcmdpblJpZ2h0PTBdICByaWdodCBtYXJnaW4gb2YgdGhlIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFttYXJnaW5Cb3R0b209MF0gYm90dG9tIG1hcmdpbiBvZiB0aGUgZWxlbWVudFxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW21hcmdpbkxlZnQ9MF0gICBsZWZ0IG1hcmdpbiBvZiB0aGUgZWxlbWVudFxuICAgICAqIEBwYXJhbSAge051bWJlcn0gc3BlY2lhbE5vZGVzICAgICBhZGRpdGlvbmFsIG5vZGVzIHRoYXQgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSBzZXRcbiAgICAgKiBAcmV0dXJuIHtTZXR9ICAgICAgICAgICAgICAgICAgICAgc2V0IG9mIG5vdCBzdWl0YWJsZSBub2Rlc1xuICAgICAqL1xuICAgIGdlbmVyYXRlQmxvY2tOb2RlcyhtYXJnaW5Ub3AgPSAwLCBtYXJnaW5SaWdodCA9IDAsIG1hcmdpbkJvdHRvbSA9IDAsIG1hcmdpbkxlZnQgPSAwLCAuLi5zcGVjaWFsTm9kZXMpIHtcbiAgICAgICAgdGhpcy5ibG9ja2VkTm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvcihsZXQgeCA9IG1hcmdpbkxlZnQgOyB4IDw9IHRoaXMuZ3JpZFdpZHRoIC0gbWFyZ2luUmlnaHQgOyB4KyspIHtcbiAgICAgICAgICAgIGZvcihsZXQgeSA9IG1hcmdpblRvcCA7IHkgPD0gdGhpcy5ncmlkSGVpZ2h0IC0gbWFyZ2luQm90dG9tIDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja2VkTm9kZXMuYWRkKHtcbiAgICAgICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICAgICAgeTogeVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBzcGVjaWFsTm9kZXMpIHtcbiAgICAgICAgICAgIHRoaXMuYmxvY2tlZE5vZGVzLmFkZChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGVtcHR5IGZ1bmN0aW9uLCByZWRlZmluZWQgaW4gaW5oZXJpdGVkIGVsZW1lbnRzXG4gICAgICogcmVmcmVzaFN0YXRlIHRha2VzIGlucHV0IGNvbm5lY3RvciB2YWx1ZXMgYW5kIHNldHMgb3V0cHV0IHZhbHVlcyBhY2NvcmRpbmdseVxuICAgICAqL1xuICAgIHJlZnJlc2hTdGF0ZSgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiQ2FsbGluZyB0aGUgdmlydHVhbCBmdW5jdGlvbiByZWZyZXNoU3RhdGUgaGFzIG5vIGVmZmVjdC5cIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2hhbmdlIGltYWdlIHRvIGFub3RoZXIgb25lIHRoYXQgZW5kcyB3aXRoIGEgc3BlY2lmaWVkIHN1ZmZpeFxuICAgICAqXG4gICAgICogKnVzYWdlOiogYGNoYW5nZUltYWdlKFwiYWJjXCIpYCBjaGFuZ2VzIGltYWdlIHVybCB0byBgaW1hZ2UtYWJjLnN2Z2AsXG4gICAgICogYGNoYW5nZUltYWdlKClgIGNoYW5nZXMgaW1hZ2UgdXJsIHRvIHRoZSBkZWZhdWx0IG9uZSAoYGltYWdlLnN2Z2ApXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBbc3VmZml4XSBuZXcgc3VmZml4IGZvciB0aGUgaW1hZ2VcbiAgICAgKi9cbiAgICBjaGFuZ2VJbWFnZShzdWZmaXgpIHtcbiAgICAgICAgaWYoc3VmZml4ID09PSB1bmRlZmluZWQgfHwgc3VmZml4ID09PSBcIlwiKSB7XG4gICAgICAgICAgICB0aGlzLmltZ1N1ZmZpeCA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmltZ1N1ZmZpeCA9IFwiLVwiICsgc3VmZml4O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbWFnZS5jaGFuZ2VVcmwodGhpcy51cmwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCBhIGpRdWVyeSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGlzIGJveFxuICAgICAqIEByZXR1cm4ge2pRdWVyeS5lbGVtZW50fVxuICAgICAqL1xuICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ZnT2JqLmdldCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJvdGF0ZSB0aGUgc2V0IG9mIGJsb2NrZWQgbm9kZXMgYnkgOTAgZGVncmVlcyB0byB0aGUgcmlnaHQgb3IgdG8gdGhlIGxlZnQsIGRlcGVuZGluZyBvbiB0aGUgcGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiB1c2VkIHRvIHJvdGF0ZSB0aGUgbm9kZXMgd2hlbiB0aGUgb2JqZWN0IGl0c2VsZiBpcyByb3RhdGVkXG4gICAgICogQHBhcmFtICB7Ym9vbGVhbn0gcmlnaHQgcm90YXRlIGNsb2Nrd2lzZSBpZiB0cnVlLCBjb3VudGVyY2xvY2t3aXNlIGlmIGZhbHNlXG4gICAgICovXG4gICAgcm90YXRlQmxvY2tlZE5vZGVzKGNlbnRlciwgcmlnaHQpIHtcbiAgICAgICAgaWYodGhpcy5yb3RhdGlvblBhcml0eT09PXVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGlvblBhcml0eSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yb3RhdGlvblBhcml0eSA9ICF0aGlzLnJvdGF0aW9uUGFyaXR5O1xuXG4gICAgICAgIGxldCBuZXdCbG9ja2VkTm9kZXMgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgLy8gcm90YXRlIHRoZSBub2RlXG5cbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMuYmxvY2tlZE5vZGVzKSB7XG4gICAgICAgICAgICBsZXQgbmV3Tm9kZTtcblxuICAgICAgICAgICAgY29uc3QgcGFyaXR5RmFjdG9yID0gICh0aGlzLnJvdGF0aW9uUGFyaXR5ID8gMSA6IC0xKTtcblxuICAgICAgICAgICAgaWYocmlnaHQpIHtcbiAgICAgICAgICAgICAgICBuZXdOb2RlID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiAtIG5vZGUueSArIHRoaXMuZ3JpZEhlaWdodCArIChjZW50ZXIueCAtIGNlbnRlci55KSAqIHBhcml0eUZhY3RvcixcbiAgICAgICAgICAgICAgICAgICAgeTogbm9kZS54ICsgKGNlbnRlci55IC0gY2VudGVyLngpICogcGFyaXR5RmFjdG9yXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3Tm9kZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogbm9kZS55ICsgKGNlbnRlci54IC0gY2VudGVyLnkpICogcGFyaXR5RmFjdG9yXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYodGhpcy5yb3RhdGlvblBhcml0eSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLnkgPSAtIG5vZGUueCArIHRoaXMuZ3JpZFdpZHRoICsgKCh0aGlzLmdyaWRIZWlnaHQgLSBjZW50ZXIueSkgLSAodGhpcy5ncmlkV2lkdGggLSBjZW50ZXIueCkpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS55ID0gLSBub2RlLnggKyB0aGlzLmdyaWRIZWlnaHQgKyAoY2VudGVyLnkgLSBjZW50ZXIueClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5ld0Jsb2NrZWROb2Rlcy5hZGQobmV3Tm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJsb2NrZWROb2RlcyA9IG5ld0Jsb2NrZWROb2RlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByb3RhdGUgdGhlIHNldCBvZiBibG9ja2VkIG5vZGVzIHRvIHRoZSByaWdodFxuICAgICAqXG4gICAgICogdXNlZCB0byByb3RhdGUgdGhlIG5vZGVzIHdoZW4gdGhlIG9iamVjdCBpdHNlbGYgaXMgcm90YXRlZFxuICAgICAqL1xuICAgIHJvdGF0ZUJsb2NrZWROb2Rlc1JpZ2h0KGNlbnRlcikge1xuICAgICAgICB0aGlzLnJvdGF0ZUJsb2NrZWROb2RlcyhjZW50ZXIsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJvdGF0ZSB0aGUgc2V0IG9mIGJsb2NrZWQgbm9kZXMgdG8gdGhlIHJpZ2h0XG4gICAgICpcbiAgICAgKiB1c2VkIHRvIHJvdGF0ZSB0aGUgbm9kZXMgd2hlbiB0aGUgb2JqZWN0IGl0c2VsZiBpcyByb3RhdGVkXG4gICAgICovXG4gICAgcm90YXRlQmxvY2tlZE5vZGVzTGVmdChjZW50ZXIpIHtcbiAgICAgICAgdGhpcy5yb3RhdGVCbG9ja2VkTm9kZXMoY2VudGVyLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgcm90YXRlKGNsb2NrV2lzZSkge1xuICAgICAgICAvLyBnZXQgdGhlIHRyYW5zZm9ybSB2YWx1ZSBmb3IgdGhpcyBib3hcbiAgICAgICAgbGV0IHRyYW5zZm9ybSA9IHRoaXMuZ2V0VHJhbnNmb3JtKCk7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBib3VuZGluZyByZWN0YW5nbGUgZm9yIHRoaXMgYm94XG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5zdmdPYmouJGVsWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIC8vIHVzZSB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIGRpbWVuc2lvbnMgdG8gZmlndXJlIG91dCB0aGUgZ2VvbWV0cmljYWwgY2VudGVyIG9mIHRoZSBib3hcbiAgICAgICAgY29uc3QgY2VudGVyID0ge1xuICAgICAgICAgICAgeDogTWF0aC5yb3VuZChyZWN0LndpZHRoIC8gMiksXG4gICAgICAgICAgICB5OiBNYXRoLnJvdW5kKHJlY3QuaGVpZ2h0IC8gMilcbiAgICAgICAgfVxuXG4gICAgICAgIGNlbnRlci54IC09IGNlbnRlci54ICUgdGhpcy5ncmlkU2l6ZTtcbiAgICAgICAgY2VudGVyLnkgLT0gY2VudGVyLnkgJSB0aGlzLmdyaWRTaXplO1xuXG4gICAgICAgIC8vIGFwcGx5IHRoZSByb3RhdGlvbiB0byB0aGUgdHJhbnNmb3JtIG9iamVjdFxuICAgICAgICBpZihjbG9ja1dpc2UpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybS5yb3RhdGVSaWdodChjZW50ZXIueCwgY2VudGVyLnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJhbnNmb3JtLnJvdGF0ZUxlZnQoY2VudGVyLngsIGNlbnRlci55KTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gYXBwbHkgdGhlIG1vZGlmaWVkIHRyYW5zZm9ybSBvYmplY3Qgb3QgdGhlIHN2Z09ialxuICAgICAgICB0aGlzLnN2Z09iai5hZGRBdHRyKHtcInRyYW5zZm9ybVwiOiB0cmFuc2Zvcm0uZ2V0KCl9KTtcblxuICAgICAgICBjb25zdCBncmlkQ2VudGVyID0ge1xuICAgICAgICAgICAgeDogY2VudGVyLnggLyB0aGlzLmdyaWRTaXplLFxuICAgICAgICAgICAgeTogY2VudGVyLnkgLyB0aGlzLmdyaWRTaXplXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcm90YXRlIGFsc28gdGhlIGJsb2NrZWQgbm9kZXNcbiAgICAgICAgaWYoY2xvY2tXaXNlKSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0ZUJsb2NrZWROb2Rlc1JpZ2h0KGdyaWRDZW50ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGVCbG9ja2VkTm9kZXNMZWZ0KGdyaWRDZW50ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSB3aXJlc1xuICAgICAgICB0aGlzLnVwZGF0ZVdpcmVzKCk7XG5cbiAgICAgICAgLy8gaWYgdHV0b3JpYWwgZXhpc3RzLCBjYWxsIHR1dG9yaWFsIGNhbGxiYWNrXG4gICAgICAgIGlmKHRoaXMucGFyZW50U1ZHLnR1dG9yaWFsKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudFNWRy50dXRvcmlhbC5vbkJveFJvdGF0ZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFkZCBhIGNvbm5lY3RvciB0byB0aGUgZWxlbWVudCBvbiB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9ICBsZWZ0ICAgICAgICAgICAgIGhvcml6b250YWwgZGlzdGFuY2UgZnJvbSB0aGUgbGVmdCBlZGdlIG9mIHRoZSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9ICB0b3AgICAgICAgICAgICAgIHZlcnRpY2FsIGRpc3RhbmNlIGZyb20gdGhlIHRvcCBlZGdlIG9mIHRoZSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpc0lucHV0Q29ubmVjdG9yIHdoZXRoZXIgb3Igbm90IHNob3VsZCB0aGlzIGNvbm5lY3RvciBhbiBpbnB1dCBjb25uZWN0b3IgKGB0cnVlYCBmb3IgaW5wdXQgY29ubmVjdG9yLCBgZmFsc2VgIGZvciBvdXRwdXQgY29ubmVjdG9yKVxuICAgICAqL1xuICAgIGFkZENvbm5lY3RvcihsZWZ0LCB0b3AsIGlzSW5wdXRDb25uZWN0b3IpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5jb25uZWN0b3JzLmxlbmd0aDtcbiAgICAgICAgaWYoaXNJbnB1dENvbm5lY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3JzW2luZGV4XSA9IG5ldyBJbnB1dENvbm5lY3Rvcih0aGlzLnBhcmVudFNWRywgbGVmdCwgdG9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yc1tpbmRleF0gPSBuZXcgT3V0cHV0Q29ubmVjdG9yKHRoaXMucGFyZW50U1ZHLCBsZWZ0LCB0b3ApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3ZnT2JqLmFkZENoaWxkKHRoaXMuY29ubmVjdG9yc1tpbmRleF0uZ2V0KCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFkZCBhbiBpbnB1dCBjb25uZWN0b3IgdG8gdGhlIGVsZW1lbnQgb24gdGhlIHNwZWNpZmllZCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IGhvcml6b250YWwgZGlzdGFuY2UgZnJvbSB0aGUgbGVmdCBlZGdlIG9mIHRoZSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvcCAgdmVydGljYWwgZGlzdGFuY2UgZnJvbSB0aGUgdG9wIGVkZ2Ugb2YgdGhlIGVsZW1lbnRcbiAgICAgKi9cbiAgICBhZGRJbnB1dENvbm5lY3RvcihsZWZ0LCB0b3ApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkQ29ubmVjdG9yKGxlZnQsIHRvcCwgdHJ1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhZGQgYW4gb3V0cHV0IGNvbm5lY3RvciB0byB0aGUgZWxlbWVudCBvbiB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgaG9yaXpvbnRhbCBkaXN0YW5jZSBmcm9tIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9wICB2ZXJ0aWNhbCBkaXN0YW5jZSBmcm9tIHRoZSB0b3AgZWRnZSBvZiB0aGUgZWxlbWVudFxuICAgICAqL1xuICAgIGFkZE91dHB1dENvbm5lY3RvcihsZWZ0LCB0b3ApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkQ29ubmVjdG9yKGxlZnQsIHRvcCwgZmFsc2UpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBjb25uZWN0b3Igb2JqZWN0IGJhc2VkIG9uIGl0cyBpZFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gY29ubmVjdG9ySWQgSUQgb2YgdGhlIHtAbGluayBDb25uZWN0b3J9XG4gICAgICogQHJldHVybiB7Q29ubmVjdG9yfSAgICAgICAgICAgICBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIENvbm5lY3Rvcn0gb3IgYHVuZGVmaW5lZGAgaWYgbm90IGZvdW5kXG4gICAgICovXG4gICAgZ2V0Q29ubmVjdG9yQnlJZChjb25uZWN0b3JJZCkge1xuICAgICAgICBmb3IobGV0IGkgPSAwIDsgaSA8IHRoaXMuY29ubmVjdG9ycy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICAgIGlmKHRoaXMuY29ubmVjdG9yc1tpXS5pZD09PWNvbm5lY3RvcklkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdG9yc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBjb25uZWN0b3Igbm90IGZvdW5kLCByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBpbnN0YW5jZSBvZiB7QGxpbmsgVHJhbnNmb3JtfSByZXByZXNlbnRpbmcgdGhlIHN0YXRlIG9mIHRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlIG9mIHRoaXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IFtncmlkUGl4ZWxzPWZhbHNlXSBpZiBgdHJ1ZWAsIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSByZXN1bHQgaW4gZ3JpZCBwaXhlbHMgaW5zdGVhZCBvZiBTVkcgcGl4ZWxzXG4gICAgICogQHJldHVybiB7VHJhbnNmb3JtfSAgICAgICAgICAgICAgICAgIHtAbGluayBUcmFuc2Zvcm19IG9mIHRoZSBlbGVtZW50XG4gICAgICovXG4gICAgZ2V0VHJhbnNmb3JtKGdyaWRQaXhlbHMgPSBmYWxzZSkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtO1xuICAgICAgICBpZiAoIXRoaXMuc3ZnT2JqLiRlbC5hdHRyKFwidHJhbnNmb3JtXCIpKSB7XG4gICAgICAgICAgICAvLyB0aGUgZWxlbWVudCBkb2VzIG5vdCBoYXZlIGEgXCJ0cmFuc2Zvcm1cIiBwcm9wZXJ0eSAtLT4gY3JlYXRlIGl0XG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICB0cmFuc2Zvcm0uc2V0VHJhbnNsYXRlKDAsIDApO1xuICAgICAgICAgICAgdGhpcy5zdmdPYmouYWRkQXR0cih7XCJ0cmFuc2Zvcm1cIjogdHJhbnNmb3JtLmdldCgpfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGUgZWxlbWVudCBkb2VzIGhhdmUgYSBcInRyYW5zZm9ybVwiIHByb3BlcnR5IC0tPiBjaGFuZ2UgaXRcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0odGhpcy5zdmdPYmouJGVsLmF0dHIoXCJ0cmFuc2Zvcm1cIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29udmVydCB2YWx1ZXMgdG8gZ3JpZCBwaXhlbHNcbiAgICAgICAgaWYoZ3JpZFBpeGVscykge1xuICAgICAgICAgICAgdHJhbnNmb3JtLnRvR3JpZFBpeGVscyh0aGlzLnBhcmVudFNWRyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJhbnNmb3JtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgaW5zdGFuY2Ugb2Yge0BsaW5rIFRyYW5zZm9ybX0gcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZiB0aGUgdHJhbnNmb3JtIGF0dHJpYnV0ZSBvZiB0aGlzIGVsZW1lbnQgX3dpdGggbGVuZ2h0IHVuaXRzIGluIGdyaWQgcGl4ZWxzX1xuICAgICAqIEByZXR1cm4ge1RyYW5zZm9ybX0ge0BsaW5rIFRyYW5zZm9ybX0gb2YgdGhlIGVsZW1lbnRcbiAgICAgKi9cbiAgICBnZXRHcmlkUGl4ZWxUcmFuc2Zvcm0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFRyYW5zZm9ybSh0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdGhlIHRyYW5zZm9ybSBhdHRyaWJ1dGUgb2YgdGhpcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybSB7QGxpbmsgVHJhbnNmb3JtfSBvZiB0aGUgZWxlbWVudCAod2l0aCBsZW5ndGhzIHNwZWNpZmllZCBpbiBTVkcgcGl4ZWxzKVxuICAgICAqL1xuICAgIHNldFRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdGhpcy5zdmdPYmouYWRkQXR0cih7XCJ0cmFuc2Zvcm1cIjogdHJhbnNmb3JtLmdldCgpfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgb24gZXZlcnkgbW91c2UgZG93biBvbiB0aGlzIGVsZW1lbnRcbiAgICAgKlxuICAgICAqIG1vdmVzIHRoZSBlbGVtZW50IHRvIHRoZSBmcm9udCBhbmQgY2FsbHMgb25Nb3VzZURvd25MZWZ0IGlmIGFwcGxpY2FibGVcbiAgICAgKiBAcGFyYW0gIHtqUXVlcnkuTW91c2VFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgICB0aGlzLm1vdXNlTGVmdCA9IGZhbHNlO1xuICAgICAgICBpZihldmVudC53aGljaCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5tb3VzZUxlZnQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5vbk1vdXNlRG93bkxlZnQoZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBtb3ZlIHRoZSBET00gZWxlbWVudCB0byBmcm9udFxuICAgICAgICAgICAgdGhpcy5wYXJlbnRTVkcubW92ZVRvRnJvbnRCeUlkKHRoaXMuc3ZnT2JqLmlkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIG9uIGV2ZXJ5IGxlZnQgbW91c2UgZG93biBvbiB0aGlzIGVsZW1lbnRcbiAgICAgKlxuICAgICAqIHByZXBhcmVzIGVsZW1lbnQgZm9yIHRoZSBcImNsaWNrXCIgYW5kIFwiZHJhZyBhbmQgZHJvcFwiIGFjdGlvbnNcbiAgICAgKiBAcGFyYW0gIHtqUXVlcnkuTW91c2VFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlRG93bkxlZnQoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5tb3VzZU1vdmVkID0gZmFsc2U7XG5cbiAgICAgICAgbGV0IHRyYW5zZm9ybSA9IHRoaXMuZ2V0VHJhbnNmb3JtKCk7XG5cbiAgICAgICAgLy8gc2F2ZSB0aGUgY3VycmVudCBpdGVtIHBvc2l0aW9uIGludG8gYSB2YXJpYWJsZVxuICAgICAgICBsZXQgY3VycmVudFBvc2l0aW9uID0gdHJhbnNmb3JtLmdldFRyYW5zbGF0ZSgpO1xuXG4gICAgICAgIGxldCB7cGFnZVgsIHBhZ2VZfSA9IHRoaXMucGFyZW50U1ZHLnZpZXdib3gudHJhbnNmb3JtRXZlbnQoZXZlbnQpXG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIG1vdXNlIG9mZnNldCBmcm9tIHRoZSBvYmplY3Qgb3JpZ2luXG4gICAgICAgIHRoaXMub2Zmc2V0ID0ge1xuICAgICAgICAgICAgeDogcGFnZVggLSBjdXJyZW50UG9zaXRpb24ueCxcbiAgICAgICAgICAgIHk6IHBhZ2VZIC0gY3VycmVudFBvc2l0aW9uLnlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBvbiBldmVyeSBsZWZ0IG1vdXNlIG1vdmUgd2l0aCB0aGlzIGVsZW1lbnRcbiAgICAgKiBhcHBsaWVzIHRoZSBjb3JyZWN0IHRyYW5zZm9ybSB2YWx1ZXMgdG8gcHJvdmlkZSB0aGUgXCJkcmFnIGFuZCBkcm9wXCIgZnVuY3Rpb25hbGl0eVxuICAgICAqIEBwYXJhbSAge2pRdWVyeS5Nb3VzZUV2ZW50fSBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICAgIGlmKHRoaXMubW91c2VMZWZ0KSB7XG4gICAgICAgICAgICB0aGlzLnN2Z09iai4kZWwuYWRkQ2xhc3MoJ2dyYWJiZWQnKTtcblxuICAgICAgICAgICAgdGhpcy5tb3VzZU1vdmVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgbGV0IHtwYWdlWCwgcGFnZVl9ID0gdGhpcy5wYXJlbnRTVkcudmlld2JveC50cmFuc2Zvcm1FdmVudChldmVudClcblxuICAgICAgICAgICAgY29uc3QgbGVmdCA9IHBhZ2VYIC0gdGhpcy5vZmZzZXQueDtcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IHBhZ2VZIC0gdGhpcy5vZmZzZXQueTtcblxuICAgICAgICAgICAgbGV0IHRyYW5zZm9ybSA9IHRoaXMuZ2V0VHJhbnNmb3JtKCk7XG4gICAgICAgICAgICB0cmFuc2Zvcm0uc2V0VHJhbnNsYXRlKGxlZnQsIHRvcCk7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlV2lyZXModHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBvbiBldmVyeSBtb3VzZSB1cCBvbiB0aGlzIGVsZW1lbnRcbiAgICAgKiBwcm92aWRlcyB0aGUgXCJjbGlja1wiIGZ1bmN0aW9uYWxpdHkgYW5kIGNhbGxzIHRoZSBvbkRyb3AgaGFuZGxlciBmb3IgdGhlIFwiZHJhZyBhbmQgZHJvcFwiIGZ1bmN0aW9uYWxpdHlcbiAgICAgKiBAcGFyYW0gIHtqUXVlcnkuTW91c2VFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlVXAoZXZlbnQpIHtcbiAgICAgICAgaWYoZXZlbnQud2hpY2ggPT09IDEpIHtcbiAgICAgICAgICAgIGlmKHRoaXMubW91c2VNb3ZlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25Ecm9wKGV2ZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsaWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQud2hpY2ggPT09IDIgKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2xpY2tNaWRkbGUoZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdmdPYmouJGVsLnJlbW92ZUNsYXNzKCdncmFiYmVkJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2FsbGVkIGJ5IG9uTW91c2VVcCB3aGVuIHRoZSBtb3VzZSBoYXMgYmVlbiBtb3ZlZCBiZXR3ZWVuIG9uTW91c2VEb3duIGFuZCBvbk1vdXNlVXBcbiAgICAgKlxuICAgICAqIGFwcGxpZXMgZ3JpZCBzbmFwcGluZyBvZiB0aGUgZWxlbWVudCBvbiB0aGUgZW5kIG9mIHRoZSBcImRyYWcgYW5kIGRyb3BcIiBhY3Rpb25cbiAgICAgKiBAcGFyYW0gIHtqUXVlcnkuTW91c2VFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvbkRyb3AoZXZlbnQpIHtcbiAgICAgICAgbGV0IHtwYWdlWCwgcGFnZVl9ID0gdGhpcy5wYXJlbnRTVkcudmlld2JveC50cmFuc2Zvcm1FdmVudChldmVudClcblxuICAgICAgICBsZXQgbGVmdCA9IHBhZ2VYIC0gdGhpcy5vZmZzZXQueDtcbiAgICAgICAgbGV0IHRvcCA9IHBhZ2VZIC0gdGhpcy5vZmZzZXQueTtcblxuICAgICAgICBsZWZ0ID0gdGhpcy5wYXJlbnRTVkcuc25hcFRvR3JpZChsZWZ0KTtcbiAgICAgICAgdG9wID0gdGhpcy5wYXJlbnRTVkcuc25hcFRvR3JpZCh0b3ApO1xuXG4gICAgICAgIGxldCB0cmFuc2Zvcm0gPSB0aGlzLmdldFRyYW5zZm9ybSgpO1xuICAgICAgICB0cmFuc2Zvcm0uc2V0VHJhbnNsYXRlKGxlZnQsIHRvcCk7XG5cbiAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0odHJhbnNmb3JtKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZVdpcmVzKCk7XG5cbiAgICAgICAgLy8gaWYgdHV0b3JpYWwgZXhpc3RzLCBjYWxsIHR1dG9yaWFsIGNhbGxiYWNrXG4gICAgICAgIGlmKHRoaXMucGFyZW50U1ZHLnR1dG9yaWFsKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudFNWRy50dXRvcmlhbC5vbkJveE1vdmVkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBlbXB0eSBmdW5jdGlvbiwgd2lsbCBiZSByZWRlZmluZWQgaW4gSW5wdXRCb3hcbiAgICAgKi9cbiAgICBvbkNsaWNrKCkge31cblxuICAgIC8qKlxuICAgICAqIGN1c3RvbSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgbWlkZGxlIGNsaWNrIHRoYXQgcm90YXRlcyB0aGUgYm94IGJ5IDkwIGRlZ3JlZXMgdG8gdGhlIHJpZ2h0XG4gICAgICovXG4gICAgb25DbGlja01pZGRsZShldmVudCkge1xuICAgICAgICBpZihldmVudC5jdHJsS2V5KSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0ZShmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0ZSh0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYWxsIHdpcmVzIGNvbm5lY3RlZCB0byB0aGlzIGJveC4gSXRlcmF0ZXMgb3ZlciBhbGwgd2lyZXMgdGhhdCBhcmUgY29ubmVjdGVkIHRvIHRoaXMgYm94XG4gICAgICogYW5kIGNhbGxzIHJvdXRlV2lyZSAob3IgdGVtcG9yYXJ5V2lyZSBpZiB0aGUgYHRlbXBvcmFyeWAgcGFyYW1ldGVyIGlzIHNldCB0byB0cnVlKSB0byB1cGRhdGUgdGhlIHdpcmUgcm91dGluZ1xuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IFt0ZW1wb3Jhcnk9ZmFsc2VdIFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICB1cGRhdGVXaXJlcyh0ZW1wb3JhcnkgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmNvbm5lY3RvcnMuZm9yRWFjaChjb25uID0+IHtcbiAgICAgICAgICAgIGNvbm4ud2lyZUlkcy5mb3JFYWNoKHdpcmVJZCA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHdpcmUgPSB0aGlzLnBhcmVudFNWRy5nZXRXaXJlQnlJZCh3aXJlSWQpO1xuICAgICAgICAgICAgICAgIGlmKHRlbXBvcmFyeSkge1xuICAgICAgICAgICAgICAgICAgICB3aXJlLnRlbXBvcmFyeVdpcmUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aXJlLnJvdXRlV2lyZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgfVxufVxuIiwiaW1wb3J0IE5ldHdvcmtFbGVtZW50IGZyb20gJy4vTmV0d29ya0VsZW1lbnQnO1xuaW1wb3J0IHtSZWN0YW5nbGV9IGZyb20gJy4uL3N2Z09iamVjdHMnXG5pbXBvcnQgTG9naWMgZnJvbSAnLi4vTG9naWMnXG5cbmltcG9ydCBzdGF0ZUNsYXNzZXMgZnJvbSAnLi9zdGF0ZUNsYXNzZXMnXG5cbi8qKiBAbW9kdWxlIGVkaXRvckVsZW1lbnRzLkNvbm5lY3RvciAqL1xuXG4vKipcbiAqIHBhcmVudCBjbGFzcyBmb3IgaW5wdXQgYW5kIG91dHB1dCBjb25uZWN0b3JzXG4gKiBAZXh0ZW5kcyBOZXR3b3JrRWxlbWVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb25uZWN0b3IgZXh0ZW5kcyBOZXR3b3JrRWxlbWVudCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDYW52YXN9IHBhcmVudFNWRyBsaW5rIHRvIHRoZSB7QGxpbmsgQ2FudmFzfSBpbnN0YW5jZSB0aGF0IHRoaXMgY29ubmVjdG9yIHdpbGwgYmVsb25nIHRvXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdyaWRTaXplICBzaXplIG9mIHRoZSBncmlkIGluIFNWRyBwaXhlbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVmdCAgICAgIGhvcml6b250YWwgcG9zaXRpb24gZGVmaW5lZCBpbiBncmlkIHVuaXRzIChTVkcgcGl4ZWxzIGRpdmlkZWQgYnkgdGhlIGdyaWQgc2l6ZSlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9wICAgICAgIHZlcnRpY2FsIHBvc2l0aW9uIGRlZmluZWQgaW4gZ3JpZCB1bml0cyAoU1ZHIHBpeGVscyBkaXZpZGVkIGJ5IHRoZSBncmlkIHNpemUpXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGFyZW50U1ZHLCBsZWZ0LCB0b3ApIHtcbiAgICAgICAgc3VwZXIocGFyZW50U1ZHKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2l6ZSBvZiB0aGUgZ3JpZCBpbiBTVkcgcGl4ZWxzXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdyaWRTaXplID0gcGFyZW50U1ZHLmdyaWRTaXplO1xuICAgICAgICAvKipcbiAgICAgICAgICogc2l6ZSBvZiB0aGUgY29ubmVjdG9yIGluIFNWRyBwaXhlbHNcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29ubmVjdG9yU2l6ZSA9IHBhcmVudFNWRy5ncmlkU2l6ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG9mZnNldCBvZiB0aGUgY29ubmVjdG9yIGZyb20gdGhlIGdyaWQgaW4gU1ZHIHBpeGVsc1xuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb25uZWN0b3JPZmZzZXQgPSB0aGlzLmNvbm5lY3RvclNpemUgLyAyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpbnN0YW5jZSBvZiB7QGxpbmsgc3ZnT2JqZWN0cy5zdmdPYmp9IHRoYXQgaG9sZHMgYWxsIFNWRyBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIGNvbm5lY3RvclxuICAgICAgICAgKiBAdHlwZSB7c3ZnT2JqfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdmdPYmogPSBuZXcgUmVjdGFuZ2xlKFxuICAgICAgICAgICAgbGVmdCAqIHRoaXMuZ3JpZFNpemUgLSB0aGlzLmNvbm5lY3Rvck9mZnNldCxcbiAgICAgICAgICAgIHRvcCAqIHRoaXMuZ3JpZFNpemUgLSB0aGlzLmNvbm5lY3Rvck9mZnNldCxcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yU2l6ZSxcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yU2l6ZSxcbiAgICAgICAgICAgIFwibm9uZVwiLFxuICAgICAgICAgICAgXCJibGFja1wiXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5zdmdPYmouJGVsLmFkZENsYXNzKFwiY29ubmVjdG9yXCIpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aGlzIGZsYWcgZGVzY3JpYmVzIHdoZXRoZXIgdGhpcyBjb25uZWN0b3IgaXMgYW4gaW5wdXQgY29ubmVjdG9yXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0lucHV0Q29ubmVjdG9yID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGN1cnJlbnQgbG9naWNhbCBzdGF0ZSBvZiB0aGlzIGNvbm5lY3RvclxuICAgICAgICAgKiBAdHlwZSB7TG9naWMuc3RhdGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVsZW1lbnRTdGF0ZSA9IExvZ2ljLnN0YXRlLnVua25vd247XG4gICAgICAgIHRoaXMuc3ZnT2JqLmFkZENsYXNzKHN0YXRlQ2xhc3Nlc1tMb2dpYy5zdGF0ZS51bmtub3duXSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCBvZiBpZHMgb2YgYWxsIHdpcmVzIGNvbm5lY3RlZCB0byB0aGlzIGNvbm5lY3RvclxuICAgICAgICAgKiBAdHlwZSB7U2V0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53aXJlSWRzID0gbmV3IFNldCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHdoZXRoZXIgdGhpcyBjb25uZWN0b3IgaXMgYW4gb3V0cHV0IGNvbm5lY3RvclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGlzT3V0cHV0Q29ubmVjdG9yKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNJbnB1dENvbm5lY3RvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB3aGV0aGVyIHRoaXMgY29ubmVjdG9yIGlzIGFuIG91dHB1dCBjb25uZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNldCBpc091dHB1dENvbm5lY3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLmlzSW5wdXRDb25uZWN0b3IgPSAhdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWRkIGEgd2lyZSBpZCB0byB0aGUgbGlzdCBvZiB3aXJlIGlkc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3aXJlSWRcbiAgICAgKi9cbiAgICBhZGRXaXJlSWQod2lyZUlkKSB7XG4gICAgICAgIHRoaXMud2lyZUlkcy5hZGQod2lyZUlkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgYSB3aXJlIGlkIGZyb20gdGhlIGxpc3Qgb2Ygd2lyZSBpZHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2lyZUlkXG4gICAgICovXG4gICAgcmVtb3ZlV2lyZUlkKHdpcmVJZCkge1xuICAgICAgICB0aGlzLndpcmVJZHMuZGVsZXRlKHdpcmVJZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIGEgd2lyZSBzcGVjaWZpZWQgYnkgSUQgYW5kIHVwZGF0ZSB0aGUgY29ubmVjdG9yXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB3aXJlSWQgSUQgb2YgdGhlIHdpcmUgdG8gYmUgcmVtb3ZlZFxuICAgICAqL1xuICAgIHJlbW92ZVdpcmVJZEFuZFVwZGF0ZSh3aXJlSWQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVXaXJlSWQod2lyZUlkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgbG9naWNhbCBzdGF0ZSBvZiB0aGUgY29ubmVjdG9yXG4gICAgICogQHBhcmFtIHtMb2dpYy5zdGF0ZX0gc3RhdGUgbmV3IHN0YXRlIG9mIHRoZSBjb25uZWN0b3JcbiAgICAgKi9cbiAgICBzZXRTdGF0ZShzdGF0ZSkge1xuICAgICAgICB0aGlzLnN2Z09iai5yZW1vdmVDbGFzc2VzKC4uLnN0YXRlQ2xhc3Nlcyk7XG4gICAgICAgIHRoaXMuc3ZnT2JqLmFkZENsYXNzKHN0YXRlQ2xhc3Nlc1tzdGF0ZV0pO1xuXG4gICAgICAgIHRoaXMuZWxlbWVudFN0YXRlID0gc3RhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHN0YXRlIG9mIHRoaXMgY29ubmVjdG9yXG4gICAgICogQHJldHVybiB7TG9naWMuc3RhdGV9XG4gICAgICovXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50U3RhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHN2Z09iaiBpbnN0YW5jZSBjb250ZW50IG9mIHRoaXMgY29ubmVjdG9yXG4gICAgICogQHJldHVybiB7c3ZnT2JqZWN0cy5SZWN0YW5nbGV9XG4gICAgICovXG4gICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdmdPYmo7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2FsbCBbd2lyZUNyZWF0aW9uSGVscGVyXSguL21vZHVsZS1DYW52YXMuaHRtbCN3aXJlQ3JlYXRpb25IZWxwZXIpIG9uIG1vdXNlIHVwXG4gICAgICovXG4gICAgb25Nb3VzZVVwKGV2ZW50KSB7XG4gICAgICAgIC8vIG9ubHkgbGVmdCBjbGljayBjb3VudHNcbiAgICAgICAgaWYoZXZlbnQud2hpY2ggPT09IDEpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gdGhpcy5wYXJlbnRTVkcudmlld2JveC50cmFuc2Zvcm1FdmVudChldmVudCk7XG5cbiAgICAgICAgICAgIGNvbnN0IG1vdXNlUG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeDogZXZlbnQucGFnZVgsXG4gICAgICAgICAgICAgICAgeTogZXZlbnQucGFnZVlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5wYXJlbnRTVkcud2lyZUNyZWF0aW9uSGVscGVyKHRoaXMuc3ZnT2JqLmlkLCBtb3VzZVBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCBMb2dpYyBmcm9tICcuLi9Mb2dpYydcblxuaW1wb3J0IEJveCBmcm9tICcuL0JveCdcblxuLyoqIEBtb2R1bGUgZWRpdG9yRWxlbWVudHMuR2F0ZSAqL1xuXG4vKipcbiAqIEdhdGUgaXMgYSBib3ggdGhhdCBwcm9jZXNzZXMgdGhlIHN0YXRlcyBvZiBpdHMgaW5wdXQgY29ubmVjdG9ycyBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGluIGl0cyBvdXRwdXQgY29ubmVjdG9ycy5cbiAqIEBleHRlbmRzIEJveFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHYXRlIGV4dGVuZHMgQm94IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0NhbnZhc30gcGFyZW50U1ZHICBpbnN0YW5jZSBvZiBbQ2FudmFzXSguL21vZHVsZS1DYW52YXMuaHRtbClcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAgICAgICBuYW1lIG9mIHRoZSBnYXRlIChhbmQsIG5vdCwgeG9yLi4uKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudFNWRywgbmFtZSkge1xuICAgICAgICBjb25zdCB3aWR0aCA9IDk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IDQ7XG5cbiAgICAgICAgc3VwZXIocGFyZW50U1ZHLCBuYW1lLCBcImdhdGVcIiwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgLy8gQUREIENPTk5FQ1RPUlNcblxuICAgICAgICBsZXQgc3BlY2lhbE5vZGVzID0gW107XG5cbiAgICAgICAgLy8gb3V0cHV0XG4gICAgICAgIHRoaXMuYWRkQ29ubmVjdG9yKHdpZHRoLCBoZWlnaHQgLyAyLCBmYWxzZSk7XG5cbiAgICAgICAgLy8gYmxvY2sgdGhlIG91dHB1dCBjb25uZWN0b3JcbiAgICAgICAgc3BlY2lhbE5vZGVzLnB1c2goe1xuICAgICAgICAgICAgeDogd2lkdGgsXG4gICAgICAgICAgICB5OiBoZWlnaHQgLyAyXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmKHRoaXMubmFtZT09PVwibm90XCIgfHwgdGhpcy5uYW1lPT09XCJyZXBlYXRlclwiKSB7XG4gICAgICAgICAgICAvLyBpbnB1dFxuICAgICAgICAgICAgdGhpcy5hZGRDb25uZWN0b3IoMCwgaGVpZ2h0IC8gMiwgdHJ1ZSk7XG4gICAgICAgICAgICAvLyBibG9jayB0aGUgaW5wdXQgY29ubmVjdG9yXG4gICAgICAgICAgICBzcGVjaWFsTm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiBoZWlnaHQgLyAyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlucHV0XG4gICAgICAgICAgICB0aGlzLmFkZENvbm5lY3RvcigwLCBoZWlnaHQgLyA0LCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuYWRkQ29ubmVjdG9yKDAsIGhlaWdodCAvICg0LzMpLCB0cnVlKTtcblxuICAgICAgICAgICAgLy8gYmxvY2sgdGhlIGlucHV0IGNvbm5lY3RvcnNcbiAgICAgICAgICAgIHNwZWNpYWxOb2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IGhlaWdodCAvIDRcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBzcGVjaWFsTm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiBoZWlnaHQgLyAoNC8zKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGFkZCBvbmUgYmxvY2tlZCBub2RlIGJldHdlZW4gdGhlIGlucHV0cyAoZm9yIGJldHRlciBsb29raW5nIHdpcmluZylcbiAgICAgICAgICAgIHNwZWNpYWxOb2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IGhlaWdodCAvIDJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5nZW5lcmF0ZUJsb2NrTm9kZXMoLi4uc3BlY2lhbE5vZGVzKTtcblxuICAgICAgICB0aGlzLnJlZnJlc2hTdGF0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFycmF5IG9mIHZhbGlkIGdhdGUgbmFtZXNcbiAgICAgKiBAdHlwZSB7U2V0fVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgdmFsaWRHYXRlcygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXQoW1wibm90XCIsIFwiYW5kXCIsIFwib3JcIiwgXCJuYW5kXCIsIFwibm9yXCIsIFwieG9yXCIsIFwieG5vclwiLCBcInJlcGVhdGVyXCJdKTtcbiAgICB9XG5cbiAgICBnZW5lcmF0ZUJsb2NrTm9kZXMoLi4uc3BlY2lhbE5vZGVzKSB7XG4gICAgICAgIGlmKHNwZWNpYWxOb2RlcyE9PXVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3VwZXIuZ2VuZXJhdGVCbG9ja05vZGVzKDAsIDEsIDAsIDEsIC4uLnNwZWNpYWxOb2Rlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdXBlci5nZW5lcmF0ZUJsb2NrTm9kZXMoMCwgMSwgMCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwcm9jY2VzcyB0aGUgaW5wdXQgY29ubmVjdG9yIHN0YXRlcyBhbmQgcmVmbGVjdCB0aGVtIGluIHRoZSBvdXRwdXQgY29ubmVjdG9yIHN0YXRlcyBhY2NvcmRpbmdcbiAgICAgKiB0byB0aGUgbG9naWMgY29ycmVzcG9uZGluZyB0byB0aGlzIGdhdGUncyBuYW1lXG4gICAgICovXG4gICAgcmVmcmVzaFN0YXRlKCkge1xuICAgICAgICAvLyBtYXAgZ2F0ZSBuYW1lcyB0byB0aGVpciBsb2dpYyBmdW5jdGlvbnNcbiAgICAgICAgY29uc3Qgc3RhdGVNYXAgPSB7XG4gICAgICAgICAgICBcImFuZFwiOiAoKSA9PiBMb2dpYy5hbmQodGhpcy5jb25uZWN0b3JzWzFdLnN0YXRlLCB0aGlzLmNvbm5lY3RvcnNbMl0uc3RhdGUpLFxuICAgICAgICAgICAgXCJuYW5kXCI6ICgpID0+IExvZ2ljLm5hbmQodGhpcy5jb25uZWN0b3JzWzFdLnN0YXRlLCB0aGlzLmNvbm5lY3RvcnNbMl0uc3RhdGUpLFxuICAgICAgICAgICAgXCJub3JcIjogKCkgPT4gTG9naWMubm9yKHRoaXMuY29ubmVjdG9yc1sxXS5zdGF0ZSwgdGhpcy5jb25uZWN0b3JzWzJdLnN0YXRlKSxcbiAgICAgICAgICAgIFwibm90XCI6ICgpID0+IExvZ2ljLm5vdCh0aGlzLmNvbm5lY3RvcnNbMV0uc3RhdGUpLFxuICAgICAgICAgICAgXCJvclwiOiAoKSA9PiBMb2dpYy5vcih0aGlzLmNvbm5lY3RvcnNbMV0uc3RhdGUsIHRoaXMuY29ubmVjdG9yc1syXS5zdGF0ZSksXG4gICAgICAgICAgICBcInhub3JcIjogKCkgPT4gTG9naWMueG5vcih0aGlzLmNvbm5lY3RvcnNbMV0uc3RhdGUsIHRoaXMuY29ubmVjdG9yc1syXS5zdGF0ZSksXG4gICAgICAgICAgICBcInhvclwiOiAoKSA9PiBMb2dpYy54b3IodGhpcy5jb25uZWN0b3JzWzFdLnN0YXRlLCB0aGlzLmNvbm5lY3RvcnNbMl0uc3RhdGUpLFxuICAgICAgICAgICAgXCJyZXBlYXRlclwiOiAoKSA9PiB0aGlzLmNvbm5lY3RvcnNbMV0uc3RhdGVcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzdGF0ZSA9IExvZ2ljLnN0YXRlLnVua25vd25cblxuICAgICAgICBpZihzdGF0ZU1hcFt0aGlzLm5hbWVdKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlTWFwW3RoaXMubmFtZV0oKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm90aWZ5IHRoZSBzaW11bGF0b3IgYWJvdXQgdGhpcyBjaGFuZ2VcbiAgICAgICAgdGhpcy5wYXJlbnRTVkcuc2ltdWxhdGlvbi5ub3RpZnlDaGFuZ2UodGhpcy5jb25uZWN0b3JzWzBdLmlkLCBzdGF0ZSlcbiAgICB9XG59XG4iLCJpbXBvcnQge1BvbHlMaW5lLCBQb2x5TGluZVBvaW50cywgUG9seUxpbmVQb2ludH0gZnJvbSAnLi4vc3ZnT2JqZWN0cydcblxuaW1wb3J0IE5ldHdvcmtFbGVtZW50IGZyb20gJy4vTmV0d29ya0VsZW1lbnQnXG5cbi8qKiBAbW9kdWxlIGVkaXRvckVsZW1lbnRzLkhlbHBlcldpcmUgKi9cblxuLyoqXG4gKiBBIHRlbXBvcmFyeSB3aXJlIHRoYXQgaXMgY29ubmVjdGluZyBhIHtAbGluayBDb25uZWN0b3J9IHdpdGggYSBtb3VzZSBwb2ludGVyIHdoZW4gdXNlciBjcmVhdGVzIGEgd2lyZS5cbiAqIEBleHRlbmRzIE5ldHdvcmtFbGVtZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhlbHBlcldpcmUgZXh0ZW5kcyBOZXR3b3JrRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50U1ZHLCBmcm9tSWQsIG1vdXNlUG9zaXRpb24pIHtcbiAgICAgICAgc3VwZXIocGFyZW50U1ZHKTtcblxuICAgICAgICBjb25zdCBjb25uZWN0b3IgPSB0aGlzLnBhcmVudFNWRy5nZXRDb25uZWN0b3JCeUlkKGZyb21JZCk7XG4gICAgICAgIHRoaXMuY29ubmVjdG9yUG9zaXRpb24gPSB0aGlzLnBhcmVudFNWRy5nZXRDb25uZWN0b3JQb3NpdGlvbihjb25uZWN0b3IsIHRydWUpO1xuXG4gICAgICAgIGNvbnN0IGZyb20gPSBuZXcgUG9seUxpbmVQb2ludCh0aGlzLmNvbm5lY3RvclBvc2l0aW9uLngsIHRoaXMuY29ubmVjdG9yUG9zaXRpb24ueSk7XG4gICAgICAgIGNvbnN0IHRvID0gbmV3IFBvbHlMaW5lUG9pbnQobW91c2VQb3NpdGlvbi54LCBtb3VzZVBvc2l0aW9uLnkpO1xuXG4gICAgICAgIGNvbnN0IHBvaW50cyA9IG5ldyBQb2x5TGluZVBvaW50cyhbZnJvbSwgdG9dKTtcblxuICAgICAgICB0aGlzLnN2Z09iaiA9IG5ldyBQb2x5TGluZShwb2ludHMsIDIsIFwiIzhiOGI4YlwiKTtcbiAgICB9XG5cbiAgICB1cGRhdGVNb3VzZVBvc2l0aW9uKG1vdXNlUG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgZnJvbSA9IG5ldyBQb2x5TGluZVBvaW50KHRoaXMuY29ubmVjdG9yUG9zaXRpb24ueCwgdGhpcy5jb25uZWN0b3JQb3NpdGlvbi55KTtcbiAgICAgICAgY29uc3QgdG8gPSBuZXcgUG9seUxpbmVQb2ludChtb3VzZVBvc2l0aW9uLngsIG1vdXNlUG9zaXRpb24ueSk7XG5cbiAgICAgICAgY29uc3QgcG9pbnRzID0gbmV3IFBvbHlMaW5lUG9pbnRzKFtmcm9tLCB0b10pO1xuXG4gICAgICAgIHRoaXMuc3ZnT2JqLnVwZGF0ZVBvaW50cyhwb2ludHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgalF1ZXJ5IGVsZW1lbnQgZm9yIHRoaXMgaGVscGVyIHdpcmVcbiAgICAgKiBAcmV0dXJuIHtqUXVlcnkuZWxlbWVudH1cbiAgICAgKi9cbiAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN2Z09iai5nZXQoKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgTG9naWMgZnJvbSAnLi4vTG9naWMnXG5cbmltcG9ydCBCb3ggZnJvbSAnLi9Cb3gnXG5cbi8qKiBAbW9kdWxlIGVkaXRvckVsZW1lbnRzLklucHV0Qm94ICovXG5cbi8qKlxuICogSW5wdXRCb3ggaGFzIG9ubHkgb3V0cHV0IGNvbm5lY3RvcnMgYW5kIGlzIHVzZWQgdG8gc2V0IHRoZSBpbnB1dCBzdGF0ZXMgZm9yIHRoZSBsb2dpYyBuZXR3b3JrLlxuICogQGV4dGVuZHMgQm94XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElucHV0Qm94IGV4dGVuZHMgQm94IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0NhbnZhc30gcGFyZW50U1ZHICBpbnN0YW5jZSBvZiBbQ2FudmFzXSguL21vZHVsZS1DYW52YXMuaHRtbClcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpc09uPWZhbHNlXSB0aGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgaW5wdXRib3ggKGB0cnVlYCBpcyAqb24qLCBgZmFsc2VgIGlzICpvZmYqKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudFNWRywgaXNPbiA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGdyaWRXaWR0aCA9IDc7XG4gICAgICAgIGNvbnN0IGdyaWRIZWlnaHQgPSA0O1xuXG4gICAgICAgIHN1cGVyKHBhcmVudFNWRywgXCJpbnB1dFwiLCBcIm90aGVyXCIsIGdyaWRXaWR0aCwgZ3JpZEhlaWdodCk7XG5cbiAgICAgICAgdGhpcy5hZGRDb25uZWN0b3IoZ3JpZFdpZHRoLCBncmlkSGVpZ2h0IC8gMiwgZmFsc2UpO1xuXG4gICAgICAgIHRoaXMub24gPSBpc09uO1xuXG4gICAgICAgIHRoaXMuZ2VuZXJhdGVCbG9ja05vZGVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IGRhdGEgb2YgdGhpcyBpbnB1dCBib3ggYXMgYSBKU09OLXJlYWR5IG9iamVjdFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gamF2YXNjcmlwdCBvYmplY3QgY29udGFpbmluZyBlc3NlbnRpYWwgZGF0YSBmb3IgdGhpcyBpbnB1dCBib3hcbiAgICAgKi9cbiAgICBnZXQgZXhwb3J0RGF0YSgpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBzdXBlci5leHBvcnREYXRhO1xuICAgICAgICBkYXRhLmlzT24gPSB0aGlzLmlzT247XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZ2VuZXJhdGVCbG9ja05vZGVzKCkge1xuICAgICAgICAvLyBibG9jayB0aGUgaW5wdXQgY29ubmVjdG9yIG5vZGVcbiAgICAgICAgY29uc3Qgc3BlY2lhbE5vZGUgPSB7XG4gICAgICAgICAgICB4OiB0aGlzLmdyaWRXaWR0aCxcbiAgICAgICAgICAgIHk6IHRoaXMuZ3JpZEhlaWdodCAvIDJcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5nZW5lcmF0ZUJsb2NrTm9kZXMoMCwgMSwgMSwgMCwgc3BlY2lhbE5vZGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHN0YXJ0IGEgbmV3IHNpbXVsYXRpb24gZnJvbSB0aGUgb3V0cHV0IGNvbm5lY3RvclxuICAgICAqL1xuICAgIHJlZnJlc2hTdGF0ZSgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnRTVkcuc3RhcnROZXdTaW11bGF0aW9uKHRoaXMuY29ubmVjdG9yc1swXSwgdGhpcy5jb25uZWN0b3JzWzBdLnN0YXRlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldCB0aGUgc3RhdGUgb2YgdGhlIGlucHV0Ym94IHRvIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gaXNPbiBzZXQgdG8gKm9uKiBpZiBgdHJ1ZWAsIHNldCB0byAqb2ZmKiBpZiBgZmFsc2VgXG4gICAgICovXG4gICAgc2V0IG9uKGlzT24pIHtcbiAgICAgICAgaWYgKGlzT24pIHtcbiAgICAgICAgICAgIC8vIHR1cm4gb25cbiAgICAgICAgICAgIHRoaXMuY2hhbmdlSW1hZ2UoXCJvblwiKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yc1swXS5zZXRTdGF0ZShMb2dpYy5zdGF0ZS5vbik7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hTdGF0ZSgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0dXJuIG9mZlxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VJbWFnZSgpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3JzWzBdLnNldFN0YXRlKExvZ2ljLnN0YXRlLm9mZik7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hTdGF0ZSgpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzT24gPSBpc09uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgc3RhdGUgb2YgdGhlIGlucHV0Ym94IChgdHJ1ZWAgaWYgKm9uKiwgYGZhbHNlYCBpZiAqb2ZmKilcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBbZGVzY3JpcHRpb25dXG4gICAgICovXG4gICAgZ2V0IG9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc09uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRvZ2dsZSB0aGUgc3RhdGUgb2YgdGhlIGlucHV0Ym94XG4gICAgICovXG4gICAgb25DbGljaygpIHtcbiAgICAgICAgdGhpcy5vbiA9ICF0aGlzLm9uO1xuXG4gICAgICAgIGlmKHRoaXMucGFyZW50U1ZHLnR1dG9yaWFsKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudFNWRy50dXRvcmlhbC5vbkNoYW5nZUlucHV0Qm94U3RhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCBDb25uZWN0b3IgZnJvbSAnLi9Db25uZWN0b3InXG5pbXBvcnQgTG9naWMgZnJvbSAnLi4vTG9naWMnXG5cbi8qKiBAbW9kdWxlIGVkaXRvckVsZW1lbnRzLklucHV0Q29ubmVjdG9yICovXG5cbi8qKlxuICogQ29ubmVjdG9yIHRoYXQgZ2V0cyBpdHMgc3RhdGUgZnJvbSBhIGNvbm5lY3RlZCB2YWx1ZSBhbmQgcGFzc2VzIGl0IHRocm91Z2ggdG8gdGhlIHtAbGluayBCb3h9IHRoaXMgY29ubmVjdG9yIGJlbG9uZ3MgdG8uXG4gKiBAZXh0ZW5kcyBDb25uZWN0b3JcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5wdXRDb25uZWN0b3IgZXh0ZW5kcyBDb25uZWN0b3Ige1xuICAgIC8qKlxuICAgICAqIENhbGwgdGhlIGNvbnN0cnVjdG9yIGZyb20gdGhlIHBhcmVudCB7QGxpbmsgQ29ubmVjdG9yfSBjbGFzcyBhbmQgc2V0IGlzSW5wdXRDb25uZWN0b3IgdG8gdHJ1ZS5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc30gcGFyZW50U1ZHIGxpbmsgdG8gdGhlIHtAbGluayBDYW52YXN9IGluc3RhbmNlIHRoYXQgdGhpcyBjb25uZWN0b3Igd2lsbCBiZWxvbmcgdG9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVmdCAgICAgIGhvcml6b250YWwgcG9zaXRpb24gZGVmaW5lZCBpbiBncmlkIHVuaXRzIChTVkcgcGl4ZWxzIGRpdmlkZWQgYnkgdGhlIGdyaWQgc2l6ZSlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9wICAgICAgIHZlcnRpY2FsIHBvc2l0aW9uIGRlZmluZWQgaW4gZ3JpZCB1bml0cyAoU1ZHIHBpeGVscyBkaXZpZGVkIGJ5IHRoZSBncmlkIHNpemUpXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGFyZW50U1ZHLCBsZWZ0LCB0b3ApIHtcbiAgICAgICAgc3VwZXIocGFyZW50U1ZHLCBsZWZ0LCB0b3ApO1xuXG4gICAgICAgIHRoaXMuaXNJbnB1dENvbm5lY3RvciA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbCB0aGUgc2V0U3RhdGUgbWV0aG9kIG9mIHtAbGluayBDb25uZWN0b3J9IGFuZCB0aGFuIHJlZnJlc2ggdGhlIHN0YXRlIG9mIHRoZSBjb25uZWN0ZWQge0BsaW5rIEJveH1cbiAgICAgKiBAcGFyYW0ge0xvZ2ljLnN0YXRlfSBzdGF0ZSBuZXcge0BsaW5rIExvZ2ljLnN0YXRlfSBvZiB0aGUgY29ubmVjdG9yXG4gICAgICovXG4gICAgc2V0U3RhdGUoc3RhdGUpIHtcbiAgICAgICAgc3VwZXIuc2V0U3RhdGUoc3RhdGUpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlNFVCBTVEFURSBPTiBJQ1wiLCB0aGlzLmlkLCBcIjpcIiwgc3RhdGUpXG5cbiAgICAgICAgbGV0IGJveCA9IHRoaXMucGFyZW50U1ZHLmdldEJveEJ5Q29ubmVjdG9ySWQodGhpcy5zdmdPYmouaWQpO1xuICAgICAgICBib3gucmVmcmVzaFN0YXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIHRoZSB3aXJlIChieSBjYWxsaW5nIHRoZSByZW1vdmVXaXJlSWRBbmRVcGRhdGUgb2Yge0BsaW5rIENvbm5lY3Rvcn0pXG4gICAgICogYW5kIHVwZGF0ZSBzdGF0ZSBvZiB0aGlzIGNvbm5lY3RvciBieSBzZXR0aW5nIGl0IHRvIHVuZGVmaW5lZCB1c2luZyB0aGUgc2V0U3RhdGUgbWV0aG9kXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB3aXJlSWQgSUQgb2YgdGhlIHtAbGluayBXaXJlfVxuICAgICAqL1xuICAgIHJlbW92ZVdpcmVJZEFuZFVwZGF0ZSh3aXJlSWQpIHtcbiAgICAgICAgc3VwZXIucmVtb3ZlV2lyZUlkQW5kVXBkYXRlKHdpcmVJZCk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoTG9naWMuc3RhdGUudW5rbm93bik7XG4gICAgfVxufVxuIiwiLyoqIEBtb2R1bGUgZWRpdG9yRWxlbWVudHMuTmV0d29ya0VsZW1lbnQgKi9cblxuLyoqXG4gKiBwYXJlbnQgY2xhc3MgZm9yIGFsbCBuZXR3b3JrIGVsZW1lbnRzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5ldHdvcmtFbGVtZW50IHtcbiAgICAvKipcbiAgICAgKiBCYXNpYyBjb25zdHJ1Y3RvciBmb3IgTmV0d29ya0VsZW1lbnRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc30gcGFyZW50U1ZHIHJlZmVyZW5jZSB0byB0aGUgaW5zdGFuY2Ugb2Yge0BsaW5rIENhbnZhc30gdGhhdCB0aGlzIGVsZW1lbnQgYmVsb25ncyB0b1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudFNWRykge1xuICAgICAgICBpZighcGFyZW50U1ZHKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiUGFyZW50IFNWRyBlbGVtZW50IGhhcyB0byBiZSBkZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmVudFNWRyA9IHBhcmVudFNWRztcblxuICAgICAgICAvLyB1c2VkIHRvIHN0b3JlIHRoZSBzdmpPYmplY3QncyBpbnN0YW5jZSBvZiB0aGlzIGVsZW1lbnRcbiAgICAgICAgdGhpcy5zdmdPYmogPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB1bmlxdWUgSUQgb2YgdGhlIFNWRyBlbGVtZW50IHRpZWQgdG8gdGhpcyBsb2dpY2FsIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IElEIG9mIHRoZSBTVkcgZWxlbWVudFxuICAgICAqL1xuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ZnT2JqLmlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGVtcHR5IGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHByZXZlbnQgZXJyb3IgbWVzc2FnZXMsIGZ1bmN0aW9uIGlzIGltcGxlbWVudGVkIGxhdGVyIGluIHRoZSB7QGxpbmsgQm94fSBjbGFzc1xuICAgICAqL1xuICAgIG9uTW91c2VEb3duKCkge31cblxuICAgIC8qKlxuICAgICAqIGVtcHR5IGZ1bmN0aW9uIHRvIHByZXZlbnQgZXJyb3IgbWVzc2FnZXMsIGZ1bmN0aW9uIGlzIGltcGxlbWVudGVkIGxhdGVyIGluIHRoZSB7QGxpbmsgQm94fSBhbmQge0BsaW5rIENvbm5lY3Rvcn0gY2xhc3Nlc1xuICAgICAqL1xuICAgIG9uTW91c2VVcCgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBlbXB0eSBmdW5jdGlvbiB0byBwcmV2ZW50IGVycm9yIG1lc3NhZ2VzLCBmdW5jdGlvbiBpcyBpbXBsZW1lbnRlZCBsYXRlciBpbiB0aGUge0BsaW5rIEJveH0gY2xhc3NcbiAgICAgKi9cbiAgICBvbk1vdXNlTW92ZSgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBcInZpcnR1YWxcIiBnZXR0ZXIgZm9yIGpzb24gZGF0YSwgcHJpbnRzIGFuIGVycm9yIHRoYXQgaXQgaGFzIHRvIGJlIHJlZGVmaW5lZCBpbiB0aGUgZGVyaXZlZCBjbGFzc2VzXG4gICAgICovXG4gICAgZ2V0IGV4cG9ydERhdGEoKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCInanNvbicgZ2V0dGVyIGhhcyBub3QgYmVlbiBkZWZpbmVkIGZvciB0aGlzIGVsZW1lbnRcIiwgdGhpcyk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuIiwiaW1wb3J0IExvZ2ljIGZyb20gJy4uL0xvZ2ljJ1xuXG5pbXBvcnQgQm94IGZyb20gJy4vQm94J1xuXG4vKiogQG1vZHVsZSBlZGl0b3JFbGVtZW50cy5PdXRwdXRCb3ggKi9cblxuLyoqXG4gKiBPdXRwdXRCb3ggaGFzIG9ubHkgaW5wdXQgY29ubmVjdG9ycyBhbmQgaXMgdXNlZCB0byB2aXN1YWxpemUgdGhlIG91dHB1dCBzdGF0ZXMgb2YgdGhlIGxvZ2ljIG5ldHdvcmsuXG4gKiBAZXh0ZW5kcyBCb3hcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3V0cHV0Qm94IGV4dGVuZHMgQm94IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0NhbnZhc30gcGFyZW50U1ZHICBpbnN0YW5jZSBvZiBbQ2FudmFzXSguL21vZHVsZS1DYW52YXMuaHRtbClcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXJlbnRTVkcpIHtcbiAgICAgICAgY29uc3QgZ3JpZEhlaWdodCA9IDQ7XG4gICAgICAgIGNvbnN0IGdyaWRXaWR0aCA9IDU7XG5cbiAgICAgICAgc3VwZXIocGFyZW50U1ZHLCBcIm91dHB1dFwiLCBcIm90aGVyXCIsIGdyaWRXaWR0aCwgZ3JpZEhlaWdodCk7XG5cbiAgICAgICAgdGhpcy5hZGRDb25uZWN0b3IoMCwgZ3JpZEhlaWdodCAvIDIsIHRydWUpO1xuXG4gICAgICAgIHRoaXMuZ2VuZXJhdGVCbG9ja05vZGVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0IHN0YXRlIG9mIHRoaXMgb3V0cHV0IGJveCB0byBtYXRjaCB0aGUgc3RhdGUgb2YgaXRzIGlucHV0IGNvbm5lY3RvclxuICAgICAqL1xuICAgIHJlZnJlc2hTdGF0ZSgpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh0aGlzLmNvbm5lY3RvcnNbMF0uc3RhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZmxlY3QgdGhlIGlucHV0IGNvbm5lY3RvciBzdGF0ZSBpbiB0aGUgYXBwZWFyYW5jZSBvZiB0aGUgZWxlbWVudCAtIHNldFxuICAgICAqIHRoZSBlbGVtZW50IGltYWdlIHRvIHJlcHJlc2VudCB0aGUgY29ycmVzcG9uZGluZyBzdGF0ZVxuICAgICAqIEBwYXJhbSB7TG9naWMuc3RhdGV9IHN0YXRlIG5ldyBzdGF0ZSBvZiB0aGlzIG91dHB1dEJveFxuICAgICAqL1xuICAgIHNldFN0YXRlKHN0YXRlKSB7XG4gICAgICAgIGlmKHN0YXRlPT09TG9naWMuc3RhdGUub24pe1xuICAgICAgICAgICAgaWYodGhpcy5wYXJlbnRTVkcudHV0b3JpYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFNWRy50dXRvcmlhbC5vbk91dHB1dEJveFRydWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzdGF0ZU1hcCA9IHt9O1xuICAgICAgICBzdGF0ZU1hcFtMb2dpYy5zdGF0ZS5vbl0gPSBcIm9uXCJcbiAgICAgICAgc3RhdGVNYXBbTG9naWMuc3RhdGUub2ZmXSA9IFwib2ZmXCJcbiAgICAgICAgc3RhdGVNYXBbTG9naWMuc3RhdGUudW5rbm93bl0gPSBcIlwiXG4gICAgICAgIHN0YXRlTWFwW0xvZ2ljLnN0YXRlLm9zY2lsbGF0aW5nXSA9IFwib3NjXCJcblxuICAgICAgICB0aGlzLmNoYW5nZUltYWdlKHN0YXRlTWFwW3N0YXRlXSk7XG4gICAgfVxuXG4gICAgZ2VuZXJhdGVCbG9ja05vZGVzKCkge1xuICAgICAgICAvLyBibG9jayB0aGUgaW5wdXQgY29ubmVjdG9yIG5vZGVcbiAgICAgICAgY29uc3Qgc3BlY2lhbE5vZGUgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogdGhpcy5ncmlkSGVpZ2h0IC8gMlxuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmdlbmVyYXRlQmxvY2tOb2RlcygwLCAwLCAwLCAxLCBzcGVjaWFsTm9kZSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IENvbm5lY3RvciBmcm9tICcuL0Nvbm5lY3RvcidcblxuLyoqIEBtb2R1bGUgZWRpdG9yRWxlbWVudHMuT3V0cHV0Q29ubmVjdG9yICovXG5cbi8qKlxuICogQ29ubmVjdG9yIHRoYXQgdGFrZXMgYSBzdGF0ZSBkZWZpbmVkIGJ5IHRoZSB7QGxpbmsgQm94fSBpdCBiZWxvbmdzIHRvIGFuZCBwYXNzZXMgaXQgdG8gYWxsIGNvbm5lY3RlZCB3aXJlXG4gKiBAZXh0ZW5kcyBDb25uZWN0b3JcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3V0cHV0Q29ubmVjdG9yIGV4dGVuZHMgQ29ubmVjdG9yIHtcbiAgICAvKipcbiAgICAgKiBDYWxsIHRoZSBjb25zdHJ1Y3RvciBmcm9tIHRoZSBwYXJlbnQge0BsaW5rIENvbm5lY3Rvcn0gY2xhc3MgYW5kIHNldCBpc091dHB1dENvbm5lY3RvciB0byB0cnVlLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzfSBwYXJlbnRTVkcgbGluayB0byB0aGUge0BsaW5rIENhbnZhc30gaW5zdGFuY2UgdGhhdCB0aGlzIGNvbm5lY3RvciB3aWxsIGJlbG9uZyB0b1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0ICAgICAgaG9yaXpvbnRhbCBwb3NpdGlvbiBkZWZpbmVkIGluIGdyaWQgdW5pdHMgKFNWRyBwaXhlbHMgZGl2aWRlZCBieSB0aGUgZ3JpZCBzaXplKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgICAgICAgdmVydGljYWwgcG9zaXRpb24gZGVmaW5lZCBpbiBncmlkIHVuaXRzIChTVkcgcGl4ZWxzIGRpdmlkZWQgYnkgdGhlIGdyaWQgc2l6ZSlcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXJlbnRTVkcsIGxlZnQsIHRvcCkge1xuICAgICAgICBzdXBlcihwYXJlbnRTVkcsIGxlZnQsIHRvcCk7XG5cbiAgICAgICAgdGhpcy5pc091dHB1dENvbm5lY3RvciA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbCB0aGUgc2V0U3RhdGUgbWV0aG9kIG9mIHtAbGluayBDb25uZWN0b3J9IGFuZCB0aGFuIHNldCB0aGUgc3RhdGUgb2YgdGhlIGNvbm5lY3RlZCB7QGxpbmsgV2lyZX1zXG4gICAgICogQHBhcmFtIHtMb2dpYy5zdGF0ZX0gc3RhdGUgbmV3IHtAbGluayBMb2dpYy5zdGF0ZX0gb2YgdGhlIGNvbm5lY3RvclxuICAgICAqL1xuICAgIHNldFN0YXRlKHN0YXRlKSB7XG4gICAgICAgIHN1cGVyLnNldFN0YXRlKHN0YXRlKTtcblxuICAgICAgICBmb3IgKGNvbnN0IHdpcmVJZCBvZiB0aGlzLndpcmVJZHMpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50U1ZHLmdldFdpcmVCeUlkKHdpcmVJZCkuc2V0U3RhdGUoc3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyoqIEBtb2R1bGUgZWRpdG9yRWxlbWVudHMuVHJhbnNmb3JtICovXG5cbi8qKlxuICogSGVscGVyIGNsYXNzIHVzZWQgYnkge0BsaW5rIFRyYW5zZm9ybX0uXG4gKlxuICogUmVwcmVzZW50cyBvbmUgc2luZ2xlIHByb3BlcnR5IG9mIHRoZSB0cmFuc2Zvcm0gYXJndW1lbnQsIGZvciBleGFtcGxlIGB0cmFuc2xhdGUoMzYwIDE1MClgXG4gKiB0aGF0IG1heSBiZSBhIHBhcnQgb2YgbG9uZ2VyIHRyYW5zZm9ybSBhcmd1bWVudCBsaWtlIGB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMzYwIDE1MCkgcm90YXRlKDkwIDMwIDIwKVwiYFxuICovXG5jbGFzcyBQcm9wZXJ0eSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgUHJvcGVydHkgb2JqZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmddIHN0cmluZyBpbiB0aGUgcHJvcGVydHkgZm9ybWF0IGBwcm9wZXJ0eW5hbWUobGlzdCBvZiBzcGFjZSBzZXBhcmF0ZWQgdmFsdWVzKWBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzdHJpbmcpIHtcbiAgICAgICAgaWYoc3RyaW5nIT09dW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBzdHJpbmcucmVwbGFjZSgvXlsgXSooW14oXSspLiovLCBcIiQxXCIpO1xuICAgICAgICAgICAgdGhpcy5hcmdzID0gc3RyaW5nLnJlcGxhY2UoL15bXihdK1xcKCguKilcXCkvLCBcIiQxXCIpLnNwbGl0KCcgJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgb3IgcmVwbGFjZSB0aGUgbmFtZSBvZiB0aGlzIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmV3IG5hbWUgZm9yIHRoaXMgcHJvcGVydHlcbiAgICAgKi9cbiAgICBzZXROYW1lKG5hbWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgYXJndW1lbnRzIG9mIHRoaXMgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBhcmdzIGFycmF5IG9mIGFyZ3VtZW50c1xuICAgICAqL1xuICAgIHNldEFyZ3VtZW50cyhhcmdzKSB7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHByb3BlcnR5IGluIHRoZSBwcm9wZXJ0eSBmb3JtYXQgYG5hbWUoYXJnMSBhcmcyKWBcbiAgICAgKi9cbiAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyBcIihcIiArIHRoaXMuYXJncy5qb2luKFwiIFwiKSArIFwiKVwiO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBUEkgZm9yIG1hbmlwdWxhdGluZyB0aGUgdHJhbnNmb3JtIGFyZ3VtZW50IHVzZWQgaW4gU1ZHXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYW5zZm9ybSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgVHJhbnNmb3JtIG9iamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nXSBzdHJpbmcgaW4gdGhlIGZvcm1hdCBvZiB0aGUgYHRyYW5zZm9ybWAgYXJndW1lbnQgaW4gU1ZHLCBmb3IgZXhhbXBsZSBgdHJhbnNsYXRlKDM2MCAxNTApIHJvdGF0ZSg5MCAzMCAyMClgXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc3RyaW5nKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhcnJheSBvZiB7QGxpbmsgUHJvcGVydHl9IGluc3RhbmNlc1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLml0ZW1zID0gW107XG5cbiAgICAgICAgaWYoc3RyaW5nIT09dW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygc3RyaW5nLnNwbGl0KFwiKVwiKSkge1xuICAgICAgICAgICAgICAgIGlmKGl0ZW0pIHsgLy8gaWYgbm90IGVtcHR5XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChuZXcgUHJvcGVydHkoaXRlbSArIFwiKVwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29udmVydCBkaXN0YW5jZXMgZnJvbSBTVkcgcGl4ZWxzIHRvIGdyaWQgcGl4ZWxzXG4gICAgICogQHBhcmFtICB7Q2FudmFzfSBwYXJlbnRTVkcgaW5zdGFuY2Ugb2YgW0NhbnZhc10oLi9tb2R1bGUtQ2FudmFzLmh0bWwpXG4gICAgICovXG4gICAgdG9HcmlkUGl4ZWxzKHBhcmVudFNWRykge1xuICAgICAgICB0aGlzLnBpeGVsQ29udmVyc2lvbigodmFsKSA9PiBwYXJlbnRTVkcuU1ZHVG9HcmlkKHZhbCkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29udmVydCBkaXN0YW5jZXMgZnJvbSBncmlkIHBpeGVscyB0byBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtICB7Q2FudmFzfSBwYXJlbnRTVkcgaW5zdGFuY2Ugb2YgW0NhbnZhc10oLi9tb2R1bGUtQ2FudmFzLmh0bWwpXG4gICAgICovXG4gICAgdG9TVkdQaXhlbHMocGFyZW50U1ZHKSB7XG4gICAgICAgIHRoaXMucGl4ZWxDb252ZXJzaW9uKCh2YWwpID0+IHBhcmVudFNWRy5ncmlkVG9TVkcodmFsKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGRpc3RhbmNlcyB1c2luZyBhIHNwZWNpZmllZCBjb252ZXJ0b3IuIFVzZWQgYnkgdG9HcmlkUGl4ZWxzIGFuZCB0b1NWR1BpeGVsc1xuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjb252ZXJ0b3IgZnVuY3Rpb24gdGhhdCBjb252ZXJ0cyBpbnQgdG8gaW50XG4gICAgICovXG4gICAgcGl4ZWxDb252ZXJzaW9uKGNvbnZlcnRvcikge1xuICAgICAgICBjb25zdCBwcm9wZXJ0eU1hcCA9IHtcbiAgICAgICAgICAgIFwidHJhbnNsYXRlXCI6IChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgaXRlbS5hcmdzID0gaXRlbS5hcmdzLm1hcChhcmcgPT4gY29udmVydG9yKGFyZykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJyb3RhdGVcIjogKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBpdGVtLmFyZ3MgPSBbXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uYXJnc1swXSxcbiAgICAgICAgICAgICAgICAgICAgY29udmVydG9yKGl0ZW0uYXJnc1sxXSksXG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnRvcihpdGVtLmFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pdGVtcyA9IHRoaXMuaXRlbXMubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcGVydHlNYXBbaXRlbS5uYW1lXSA/IHByb3BlcnR5TWFwW2l0ZW0ubmFtZV0oaXRlbSkgOiBpdGVtXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZmluZCBhIHRyYW5zZm9ybSBwcm9wZXJ0eSBieSBuYW1lIGFuZCBnZXQgaXRzIGluZGV4IGluIHRoZSBbaXRlbXNdKCNpdGVtcykgYXJyYXlcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgaW5kZXggb2YgdGhlIHByb3BlcnR5IGluIHRoZSBhcnJheSBvZiBwcm9wZXJ0aWVzIG9yIGAtMWAgaWYgbm90IGZvdW5kXG4gICAgICovXG4gICAgZ2V0SW5kZXgobmFtZSkge1xuICAgICAgICBmb3IobGV0IGkgPSAwIDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmKG5hbWUgPT09IHRoaXMuaXRlbXNbaV0ubmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgdHJhbnNsYXRlIHByb3BlcnR5XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJzIG9mIHRoZSB0cmFuc2xhdGUgYXR0cmlidXRlXG4gICAgICovXG4gICAgZ2V0VHJhbnNsYXRlKCkge1xuICAgICAgICBsZXQgYXJncyA9IHRoaXMuZ2V0QXJndW1lbnRzKHRoaXMuZ2V0SW5kZXgoXCJ0cmFuc2xhdGVcIikpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBOdW1iZXIoYXJnc1swXSksXG4gICAgICAgICAgICB5OiBOdW1iZXIoYXJnc1sxXSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgcm90YXRlIHByb3BlcnR5XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJzIG9mIHRoZSByb3RhdGUgYXR0cmlidXRlXG4gICAgICovXG4gICAgZ2V0Um90YXRlKCkge1xuICAgICAgICBsZXQgYXJncyA9IHRoaXMuZ2V0QXJndW1lbnRzKHRoaXMuZ2V0SW5kZXgoXCJyb3RhdGVcIikpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWc6IE51bWJlcihhcmdzWzBdKSxcbiAgICAgICAgICAgIGNlbnRlclg6IE51bWJlcihhcmdzWzFdKSxcbiAgICAgICAgICAgIGNlbnRlclk6IE51bWJlcihhcmdzWzJdKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0IHRyYW5zbGF0ZSB0byB0aGUgc3BlY2lmaWVkIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IGhvcml6b250YWwgdHJhbnNsYXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSB2ZXJ0aWNhbCB0cmFuc2xhdGlvblxuICAgICAqL1xuICAgIHNldFRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgICAgIHRoaXMuc2V0UGFyYW1ldGVyKFwidHJhbnNsYXRlXCIsIFt4LCB5XSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0IHJvdGF0ZSB0byB0aGUgc3BlY2lmaWVkIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWcgICAgIGFuZ2xlIG9mIHRoZSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNlbnRlclggaG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9mIHRoZSByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjZW50ZXJZIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHJvdGF0aW9uXG4gICAgICovXG4gICAgc2V0Um90YXRlKGRlZywgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgICB0aGlzLnNldFBhcmFtZXRlcihcInJvdGF0ZVwiLCBbZGVnLCBjZW50ZXJYLCBjZW50ZXJZXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcm90YXRlIGJ5IDkwIGRlZ3JlZXMgdG8gdGhlIHJpZ2h0IG9yIGxlZnQsIGRlcGVuZGluZyBvbiB0aGUgcGFyYW1ldGVyIGByaWdodGBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2VudGVyWCBob3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHJvdGF0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNlbnRlclkgdmVydGljYWwgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvZiB0aGUgcm90YXRpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJpZ2h0IHJvdGF0ZSB0byB0aGUgcmlnaHQgaWYgYHRydWVgLCB0byB0aGUgbGVmdCBpZiBgZmFsc2VgXG4gICAgICovXG4gICAgcm90YXRlUmlnaHRBbmdsZShjZW50ZXJYLCBjZW50ZXJZLCByaWdodCkge1xuICAgICAgICBjb25zdCBhbW91bnQgPSByaWdodCA/IDkwIDogMjcwO1xuXG4gICAgICAgIGlmKHRoaXMuZ2V0SW5kZXgoXCJyb3RhdGVcIik9PT0tMSkge1xuICAgICAgICAgICAgdGhpcy5zZXRSb3RhdGUoYW1vdW50LCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuZXdSb3RhdGlvbiA9IChwYXJzZUludCh0aGlzLmdldFJvdGF0ZSgpLmRlZykgKyBhbW91bnQpICUgMzYwO1xuXG4gICAgICAgICAgICBpZihuZXdSb3RhdGlvbj09PTE4MCkge1xuICAgICAgICAgICAgICAgIC8vIHN3YXAgY2VudGVyIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSByb3RhdGUoYywgeCwgeSkgaXMgZGVmaW5lZCBsaWtlIHRyYW5zZm9ybSgteCwgLXkpIHJvdGF0ZShjKSB0cmFuc2Zvcm0oeCwgeSlcbiAgICAgICAgICAgICAgICBsZXQgYSA9IGNlbnRlclg7XG4gICAgICAgICAgICAgICAgY2VudGVyWCA9IGNlbnRlclk7XG4gICAgICAgICAgICAgICAgY2VudGVyWSA9IGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2V0Um90YXRlKFxuICAgICAgICAgICAgICAgIG5ld1JvdGF0aW9uLFxuICAgICAgICAgICAgICAgIGNlbnRlclgsXG4gICAgICAgICAgICAgICAgY2VudGVyWVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJvdGF0ZSBieSA5MCBkZWdyZWVzIHRvIHRoZSByaWdodFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gY2VudGVyWCBob3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHJvdGF0aW9uXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBjZW50ZXJZIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHJvdGF0aW9uXG4gICAgICovXG4gICAgcm90YXRlUmlnaHQoY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgICB0aGlzLnJvdGF0ZVJpZ2h0QW5nbGUoY2VudGVyWCwgY2VudGVyWSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcm90YXRlIGJ5IDkwIGRlZ3JlZXMgdG8gdGhlIGxlZnRcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNlbnRlclggaG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9mIHRoZSByb3RhdGlvblxuICAgICAqIEBwYXJhbSAge251bWJlcn0gY2VudGVyWSB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9mIHRoZSByb3RhdGlvblxuICAgICAqL1xuICAgIHJvdGF0ZUxlZnQoY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgICB0aGlzLnJvdGF0ZVJpZ2h0QW5nbGUoY2VudGVyWCwgY2VudGVyWSwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgdHJhbnNmb3JtIHZhbHVlcyBpbiBhIHN0cmluZ1xuICAgICAqIEByZXR1cm4ge3N0cmluZ30gc3RyaW5nIHRoYXQgY2FuIGJlIHVzZWQgYXMgYSB2YWx1ZSBmb3IgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0eSBvZiBhIFNWRyBlbGVtZW50XG4gICAgICovXG4gICAgZ2V0KCkge1xuICAgICAgICBsZXQgcmV0VmFsO1xuICAgICAgICBmb3IoY29uc3QgaXRlbSBvZiB0aGlzLml0ZW1zKSB7XG4gICAgICAgICAgICBpZihyZXRWYWwpIHtcbiAgICAgICAgICAgICAgICByZXRWYWwgKz0gXCIgXCIgKyBpdGVtLmdldCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXRWYWwgPSBpdGVtLmdldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXRWYWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IGFyZ3VtZW50cyBvZiBhIHByb3BlcnR5IHNwZWNpZmllZCBieSBpbmRleFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gaW5kZXggaW5kZXggb2YgdGhlIHByb3BlcnR5XG4gICAgICogQHJldHVybiB7YXJyYXl9ICAgICAgIGFycmF5IG9mIGFyZ3VtZW50cyBvZiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5XG4gICAgICovXG4gICAgZ2V0QXJndW1lbnRzKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zW2luZGV4XS5hcmdzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldCBhcmd1bWV0cyBvZiBhIHByb3BlcnR5IHNwZWNpZmllZCBieSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBhcmdzIGFycmF5IG9mIGFyZ3VtZW50cyBvZiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5XG4gICAgICovXG4gICAgc2V0UGFyYW1ldGVyKG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgLy8gZGV0ZXJtaW5lIGluZGV4IG9mIHRoZSBwYXJhbWV0ZXIgKGlmIHNldCksIGVsc2UgaW5kZXggPT0gLTFcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5nZXRJbmRleChuYW1lKTtcblxuICAgICAgICAvLyBpZiB0aGUgcHJvcGVydHkgaGFzIGJlZW4gYWxyZWFkeSBzZXQsIGNoYW5nZSBpdCAocmV3cml0ZSB0aGUgYXJyYXkgaW4gdGhlIHJpZ2h0IGluZGV4KVxuICAgICAgICAvLyBlbHNlIGNyZWF0ZSBhIG5ldyBvbmUgKHNldCBpbmRleCB0byB0aGUgbGVuZ3RoIG9mIGFuIGFycmF5IC0tPiBhZCBhbiBpdGVtIHRvIHRoZSBlbmQpXG4gICAgICAgIGlmKGluZGV4PT09LTEpIHtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLml0ZW1zW2luZGV4XSA9IG5ldyBQcm9wZXJ0eSgpO1xuICAgICAgICAgICAgdGhpcy5pdGVtc1tpbmRleF0uc2V0TmFtZShuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNhdmUgYXJncyB1bmRlciB0aGUgcmlnaHQgaW5kZXhcbiAgICAgICAgdGhpcy5pdGVtc1tpbmRleF0uc2V0QXJndW1lbnRzKGFyZ3MpO1xuICAgIH1cbn1cbiIsIi8qKiBAbW9kdWxlIGVkaXRvckVsZW1lbnRzLldpcmUgKi9cblxuaW1wb3J0IHtQb2x5TGluZSwgUG9seUxpbmVQb2ludHMsIFBvbHlMaW5lUG9pbnQsIEdyb3VwfSBmcm9tICcuLi9zdmdPYmplY3RzJ1xuaW1wb3J0IExvZ2ljIGZyb20gJy4uL0xvZ2ljJ1xuaW1wb3J0IHN0YXRlQ2xhc3NlcyBmcm9tICcuL3N0YXRlQ2xhc3NlcydcbmltcG9ydCBmaW5kUGF0aCBmcm9tICcuLi9maW5kUGF0aCdcbmltcG9ydCBwb2ludFRyYXZlbGxlciBmcm9tICcuL3BvaW50VHJhdmVsbGVyJ1xuXG5pbXBvcnQgTmV0d29ya0VsZW1lbnQgZnJvbSAnLi9OZXR3b3JrRWxlbWVudCdcbmltcG9ydCBXaXJlQW5jaG9yIGZyb20gJy4vV2lyZUFuY2hvcidcblxuLyoqXG4gKiBXaXJlIHJlcHJlc2VudHMgY29ubmVjdGlvbiBvZiB0d28ge0BsaW5rIENvbm5lY3Rvcn1zLlxuICogQGV4dGVuZHMgTmV0d29ya0VsZW1lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2lyZSBleHRlbmRzIE5ldHdvcmtFbGVtZW50IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0NhbnZhc30gcGFyZW50U1ZHICBpbnN0YW5jZSBvZiBbQ2FudmFzXSguL21vZHVsZS1DYW52YXMuaHRtbClcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gIGZyb21JZCAgICBpZCBvZiB0aGUgZmlyc3QgY29ubmVjdG9yIHRoaXMgd2lyZSB3aWxsIGJlIGNvbm5lY3RlZCB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgdG9JZCAgICAgIGlkIG9mIHRoZSBzZWNvbmQgY29ubmVjdG9yIHRoaXMgd2lyZSB3aWxsIGJlIGNvbm5lY3RlZCB0b1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JlZnJlc2g9dHJ1ZV0gaWYgYHRydWVgLCB0aGUgW0NhbnZhc10oLi9tb2R1bGUtQ2FudmFzLmh0bWwpIHdpbGwgcmVmcmVzaCBhZnRlciBjcmVhdGluZyB0aGlzIHdpcmVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXJlbnRTVkcsIGZyb21JZCwgdG9JZCwgcmVmcmVzaCA9IHRydWUsIHJvdXRlID0gdHJ1ZSkge1xuICAgICAgICBzdXBlcihwYXJlbnRTVkcpO1xuXG4gICAgICAgIHRoaXMuZ3JpZFNpemUgPSBwYXJlbnRTVkcuZ3JpZFNpemU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFycmF5IG9mIGFuY2hvcnMgZGVmaW5lZCBmb3IgdGhpcyBhcnJheSxcbiAgICAgICAgICogZWFjaCBhbmNob3IgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBXaXJlQW5jaG9yfSBjbGFzc1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFuY2hvcnMgPSBbXVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHdpcmUgZW5kcG9pbnRzLCBjb250YWlucyB0d28gbWVtYmVyczogYGZyb21gIGFuZCBgdG9gLlxuICAgICAgICAgKlxuICAgICAgICAgKiBCb3RoIG1lbWJlcnMgYXJlIG9iamVjdHMgd2l0aCBtZW1iZXJzIGBpZGAsIGBib3hgIGFuZCBgY29ubmVjdG9yYCBjb250YWluaW5nXG4gICAgICAgICAqIHRoZSBjb25uZWN0b3IgaWQsIGJveCBvYmplY3QgcmVmZXJlbmNlIGFuZCBjb25uZWN0b3Igb2JqZWN0IHJlZmVyZW5jZSBmb3IgdGhlIGVuZHBvaW50LlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0ge1xuICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICAgIGlkOiBmcm9tSWQsXG4gICAgICAgICAgICAgICAgYm94OiB0aGlzLnBhcmVudFNWRy5nZXRCb3hCeUNvbm5lY3RvcklkKGZyb21JZCksXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yOiB0aGlzLnBhcmVudFNWRy5nZXRDb25uZWN0b3JCeUlkKGZyb21JZClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgICAgIGlkOiB0b0lkLFxuICAgICAgICAgICAgICAgIGJveDogdGhpcy5wYXJlbnRTVkcuZ2V0Qm94QnlDb25uZWN0b3JJZCh0b0lkKSxcbiAgICAgICAgICAgICAgICBjb25uZWN0b3I6IHRoaXMucGFyZW50U1ZHLmdldENvbm5lY3RvckJ5SWQodG9JZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuY29ubmVjdGlvbi5mcm9tLmNvbm5lY3Rvci5pc091dHB1dENvbm5lY3Rvcikge1xuICAgICAgICAgICAgaWYodGhpcy5jb25uZWN0aW9uLnRvLmNvbm5lY3Rvci5pc0lucHV0Q29ubmVjdG9yKSB7XG4gICAgICAgICAgICAgICAgLy8gZGVzaXJlZCBzdGF0ZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjb25uZWN0aW5nIHR3byBvdXRwdXQgY29ubmVjdG9yc1xuICAgICAgICAgICAgICAgIHRocm93IFwiQ2FuIG5vdCBwbGFjZSB3aXJlIGJldHdlZW4gdHdvIG91dHB1dCBjb25uZWN0b3JzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZih0aGlzLmNvbm5lY3Rpb24udG8uY29ubmVjdG9yLmlzSW5wdXRDb25uZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25uZWN0aW5nIHR3byBpbnB1dCBjb25uZWN0b3JzXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJDYW4gbm90IHBsYWNlIHdpcmUgYmV0d2VlbiB0d28gaW5wdXQgY29ubmVjdG9yc1wiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzd2FwIHRoZW0gYW5kIHdlIGFyZSByZWFkeSB0byBnb1xuICAgICAgICAgICAgICAgIFsgdGhpcy5jb25uZWN0aW9uLmZyb20sIHRoaXMuY29ubmVjdGlvbi50byBdID0gWyB0aGlzLmNvbm5lY3Rpb24udG8sIHRoaXMuY29ubmVjdGlvbi5mcm9tIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihyb3V0ZSkge1xuICAgICAgICAgICAgdGhpcy5yb3V0ZVdpcmUodHJ1ZSwgcmVmcmVzaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRlbXBvcmFyeVdpcmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjdXJyZW50IHN0YXRlIG9mIHRoZSBlbGVtZW50XG4gICAgICAgICAqIEB0eXBlIHtMb2dpYy5zdGF0ZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZWxlbWVudFN0YXRlID0gTG9naWMuc3RhdGUudW5rbm93bjtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHRoaXMuY29ubmVjdGlvbi5mcm9tLmNvbm5lY3Rvci5zdGF0ZSlcblxuICAgICAgICBpZihyZWZyZXNoKSB7XG4gICAgICAgICAgICBjb25zdCB7Y29ubmVjdG9yfSA9IHRoaXMuY29ubmVjdGlvbi50bztcbiAgICAgICAgICAgIHRoaXMucGFyZW50U1ZHLnN0YXJ0TmV3U2ltdWxhdGlvbihjb25uZWN0b3IsIGNvbm5lY3Rvci5zdGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN2Z09iai5hZGRDbGFzcyhcIndpcmVcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBib3ggb2JqZWN0cyB0aGF0IHRoaXMgd2lyZSBpcyBjb25uZWN0aW5nXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFycmF5IGNvbnRhaW5pbmcgdHdvIGluc3RhbmNlcyBvZiB0aGUge0BsaW5rIEJveH0gY2xhc3NcbiAgICAgKi9cbiAgICBnZXQgYm94ZXMoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5jb25uZWN0aW9uLmZyb20uYm94LCB0aGlzLmNvbm5lY3Rpb24udG8uYm94XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIGNvbm5lY3RvciBvYmplY3RzIHRoYXQgdGhpcyB3aXJlIGlzIGNvbm5lY3RpbmdcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgY29udGFpbmluZyB0d28gaW5zdGFuY2VzIG9mIHRoZSB7QGxpbmsgQ29ubmVjdG9yfSBjbGFzc1xuICAgICAqL1xuICAgIGdldCBjb25uZWN0b3JzKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuY29ubmVjdGlvbi5mcm9tLmNvbm5lY3RvciwgdGhpcy5jb25uZWN0aW9uLnRvLmNvbm5lY3Rvcl07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IGRhdGEgb2YgdGhpcyB3aXJlIGFzIGEgSlNPTi1yZWFkeSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgZXNzZW50aWFsIGRhdGEgZm9yIHRoaXMgd2lyZVxuICAgICAqL1xuICAgIGdldCBleHBvcnREYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvbUlkOiB0aGlzLmNvbm5lY3Rpb24uZnJvbS5pZCxcbiAgICAgICAgICAgIHRvSWQ6IHRoaXMuY29ubmVjdGlvbi50by5pZFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldCB0aGUgc3RhdGUgb2YgdGhpcyB3aXJlIHRvIG1hdGNoIHRoZSBzdGF0ZSBvZiB0aGUgaW5wdXQgY29ubmVjdG9yIGl0IGlzIGNvbm5lY3RlZCB0b1xuICAgICAqIEBwYXJhbSB7TG9naWMuc3RhdGV9IHN0YXRlIFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICBzZXRTdGF0ZShzdGF0ZSkge1xuICAgICAgICB0aGlzLnN2Z09iai5yZW1vdmVDbGFzc2VzKC4uLnN0YXRlQ2xhc3Nlcyk7XG4gICAgICAgIHRoaXMuc3ZnT2JqLmFkZENsYXNzKHN0YXRlQ2xhc3Nlc1tzdGF0ZV0pO1xuXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi50by5jb25uZWN0b3Iuc2V0U3RhdGUoc3RhdGUpO1xuXG4gICAgICAgIHRoaXMuZWxlbWVudFN0YXRlID0gc3RhdGU7XG5cbiAgICAgICAgLy8gdXBkYXRlIHN0YXRlcyBvZiBhbGwgYW5jaG9ycyBhcyB3ZWxsXG4gICAgICAgIGZvcihsZXQgYW5jaG9yIG9mIHRoaXMuYW5jaG9ycykge1xuICAgICAgICAgICAgYW5jaG9yLnNldFN0YXRlKHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgY3VycmVudCBbTG9naWMuc3RhdGVdKC4vbW9kdWxlcy1Mb2dpYy5odG1sIy5zdGF0ZSkgb2YgdGhpcyB3aXJlXG4gICAgICogQHJldHVybiB7TG9naWMuc3RhdGV9XG4gICAgICovXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50U3RhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSBzdGF0ZSBvZiB0aGlzIHdpcmVcbiAgICAgKi9cbiAgICB1cGRhdGVXaXJlU3RhdGUoKSB7XG4gICAgICAgIGZvciAoY29uc3QgYm94IG9mIHRoaXMuYm94ZXMpIHtcbiAgICAgICAgICAgIGJveC5yZWZyZXNoU3RhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBqUXVlcnkgZWxlbWVudCBmb3IgdGhpcyB3aXJlXG4gICAgICogQHJldHVybiB7alF1ZXJ5LmVsZW1lbnR9XG4gICAgICovXG4gICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdmdPYmouZ2V0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcm91dGUgdGhlIHdpcmUgdXNpbmcgdGhlIHRlbXBvcmFyeSB3aXJlIHBvaW50c1xuICAgICAqL1xuICAgIHRlbXBvcmFyeVdpcmUoKSB7XG4gICAgICAgIGNvbnN0IFtmcm9tLCB0b10gPSB0aGlzLmNvbm5lY3RvcnMubWFwKGNvbm5lY3RvciA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRTVkcuZ2V0Q29ubmVjdG9yUG9zaXRpb24oY29ubmVjdG9yLCBmYWxzZSlcbiAgICAgICAgfSlcblxuICAgICAgICBsZXQgcG9pbnRzID0gbmV3IFBvbHlMaW5lUG9pbnRzKCk7XG4gICAgICAgIHBvaW50cy5hcHBlbmQobmV3IFBvbHlMaW5lUG9pbnQoZnJvbS54LCBmcm9tLnkpKTtcblxuICAgICAgICBmb3IoY29uc3QgYW5jaG9yIG9mIHRoaXMuYW5jaG9ycykge1xuICAgICAgICAgICAgcG9pbnRzLmFwcGVuZChuZXcgUG9seUxpbmVQb2ludChhbmNob3Iuc3ZnUG9zaXRpb24ueCwgYW5jaG9yLnN2Z1Bvc2l0aW9uLnkpKVxuICAgICAgICB9XG5cbiAgICAgICAgcG9pbnRzLmFwcGVuZChuZXcgUG9seUxpbmVQb2ludCh0by54LCB0by55KSk7XG5cbiAgICAgICAgdGhpcy5zZXRXaXJlUGF0aChwb2ludHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJvdXRlIHRoZSB3aXJlIHVzaW5nIHRoZSBtb2RpZmllZCBBKiB3aXJlIHJvdXRpbmcgYWxnb3JpdGhtXG4gICAgICovXG4gICAgcm91dGVXaXJlKHNuYXBUb0dyaWQgPSB0cnVlLCByZWZyZXNoID0gdHJ1ZSkge1xuICAgICAgICBsZXQgZW5kcG9pbnRzID0gdGhpcy5jb25uZWN0b3JzLm1hcChjb25uZWN0b3IgPT4ge1xuICAgICAgICAgICAgY29uc3Qge3gsIHl9ID0gdGhpcy5wYXJlbnRTVkcuZ2V0Q29ubmVjdG9yUG9zaXRpb24oY29ubmVjdG9yLCBzbmFwVG9HcmlkKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogdGhpcy5wYXJlbnRTVkcuU1ZHVG9HcmlkKHgpLFxuICAgICAgICAgICAgICAgIHk6IHRoaXMucGFyZW50U1ZHLlNWR1RvR3JpZCh5KVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIGdldCByb3V0ZSBiZXR3ZWVuIHRoZSBlbmRwb2ludHNcbiAgICAgICAgY29uc3QgcG9pbnRzID0gdGhpcy5maW5kUm91dGUoLi4uZW5kcG9pbnRzKTtcblxuICAgICAgICAvLyBzZXQgdGhlIHdpcmUgcGF0aCB0byB0aGUgZ2VuZXJhdGVkIHBvaW50c1xuICAgICAgICB0aGlzLnNldFdpcmVQYXRoKHBvaW50cyk7XG5cbiAgICAgICAgaWYgKHJlZnJlc2gpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVdpcmVTdGF0ZSgpO1xuXG4gICAgICAgIC8vIHJlZ2VuZXJhdGUgaW5jb252ZW5pZW50IG5vZGVzXG4gICAgICAgIHRoaXMuZ2VuZXJhdGVJbmNvbnZlbmllbnROb2RlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldCB0aGUgd2lyZSB0byBmb2xsb3cgdGhlIHNwZWNpZmllZCBwb2ludHNcbiAgICAgKiBAcGFyYW0ge1BvbHlMaW5lUG9pbnRzfSBwb2ludHMgaW5zdGFuY2Ugb2Yge0BsaW5rIFBvbHlMaW5lUG9pbnRzfVxuICAgICAqL1xuICAgIHNldFdpcmVQYXRoKHBvaW50cykge1xuICAgICAgICAvLyBzZXQgdGhlIGxpbmVcbiAgICAgICAgaWYodGhpcy5zdmdPYmohPT11bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHRoaXMuc3ZnT2JqLnVwZGF0ZVBvaW50cyhwb2ludHMpO1xuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5zdmdPYmouY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBjaGlsZC51cGRhdGVQb2ludHMocG9pbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3ZnT2JqID0gbmV3IEdyb3VwKCk7XG5cbiAgICAgICAgICAgIGxldCBoaXRib3ggPSBuZXcgUG9seUxpbmUocG9pbnRzLCAxMCwgJ3doaXRlJyk7XG4gICAgICAgICAgICBoaXRib3guYWRkQ2xhc3MoXCJoaXRib3hcIik7XG4gICAgICAgICAgICBoaXRib3guYWRkQXR0cih7b3BhY2l0eTogMH0pO1xuICAgICAgICAgICAgdGhpcy5zdmdPYmouYWRkQ2hpbGQoaGl0Ym94KTtcblxuICAgICAgICAgICAgbGV0IG1haW5MaW5lID0gbmV3IFBvbHlMaW5lKHBvaW50cywgMik7XG4gICAgICAgICAgICBtYWluTGluZS5hZGRDbGFzcyhcIm1haW5cIiwgXCJzdGF0ZVVua25vd25cIik7XG4gICAgICAgICAgICB0aGlzLnN2Z09iai5hZGRDaGlsZChtYWluTGluZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcbiAgICB9XG5cbiAgICBwYXRoVG9Qb2x5TGluZShwYXRoKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhcnJheSBvZiBwb2x5bGluZSBwb2ludHMgZnJvbSB0aGUgY29vcmRpbmF0ZXMgZnJvbSBgcGF0aGAgdHJhbnNmb3JtZWQgZnJvbSBncmlkIHBpeGVscyB0byBTVkcgcGl4ZWxzXG4gICAgICAgIGNvbnN0IHBvaW50cyA9IHBhdGgubWFwKCh7eCwgeX0pID0+IG5ldyBQb2x5TGluZVBvaW50KHRoaXMucGFyZW50U1ZHLmdyaWRUb1NWRyh4KSwgdGhpcy5wYXJlbnRTVkcuZ3JpZFRvU1ZHKHkpKSk7XG5cbiAgICAgICAgY29uc3QgdG90YWxQYXRoID0gbmV3IFBvbHlMaW5lUG9pbnRzKHBvaW50cyk7XG5cbiAgICAgICAgcmV0dXJuIHRvdGFsUGF0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBmaW5kIGEgbmljZSByb3V0ZSBmb3IgdGhlIHdpcmVcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHN0YXJ0IG9iamVjdCBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YCB0aGF0IHJlcHJlc2VudCB0aGUgZmlyc3QgZW5kcG9pbnQgb2YgdGhlIHdpcmUgaW4gZ3JpZCBwaXhlbFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZW5kICAgb2JqZWN0IGNvbnRhaW5pbmcgbnVtZXJpYyBhdHRyaWJ1dGVzIGB4YCBhbmQgYHlgIHRoYXQgcmVwcmVzZW50IHRoZSBzZWNvbmQgZW5kcG9pbnQgb2YgdGhlIHdpcmUgaW4gZ3JpZCBwaXhlbHNcbiAgICAgKiBAcmV0dXJuIHtQb2x5TGluZVBvaW50c30gICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgIGZpbmRSb3V0ZShzdGFydCwgZW5kKSB7XG4gICAgICAgIGxldCBub25Sb3V0YWJsZSA9IHRoaXMucGFyZW50U1ZHLmdldE5vblJvdXRhYmxlTm9kZXMoKTtcblxuICAgICAgICBsZXQgcHVuaXNoZWRCdXRSb3V0YWJsZTtcbiAgICAgICAgaWYodGhpcy5zdmdPYmo9PT11bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHB1bmlzaGVkQnV0Um91dGFibGUgPSB0aGlzLnBhcmVudFNWRy5nZXRJbmNvbnZlbmllbnROb2RlcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHVuaXNoZWRCdXRSb3V0YWJsZSA9IHRoaXMucGFyZW50U1ZHLmdldEluY29udmVuaWVudE5vZGVzKHRoaXMuc3ZnT2JqLmlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByb3V0ZVBvaW50cyA9IFtcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgLi4udGhpcy5hbmNob3JzLm1hcCgoe3gsIHl9KSA9PiAoe3gsIHl9KSksIC8vIHN0cmlwIGFsbCBvdGhlciBkYXRhIHRoYXQgeCBhbmQgeSBjb29yZGluYXRlc1xuICAgICAgICAgICAgZW5kXG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gYWRkIHN0YXJ0IGhlcmUgYmVjYXVzZSBvZiB0aGUgc2xpY2UoMSkgYmVsb3dcbiAgICAgICAgbGV0IHBhdGggPSBbc3RhcnRdO1xuXG4gICAgICAgIGxldCBwcmV2O1xuICAgICAgICBmb3IgKGNvbnN0IHJvdXRlUG9pbnQgb2Ygcm91dGVQb2ludHMpIHtcbiAgICAgICAgICAgIGlmKHByZXYpIHtcbiAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBiZXN0IHBhdGggZnJvbSAncHJldicgdG8gJ3JvdXRlUG9pbnRzJ1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvdW5kUGF0aCA9IGZpbmRQYXRoKHByZXYsIHJvdXRlUG9pbnQsIG5vblJvdXRhYmxlLCBwdW5pc2hlZEJ1dFJvdXRhYmxlKTtcblxuICAgICAgICAgICAgICAgIC8vIHRvIGF2b2lkIHJlcGV0aXRpb24gb2YgdGhlIGpvaW50cywgaWdub3JlIHRoZSBmaXJzdCBwb2ludFxuICAgICAgICAgICAgICAgIHBhdGgucHVzaCguLi5mb3VuZFBhdGguc2xpY2UoMSkpO1xuXG4gICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBuZXcgcG9pbnRzIHRvIHRoZSBwdW5pc2hlZEJ1dFJvdXRhYmxlIHNldFxuICAgICAgICAgICAgICAgIGNvbnN0IHB0ID0gcG9pbnRUcmF2ZWxsZXIoZm91bmRQYXRoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIHB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHB1bmlzaGVkQnV0Um91dGFibGUuYWRkKHBvaW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2ID0gcm91dGVQb2ludDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxldCBwYXRoID0gZmluZFBhdGgoc3RhcnQsIGVuZCwgbm9uUm91dGFibGUsIHB1bmlzaGVkQnV0Um91dGFibGUsIHRoaXMuZ3JpZFNpemUpO1xuXG4gICAgICAgIGlmKHBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhdGhUb1BvbHlMaW5lKHBhdGgpO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBpZiBhIHBhdGggd2FzIG5vdCBmb3VuZCwgdHJ5IGFnYWluIGJ1dCBkb24ndCB0YWtlIGludG8gYWNjb3VudCB0aGUgcHVuaXNoZWQgYW5kIG5vbiByb3V0YWJsZSBub2RlXG4gICAgICAgIHBhdGggPSBmaW5kUGF0aChzdGFydCwgZW5kLCBuZXcgU2V0KCksIG5ldyBTZXQoKSwgdGhpcy5ncmlkU2l6ZSk7XG5cbiAgICAgICAgaWYocGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGF0aFRvUG9seUxpbmUocGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgcGF0aCB3YXMgc3RpbGwgbm90IGZvdW5kLCBnaXZlIHVwIGFuZCByZXR1cm4gdGVtcG9yYXJ5IHBvaW50c1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUZW1wb3JhcnlXaXJlUG9pbnRzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdG9yIHRoYXQgdHJhdmVscyB0aGUgcGF0aCBmcm9tIHRoZSBzdGFydCB0byB0aGUgZW5kIGFuZCBlYWNoIGl0ZW1cbiAgICAgKiBpcyBhIHBvaW50IHdpdGggYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgaW4gZ3JpZCBwaXhlbHNcbiAgICAgKiBAcmV0dXJuIHtHZW5lcmF0b3J9XG4gICAgKi9cbiAgICAqcGF0aFRyYXZlbGxlcigpIHtcbiAgICAgICAgY29uc3QgdHJhdmVsbGVyID0gcG9pbnRUcmF2ZWxsZXIodGhpcy5wb2ludHMubWFwKCh7eCwgeX0pID0+ICh7XG4gICAgICAgICAgICB4OiB0aGlzLnBhcmVudFNWRy5TVkdUb0dyaWQoeCksXG4gICAgICAgICAgICB5OiB0aGlzLnBhcmVudFNWRy5TVkdUb0dyaWQoeSlcbiAgICAgICAgfSkpKTtcblxuICAgICAgICBmb3IoY29uc3QgcG9pbnQgb2YgdHJhdmVsbGVyKSB7XG4gICAgICAgICAgICB5aWVsZCBwb2ludDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdlbmVyYXRlIGEgc2V0IG9mIG5vZGVzLCB0aGF0IGFyZSBpbmNvbnZlbmllbnQgZm9yIHdpcmluZywgYnV0IGNhbiBiZSB1c2VkLCBqdXN0IGFyZSBub3QgcHJlZmVycmVkXG4gICAgICogQHJldHVybiB7U2V0fSBzZXQgb2Ygbm9kZXMgKG9iamVjdHMgY29udGFpbmluZyB4IGFuZCB5IGNvb3JkaW5hdGVzKSB0aGF0IGFyZSBub3QgcHJlZmVycmVkIGZvciB3aXJpbmdcbiAgICAgKi9cbiAgICBnZW5lcmF0ZUluY29udmVuaWVudE5vZGVzKCkge1xuICAgICAgICB0aGlzLmluY29udmVuaWVudE5vZGVzID0gbmV3IFNldCgpO1xuXG4gICAgICAgIGNvbnN0IHB0ID0gdGhpcy5wYXRoVHJhdmVsbGVyKCk7XG4gICAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgcHQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5jb252ZW5pZW50Tm9kZXMuYWRkKHBvaW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFkZCBhIG5ldyBhbmNob3IgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvblxuICAgICAqXG4gICAgICogaWYgdGhlcmUgaXMgYWxyZWFkeSBhbiBhbmNob3IgYXQgdGhpcyBwb3NpdGlvbiwgZG8gbm90aGluZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhbmNob3Igb2JqZWN0IHdpdGggYHhgIGFuZCBgeWAgaW4gZ3JpZCBwaXhlbHNcbiAgICAgKi9cbiAgICBhZGRBbmNob3Ioe3gsIHl9KSB7XG4gICAgICAgIC8vIHBsYWNlIHRoZSBhbmNob3IgdG8gdGhlIHJpZ2h0IHBvc2l0aW9uIGluIHRoZSBhcnJheVxuXG4gICAgICAgIGxldCBuZXdBbmNob3IgPSBuZXcgV2lyZUFuY2hvcih0aGlzLCB4LCB5KTtcblxuICAgICAgICAvLyB0cmF2ZWwgdGhlIHBhdGhcbiAgICAgICAgY29uc3QgcHQgPSB0aGlzLnBhdGhUcmF2ZWxsZXIoKTtcbiAgICAgICAgbGV0IHBvaW50ZXIgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIHB0KSB7XG4gICAgICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgYW5jaG9yIHRoYXQgdGhlIHBvaW50ZXIgaXMgcG9pbnRpbmcgYXRcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRBbmNob3IgPSB0aGlzLmFuY2hvcnNbcG9pbnRlcl07XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IGFuY2hvciBkb2VzIG5vdCBleGlzdCwgdGhhdCBtZWFucyB0aGF0XG4gICAgICAgICAgICAvLyB0aGUgcG9pbnRlciBwYXNzZWQgYWxsIGN1cnJlbnQgYW5jaG9ycywgc28gdGhlXG4gICAgICAgICAgICAvLyBuZXcgYW5jaG9yIGlzIHRoZSBsYXN0IGFuY2hvciBvbiB0aGlzIHdpcmVcbiAgICAgICAgICAgIGlmKCFjdXJyZW50QW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmNob3JzLnB1c2gobmV3QW5jaG9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgYW5jaG9yIGhhcyB0aGUgc2FtZSBjb29yZGluYXRlcyBhcyB0aGlzIHBvaW50XG4gICAgICAgICAgICAvLyBtb3ZlIHRoZSBwb2ludGVyIHRvIHRoZSBuZXh0IGFuY2hvclxuICAgICAgICAgICAgaWYoY3VycmVudEFuY2hvci54ID09PSBwb2ludC54ICYmIGN1cnJlbnRBbmNob3IueSA9PT0gcG9pbnQueSkge1xuICAgICAgICAgICAgICAgIHBvaW50ZXIrKztcblxuICAgICAgICAgICAgICAgIC8vIHRoaXMgY29udGludWUgYXNzdXJlcyB0aGF0IHRoZXJlIGNhbiBiZSBhdCBtb3N0IG9uZVxuICAgICAgICAgICAgICAgIC8vIGFuY2hvciBvbiBvbmUgcG9zaXRpb24uIElmIHRoZSBuZXcgYW5jaG9yIGhhZCB0aGUgc2FtZVxuICAgICAgICAgICAgICAgIC8vIGNvb3JkaW5hdGVzIGFzIHRoaXMgb25lLCBpdCB3aWxsIGJlIHNraXBwZWRcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIGJ1dCB0ZWNobmljYWxseSB0aGlzIHNob3VsZCBuZXZlciBoYXBwZW4gYmVjYXVzZSB1c2VyXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIG5vdCBhYmxlIHRvIGNsaWNrIG9uIHRoZSB3aXJlIGF0IHRoaXNcbiAgICAgICAgICAgICAgICAvLyBwb3NpdGlvbiBpZiB0aGVyZSBpcyBhbHJlYWR5IGFuIGFuY2hvclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGUgbmV3IGFuY2hvciBoYXMgdGhlIHNhbWUgY29vcmRpbmF0ZXMgYXMgdGhpcyBwb2ludFxuICAgICAgICAgICAgLy8gcHV0IGl0IGluIHRoZSBwbGFjZSBvZiB0aGUgcG9pbnRlciAodGhlIHJlc3Qgb2YgdGhlIGFycmF5IGlzIG1vdmVkIHRvIHRoZSByaWdodClcbiAgICAgICAgICAgIGlmKG5ld0FuY2hvci54ID09PSBwb2ludC54ICYmIG5ld0FuY2hvci55ID09PSBwb2ludC55KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmNob3JzLnNwbGljZShwb2ludGVyLCAwLCBuZXdBbmNob3IpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHRoZSBhbmNob3IgY2xhc3MgdG8gdGhlIGN1cnJlbnQgd2lyZSBzdGF0ZVxuICAgICAgICBuZXdBbmNob3Iuc2V0U3RhdGUodGhpcy5zdGF0ZSk7XG5cbiAgICAgICAgdGhpcy5wYXJlbnRTVkcuYXBwZW5kRWxlbWVudChuZXdBbmNob3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBhbiBhbmNob3Igc3BlY2lmaWVkIGJ5IGl0cyBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhbmNob3Igb2JqZWN0IHdpdGggYHhgIGFuZCBgeWAgaW4gZ3JpZCBwaXhlbHNcbiAgICAgKi9cbiAgICByZW1vdmVBbmNob3IoYW5jaG9yKSB7XG4gICAgICAgIGNvbnN0IHt4LCB5fSA9IGFuY2hvcjtcbiAgICAgICAgbGV0ICRlbCA9IGFuY2hvci5zdmdPYmouJGVsO1xuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgYW5jaG9yIGZyb20gdGhlIGFycmF5XG4gICAgICAgIHRoaXMuYW5jaG9ycyA9IHRoaXMuYW5jaG9ycy5maWx0ZXIoYW5jaG9yID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhbmNob3IueCAhPT0geCB8fCBhbmNob3IueSAhPT0geVxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgYW5jaG9yIGZyb20gdGhlIFNWR1xuICAgICAgICAkZWwucmVtb3ZlKCk7XG5cbiAgICAgICAgLy8gcmVyb3V0ZSB0aGUgd2lyZVxuICAgICAgICB0aGlzLnJvdXRlV2lyZSgpO1xuICAgIH1cblxuICAgIGFuY2hvck1vdmVkKCkge1xuICAgICAgICB0aGlzLnRlbXBvcmFyeVdpcmUoKTtcbiAgICB9XG5cbiAgICBhbmNob3JEcm9wcGVkKCkge1xuICAgICAgICB0aGlzLnJvdXRlV2lyZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIGZvciBhIG1vdXNlZG93biwgdGhhdCBhZGRzIGEgbmV3IGFuY2hvciBvbiB0aGUgcGxhY2UgdGhhdCB1c2VyIGNsaWNrZWQgb24uXG4gICAgICogQHBhcmFtICB7alF1ZXJ5Lk1vdXNlRXZlbnR9IGV2ZW50IHRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgICAvLyBvbmx5IGxlZnQgY2xpY2sgY291bnRzXG4gICAgICAgIGlmKGV2ZW50LndoaWNoPT09MSkge1xuICAgICAgICAgICAgLy8gY29udmVydCBwaXhlbHMgaW4gdGhlIGV2ZW50IGZyb20gQ1NTIHBpeGVscyB0byBTVkcgcGl4ZWxzIHJlbGF0aXZlIHRvIHRoZSBTVkcgZG9jdW1lbnRcbiAgICAgICAgICAgIGV2ZW50ID0gdGhpcy5wYXJlbnRTVkcudmlld2JveC50cmFuc2Zvcm1FdmVudChldmVudCk7XG5cbiAgICAgICAgICAgIGxldCBjbGljayA9IHtcbiAgICAgICAgICAgICAgICB4OiBldmVudC5wYWdlWCxcbiAgICAgICAgICAgICAgICB5OiBldmVudC5wYWdlWVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IoY29uc3Qga2V5IGluIGNsaWNrKSB7XG4gICAgICAgICAgICAgICAgaWYoY2xpY2suaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjbGlja1trZXldID0gdGhpcy5wYXJlbnRTVkcuc25hcFRvR3JpZChjbGlja1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tba2V5XSA9IHRoaXMucGFyZW50U1ZHLlNWR1RvR3JpZChjbGlja1trZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFkZCBhbiBhbmNob3Igb24gdGhpcyBwb3NpdGlvblxuICAgICAgICAgICAgdGhpcy5hZGRBbmNob3IoY2xpY2spO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IE5ldHdvcmtFbGVtZW50IGZyb20gJy4vTmV0d29ya0VsZW1lbnQnO1xuaW1wb3J0IFRyYW5zZm9ybSBmcm9tICcuL1RyYW5zZm9ybSdcbmltcG9ydCBzdGF0ZUNsYXNzZXMgZnJvbSAnLi9zdGF0ZUNsYXNzZXMnO1xuXG5pbXBvcnQge1JlY3RhbmdsZX0gZnJvbSAnLi4vc3ZnT2JqZWN0cydcbi8vIGltcG9ydCBMb2dpYyBmcm9tICcuLi9Mb2dpYydcblxuLy8gaW1wb3J0IHN0YXRlQ2xhc3NlcyBmcm9tICcuL3N0YXRlQ2xhc3NlcydcblxuLyoqIEBtb2R1bGUgZWRpdG9yRWxlbWVudHMuV2lyZUFuY2hvciAqL1xuXG4vKipcbiAqIHBhcmVudCBjbGFzcyBmb3IgaW5wdXQgYW5kIG91dHB1dCBjb25uZWN0b3JzXG4gKiBAZXh0ZW5kcyBOZXR3b3JrRWxlbWVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXaXJlQW5jaG9yIGV4dGVuZHMgTmV0d29ya0VsZW1lbnQge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzfSBwYXJlbnRTVkcgbGluayB0byB0aGUge0BsaW5rIENhbnZhc30gaW5zdGFuY2UgdGhhdCB0aGlzIGNvbm5lY3RvciB3aWxsIGJlbG9uZyB0b1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncmlkU2l6ZSAgc2l6ZSBvZiB0aGUgZ3JpZCBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggICAgICBob3Jpem9udGFsIHBvc2l0aW9uIGRlZmluZWQgaW4gZ3JpZCBwaXhlbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAgICAgICB2ZXJ0aWNhbCBwb3NpdGlvbiBkZWZpbmVkIGluIGdyaWQgcGl4ZWxzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGFyZW50V2lyZSwgeCwgeSkge1xuICAgICAgICBzdXBlcihwYXJlbnRXaXJlLnBhcmVudFNWRyk7XG5cbiAgICAgICAgdGhpcy5wYXJlbnRXaXJlID0gcGFyZW50V2lyZTtcblxuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuXG4gICAgICAgIHRoaXMuYW5jaG9yU2l6ZSA9IDEwO1xuICAgICAgICB0aGlzLmFuY2hvckNlbnRlciA9IHRoaXMuYW5jaG9yU2l6ZSAvIDI7XG5cbiAgICAgICAgdGhpcy5zdmdQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIHg6IHRoaXMucGFyZW50U1ZHLmdyaWRUb1NWRyh4KSxcbiAgICAgICAgICAgIHk6IHRoaXMucGFyZW50U1ZHLmdyaWRUb1NWRyh5KVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdmdPYmogPSBuZXcgUmVjdGFuZ2xlKFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICB0aGlzLmFuY2hvclNpemUsXG4gICAgICAgICAgICB0aGlzLmFuY2hvclNpemUsXG4gICAgICAgICAgICBcIm5vbmVcIixcbiAgICAgICAgICAgIFwiYmxhY2tcIlxuICAgICAgICApO1xuXG4gICAgICAgIC8vIG1vdmUgdG8gdGhlIGNvcnJlY3QgcG9zaXRpb25cbiAgICAgICAgdGhpcy5tb3ZlKHRoaXMuc3ZnUG9zaXRpb24ueCwgdGhpcy5zdmdQb3NpdGlvbi55KTtcblxuICAgICAgICAvLyByb3RhdGUgdGhlIGFuY2hvciBieSA0NSBkZWdyZWVzXG4gICAgICAgIGxldCB0cmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKHRoaXMuc3ZnT2JqLmdldEF0dHIoXCJ0cmFuc2Zvcm1cIikpO1xuICAgICAgICB0cmFuc2Zvcm0uc2V0Um90YXRlKFxuICAgICAgICAgICAgNDUsXG4gICAgICAgICAgICB0aGlzLmFuY2hvckNlbnRlcixcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yQ2VudGVyXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuc3ZnT2JqLmFkZEF0dHIoe3RyYW5zZm9ybTogdHJhbnNmb3JtLmdldCgpfSk7XG5cbiAgICAgICAgdGhpcy5zdmdPYmouJGVsLmFkZENsYXNzKFwid2lyZUFuY2hvclwiKTtcblxuICAgICAgICB0aGlzLm1vdXNlRXZlbnQ7XG4gICAgfVxuXG4gICAgbW92ZSh4LCB5KSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKHRoaXMuc3ZnT2JqLmdldEF0dHIoXCJ0cmFuc2Zvcm1cIikpO1xuICAgICAgICB0cmFuc2Zvcm0uc2V0VHJhbnNsYXRlKHggLSB0aGlzLmFuY2hvckNlbnRlciwgeSAtIHRoaXMuYW5jaG9yQ2VudGVyKVxuICAgICAgICB0aGlzLnN2Z09iai5hZGRBdHRyKHt0cmFuc2Zvcm06IHRyYW5zZm9ybS5nZXQoKX0pXG5cbiAgICAgICAgdGhpcy5zdmdQb3NpdGlvbiA9IHsgeCwgeSB9XG5cbiAgICAgICAgdGhpcy54ID0gdGhpcy5wYXJlbnRTVkcuU1ZHVG9HcmlkKHRoaXMucGFyZW50U1ZHLnNuYXBUb0dyaWQoeCkpO1xuICAgICAgICB0aGlzLnkgPSB0aGlzLnBhcmVudFNWRy5TVkdUb0dyaWQodGhpcy5wYXJlbnRTVkcuc25hcFRvR3JpZCh5KSk7XG4gICAgfVxuXG4gICAgc2V0U3RhdGUoc3RhdGUpIHtcbiAgICAgICAgdGhpcy5zdmdPYmoucmVtb3ZlQ2xhc3NlcyguLi5zdGF0ZUNsYXNzZXMpO1xuICAgICAgICB0aGlzLnN2Z09iai5hZGRDbGFzcyhzdGF0ZUNsYXNzZXNbc3RhdGVdKTtcbiAgICB9XG5cbiAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN2Z09iai4kZWw7XG4gICAgfVxuXG4gICAgb25Nb3VzZURvd24oKSB7XG4gICAgICAgIHRoaXMubW91c2VFdmVudCA9IHtcbiAgICAgICAgICAgIG1vdmVkOmZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgICB0aGlzLm1vdXNlRXZlbnQubW92ZWQgPSB0cnVlO1xuXG4gICAgICAgIGV2ZW50ID0gdGhpcy5wYXJlbnRTVkcudmlld2JveC50cmFuc2Zvcm1FdmVudChldmVudCk7XG5cbiAgICAgICAgdGhpcy5tb3ZlKGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSlcblxuICAgICAgICB0aGlzLnBhcmVudFdpcmUuYW5jaG9yTW92ZWQoKVxuICAgIH1cblxuICAgIG9uTW91c2VVcChldmVudCkge1xuICAgICAgICBpZih0aGlzLm1vdXNlRXZlbnQubW92ZWQpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gdGhpcy5wYXJlbnRTVkcudmlld2JveC50cmFuc2Zvcm1FdmVudChldmVudCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLnBhcmVudFNWRy5zbmFwVG9HcmlkKGV2ZW50LnBhZ2VYKVxuICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMucGFyZW50U1ZHLnNuYXBUb0dyaWQoZXZlbnQucGFnZVkpXG5cbiAgICAgICAgICAgIHRoaXMubW92ZSh4LCB5KTtcblxuICAgICAgICAgICAgdGhpcy5wYXJlbnRXaXJlLmFuY2hvckRyb3BwZWQoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaXQgd2FzIGEgY2xpY2sgLS0gZGVsZXRlIHRoaXMgYW5jaG9yXG4gICAgICAgICAgICB0aGlzLnBhcmVudFdpcmUucmVtb3ZlQW5jaG9yKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tb3VzZUV2ZW50ID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbiIsIi8qKlxuICogQ3JlYXRlIGEgZ2VuZXJhdG9yIHRoYXQgdHJhdmVscyBiZXR3ZWVuIHNwZWNpZmllZCBwb2ludHMgcmV0dXJuaW5nIGVhY2ggdmlzaXRlZCBwb2ludFxuICogQHBhcmFtICB7QXJyYXl9ICAgIHBvaW50cyBhcnJheSBvZiBwb2ludHMgcmVwcmVzZW50ZWQgYnkgYW4gb2JqZWN0OiBge3gsIHl9YCwgc3Vic2VxdWVudCBwb2ludHMgbXVzdCBoYXZlIG9uZSBlcXVhbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlIChzbyB0aGUgdHJhdmVsbGVyIGNhbiB0cmF2ZWwgZWl0aGVyIHZlcnRpY2FsbHkgb3IgaG9yaXpvbnRhbGx5KVxuICogQHJldHVybiB7R2VuZXJhdG9yfSAgICAgICBnZW5lcmF0b3IgdGhhdCB0cmF2ZWxzIGJldHdlZW4gc3BlY2lmaWVkIHBvaW50cyByZXR1cm5pbmcgZWFjaCB2aXNpdGVkIHBvaW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKiAocG9pbnRzKSB7XG4gICAgbGV0IHByZXZQb2ludDtcblxuICAgIGZvciAoY29uc3Qge3gsIHl9IG9mIHBvaW50cykge1xuXG4gICAgICAgIGlmIChwcmV2UG9pbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIHByZXZQb2ludCBpcyB1bmRlZmluZWQsIGFkZCB0aGUgZmlyc3QgcG9pbnRcbiAgICAgICAgICAgIC8vIHlpZWxkICh7eCwgeX0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZWxzZSBhZGQgYWxsIHRoZSBwb2ludCBiZXR3ZWVuIHRoZSBwcmV2UG9pbnQgKGV4Y2x1ZGVkKSBhbmQgcG9pbnQgKGluY2x1ZGVkKVxuXG4gICAgICAgICAgICBpZiAocHJldlBvaW50LnggPT09IHgpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbGluZSBpcyBob3Jpem9udGFsXG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1pbihwcmV2UG9pbnQueSwgeSk7XG4gICAgICAgICAgICAgICAgbGV0IHRvID0gTWF0aC5tYXgocHJldlBvaW50LnksIHkpO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGZyb20gPD0gdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQoe3g6IHgsIHk6IGZyb219KTtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldlBvaW50LnkgPT09IHkpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbGluZSBpcyB2ZXJ0aWNhbFxuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gTWF0aC5taW4ocHJldlBvaW50LngsIHgpO1xuICAgICAgICAgICAgICAgIGxldCB0byA9IE1hdGgubWF4KHByZXZQb2ludC54LCB4KTtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChmcm9tIDw9IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkKHt4OiBmcm9tLCB5OiB5fSk7XG4gICAgICAgICAgICAgICAgICAgIGZyb20rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGxpbmUgaXMgbmVpdGhlciBob3Jpem9udGFsIG5vciB2ZXJ0aWNhbCwgdGhyb3cgYW4gZXJyb3IgZm9yIGJldHRlciBmdXR1cmUgZGVidWdnaW5nXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcihcImdldEluY29udmVuaWVudE5vZGVzOiBsaW5lIGJldHdlZW4gdHdvIHBvaW50cyBpcyBuZWl0aGVyIGhvcml6b250YWwgbm9yIHZlcnRpY2FsXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IG5ldyBwcmV2UG9pbnRcbiAgICAgICAgcHJldlBvaW50ID0ge1xuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHlcbiAgICAgICAgfTtcbiAgICB9XG59XG4iLCJpbXBvcnQgTG9naWMgZnJvbSAnLi4vTG9naWMnXG5cbi8qKlxuICogbWFwcGluZyBvZiBsb2dpY2FsIHN0YXRlcyB0byBjc3MgY2xhc3Nlc1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuXG5sZXQgbWFwID0gW107IC8vIGFycmF5IHNvIHdlIGNhbiB1c2UgdGhlIC4uLnNwcmVhZCBvcGVyYXRvclxuXG5tYXBbTG9naWMuc3RhdGUub25dID0gXCJzdGF0ZU9uXCJcbm1hcFtMb2dpYy5zdGF0ZS5vZmZdID0gXCJzdGF0ZU9mZlwiXG5tYXBbTG9naWMuc3RhdGUudW5rbm93bl0gPSBcInN0YXRlVW5rbm93blwiXG5tYXBbTG9naWMuc3RhdGUub3NjaWxsYXRpbmddID0gXCJzdGF0ZU9zY2lsbGF0aW5nXCJcblxuZXhwb3J0IGRlZmF1bHQgbWFwO1xuIiwiaW1wb3J0IHsgbWFuaGF0dGFuRGlzdGFuY2UgfSBmcm9tICcuL290aGVyL2hlbHBlckZ1bmN0aW9ucydcbmltcG9ydCBNYXBXaXRoRGVmYXVsdFZhbHVlIGZyb20gJy4vb3RoZXIvbWFwV2l0aERlZmF1bHRWYWx1ZSdcblxuaW1wb3J0IHsgUHJpb3JpdHlRdWV1ZSB9IGZyb20gJ2xpYnN0bCc7IC8vIG5vdGU6IGltcG9ydGVkIGZyb20gYSBub2RlIG1vZHVsZVxuXG4vKiogQG1vZHVsZSBmaW5kUGF0aCAqL1xuXG4vKipcbiAqIEhlYXZpbHkgbW9kaWZpZWQgaW1wbGVtZW50YXRpb24gb2YgdGhlIEEqIGFsZ29yaXRobVxuICogQHBhcmFtICB7T2JqZWN0fSBzdGFydCBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWAgdGhhdCByZXByZXNlbnQgdGhlIGZpcnN0IGVuZHBvaW50IG9mIHRoZSB3aXJlIGluIGdyaWQgcGl4ZWxzXG4gKiBAcGFyYW0gIHtPYmplY3R9IGVuZCAgIG9iamVjdCBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YCB0aGF0IHJlcHJlc2VudCB0aGUgc2Vjb25kIGVuZHBvaW50IG9mIHRoZSB3aXJlIGluIGdyaWQgcGl4ZWxzXG4gKiBAcGFyYW0gIHtTZXR9IG5vblJvdXRhYmxlIHNldCBvZiBub24gcm91dGFibGUgbm9kZXNcbiAqIEBwYXJhbSAge1NldH0gcHVuaXNoZWRCdXRSb3V0YWJsZSBzZXQgb2Ygbm9kZXMgdGhhdCBhcmUgbm90IG9wdGltYWwgZm9yIHJvdXRpbmdcbiAqIEByZXR1cm4ge0FycmF5fSBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgbnVtZXJpYyBhdHRyaWJ1dGVzIGB4YCBhbmQgYHlgXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpbmRQYXRoKHN0YXJ0LCBlbmQsIG5vblJvdXRhYmxlLCBwdW5pc2hlZEJ1dFJvdXRhYmxlKSB7XG4gICAgY29uc3QgZGlzdGFuY2VGdW5jdGlvbiA9IG1hbmhhdHRhbkRpc3RhbmNlO1xuXG4gICAgY29uc3Qgd2lyZUNyb3NzUHVuaXNobWVudCA9IDE7XG4gICAgY29uc3Qgd2lyZUJlbmRQdW5pc2htZW50ID0gMTtcblxuICAgIC8vIG51bWJlciBvZiBub2RlcywgdGhhdCBjYW4gYmUgb3BlbmVkIGF0IG9uY2VcbiAgICAvLyBvbmNlIGlzIHRoaXMgbGltaXQgZXhjZWVkZWQsIGFTdGFyIHdpbGwgZmFpbCBhbmQgcmV0dXJuIHVuZGVmaW5lZFxuICAgIGNvbnN0IG1heE5vZGVMaW1pdCA9IDEwMDAwMDtcblxuICAgIGxldCBjbG9zZWROb2RlcyA9IG5ldyBTZXQoKTtcbiAgICBsZXQgb3Blbk5vZGVzID0gbmV3IFNldCgpO1xuICAgIGxldCBvcGVuTm9kZVF1ZXVlID0gbmV3IFByaW9yaXR5UXVldWUoKTtcblxuICAgIC8vIGZ1bmN0aW9ucyBmb3Igd29ya2luZyB3aXRoIG9wZW4gbm9kZXM6XG5cbiAgICAvKipcbiAgICAgKiBhZGQgYSBuZXcgb3BlbiBub2RlIHRvIHRoZSBzdHJ1Y3R1cmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSAgIG9iamVjdCBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YCB0aGF0IHJlcHJlc2VudCB0aGUgZmlyc3QgZW5kcG9pbnQgb2YgdGhlIHdpcmVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZnNjb3JlIGZTY29yZSBvZiB0aGlzIG5vZGVcbiAgICAgKi9cbiAgICBjb25zdCBhZGRPcGVuTm9kZSA9IChub2RlLCBmc2NvcmUpID0+IHtcbiAgICAgICAgb3Blbk5vZGVzLmFkZChub2RlKTtcbiAgICAgICAgLy8gZmxpcCB0aGUgZnNjb3JlLCBiZWNhdXNlIFByaW9yaXR5UXVldWUgdXNlcyBtYXggaGVhcFxuICAgICAgICBvcGVuTm9kZVF1ZXVlLmVucXVldWUobm9kZSwgMSAvIGZzY29yZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBvcGVuIG5vZGUgd2l0aCB0aGUgbG93ZXN0IGZTY29yZSBhbmQgcmVtb3ZlIGl0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWAgdGhhdCByZXByZXNlbnQgdGhlIGZpcnN0IGVuZHBvaW50IG9mIHRoZSB3aXJlXG4gICAgICovXG4gICAgY29uc3QgZ2V0T3Blbk5vZGUgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBvcGVuTm9kZVF1ZXVlLmRlcXVldWUoKTtcbiAgICAgICAgb3Blbk5vZGVzLmRlbGV0ZShub2RlKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgbGV0IGNhbWVGcm9tID0gbmV3IE1hcCgpO1xuXG4gICAgLy8gZGVmYXVsdCB2YWx1ZTogaW5maW5pdHlcbiAgICBsZXQgZ1Njb3JlID0gbmV3IE1hcFdpdGhEZWZhdWx0VmFsdWUoSW5maW5pdHkpO1xuICAgIGdTY29yZS5zZXQoc3RhcnQsIDApO1xuXG4gICAgbGV0IHN0YXJ0RlNjb3JlID0gZGlzdGFuY2VGdW5jdGlvbihzdGFydCwgZW5kKTtcblxuICAgIGFkZE9wZW5Ob2RlKHN0YXJ0LCBzdGFydEZTY29yZSk7XG5cbiAgICBvcGVuTm9kZXMuYWRkKHN0YXJ0KTtcbiAgICBvcGVuTm9kZVF1ZXVlLmVucXVldWUoc3RhcnQsIDEgLyBzdGFydEZTY29yZSk7XG5cbiAgICB3aGlsZSAob3Blbk5vZGVzLnNpemUgPiAwKSB7XG4gICAgICAgIC8vIGdldCB0aGUgdmFsdWUgZnJvbSBvcGVuTm9kZXMgdGhhdCBoYXMgdGhlIGxvd2VzdCBmU2NvcmVcbiAgICAgICAgY29uc3QgY3VycmVudE5vZGUgPSBnZXRPcGVuTm9kZSgpO1xuXG4gICAgICAgIC8vIGlmIHdlIHJlYWNoZWQgdGhlIGVuZCBwb2ludCwgcmVjb25zdHJ1Y3QgdGhlIHBhdGggYW5kIHJldHVybiBpdFxuICAgICAgICBpZiAoY3VycmVudE5vZGUueCA9PSBlbmQueCAmJiBjdXJyZW50Tm9kZS55ID09IGVuZC55KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjb25zdHJ1Y3RQYXRoKGNhbWVGcm9tLCBjdXJyZW50Tm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgdGhpcyBub2RlIHRvIHRoZSBjbG9zZWQgbm9kZXNcbiAgICAgICAgY2xvc2VkTm9kZXMuYWRkKGN1cnJlbnROb2RlKTtcblxuICAgICAgICAvLyB0aGUgZmFydGhlc3QgcG9pbnRzIGFjY2Vzc2libGUgd2l0aG91dCBhdm9pZGluZyBvYnN0YWNsZXMgaW4gZXZlcnkgZGlyZWN0aW9uXG4gICAgICAgIC8vIChidXQgbWF4IDUwIGluIGVhY2ggZGlyZWN0aW9uKVxuICAgICAgICBmb3IgKGxldCBkaXJlY3Rpb24gPSAwOyBkaXJlY3Rpb24gPCA0OyBkaXJlY3Rpb24rKykge1xuICAgICAgICAgICAgbGV0IG5ld1BvaW50ID0gbW92ZVBvaW50KGN1cnJlbnROb2RlLCBkaXJlY3Rpb24pO1xuXG4gICAgICAgICAgICBsZXQgd2lyZXNDcm9zc2VkID0gMDtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1MDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgbmV3UG9pbnQgaXMgaW4gdGhlIHNldCBvZiBub24gcm91dGFibGUgcG9pbnRzLFxuICAgICAgICAgICAgICAgIC8vIGRvbid0IGFkZCBpdCBhbmQgc3RvcCBwcm9jZWVkaW5nIGluIHRoaXMgZGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHNldEhhc1RoaXNQb2ludChub25Sb3V0YWJsZSwgbmV3UG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgbm90IHRoZSBlbmQgb3Igc3RhcnQgcG9pbnQsIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGlmICghKG5ld1BvaW50LnggPT09IGVuZC54ICYmIG5ld1BvaW50LnkgPT09IGVuZC55KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIShuZXdQb2ludC54ID09PSBzdGFydC54ICYmIG5ld1BvaW50LnkgPT09IHN0YXJ0LnkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBza2lwIHRoaXMgbm9kZSwgaWYgaXQgaGFzIGJlZW4gYWxyZWFkeSBjbG9zZWRcbiAgICAgICAgICAgICAgICAvLyBvciBpZiBpdCBpcyBvbiB0aGUgbGlzdCBvZiBub24gcm91dGFibGUgbm9kZXNcbiAgICAgICAgICAgICAgICBpZiAoY2xvc2VkTm9kZXMuaGFzKG5ld1BvaW50KSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgcG9zc2libGUgR1Njb3JlIGJ5IGFwcGx5aW5nIGEgcHVuaXNobWVudCBmb3IgZWFjaCBub2RlIChcImJlbmRcIikgaW4gdGhlIHBhdGhcbiAgICAgICAgICAgICAgICBsZXQgbmV3R1Njb3JlID0gd2lyZUJlbmRQdW5pc2htZW50ICsgZ1Njb3JlLmdldFdpdGhEZWZhdWx0KGN1cnJlbnROb2RlKTtcblxuICAgICAgICAgICAgICAgIGlmIChzZXRIYXNUaGlzUG9pbnQocHVuaXNoZWRCdXRSb3V0YWJsZSwgbmV3UG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBub2RlIGlzIGluIHRoZSBzZXQgb2YgcHVuaXNoZWQgbm9kZXMsIGFwcGx5IHRoZSBwdW5pc2htZW50XG4gICAgICAgICAgICAgICAgICAgIHdpcmVzQ3Jvc3NlZCsrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGFwcGx5IHRoZSBwdW5pc2htZW50IGZvciBlYWNoIHdpcmUgY3Jvc3NlZCBpbiB0aGlzIGRpcmVjdGlvblxuICAgICAgICAgICAgICAgIC8vIG5vdGU6IHdlIGFyZSBjb3VudGluZyB0aGUgd2lyZXMgY3Jvc3NlZCB3aGVuIGV4cG9ydGluZyB0aGlzIGRpcmVjdGlvbiwgbm90IHRoZSB3aXJlc1xuICAgICAgICAgICAgICAgIC8vIGNyb3NzZWQgaW4gdGhlIGZpbmFsIHBhdGgsIHRoZXJlIHdpbGwgYmUgcHJvYmFibHkgb25seSBhdCBtb3N0IG9mIHRoZXNlIG5vZGVzIGluIHRoZVxuICAgICAgICAgICAgICAgIC8vIGZpbmFsIHBhdGgsIG5vdCBtdWx0aXBsZVxuICAgICAgICAgICAgICAgIG5ld0dTY29yZSArPSB3aXJlc0Nyb3NzZWQgKiB3aXJlQ3Jvc3NQdW5pc2htZW50O1xuXG4gICAgICAgICAgICAgICAgLy8gc2tpcCB0aGlzIG5vZGUgaWYgaXQgaGFzIHdvcnN0IGVzdGltYWdlIGdzY29yZSB0aGFuIGluIHRoZSBnc2NvcmUgdGFibGVcbiAgICAgICAgICAgICAgICBpZiAobmV3R1Njb3JlID49IGdTY29yZS5nZXRXaXRoRGVmYXVsdChuZXdQb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2FtZUZyb20uc2V0KG5ld1BvaW50LCBjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgZ1Njb3JlLnNldChuZXdQb2ludCwgbmV3R1Njb3JlKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0ZTY29yZSA9IG5ld0dTY29yZSArIGRpc3RhbmNlRnVuY3Rpb24obmV3UG9pbnQsIGVuZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW9wZW5Ob2Rlcy5oYXMobmV3UG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgcG9pbnQgdG8gdGhlIGxpc3Qgb2YgcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgIGFkZE9wZW5Ob2RlKG5ld1BvaW50LCBuZXdGU2NvcmUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG1vdmUgdG8gdGhlIG5leHQgcG9pbnQgaW4gdGhlIGRpcmVjaXRvblxuICAgICAgICAgICAgICAgIG5ld1BvaW50ID0gbW92ZVBvaW50KG5ld1BvaW50LCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wZW5Ob2Rlcy5zaXplID4gbWF4Tm9kZUxpbWl0KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgYVN0YXI6IE51bWJlciBvZiBvcGVuIG5vZGVzICgke29wZW5Ob2Rlcy5zaXplfSkgZXhjZWVkZWQgdGhlIGxpbWl0IGZvciBvcGVuIG5vZGVzICgke21heE5vZGVMaW1pdH0pLmApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiB3ZSBnb3QgaGVyZSwgdGhlIHBhdGggd2FzIG5vdCBmb3VuZFxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiByZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3BlY2lmaWVkIHNldCBvZiBwb2ludHMgY29udGFpbnMgdGhlIHNwZWNpZmllZCBwb2ludCAoYW5kIHJldHVybnMgYGZhbHNlYCBvdGhlcndpc2UpXG4gKiBAcGFyYW0ge1NldH0gc2V0IHNldCBvZiBwb2ludHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludCBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWBcbiAqL1xuZnVuY3Rpb24gc2V0SGFzVGhpc1BvaW50KHNldCwgcG9pbnQpIHtcbiAgICBmb3IgKGxldCBpdGVtIG9mIHNldCkge1xuICAgICAgICBpZiAoaXRlbS54ID09PSBwb2ludC54ICYmIGl0ZW0ueSA9PT0gcG9pbnQueSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IG1vdmVzIHRoZSBwYXNzZWQgcG9pbnQgaW4gdGhlIHNwZWNpZmllZCBkaXJlY3Rpb24uIEl0IHNpbXBseSBhZGRzIG9yIHN1YnRyYWN0cyAxIGZyb20gb25lIG9mIHRoZSBjb29yZGluYXRlcyBkZXBlbmRpbmcgb24gdGhlIGRpcmVjdGlvbiBhdHRyaWJ1dGUuXG4gKiBAcGFyYW0gIHtPYmplY3R9IHBvaW50ICAgICBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWBcbiAqIEBwYXJhbSAge251bWJlcn0gZGlyZWN0aW9uIGRpcmVjdGlvbnM6XG4gKiAgICAgLSAwOiB1cFxuICogICAgIC0gMTogcmlnaHRcbiAqICAgICAtIDI6IGRvd25cbiAqICAgICAtIDM6IGxlZnRcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgIG9iamVjdCBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YFxuICovXG5mdW5jdGlvbiBtb3ZlUG9pbnQoe3gsIHl9LCBkaXJlY3Rpb24pIHtcbiAgICAvLyBtYXAgZGlyZWN0aW9uIGRvIHBvaW50IGNvb3JkaW5hdGUgbW9kaWZpY2F0aW9uXG4gICAgY29uc3QgZGlyTWFwID0ge1xuICAgICAgICAwOiAoKSA9PiB7XG4gICAgICAgICAgICB5IC09IDFcbiAgICAgICAgfSxcbiAgICAgICAgMTogKCkgPT4ge1xuICAgICAgICAgICAgeCArPSAxXG4gICAgICAgIH0sXG4gICAgICAgIDI6ICgpID0+IHtcbiAgICAgICAgICAgIHkgKz0gMVxuICAgICAgICB9LFxuICAgICAgICAzOiAoKSA9PiB7XG4gICAgICAgICAgICB4IC09IDFcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpck1hcFtkaXJlY3Rpb25dKCk7XG5cbiAgICByZXR1cm4ge3gsIHl9XG59XG5cbi8qKlxuICogaGVscGVyIGJhY2t0cmFja2luZyBmdW5jdGlvbiB1c2VkIGJ5IHRoZSBhU3RhciBhbGdvcml0aG0gdG8gY29uc3RydWN0IHRoZSBmaW5hbCBwYXRoXG4gKiBAcGFyYW0gIHtPYmplY3R9IGNhbWVGcm9tICAgIG9iamVjdCBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YFxuICogQHBhcmFtICB7T2JqZWN0fSBjdXJyZW50Tm9kZSBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWBcbiAqIEByZXR1cm4ge0FycmF5fSBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgbnVtZXJpYyBhdHRyaWJ1dGVzIGB4YCBhbmQgYHlgXG4gKi9cbmZ1bmN0aW9uIHJlY29uc3RydWN0UGF0aChjYW1lRnJvbSwgY3VycmVudE5vZGUpIHtcbiAgICBsZXQgcGF0aCA9IFtdO1xuXG4gICAgcGF0aC5wdXNoKHtcbiAgICAgICAgeDogY3VycmVudE5vZGUueCxcbiAgICAgICAgeTogY3VycmVudE5vZGUueVxuICAgIH0pXG5cbiAgICB3aGlsZSAoY2FtZUZyb20uaGFzKGN1cnJlbnROb2RlKSkge1xuICAgICAgICBjdXJyZW50Tm9kZSA9IGNhbWVGcm9tLmdldChjdXJyZW50Tm9kZSk7XG4gICAgICAgIC8vIHB1c2ggdGhlIHBvaW50IG9uIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5IGluc3RlYWQgb2YgdGhlIGVuZFxuICAgICAgICBwYXRoLnNwbGljZSgwLCAwLCB7XG4gICAgICAgICAgICB4OiBjdXJyZW50Tm9kZS54LFxuICAgICAgICAgICAgeTogY3VycmVudE5vZGUueVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiBwYXRoO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIEhlbHBlckZ1bmN0aW9uc1xuICovXG5cbmltcG9ydCBzdHJpbmdpZnkgZnJvbSBcImpzb24tc3RyaW5naWZ5LXByZXR0eS1jb21wYWN0XCI7IC8vIG5vdGU6IGltcG9ydGVkIGZyb20gYSBtb2R1bGVcblxuLyoqXG4gKiBhZGQgYSBjcm9zcyBicm93c2VyIGV2ZW50IGxpc3RlbmVyIG9uIGEgbW91c2Ugc2Nyb2xsXG4gKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgRE9NIHF1ZXJ5IG9mIHRoZSBlbGVtZW50IHRoYXQgdGhlIGxpc3RlbmVyIHdpbGwgYmUgYWRkZWQgdG9cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgIEZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgb2NjdXJzLiBUaGUgZnVuY3Rpb24gdGFrZXMgYXMgYSBwYXJhbWV0ZXIgYW4gZXZlbnQgb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkTW91c2VTY3JvbGxFdmVudExpc3RlbmVyKHF1ZXJ5LCBmdW5jKSB7XG4gICAgbGV0IE1vdXNlV2hlZWxIYW5kbGVyID0gZXZlbnQgPT4ge1xuICAgICAgICAvLyByZWRlY2xhcmUgZm9yIG9sZCBJRSBzdXBwb3J0XG4gICAgICAgIHZhciBldmVudCA9IHdpbmRvdy5ldmVudCB8fCBldmVudDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZWRlY2xhcmVcblxuICAgICAgICBldmVudC5kZWx0YSA9IE1hdGgubWF4KC0xLCBNYXRoLm1pbigxLCAoZXZlbnQud2hlZWxEZWx0YSB8fCAtZXZlbnQuZGV0YWlsKSkpO1xuXG4gICAgICAgIGZ1bmMoZXZlbnQpXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBzdmdlbGVtZW50O1xuXG4gICAgLy8gaWYgdGhlIHF1ZXJ5IGlzIGEgc2ltcGxlIERPTSBpZCBzZWxlY3Rvciwgd2UgY2FuIHVzZSBnZXRFbGVtZW50QnlJZCB3aGljaCBoYXMgYmV0dGVyIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgaWYocXVlcnkubWF0Y2goL14jXFx3KyQvKSkge1xuICAgICAgICBzdmdlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocXVlcnkuc3Vic3RyKDEpKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHN2Z2VsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHF1ZXJ5KVxuICAgIH1cblxuICAgIGlmIChzdmdlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgLy8gSUU5LCBDaHJvbWUsIFNhZmFyaSwgT3BlcmFcbiAgICAgICAgc3ZnZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V3aGVlbFwiLCBNb3VzZVdoZWVsSGFuZGxlciwgZmFsc2UpO1xuICAgICAgICAvLyBGaXJlZm94XG4gICAgICAgIHN2Z2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTU1vdXNlU2Nyb2xsXCIsIE1vdXNlV2hlZWxIYW5kbGVyLCBmYWxzZSk7XG4gICAgfSBlbHNlICB7XG4gICAgICAgIC8vIElFIDYvNy84XG4gICAgICAgIHN2Z2VsZW1lbnQuYXR0YWNoRXZlbnQoXCJvbm1vdXNld2hlZWxcIiwgTW91c2VXaGVlbEhhbmRsZXIpO1xuICAgIH1cbiAgICBzdmdlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdldmVudCcsIGUpXG4gICAgfSwgZmFsc2UpXG59XG5cbi8qKlxuICogY29udmVydCBhIGRhdGEgb2JqZWN0IHRvIEpTT04gc3RyaW5nIG9yIHRvIGEgZGF0YSBVUkkgY29udGFpbmluZyBhIEpTT04gc3RyaW5nXG4gKiBAcGFyYW0gIHtPYmplY3R9ICBkYXRhICAgICAgICAgICAgb2JqZWN0IHRoYXQgd2lsbCBiZSBzZXJpYWxpemVkIGludG8gYSBKU09OIHN0cmluZ1xuICogQHBhcmFtICB7Qm9vbGVhbn0gW3ByZXR0eT1mYWxzZV0gIGlmIGB0cnVlYCwgdGhlIGNvZGUgd2lsbCBiZSBwcm9wcmVybHkgaW5kZW50ZWQsIGVsc2UgYSBtb3JlIGNvbXBhY3Qgc3ludGF4IHdpbGwgYmUgdXNlZFxuICogQHBhcmFtICB7Qm9vbGVhbn0gW2RhdGFVcmk9ZmFsc2VdIHJldHVybiBkYXRhVXJpIGNvbnRhaW5pbmcgdGhlIEpTT04gc3RyaW5nIGluc3RlYWQgb2YgdGhlIHB1cmUgSlNPTiBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEpTT05TdHJpbmcoZGF0YSwgcHJldHR5ID0gZmFsc2UsIGRhdGFVcmkgPSBmYWxzZSkge1xuICAgIGlmKGRhdGFVcmkpIHtcbiAgICAgICAgcmV0dXJuICdkYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCwnXG4gICAgICAgICAgICArIGVuY29kZVVSSUNvbXBvbmVudChnZXRKU09OU3RyaW5nKGRhdGEsIHByZXR0eSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcmV0dHkpXG4gICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5KGRhdGEsIHttYXhMZW5ndGg6IDUwfSk7XG5cbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIH1cbn1cblxuLyoqXG4gKiByZXR1cm5zIHRoZSBNYW5oYXR0YW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgcG9pbnRzIF9hXyBhbmQgX2JfXG4gKiBAcGFyYW0gIHtPYmplY3R9IGEgb2JqZWN0IGNvbnRhaW5pbmcgbnVtZXJpYyBhdHRyaWJ1dGVzIGB4YCBhbmQgYHlgXG4gKiBAcGFyYW0gIHtPYmplY3R9IGIgb2JqZWN0IGNvbnRhaW5pbmcgbnVtZXJpYyBhdHRyaWJ1dGVzIGB4YCBhbmQgYHlgXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYW5oYXR0YW5EaXN0YW5jZShhLCBiKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKGEueCAtIGIueCkgKyBNYXRoLmFicyhhLnkgLSBiLnkpO1xufVxuIiwiLyoqIEBtb2R1bGUgSWQgKi9cblxuLyoqXG4gKiB0aGUgY3VycmVudCBpbnN0YW5jZSBvZiBJZFxuICogQHR5cGUge0lkfVxuICovXG5sZXQgZXhpc3RpbmdJZEluc3RhbmNlO1xuXG4vKipcbiAqIHNpbmdsZXRvbiB0byBnZW5lcmF0ZSB1bmlxdWUgaWQnc1xuICpcbiAqIHVzYWdlOiBgbGV0IGlkID0gbmV3IElkKCkudW5pcXVlYFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGlmKCFleGlzdGluZ0lkSW5zdGFuY2Upe1xuICAgICAgICAgICAgZXhpc3RpbmdJZEluc3RhbmNlID0gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcmVmaXggZm9yIHRoZSBpZCwgdGhhdCBpcyBjb21tb24gaW4gYWxsIHRoZSBJZHNcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJlZml4ID0gXCJpZFwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBudW1lcmljIHBhcnQgb2YgdGhlIG5leHQgaWQgKHRoZSBuZXh0IGlkIHdpdGhvdXQgdGhlIHByZWZpeClcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmV4dElkID0gMDtcblxuICAgICAgICByZXR1cm4gZXhpc3RpbmdJZEluc3RhbmNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB1bmlxdWUgSURcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IG5ldyB1bmlxdWUgSURcbiAgICAgKi9cbiAgICBnZXQgdW5pcXVlKCkge1xuICAgICAgICBsZXQgcmV0VmFsID0gdGhpcy5wcmVmaXggKyB0aGlzLm5leHRJZDtcblxuICAgICAgICAvLyBmaW5kIG5leHQgdW51c2VkIGlkWFhYWCB0byBwcmV2ZW50IGlkIGNvbGxpc2lvbiB0aGF0IG1pZ2h0IGJlIGNhdXNlZCBieSBzb21lIG90aGVyIGNvbXBvbmVudFxuICAgICAgICAvLyAoaXQgcmVhbGx5IHNob3VsZCBub3QgaGFwcGVuLCBidXQgdGhpcyBpcyBhIHNpbXBsZSB3YXkgdG8gZW5zdXJlIGl0KVxuICAgICAgICB3aGlsZSgkKFwiI1wiK3JldFZhbCkubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRJZCsrO1xuICAgICAgICAgICAgcmV0VmFsID0gdGhpcy5nZW5lcmF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJldHVybiB0aGlzIGlkXG4gICAgICAgIHRoaXMubmV4dElkKys7XG5cbiAgICAgICAgcmV0dXJuIHJldFZhbDtcbiAgICB9XG59XG4iLCIvKiogQG1vZHVsZSBNYXBXaXRoRGVmYXVsdFZhbHVlICovXG4vKipcbiAqIE1hcCB0aGF0IGhhcyBhIGRlZmF1bHQgdmFsdWUgc3BlY2lmaWVkIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBGb3IgdGhlIGNvbXBsZXRlIGRvY3VtZW50YXRpb24gb2YgdGhlIE1hcCBzZWUgW01hcCBpbiB0aGUgTUROIHdlYiBkb2NzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXApXG4gKlxuICogVXNhZ2U6XG4gKiBgYGBKYXZhU2NyaXB0XG4gbGV0IG15TWFwID0gbmV3IE1hcFdpdGhEZWZhdWx0VmFsdWUoSW5maW5pdHkpO1xuIGNvbnN0IHZhbHVlID0gbXlNYXAuZ2V0V2l0aERlZmF1bHQoa2V5KVxuIGBgYFxuICpcbiAqIF9Ob3RlOiBUaGlzIHZlcnNpb24gaXMgd3JpdHRlbiBzcGVjaWFsbHkgZm9yIEVTNiBjb21waWxlZCBpbnRvIEVTNS4gSW4gbm9uLWNvbXBpbGVkIEVTNiBpcyB0aGUgaW1wbGVtZW50YXRpb24gZmFyIG1vcmUgZWxlZ2FudDpfXG4gKlxuICogYGBgSmF2YVNjcmlwdFxuIGV4cG9ydCBjbGFzcyBNYXBXaXRoRGVmYXVsdFZhbHVlIGV4dGVuZHMgTWFwIHtcbiAgICAgY29uc3RydWN0b3IoZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgICB0aGlzLmRlZmF1bHQgPSBkZWZhdWx0VmFsdWU7XG4gICAgIH1cblxuICAgICBnZXQoa2V5KSB7XG4gICAgICAgICBpZih0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmdldChrZXkpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0O1xuICAgICAgICAgfVxuICAgICB9XG4gfWBgYFxuICogQGNsYXNzIE1hcFdpdGhEZWZhdWx0VmFsdWVcbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUge2FueX0gZGVmYXVsdCB2YWx1ZSB0aGF0IHdpbGwgYmUgcmV0dXJuZWQgd2hlbiB0aGUgcmVxdWVzdGVkIGtleSBpcyBub3QgZm91bmQgaW4gdGhlIG1hcFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkZWZhdWx0VmFsdWUpIHtcbiAgICBsZXQgbWFwID0gbmV3IE1hcCgpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge2FueX0ga2V5IGtleSBvZiBhIHJlcXVlc3RlZCBpdGVtXG4gICAgICogQHJldHVybiB7YW55fSB2YWx1ZSBvZiB0aGUgaXRlbSB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGtleSwgb3IgZGVmYXVsdFZhbHVlIGlmIHRoZSBrZXkgaXMgbm90IGZvdW5kIGluIHRoZSBtYXBcbiAgICAgKi9cbiAgICBtYXAuZ2V0V2l0aERlZmF1bHQgPSAoa2V5KSA9PiB7XG4gICAgICAgIHJldHVybiBtYXAuaGFzKGtleSlcbiAgICAgICAgICAgID8gbWFwLmdldChrZXkpXG4gICAgICAgICAgICA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbn1cbiIsIi8qKiBAbW9kdWxlIHN2Z09iamVjdHMgKi9cblxuLy8gbm9uLXN2ZyBjbGFzc2VzIHVzZWQgYXMgaGVscGVyc1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQb2x5TGluZVBvaW50IH0gZnJvbSAnLi9zdmdPYmplY3RzL1BvbHlMaW5lUG9pbnQnXG5leHBvcnQgeyBkZWZhdWx0IGFzIFBvbHlMaW5lUG9pbnRzIH0gZnJvbSAnLi9zdmdPYmplY3RzL1BvbHlMaW5lUG9pbnRzJ1xuXG4vLyB2aXJ0dWFsIHN2ZyBlbGVtZW50c1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQYXR0ZXJuIH0gZnJvbSAnLi9zdmdPYmplY3RzL1BhdHRlcm4nXG5leHBvcnQgeyBkZWZhdWx0IGFzIEdyb3VwIH0gZnJvbSAnLi9zdmdPYmplY3RzL0dyb3VwJ1xuXG4vLyBcInBoeXNpY2FsL3RvdWNoYWJsZVwiIHN2ZyBlbGVtZW50c1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBSZWN0YW5nbGUgfSBmcm9tICcuL3N2Z09iamVjdHMvUmVjdGFuZ2xlJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdmdJbWFnZSB9IGZyb20gJy4vc3ZnT2JqZWN0cy9TdmdJbWFnZSdcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUG9seUxpbmUgfSBmcm9tICcuL3N2Z09iamVjdHMvUG9seUxpbmUnXG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGV4dCB9IGZyb20gJy4vc3ZnT2JqZWN0cy9UZXh0J1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNdWx0aUxpbmVUZXh0IH0gZnJvbSAnLi9zdmdPYmplY3RzL011bHRpTGluZVRleHQnXG4iLCJpbXBvcnQgVGFnIGZyb20gJy4vVGFnJ1xuXG4vKiogQG1vZHVsZSBzdmdPYmplY3RzLkdyb3VwICovXG5cbi8qKlxuICogU1ZHIGdyb3VwLCB1c2VkIGZvciBncm91cGluZyBlbGVtZW50cywgZm9yIGV4YW1wbGUgYSBnYXRlIGlzIHJlcHJlc2VudGVkIGJ5IG1hbnkgZWxlbWVudHMgKHJlY3RhbmdsZSwgaW1hZ2UsIGluaXZpc2libGUgaGl0Ym94IHJlY3RhbmdsZS4uLiksXG4gKiBidXQgYWxsIG9mIHRoZSBlbGVtZW50cyBuZWVkIHRvIGJlIHRyYW5zZm9ybWVkIHRvZ2V0aGVyLiBVc2luZyBncm91cHMgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0eSBjYW4gYmUgc2V0IG9uIHRoZSBncm91cCB3aGljaCBjb250YWlucyBhbGwgdGhlIGVsZW1lbnRzLlxuICogQGV4dGVuZHMgVGFnXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyb3VwIGV4dGVuZHMgVGFnIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJnXCIpO1xuXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhZGQgYW4gZWxlbWVudCB0byB0aGUgZ3JvdXBcbiAgICAgKiBAcGFyYW0ge1N2Z0VsZW1lbnR9IGVsIGFuIGluc3RhbmNlIG9mIHtAbGluayBTdmdFbGVtZW50fVxuICAgICAqL1xuICAgIGFkZENoaWxkKGVsKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChlbCk7XG5cbiAgICAgICAgdGhpcy4kZWwuYXBwZW5kKGVsLiRlbCk7XG4gICAgICAgIHJldHVybiBlbDsgLy8gcHJvIGplZG5vZHVzc2kgXCJsZXQgcmVjdCA9IGcuYWRkQ2hpbGQobmV3IFJlY3RhbmdsZSguLi5cIlxuICAgIH1cbn1cbiIsImltcG9ydCBUYWcgZnJvbSAnLi9UYWcnXG5pbXBvcnQgVGV4dCBmcm9tICcuL1RleHQnXG5cbi8qKiBAbW9kdWxlIHN2Z09iamVjdHMuTXVsdGlMaW5lVGV4dCAqL1xuXG4vKipcbiAqIE11bHRpIGxpbmUgdGV4dCBlbGVtZW50IGluIFNWR1xuICpcbiAqIE11bHRpIGxpbmUgdGV4dCBpcyBub3QgbmF0aXZlbHkgc3VwcG9ydGVuZCBpbiBTVkcgMS4xLFxuICogdGhlIHdvcmthcm91bmQgaXMgdG8gdXNlIHRoZSA8Zm9yZWlnbk9iamVjdD4gZWxlbWVudCBhbmQgZGlzcGxheVxuICogYSBIVE1MIHBhcmFncmFwaCBpbnNpZGUgb2YgdGhlIFNWRyBkb2N1bWVudC5cbiAqXG4gKiBCZWNhdXNlIHRoaXMgdGVjaG5pcXVlIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYWxsIG9mIHRoZSBicm93c2VycyxcbiAqIHRoZSBmb3JlaWduT2JqZWN0IGVsZW1lbnQgaXMgd3JhcHBlZCBpbiA8c3dpdGNoPiwgd2hpY2hcbiAqIHByb3ZpZGVzIGZhbGxiYWNrIGZvciB0aG9zZSBjYXNlcy5cbiAqXG4gKiByZWFkIG1vcmU6IFtmb3JlaWduT2JqZWN0IG9uIE1ETiB3ZWIgZG9jc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0VsZW1lbnQvZm9yZWlnbk9iamVjdClcbiAqXG4gKiBAZXh0ZW5kcyBUYWdcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTXVsdGlMaW5lVGV4dCBleHRlbmRzIFRhZyB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggICAgICAgaG9yaXpvbnRhbCBwb3NpdGlvbiBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgICAgICAgdmVydGljYWwgcG9zaXRpb24gaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3ICAgICAgIHdpZHRoIG9mIHRoZSB0ZXh0IGJveCBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGggICAgICAgaGVpZ2h0IG9mIHRoZSB0ZXh0IGJveCBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRleHQgICAgdGV4dCBjb250ZW50IG9mIHRoZSB0ZXh0IGJveFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzaXplICAgIENTUyBmb250IHNpemUgb2YgdGhlIHRleHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbG9yPVwiYmxhY2tcIl0gY29sb3Igb2YgdGhlIHRleHRcbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHgsIHksIHcsIGgsIHRleHQsIHNpemUsIGNvbG9yID0gXCJibGFja1wiKSB7XG4gICAgICAgIHN1cGVyKFwic3dpdGNoXCIpO1xuXG4gICAgICAgIGxldCBmb3JlaWduT2JqZWN0ID0gbmV3IFRhZyhcImZvcmVpZ25PYmplY3RcIik7XG4gICAgICAgIGxldCBhbHRlcm5hdGl2ZVRleHQgPSBuZXcgVGV4dCh4LCB5LCB3LCBoLCB0ZXh0LCBzaXplLCBjb2xvcik7XG5cbiAgICAgICAgZm9yZWlnbk9iamVjdC5hZGRBdHRyKHtcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5LFxuICAgICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgICBoZWlnaHQ6IGhcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0ICR3cmFwcGVyID0gJChcIjxkaXY+XCIpXG4gICAgICAgICAgICAuYXR0cihcInhtbG5zXCIsIFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiKVxuICAgICAgICAgICAgLmFkZENsYXNzKFwibXVsdGlsaW5ldGV4dFwiKVxuICAgICAgICAgICAgLmNzcyhcImhlaWdodFwiLCBoKTtcblxuICAgICAgICBsZXQgJHBhcmFncmFwaCA9ICQoXCI8cD5cIilcbiAgICAgICAgICAgIC5hdHRyKFwieG1sbnNcIiwgXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIpXG4gICAgICAgICAgICAuY3NzKFwiZm9udC1zaXplXCIsIHNpemUpXG4gICAgICAgICAgICAuYXBwZW5kKHRleHQpO1xuXG4gICAgICAgICR3cmFwcGVyLmFwcGVuZCgkcGFyYWdyYXBoKTtcbiAgICAgICAgZm9yZWlnbk9iamVjdC4kZWwuYXBwZW5kKCR3cmFwcGVyKVxuXG4gICAgICAgIHRoaXMuJGVsLmFwcGVuZChcbiAgICAgICAgICAgIGZvcmVpZ25PYmplY3QuJGVsXG4gICAgICAgICkuYXBwZW5kKFxuICAgICAgICAgICAgYWx0ZXJuYXRpdmVUZXh0LiRlbFxuICAgICAgICApXG4gICAgfVxufVxuIiwiaW1wb3J0IFRhZyBmcm9tICcuL1RhZydcblxuLyoqIEBtb2R1bGUgc3ZnT2JqZWN0cy5QYXR0ZXJuICovXG5cbi8qKlxuICogcGF0dGVybiBvYmplY3QgaW4gU1ZHXG4gKiBAZXh0ZW5kcyBUYWdcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGF0dGVybiBleHRlbmRzIFRhZyB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkICAgICB1bmlxdWUgaWQgb2YgdGhpcyBwYXR0ZXJuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoICB3aWR0aCBvZiBvbmUgcGF0dGVybiB0aWxlIGluIFNWRyBwaXhlbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IGhlaWdodCBvZiBvbmUgcGF0dGVybiB0aWxlIGluIFNWRyBwaXhlbHNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpZCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihcInBhdHRlcm5cIik7XG5cbiAgICAgICAgdGhpcy5hZGRBdHRyKHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICBwYXR0ZXJuVW5pdHM6IFwidXNlclNwYWNlT25Vc2VcIixcbiAgICAgICAgICAgIHZpZXdCb3g6IFwiMCAwIFwiK3dpZHRoK1wiIFwiK2hlaWdodFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhZGQgYSBjaGlsZCB0byB0aGlzIHBhdHRlcm5cbiAgICAgKlxuICAgICAqIHBhdHRlcm4gYmVoYXZlcyBhIGxpdHRsZSBsaWtlIHtAbGluayBHcm91cH0gLSBpdCBjb250YWlucyBjaGlsZCBlbGVtZW50cywgd2hpY2ggcmVwcmVzZW50IHRoZSBjb250ZW50IG9mIG9uZSB0aWxlIG9mIHRoZSBwYXR0ZXJuXG4gICAgICogYW5kIHRoZSB3aG9sZSBwYWNrYWdlIG9mIHRoZSBjaGlsZCBlbGVtZW50cyBpcyByZXBlYXRlZCBvbiBlYWNoIHRpbGUgb2YgdGhlIHBhdHRlcm5cbiAgICAgKiBAcGFyYW0ge1N2Z0VsZW1lbnR9IGVsIGVsZW1lbnQgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBwYXR0ZXJuXG4gICAgICovXG4gICAgYWRkQ2hpbGQoZWwpIHtcbiAgICAgICAgdGhpcy4kZWwuYXBwZW5kKGVsLiRlbCk7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9XG59XG4iLCJpbXBvcnQgVGFnIGZyb20gJy4vVGFnJ1xuXG4vKiogQG1vZHVsZSBzdmdPYmplY3RzLlBvbHlMaW5lICovXG5cbi8qKlxuICogU1ZHIFBvbHlMaW5lIChhIHBhdGggZGVmaW5lZCBieSBzZXF1ZW5jZSBvZiBwb2ludHMgb24gcGxhbmUpXG4gKiBAZXh0ZW5kcyBUYWdcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9seUxpbmUgZXh0ZW5kcyBUYWcge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UG9seUxpbmVQb2ludHN9IHBvaW50cyBwb2ludHMgZGVzY3JpYmluZyB0aGlzIFBvbHlMaW5lXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdHJva2VXaWR0aF0gd2lkdGggb2YgdGhlIHN0cm9rZSBmb3IgdGhpcyBQb2x5TGluZSBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb2xvcl0gQ1NTIGNvbG9yIG9mIHRoaXMgUG9seUxpbmVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwb2ludHMsIHN0cm9rZVdpZHRoLCBjb2xvcikge1xuICAgICAgICBzdXBlcihcIlBvbHlMaW5lXCIpO1xuXG4gICAgICAgIGxldCBhdHRyaWJ1dGVzID0ge1xuICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMuc3RyaW5nLFxuICAgICAgICAgICAgZmlsbDogXCJub25lXCIsXG4gICAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiBzdHJva2VXaWR0aFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmKGNvbG9yIT09dW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnN0cm9rZSA9IGNvbG9yXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFkZEF0dHIoYXR0cmlidXRlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdXBkYXRlIHBvaW50cyBvZiB0aGlzIFBvbHlMaW5lXG4gICAgICogQHBhcmFtIHtQb2x5TGluZVBvaW50c30gcG9pbnRzIG5ldyBzZXQgb2YgcG9pbnRzIGRlc2NyaWJpbmcgdGhpcyBQb2x5TGluZVxuICAgICAqL1xuICAgIHVwZGF0ZVBvaW50cyhwb2ludHMpIHtcbiAgICAgICAgdGhpcy5hZGRBdHRyKHtcbiAgICAgICAgICAgIHBvaW50czogcG9pbnRzLnN0cmluZ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCIvKiogQG1vZHVsZSBzdmdPYmplY3RzLlBvbHlMaW5lUG9pbnQgKi9cblxuLyoqXG4gKiBvbmUgcG9pbnQgb2Yge0BsaW5rIFBvbHlMaW5lUG9pbnRzfSwgdXNlZCBpbiB0aGUge0BsaW5rIFBvbHlMaW5lfSBvYmplY3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9seUxpbmVQb2ludCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggaG9yaXpvbnRhbCBjb29yZGluYXRlIG9mIHRoZSBQb2x5TGluZSBwb2ludFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IHZlcnRpY2FsIGNvb3JkaW5hdGUgb2YgdGhlIFBvbHlMaW5lIHBvaW50XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeCwgeSkge1xuICAgICAgICB0aGlzLnggPSAwO1xuICAgICAgICB0aGlzLnkgPSAwO1xuICAgICAgICBpZih4ICE9PSB1bmRlZmluZWQgJiYgeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNoYW5nZSB0aGUgY29vcmRpbmF0ZXMgb2YgdGhpcyBwb2ludFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IGhvcml6b250YWwgY29vcmRpbmF0ZSBvZiB0aGUgUG9seUxpbmUgcG9pbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSB2ZXJ0aWNhbCBjb29yZGluYXRlIG9mIHRoZSBQb2x5TGluZSBwb2ludFxuICAgICAqL1xuICAgIHNldCh4LCB5KSB7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIFBvbHlMaW5lIGZyb20gYSBjb21tYSBzZXBhcmF0ZWQgc3RyaW5nIChlLmcuIGZyb20gYSBzdHJpbmcgZm9ybWF0dGVkIGxpa2UgdGhpczogXCJ4LHlcIiwgZm9yIGV4YW1wbGUgXCIxNSw4XCIpXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBzdHJpbmcgc3RyaW5nIGluIHRoZSBmb3JtYXQgXCJ4LHlcIiByZXByZXNlbnRpbmcgYSBwb2ludCBpbiB0aGUgU1ZHIFBvbHlMaW5lXG4gICAgICogQHJldHVybiB7UG9seUxpbmVQb2ludH0gbmV3bHkgY3JlYXRlZCBpbnN0YW5jZSBvZiB7QGxpbmsgUG9seUxpbmVQb2ludH1cbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VGcm9tU3RyaW5nKHN0cmluZykge1xuICAgICAgICBsZXQgYXJyID0gc3RyaW5nLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5TGluZVBvaW50KGFyclswXSwgYXJyWzFdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBQb2x5TGluZSBwb2ludFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gc3RyaW5nIGluIHRoZSBmb3JtYXQgXCJ4LHlcIlxuICAgICAqL1xuICAgIGdldCBzdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggKyBcIixcIiArIHRoaXMueTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb21wYXJlIFBvbHlMaW5lIHBvaW50cywgcmV0dXJuIGB0cnVlYCBpZiB0aGV5IGFyZSBlcXVhbCwgZWxzZSByZXR1cm4gYGZhbHNlYFxuICAgICAqIEBwYXJhbSAge1BvbHlMaW5lUG9pbnR9IGFcbiAgICAgKiBAcGFyYW0gIHtQb2x5TGluZVBvaW50fSBiXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEueCA9PT0gYi54ICYmIGEueSA9PT0gYi55O1xuICAgIH1cbn1cbiIsImltcG9ydCBQb2x5TGluZVBvaW50IGZyb20gJy4vUG9seUxpbmVQb2ludCdcblxuLyoqIEBtb2R1bGUgc3ZnT2JqZWN0cy5Qb2x5TGluZVBvaW50cyAqL1xuXG4vKipcbiAqIGFycmF5LWxpa2Ugc3RydWN0dXJlIHVzZWQgaW4ge0BsaW5rIFBvbHlMaW5lUG9pbnRzfVxuICovXG5jbGFzcyBTbWFydEFycmF5IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyXSBpZiBzZXQsIGluaXRpYWxpemVkIFNtYXJ0QXJyYXkgd2lsbCBjb250YWluIHRoZXNlIHZhbHVlc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFycikge1xuICAgICAgICBpZihhcnIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5hcnIgPSBhcnI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFyciA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IGEgZGVlcCBjb3B5IG9mIHRoaXMgYXJyYXlcbiAgICAgKiBAcmV0dXJuIHtTbWFydEFycmF5fVxuICAgICAqL1xuICAgIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiBTbWFydEFycmF5KCQuZXh0ZW5kKHRydWUsIFtdLCB0aGlzLmFycikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFwcGVuZCBhbiBpdGVtIHRvIHRoZSBhcnJheVxuICAgICAqIEBwYXJhbSBpdGVtIG5ldyBpdGVtIHRoYXQgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgYXJyYXlcbiAgICAgKi9cbiAgICBhcHBlbmQoaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRXaXRoSW5kZXgoaXRlbSwgdGhpcy5hcnIubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwcmVwZW5kIGFuIGl0ZW0gdG8gdGhlIGFycmF5XG4gICAgICogQHBhcmFtIGl0ZW0gbmV3IGl0ZW0gdGhhdCB3aWxsIGJlIHByZXBlbmRlZCB0byB0aGUgYXJyYXlcbiAgICAgKi9cbiAgICBwcmVwZW5kKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkV2l0aEluZGV4KGl0ZW0sIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFkZCBhIG5ldyBpdGVtIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXgsIG1vdmUgYWxsIGZvbGxvd2luZyBpdGVtc1xuICAgICAqIEBwYXJhbSBpdGVtIG5ldyBpdGVtIHRoYXQgd2lsbCBiZSBhZGRlZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4IG9mIHRoaXMgaXRlbVxuICAgICAqL1xuICAgIGFkZFdpdGhJbmRleChpdGVtLCBpbmRleCkge1xuICAgICAgICBmb3IobGV0IGkgPSB0aGlzLmFyci5sZW5ndGggOyBpID4gaW5kZXggOyAtLWkpIHtcbiAgICAgICAgICAgIHRoaXMuYXJyW2ldID0gdGhpcy5hcnJbaS0xXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFycltpbmRleF0gPSBpdGVtO1xuICAgICAgICByZXR1cm4gdGhpczsgLy8gdG8gZW5hYmxlIGNoYWluaW5nIG9mIGFwcGVuZCAvIHByZXBwZW5kIC8gYWRkV2l0aEluZGV4IGNvbW1hbmRzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IGxlbmd0aCBvZiB0aGUgYXJyYXlcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgaXRlbSBieSBpbmRleFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gaW5kZXggaW5kZXggb2YgdGhlIGl0ZW1cbiAgICAgKiBAcmV0dXJuIGNvbnRlbnRzIG9mIHRoZSBhcnJheSBvbiB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAgICovXG4gICAgZ2V0SXRlbShpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcnJbaW5kZXhdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gbGFzdCBlbGVtZW50IG9mIHRoZSBhcnJheVxuICAgICAqL1xuICAgIGdldCBsYXN0KCkge1xuICAgICAgICBpZih0aGlzLmxlbmd0aCE9PTApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFyclt0aGlzLmxlbmd0aCAtIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiBmaXJzdCBlbGVtZW50IG9mIHRoZSBhcnJheVxuICAgICAqL1xuICAgIGdldCBmaXJzdCgpIHtcbiAgICAgICAgaWYodGhpcy5sZW5ndGghPT0wKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcnJbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgYW4gaXRlbSBmcm9tIHRoZSBhcnJheSBieSBpbmRleFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gaW5kZXggaW5kZXggb2YgdGhlIGl0ZW0gdGhhdCB3aWxsIGJlIHJlbW92ZWRcbiAgICAgKi9cbiAgICByZW1vdmUoaW5kZXgpIHtcbiAgICAgICAgbGV0IGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuXG4gICAgICAgIGZvcihsZXQgaSA9IGluZGV4IDsgaSA8IGxlbmd0aCA7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5hcnJbaV0gPSB0aGlzLmFycltpICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcnIucG9wKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbWFrZSB0aGUgYXJyYXkgaXRlcmFibGVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBsZXQgaW5kZXggPSAtMTtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmFycjtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dDogKCkgPT4gKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGF0YVsrK2luZGV4XSxcbiAgICAgICAgICAgICAgICBkb25lOiAhKGluZGV4IGluIGRhdGEpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIG1hcChmdW5jKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFyci5tYXAoZnVuYyk7XG4gICAgfVxufVxuXG4vKipcbiAqIHBvaW50cyBvZiB0aGUge0BsaW5rIFBvbHlMaW5lfVxuICogQGV4dGVuZHMgU21hcnRBcnJheVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2x5TGluZVBvaW50cyBleHRlbmRzIFNtYXJ0QXJyYXkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcnJdIGFycmF5IGNvbnRhaW5pbmcgaW5zdGFuY2VzIG9mIHtAbGluayBQb2x5TGluZVBvaW50fVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFycikge1xuICAgICAgICBzdXBlcihhcnIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCBhIGRlZXAgY29weSBvZiB0aGlzIG9iamVjdFxuICAgICAqIEByZXR1cm4ge1BvbHlMaW5lUG9pbnRzfVxuICAgICAqL1xuICAgIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9seUxpbmVQb2ludHMoJC5leHRlbmQodHJ1ZSwgW10sIHRoaXMuYXJyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYXBwZW5kIGEgcG9pbnRcbiAgICAgKiBAcGFyYW0gIHtQb2x5TGluZVBvaW50fSBwb2ludCBhIG5ldyBwb2ludFxuICAgICAqL1xuICAgIGFwcGVuZChwb2ludCkge1xuICAgICAgICAvLyBjYWxsIGluaGVyaXRlZCBmdW5jdGlvbiB0byBoYW5kbGUgdGhlIGFwcGVuZGluZ1xuICAgICAgICBzdXBlci5hcHBlbmQocG9pbnQpO1xuXG4gICAgICAgIC8vIGlmIHRoZSBzZWNvbmQgdG8gbGFzdCBwb2ludCBpcyB1bm5lY2Vzc2FyeSwgcmVtb3ZlIGl0XG4gICAgICAgIGxldCBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKCBsZW5ndGggPj0gM1xuICAgICAgICAgICAgICAgICYmICggICAgKCB0aGlzLmdldEl0ZW0obGVuZ3RoIC0gMykueCA9PT0gdGhpcy5nZXRJdGVtKGxlbmd0aCAtIDIpLnggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRJdGVtKGxlbmd0aCAtIDIpLnggPT09IHRoaXMuZ2V0SXRlbShsZW5ndGggLSAxKS54IClcbiAgICAgICAgICAgICAgICAgICAgIHx8ICggdGhpcy5nZXRJdGVtKGxlbmd0aCAtIDMpLnkgPT09IHRoaXMuZ2V0SXRlbShsZW5ndGggLSAyKS55ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0SXRlbShsZW5ndGggLSAyKS55ID09PSB0aGlzLmdldEl0ZW0obGVuZ3RoIC0gMSkueSApXG4gICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGxlbmd0aCAtIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJuIHRoaXMgZWxlbWVudCAodG8gYWxsb3cgY2hhaW5pbmcpXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHBhcnNlIFBvbHlMaW5lIGZyb20gc3RyaW5nXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBzdHJpbmcgc3RyaW5nIGluIHRoZSBQb2x5TGluZSBmb3JtYXQgKGB4MSx5MSB4Mix5MiwgeDMseTNgKVxuICAgICAqIEByZXR1cm4ge1BvbHlMaW5lUG9pbnRzfSBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgUG9seUxpbmVQb2ludHN9IGNyZWF0ZWQgYnkgcGFyc2luZyB0aGUgc3RyaW5nXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlRnJvbVN0cmluZyhzdHJpbmcpIHtcbiAgICAgICAgbGV0IHBvaW50U3RyaW5ncyA9IHN0cmluZy5zcGxpdChcIiBcIik7XG4gICAgICAgIGxldCBwb2ludHMgPSBuZXcgUG9seUxpbmVQb2ludHMoKTtcblxuICAgICAgICBmb3IobGV0IGkgPSAwIDsgaSA8IHBvaW50U3RyaW5ncy5sZW5ndGggOyArK2kpIHtcbiAgICAgICAgICAgIHBvaW50cy5hcHBlbmQoUG9seUxpbmVQb2ludC5wYXJzZUZyb21TdHJpbmcocG9pbnRTdHJpbmdzW2ldKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIFBvbHlMaW5lXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBzdHJpbmcgaW4gdGhlIFBvbHlMaW5lIGZvcm1hdCAoYHgxLHkxIHgyLHkyLCB4Myx5M2ApXG4gICAgICovXG4gICAgZ2V0IHN0cmluZygpIHtcbiAgICAgICAgbGV0IHN0cmluZyA9IFwiXCI7XG4gICAgICAgIGZvcihsZXQgaSA9IDAgOyBpIDwgdGhpcy5sZW5ndGggOyArK2kpIHtcbiAgICAgICAgICAgIGlmKGkgIT09IDApIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gXCIgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJpbmcgKz0gdGhpcy5hcnJbaV0uc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogd3JhcHBlciBmb3IgZm9yZWFjaCBvbiB0aGUgUG9seUxpbmUgcG9pbnRzXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGZ1bmMgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIGVsZW1lbnRcbiAgICAgKi9cbiAgICBmb3JFYWNoKGZ1bmMpIHtcbiAgICAgICAgZm9yKGxldCBpID0gMCA7IGkgPCB0aGlzLmFyci5sZW5ndGggOyArK2kpIHtcbiAgICAgICAgICAgIGZ1bmModGhpcy5hcnJbaV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IFN2Z0VsZW1lbnQgZnJvbSAnLi9TdmdFbGVtZW50J1xuXG4vKiogQG1vZHVsZSBzdmdPYmplY3RzLlJlY3RhbmdsZSAqL1xuXG4vKipcbiAqIGEgcmVjdGFuZ2xlIGluIFNWR1xuICogQGV4dGVuZHMgU3ZnRWxlbWVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWN0YW5nbGUgZXh0ZW5kcyBTdmdFbGVtZW50IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAgICAgICBob3Jpem9udGFsIHBvc2l0aW9uIGluIFNWRyBwaXhlbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAgICAgICB2ZXJ0aWNhbCBwb3NpdGlvbiBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHcgICAgICAgd2lkdGggaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoICAgICAgIGhlaWdodCBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGwgICAgZmlsbGluZyBjb2xvciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cm9rZSAgc3Ryb2tlIGNvbG9yIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih4LCB5LCB3LCBoLCBmaWxsLCBzdHJva2UpIHtcbiAgICAgICAgc3VwZXIoeCwgeSwgdywgaCwgXCJyZWN0XCIpO1xuICAgICAgICB0aGlzLmFkZEF0dHIoe1xuICAgICAgICAgICAgZmlsbDogZmlsbCxcbiAgICAgICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IDAuNSxcbiAgICAgICAgICAgICdwb2ludGVyLWV2ZW50cyc6ICdhbGwnIC8vIHRvIHRyaWdnZXIgaG92ZXIgZXZlbiB3aXRoIHRyYW5zcGFyZW50IGJhY2tncm91bmRcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IFRhZyBmcm9tICcuL1RhZydcblxuLyoqIEBtb2R1bGUgc3ZnT2JqZWN0cy5TdmdFbGVtZW50ICovXG5cbi8qKlxuICogcmVwcmVzZW50cyB2aXNpYmxlIGVsZW1lbnQgaW4gU1ZHIHRoYXQgaGFzIHBvc2l0aW9uIGFuZCBkaW1lbnNpb25zIChmb3IgZXhhbXBsZSBgcmVjdGFuZ2xlYCBpcyBhIFN2Z0VsZW1lbnQsIGJ1dCBgcGF0dGVybmAgaXMgbm90LCBldmVuIHRob3VnaCBib3RoIGFyZSB0YWdzKVxuICogQGV4dGVuZHMgVGFnXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN2Z0VsZW1lbnQgZXh0ZW5kcyBUYWcge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4ICAgICAgIGhvcml6b250YWwgcG9zaXRpb24gaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5ICAgICAgIHZlcnRpY2FsIHBvc2l0aW9uIGluIFNWRyBwaXhlbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdyAgICAgICB3aWR0aCBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGggICAgICAgaGVpZ2h0IGluIFNWRyBwaXhlbHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZSB0YWcgbmFtZSBvZiB0aGUgZWxlbWVudFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHgsIHksIHcsIGgsIHRhZ05hbWUpIHtcbiAgICAgICAgc3VwZXIodGFnTmFtZSk7XG5cbiAgICAgICAgdGhpcy5hZGRBdHRyKHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgICBoZWlnaHQ6IGhcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IFN2Z0VsZW1lbnQgZnJvbSAnLi9TdmdFbGVtZW50J1xuXG4vKiogQG1vZHVsZSBzdmdPYmplY3RzLlN2Z0ltYWdlICovXG5cbi8qKlxuICogYW4gaW1hZ2UgaW4gU1ZHXG4gKiBAZXh0ZW5kcyBTdmdFbGVtZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN2Z0ltYWdlIGV4dGVuZHMgU3ZnRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoeCwgeSwgdywgaCwgdXJsKSB7XG4gICAgICAgIHN1cGVyKHgsIHksIHcsIGgsIFwiaW1hZ2VcIik7XG4gICAgICAgIHRoaXMuYWRkQXR0cih7XG4gICAgICAgICAgICBcInhsaW5rOmhyZWZcIjogdXJsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNoYW5nZSB1cmwgb2YgdGhlIGltYWdlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCB0aGUgbmV3IHVybCBvZiB0aGUgaW1hZ2VcbiAgICAgKi9cbiAgICBjaGFuZ2VVcmwodXJsKSB7XG4gICAgICAgIHRoaXMuYWRkQXR0cih7XG4gICAgICAgICAgICBcInhsaW5rOmhyZWZcIjogdXJsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsImltcG9ydCBJZCBmcm9tICcuLi9vdGhlci9pZCdcblxuLyoqIEBtb2R1bGUgc3ZnT2JqZWN0cy5UYWcgKi9cblxuLyoqXG4gKiBQYXJlbnQgY2xhc3MgZm9yIGFsbCBzdmdPYmplY3RzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRhZyB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgU1ZHIHRhZyBpZGVudGlmaWVyIChgcmVjdGAsIGBpbWFnZWAsIGBQb2x5TGluZWApXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGFnTmFtZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogU1ZHIHRhZyBpZGVudGlmaWVyIChgcmVjdGAsIGBpbWFnZWAsIGBQb2x5TGluZWApXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhZ05hbWUgPSB0YWdOYW1lO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBqUXVlcnkgZWxlbWVudCBmb3IgdGhpcyB0YWdcbiAgICAgICAgICogQHR5cGUge2pRdWVyeS5lbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy4kZWwgPSAkKFwiPFwiK3RoaXMudGFnTmFtZStcIj5cIik7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHVuaXF1ZSBJRCBvZiB0aGlzIFNWRyBvYmplY3RcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBuZXcgSWQoKS51bmlxdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWRkIGEgY2xhc3MgdG8gdGhpcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgY2xhc3MgbmFtZSB0byBiZSBhZGRlZFxuICAgICAqL1xuICAgIGFkZENsYXNzKG5hbWUpIHtcbiAgICAgICAgdGhpcy5jaGVja0lmRWxlbWVudEV4aXN0c0luRE9NKCk7XG5cbiAgICAgICAgdGhpcy4kZWwuYWRkQ2xhc3MobmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIGNsYXNzIG5hbWVzIGZyb20gdGhpcyBlbGVtZW50XG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBjbGFzc2VzIGNsYXNzIG5hbWVzIHRvIGJlIHJlbW92ZWRcbiAgICAgKi9cbiAgICByZW1vdmVDbGFzc2VzKC4uLmNsYXNzZXMpIHtcbiAgICAgICAgdGhpcy5jaGVja0lmRWxlbWVudEV4aXN0c0luRE9NKCk7XG5cbiAgICAgICAgZm9yKGxldCBpdGVtIG9mIGNsYXNzZXMpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsLnJlbW92ZUNsYXNzKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0IGF0dHJpYnV0ZXMgb2YgdGhpcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFzc29jIGphdmFzY3JpcHQgb2JqZWN0IHRoYXQgd2lsbCBiZSBtYXBwZWQgaW50byBhdHRyaWJ1dGVzIChge2tleTogdmFsdWV9YCAtPiBga2V5PVwidmFsdWVcImApXG4gICAgICovXG4gICAgYWRkQXR0cihhc3NvYykge1xuICAgICAgICB0aGlzLmNoZWNrSWZFbGVtZW50RXhpc3RzSW5ET00oKTtcblxuICAgICAgICAvLyBhZGQgYXR0cmlidXRlcyB0byB0aGUgZWxlbWVudFxuICAgICAgICB0aGlzLiRlbC5hdHRyKGFzc29jKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgYXR0cmlidXRlIHZhbHVlIGJ5IG5hbWVcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgICogQHJldHVybiB7c3RyaW5nfSAgICAgIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICAgKi9cbiAgICBnZXRBdHRyKG5hbWUpIHtcbiAgICAgICAgdGhpcy5jaGVja0lmRWxlbWVudEV4aXN0c0luRE9NKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJGVsLmF0dHIobmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIGF0dHJpYnV0ZSBieSB2YWx1ZVxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gYmUgcmVtb3ZlZFxuICAgICAqL1xuICAgIHJlbW92ZUF0dHIobmFtZSkge1xuICAgICAgICB0aGlzLmNoZWNrSWZFbGVtZW50RXhpc3RzSW5ET00oKTtcblxuICAgICAgICB0aGlzLiRlbC5yZW1vdmVBdHRyKG5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldCBpZCBvZiB0aGlzIFNWRyBvYmplY3RcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkIG5ldyBpZCBmb3IgdGhpcyBvYmplY3RcbiAgICAgKi9cbiAgICBzZXQgaWQoaWQpIHtcbiAgICAgICAgdGhpcy5hZGRBdHRyKHtcImlkXCI6IGlkfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IGlkIG9mIHRoaXMgU1ZHIG9iamVjdFxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEF0dHIoXCJpZFwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgalF1ZXJ5IGVsZW1lbnQgZm9yIHRoaXMgU1ZHIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2pRdWVyeS5lbGVtZW50fVxuICAgICAqL1xuICAgIGdldCgpIHtcbiAgICAgICAgdGhpcy5jaGVja0lmRWxlbWVudEV4aXN0c0luRE9NKCk7XG4gICAgICAgIHJldHVybiB0aGlzLiRlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjaGVjayBpZiB0aGUgZWxlbWVudCBleGlzdHMgaW4gZG9tLCBpZiBzbywgcmVmZXRjaCBpdCBmcm9tIERPTSB1c2luZyBqUXVlcnlcbiAgICAgKi9cbiAgICBjaGVja0lmRWxlbWVudEV4aXN0c0luRE9NKCkge1xuICAgICAgICBsZXQgJGpxRWxlbWVudCA9ICQoXCIjXCIrdGhpcy4kZWwuYXR0cignaWQnKSk7XG4gICAgICAgIGlmKCRqcUVsZW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLiRlbCA9ICRqcUVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgVGFnIGZyb20gJy4vVGFnJ1xuXG4vKiogQG1vZHVsZSBzdmdPYmplY3RzLlRleHQgKi9cblxuLyoqXG4gKiBUZXh0IGVsZW1lbnQgaW4gU1ZHXG4gKiBAZXh0ZW5kcyBUYWdcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dCBleHRlbmRzIFRhZyB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggICAgICAgaG9yaXpvbnRhbCBwb3NpdGlvbiBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgICAgICAgdmVydGljYWwgcG9zaXRpb24gaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3ICAgICAgIHdpZHRoIG9mIHRoZSB0ZXh0IGJveCBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGggICAgICAgaGVpZ2h0IG9mIHRoZSB0ZXh0IGJveCBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRleHQgICAgdGV4dCBjb250ZW50IG9mIHRoZSB0ZXh0IGJveFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzaXplICAgIENTUyBmb250IHNpemUgb2YgdGhlIHRleHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbG9yPVwiYmxhY2tcIl0gY29sb3Igb2YgdGhlIHRleHRcbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHgsIHksIHcsIGgsIHRleHQsIHNpemUsIGNvbG9yID0gXCJibGFja1wiKSB7XG4gICAgICAgIHN1cGVyKFwidGV4dFwiKTtcbiAgICAgICAgdGhpcy5hZGRBdHRyKHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgICBoZWlnaHQ6IGgsXG4gICAgICAgICAgICBmaWxsOiBjb2xvclxuICAgICAgICB9KTtcblxuICAgICAgICBpZihzaXplKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEF0dHIoe1xuICAgICAgICAgICAgICAgICdmb250LXNpemUnOiBzaXplXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4kZWwuYXBwZW5kKHRleHQpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7XG4gICAgZ2V0TGlicmFyeSxcbiAgICBnZXROZXR3b3JrRnJvbUxpYnJhcnlcbn0gZnJvbSAnLi9uZXR3b3JrTGlicmFyeSc7XG5cbmltcG9ydCB7R2F0ZX0gZnJvbSAnLi4vZWRpdG9yRWxlbWVudHMnXG5cbi8qKlxuICogSXRlbSBpbiB0aGUgW0NvbnRleHRNZW51XSguL21vZHVsZS1Db250ZXh0TWVudS5odG1sKS4gQ29udGV4dE1lbnVJdGVtcyBjYW4gYmUgbmVzdGVkIHVzaW5nIHRoZSBhcHBlbmRJdGVtIGZ1bmN0aW9uLlxuICovXG5jbGFzcyBDb250ZXh0TWVudUl0ZW0ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0ICAgICAgICAgIHRleHQgb24gdGhlIGJ1dHRvblxuICAgICAqIEBwYXJhbSB7Q29udGV4dE1lbnV9IGNvbnRleHRNZW51IGluc3RhbmNlIG9mIHRoZSBbQ29udGV4dE1lbnVdKC4vbW9kdWxlLUNvbnRleHRNZW51Lmh0bWwpIHRoaXMgaXRlbSBiZWxvbmdzIHRvXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2xpY2tGdW5jdGlvbiBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdXNlciBjbGlja3MgdGhpcyBpdGVtXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGV4dCwgY29udGV4dE1lbnUsIGNsaWNrRnVuY3Rpb24pIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRleHQgb24gdGhlIGJ1dHRvblxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogaW5zdGFuY2Ugb2YgdGhlIFtDb250ZXh0TWVudV0oLi9tb2R1bGUtQ29udGV4dE1lbnUuaHRtbCkgdGhpcyBpdGVtIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHR5cGUge0NvbnRleHRNZW51fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250ZXh0TWVudSA9IGNvbnRleHRNZW51O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBqUXVlcnkgZWxlbWVudCByZXByZXNlbnRpbmcgRE9NIGNvbnRlbnQgb2YgdGhpcyBtZW51IGl0ZW1cbiAgICAgICAgICogQHR5cGUge2pRdWVyeS5lbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy4kZWwgPSAkKFwiPGxpPlwiKS50ZXh0KHRleHQpO1xuXG4gICAgICAgIC8vIHNldCB1cCBjbGljayBjYWxsYmFjayBpZiBjbGlja0Z1bmN0aW9uIGlzIGRlZmluZWRcbiAgICAgICAgaWYoY2xpY2tGdW5jdGlvbiE9PXVuZGVmaW5lZCkge1xuICAgICAgICAgICAgJCh0aGlzLiRlbCkuY2xpY2soXG4gICAgICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWNrRnVuY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dE1lbnUuaGlkZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogalF1ZXJ5IGVsZW1lbnQgY29udGFpbmluZyB0aGUgc3VibWVudSAob3IgdW5kZWZpbmVkLCBpZiBpdGVtIGhhcyBubyBzdWJpdGVtcylcbiAgICAgICAgICogQHR5cGUge2pRdWVyeS5lbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy4kc3VibWVudSA9IHVuZGVmaW5lZFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzdWJtZW51IGl0ZW0gY291bnRlclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pdGVtQ291bnQgPSAwXG5cbiAgICAgICAgLy8gc2V0IGhvdmVyIGNhbGxiYWNrXG4gICAgICAgICQodGhpcy4kZWwpLmhvdmVyKChldmVudCkgPT4ge1xuICAgICAgICAgICAgLy8gbW91c2Ugb25cblxuICAgICAgICAgICAgaWYodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kc3VibWVudS5jc3Moe1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogdGhpcy4kZWwub2Zmc2V0KCkudG9wLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLiRlbC5wYXJlbnQoKS5vZmZzZXQoKS5sZWZ0ICsgdGhpcy4kZWwucGFyZW50KCkud2lkdGgoKSxcbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0TWVudS4kZWwuYWZ0ZXIodGhpcy4kc3VibWVudSk7XG5cbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBtb3VzZSBvdXRcbiAgICAgICAgICAgIGlmKHRoaXMuJHN1Ym1lbnUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRzdWJtZW51LmNzcyh7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwibm9uZVwiXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZG8gbm90IHN0b3AgZXZlbnQgcHJvcGFnYXRpb24sIGhlcmUgaXQgaXMgd2FudGVkXG4gICAgICAgICAgICAvLyAoYmVjYXVzZSBzdWJtZW51IG92ZXJyaWRlcyBkaXNwbGF5OiBub25lIHdoZW4gdXNlciBtb3ZlcyBmcm9tIHRoaXMgbWVudSBpdGVtIHRvIHRoZSBzdWJtZW51KVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGluc3RhbmNlIG9mIFtDYW52YXNdKC4vbW9kdWxlLUNhbnZhcy5odG1sKSB0aGlzIG1lbnUgYmVsb25ncyB0b1xuICAgICAqIEB0eXBlIHtDYW52YXN9XG4gICAgICovXG4gICAgZ2V0IHBhcmVudFNWRygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dE1lbnUucGFyZW50U1ZHO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgc3VibWVudVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtQ291bnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWRkIGEgQ1NTIGNsYXNzIHRvIHRoaXMgaXRlbVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbHMgW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgIGFkZENsYXNzKGNscykge1xuICAgICAgICB0aGlzLiRlbC5hZGRDbGFzcyhjbHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhcHBlbmQgYSBuZXN0ZWQge0BsaW5rIENvbnRleHRNZW51SXRlbX0gdG8gdGhpcyBpdGVtXG4gICAgICogQHBhcmFtICB7Q29udGV4dE1lbnVJdGVtfSBpdGVtIGl0ZW0gdGhhdCB3aWxsIGJlIGFwcGVuZGVkXG4gICAgICovXG4gICAgYXBwZW5kSXRlbShpdGVtKSB7XG4gICAgICAgIGlmKCF0aGlzLiRzdWJtZW51KSB7XG4gICAgICAgICAgICB0aGlzLiRzdWJtZW51ID0gJChcIjx1bD5cIikuYWRkQ2xhc3MoXCJzdWJMaXN0XCIpO1xuICAgICAgICAgICAgdGhpcy4kc3VibWVudS5ob3ZlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4kc3VibWVudS5jc3MoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG4gICAgICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4kc3VibWVudS5jc3MoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kc3VibWVudS5hcHBlbmQoaXRlbS4kZWwpO1xuXG4gICAgICAgIHRoaXMuaXRlbUNvdW50Kys7XG5cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IGpRdWVyeSBlbGVtZW50IG9mIHRoaXMgbWVudSBpdGVtXG4gICAgICogQHJldHVybiB7alF1ZXJ5LmVsZW1lbnR9IGpRdWVyeSBlbGVtZW50IGNvbnRhaW5pbmcgYWxsIERPTSBjb250ZW50IGZvciB0aGlzIG1lbnUgaXRlbVxuICAgICAqL1xuICAgIGdldCBqUXVlcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRlbDtcbiAgICB9XG5cbiAgICBnZXQgalF1ZXJ5U3VibWVudSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHN1Ym1lbnU7XG4gICAgfVxufVxuXG4vKipcbiAqIE1lbnUgaXRlbSB0aGF0IGhhcyBhIGN1c3RvbSBjbGljayBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGFkZHMgYSB7QGxpbmsgR2F0ZX0gb2YgdGhlIHNwZWNpZmllZCB0eXBlIHRvIHRoZSBbQ2FudmFzXSguL21vZHVsZS1DYW52YXMuaHRtbClcbiAqIEBleHRlbmRzIENvbnRleHRNZW51SXRlbVxuICovXG5jbGFzcyBHYXRlTWVudUl0ZW0gZXh0ZW5kcyBDb250ZXh0TWVudUl0ZW0ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlICAgICAgICB0eXBlIG9mIHRoZSBnYXRlIHtAbGluayBHYXRlfSAoYW5kLCBvciwgLi4uKVxuICAgICAqIEBwYXJhbSB7Q29udGV4dE1lbnV9IGNvbnRleHRNZW51IGluc3RhbmNlIG9mIHRoZSBbQ29udGV4dE1lbnVdKC4vbW9kdWxlLUNvbnRleHRNZW51Lmh0bWwpIHRoYXQgdGhpcyBpdGVtIGJlbG9uZ3MgdG9cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBjb250ZXh0TWVudSkge1xuICAgICAgICBzdXBlcihcbiAgICAgICAgICAgIGAke3R5cGUudG9VcHBlckNhc2UoKX0gZ2F0ZWAsXG4gICAgICAgICAgICBjb250ZXh0TWVudSxcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFNWRy5uZXdHYXRlKFxuICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFNWRy5zbmFwVG9HcmlkKHRoaXMucGFyZW50U1ZHLnZpZXdib3gudHJhbnNmb3JtWChjb250ZXh0TWVudS5wb3NpdGlvbi54KSksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50U1ZHLnNuYXBUb0dyaWQodGhpcy5wYXJlbnRTVkcudmlld2JveC50cmFuc2Zvcm1ZKGNvbnRleHRNZW51LnBvc2l0aW9uLnkpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIE1lbnUgaXRlbSB0aGF0IGhhcyBhIGN1c3RvbSBjbGljayBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGFkZHMgYSBzcGVjaWZpZWQge0BsaW5rIEJsYWNrYm94fSB0byB0aGUgW0NhbnZhc10oLi9tb2R1bGUtQ2FudmFzLmh0bWwpXG4gKiBAZXh0ZW5kcyBDb250ZXh0TWVudUl0ZW1cbiAqL1xuY2xhc3MgQmxhY2tib3hNZW51SXRlbSBleHRlbmRzIENvbnRleHRNZW51SXRlbSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgZmlsZSwgY29udGV4dE1lbnUpIHtcbiAgICAgICAgc3VwZXIoXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgY29udGV4dE1lbnUsXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZ2V0TmV0d29ya0Zyb21MaWJyYXJ5KGZpbGUpLnRoZW4oKHtibGFja2JveCwgbmFtZX0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qge2lucHV0cywgb3V0cHV0cywgdGFibGV9ID0gYmxhY2tib3g7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBuYW1lIHNwZWNpZmllZCBpbiB0aGUgYmxhY2tib3ggaXRlbSwgaWYgaXQgZG9lcyBub3QgZXhpc3QsIHVzZSB0aGUgbmFtZSBmb3IgdGhlIG5ldHdvcmtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVzZWROYW1lID0gYmxhY2tib3gubmFtZSB8fCBuYW1lO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50U1ZHLm5ld0JsYWNrYm94KFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlZE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFNWRy5zbmFwVG9HcmlkKHRoaXMucGFyZW50U1ZHLnZpZXdib3gudHJhbnNmb3JtWChjb250ZXh0TWVudS5wb3NpdGlvbi54KSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFNWRy5zbmFwVG9HcmlkKHRoaXMucGFyZW50U1ZHLnZpZXdib3gudHJhbnNmb3JtWShjb250ZXh0TWVudS5wb3NpdGlvbi55KSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIClcbiAgICB9XG59XG5cbi8qKlxuICogTWVudSBpdGVtIHRoYXQgaGFzIGEgY3VzdG9tIGNsaWNrIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgYWRkcyBhIHNwZWNpZmllZCBOZXR3b3JrIHRvIHRoZSBbQ2FudmFzXSguL21vZHVsZS1DYW52YXMuaHRtbClcbiAqIEBleHRlbmRzIENvbnRleHRNZW51SXRlbVxuICovXG5jbGFzcyBOZXR3b3JrTWVudUl0ZW0gZXh0ZW5kcyBDb250ZXh0TWVudUl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGZpbGUsIGNvbnRleHRNZW51KSB7XG4gICAgICAgIHN1cGVyKFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGNvbnRleHRNZW51LFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGdldE5ldHdvcmtGcm9tTGlicmFyeShmaWxlKS50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFNWRy5pbXBvcnREYXRhKFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgucm91bmQodGhpcy5wYXJlbnRTVkcudmlld2JveC50cmFuc2Zvcm1YKGNvbnRleHRNZW51LnBvc2l0aW9uLngpIC8gdGhpcy5wYXJlbnRTVkcuZ3JpZFNpemUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5yb3VuZCh0aGlzLnBhcmVudFNWRy52aWV3Ym94LnRyYW5zZm9ybVkoY29udGV4dE1lbnUucG9zaXRpb24ueSkgLyB0aGlzLnBhcmVudFNWRy5ncmlkU2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgKS50aGVuKHdhcm5pbmdzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgd2FybmluZyBvZiB3YXJuaW5ncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50U1ZHLm1lc3NhZ2VzLm5ld1dhcm5pbmdNZXNzYWdlKHdhcm5pbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFNWRy5tZXNzYWdlcy5uZXdFcnJvck1lc3NhZ2UoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIClcbiAgICB9XG59XG5cbi8qKiBAbW9kdWxlIENvbnRleHRNZW51ICovXG4vKipcbiAqIENvbnRleHRNZW51IHJlcHJlc2VudHMgdGhlIG1lbnUgdGhhdCBpcyBkaXNwbGF5ZWQgdG8gdGhlIHVzZXIgd2hlbiB0aGV5IHJpZ2h0IGNsaWNrIG9uIGEgY2FudmFzLlxuICogVGhpcyBtZW51IGFsbG93cyB1c2VyIHRvIGFkZCBlbGVtZW50cyB0byB0aGUgQ2FudmFzIGFuZCBpbiB0aGUgY2FzZSB0aGF0IHVzZXIgcmlnaHRjbGlja2VkXG4gKiBvbiBhIHNwZWNpZmljIGVsZW1lbnQsIHRoaXMgbWVudSBhbGxvd3MgdGhlbSB0byByZW1vdmUgdGhpcyBlbGVtZW50LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb250ZXh0TWVudSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDYW52YXN9IHBhcmVudFNWRyBpbnN0YW5jZSBvZiBbQ2FudmFzXSguL21vZHVsZS1DYW52YXMuaHRtbCkgdGhpcyBtZW51IGJlbG9uZ3MgdG9cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXJlbnRTVkcpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGluc3RhbmNlIG9mIFtDYW52YXNdKC4vbW9kdWxlLUNhbnZhcy5odG1sKSB0aGlzIG1lbnUgYmVsb25ncyB0b1xuICAgICAgICAgKiBAdHlwZSB7Q2FudmFzfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYXJlbnRTVkcgPSBwYXJlbnRTVkc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBvc2l0aW9uIG9mIHRoZSBjb250ZXh0IG1lbnUuIEl0IGlzIHVzZWQgdG8gYWRkIHRoZSBuZXcgZWxlbWVudHMgdG8gdGhlIGNvcnJlY3QgcG9zaXRpb24gb24gdGhlIENhbnZhcy5cbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSB7XG4gICAgICAgICAgICB4OiAwLCB5OiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGpRdWVyeSBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIGNvbnRleHQgbWVudVxuICAgICAgICAgKiBAdHlwZSB7alF1ZXJ5LmVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiRlbCA9ICQoXCI8dWw+XCIpO1xuICAgICAgICB0aGlzLiRlbC5hdHRyKCdpZCcsICdjb250ZXh0TWVudScpO1xuXG4gICAgICAgIGxldCBzcGVjaWFsID0gbmV3IENvbnRleHRNZW51SXRlbShcIlNwZWNpYWwgZWxlbWVudHNcIiwgdGhpcyk7XG5cbiAgICAgICAgLy8gYWRkIGlucHV0IGJveFxuICAgICAgICBzcGVjaWFsLmFwcGVuZEl0ZW0oXG4gICAgICAgICAgICBuZXcgQ29udGV4dE1lbnVJdGVtKFwiSW5wdXQgYm94XCIsIHRoaXMsXG4gICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLnBhcmVudFNWRy5zbmFwVG9HcmlkKHBhcmVudFNWRy52aWV3Ym94LnRyYW5zZm9ybVgodGhpcy5wb3NpdGlvbi54KSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHRoaXMucGFyZW50U1ZHLnNuYXBUb0dyaWQocGFyZW50U1ZHLnZpZXdib3gudHJhbnNmb3JtWSh0aGlzLnBvc2l0aW9uLnkpKVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFNWRy5uZXdJbnB1dChwb3NpdGlvbi5sZWZ0LCBwb3NpdGlvbi50b3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBhZGQgb3V0cHV0IGJveFxuICAgICAgICBzcGVjaWFsLmFwcGVuZEl0ZW0obmV3IENvbnRleHRNZW51SXRlbShcIk91dHB1dCBib3hcIiwgdGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMucGFyZW50U1ZHLnNuYXBUb0dyaWQocGFyZW50U1ZHLnZpZXdib3gudHJhbnNmb3JtWCh0aGlzLnBvc2l0aW9uLngpKSxcbiAgICAgICAgICAgICAgICB0b3A6IHRoaXMucGFyZW50U1ZHLnNuYXBUb0dyaWQocGFyZW50U1ZHLnZpZXdib3gudHJhbnNmb3JtWSh0aGlzLnBvc2l0aW9uLnkpKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcGFyZW50U1ZHLm5ld091dHB1dChwb3NpdGlvbi5sZWZ0LCBwb3NpdGlvbi50b3ApO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgdGhpcy5hcHBlbmRJdGVtKHNwZWNpYWwpO1xuXG4gICAgICAgIC8vIGxpc3Qgb2YgZ2F0ZXMgdGhhdCBjYW4gYmUgYWRkZWRcbiAgICAgICAgY29uc3QgZ2F0ZXMgPSBHYXRlLnZhbGlkR2F0ZXM7XG4gICAgICAgIGxldCBnYXRlTGlzdCA9IG5ldyBDb250ZXh0TWVudUl0ZW0oXCJOZXcgZ2F0ZVwiLCB0aGlzLCBwYXJlbnRTVkcpO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgZ2F0ZXMpIHtcbiAgICAgICAgICAgIGdhdGVMaXN0LmFwcGVuZEl0ZW0oXG4gICAgICAgICAgICAgICAgbmV3IEdhdGVNZW51SXRlbShuYW1lLCB0aGlzKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwcGVuZEl0ZW0oZ2F0ZUxpc3QpO1xuXG4gICAgICAgIC8vIG1vcmUgb3B0aW9ucyB3aWxsIGJlIGFkZGVkIGluIHRoZSBnZXRMaWJyYXJ5KCkgY2FsbGJhY2sgYmVsb3dcbiAgICAgICAgbGV0IG5ldHdvcmtMaXN0ID0gbmV3IENvbnRleHRNZW51SXRlbShcIkFkZCBhIG5ldHdvcmtcIiwgdGhpcyk7XG4gICAgICAgIG5ldHdvcmtMaXN0LmFwcGVuZEl0ZW0obmV3IENvbnRleHRNZW51SXRlbShcIlBhc3RlIGEgbmV0d29ya1wiLCB0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlJbXBvcnREaWFsb2coKVxuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuYXBwZW5kSXRlbShuZXR3b3JrTGlzdCk7IC8vIGFsd2F5cyBhcHBlbmRcblxuICAgICAgICBsZXQgYmxhY2tib3hMaXN0ID0gbmV3IENvbnRleHRNZW51SXRlbShcIkFkZCBhIGJsYWNrYm94XCIsIHRoaXMpOyAvLyBhcHBlbmRzIG9ubHkgaWYgY29udGFpbnMgaXRlbXMgKHNlZSB0aGUgY2FsbGJhY2spXG5cbiAgICAgICAgLy8gbmV0d29yayBpbXBvcnQgKGJsYWNrYm94LCBuZXR3b3JrKVxuICAgICAgICBnZXRMaWJyYXJ5KCkudGhlbihuZXR3b3JrcyA9PiB7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3Qge25hbWUsIGZpbGUsIGhhc1RhYmxlLCBoYXNOZXR3b3JrfSBvZiBuZXR3b3Jrcykge1xuICAgICAgICAgICAgICAgIC8vIGFkZCBhIG5ldHdvcmsgYXMgYSBibGFja2JveFxuICAgICAgICAgICAgICAgIGlmKGhhc1RhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsYWNrYm94TGlzdC5hcHBlbmRJdGVtKFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEJsYWNrYm94TWVudUl0ZW0obmFtZSwgZmlsZSwgdGhpcylcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBsb2FkIGEgbmV0d29yayBhcyBhIG5ldHdvcmsgb2YgY29tcG9uZW50cyBjb25uZWN0ZWQgd2l0aCB3aXJlc1xuICAgICAgICAgICAgICAgIGlmKGhhc05ldHdvcmspIHtcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya0xpc3QuYXBwZW5kSXRlbShcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOZXR3b3JrTWVudUl0ZW0obmFtZSwgZmlsZSwgdGhpcylcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGJsYWNrYm94TGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRJdGVtKGJsYWNrYm94TGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9KVxuXG4gICAgICAgIC8vIGFkZCBjb25kaXRpb25hbCBpdGVtcyBmb3IgYm94IGFuZCB3aXJlIHJlbW92YWxcbiAgICAgICAgdGhpcy5hcHBlbmRDb25kaXRpb25hbEl0ZW0oJ2JveCcsICdSZW1vdmUgdGhpcyBpdGVtJywgaWQgPT4ge3RoaXMucGFyZW50U1ZHLnJlbW92ZUJveChpZCl9KTtcbiAgICAgICAgdGhpcy5hcHBlbmRDb25kaXRpb25hbEl0ZW0oJ3dpcmUnLCAnUmVtb3ZlIHRoaXMgd2lyZScsIGlkID0+IHt0aGlzLnBhcmVudFNWRy5yZW1vdmVXaXJlQnlJZChpZCl9KTtcblxuICAgICAgICAvLyBhZGQgdGhlIGNvbnRleHQgbWVudSB0byB0aGUgRE9NXG4gICAgICAgIHBhcmVudFNWRy4kc3ZnLmJlZm9yZSh0aGlzLiRlbCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE51bWJlciBvZiBpdGVtcyBpbiB0aGlzIG1lbnUgKHVzZWQgaW4gdGhlIC5sZW5naHQgZ2V0dGVyKS4gQ29uZGl0aW9uYWwgaXRlbXMgZG8gbm90IGNvdW50LlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pdGVtQ291bnQgPSAwO1xuICAgIH1cblxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1Db3VudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhcHBlbmQgYSBjb250ZXh0IG1lbnUgaXRlbSB0byB0aGUgY29udGV4dCBtZW51XG4gICAgICogQHBhcmFtICB7Q29udGV4dE1lbnVJdGVtfSBpdGVtIGluc3RhbmNlIG9mIHtAbGluayBDb250ZXh0TWVudUl0ZW19IHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGlzIG1lbnVcbiAgICAgKi9cbiAgICBhcHBlbmRJdGVtKGl0ZW0pIHtcbiAgICAgICAgdGhpcy4kZWwuYXBwZW5kKGl0ZW0ualF1ZXJ5KTtcblxuICAgICAgICB0aGlzLml0ZW1Db3VudCsrO1xuXG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFwcGVuZHMgYW4gY29ubmRpdGlvbmFsIGl0ZW0gKHRoYXQgaXMgc2hvd24gb25seSBpZiB0aGUgdGFyZ2V0IGhhcyB0aGUgY2xhc3MgaXRlbUNsYXNzKVxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gaXRlbUNsYXNzICAgICBzaG93IHRoZSBpdGVtIG9ubHkgaWYgdGhlIHRhcmdldCBoYXMgdGhpcyBjbGFzc1xuICAgICAqIEBwYXJhbSAge3N0cmluZ30gdGV4dCAgICAgICAgICB0ZXh0IG9mIHRoaXMgbWVudSBpdGVtXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNsaWNrRnVuY3Rpb24gZnVuY3Rpb24gd2l0aCBvbmUgYXJndW1lbnQgKElEIG9mIHRoZSB0YXJnZXQpIHRoYXQgd2lsbCBiZSBjYWxsZWQgb24gY2xpY2tcbiAgICAgKi9cbiAgICBhcHBlbmRDb25kaXRpb25hbEl0ZW0oaXRlbUNsYXNzLCB0ZXh0LCBjbGlja0Z1bmN0aW9uKSB7XG4gICAgICAgIGlmKCF0aGlzLmNvbmRpdGlvbmFsSXRlbXMpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uYWxJdGVtcyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb25kaXRpb25hbEl0ZW1zW3RoaXMuY29uZGl0aW9uYWxJdGVtcy5sZW5ndGhdID0ge1xuICAgICAgICAgICAgaXRlbUNsYXNzOiBpdGVtQ2xhc3MsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgY2xpY2tGdW5jdGlvbjogY2xpY2tGdW5jdGlvblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZGlzcGxheSB0aGUgZGlhbG9nIGZvciBpbXBvcnRpbmcgYSBuZXR3b3JrIGZyb20gYSBjbGlwYm9hcmRcbiAgICAgKi9cbiAgICBkaXNwbGF5SW1wb3J0RGlhbG9nKCkge1xuICAgICAgICBsZXQgJHBvcHVwID0gJChcIjxkaXY+XCIpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoXCJpbXBvcnRFeHBvcnRcIilcbiAgICAgICAgICAgIC5hZGRDbGFzcyhcImltcG9ydFwiKTtcblxuICAgICAgICBsZXQgdGV4dGFyZWFJZCA9IFwiaW1wb3J0SlNPTlwiO1xuICAgICAgICBsZXQgJHRleHRibG9jayA9ICQoXCI8dGV4dGFyZWE+XCIpLmF0dHIoJ2lkJywgdGV4dGFyZWFJZCk7XG5cbiAgICAgICAgbGV0IGxpdHlJbnN0YW5jZTtcblxuICAgICAgICAkcG9wdXAuYXBwZW5kKFxuICAgICAgICAgICAgJHRleHRibG9ja1xuICAgICAgICApLmFwcGVuZChcbiAgICAgICAgICAgICQoXCI8YT5cIikuYXR0cih7XG4gICAgICAgICAgICAgICAgXCJocmVmXCI6IFwiI1wiLFxuICAgICAgICAgICAgICAgIFwiY2xhc3NcIjogXCJ1cGxvYWRcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hcHBlbmQoXG4gICAgICAgICAgICAgICAgJChcIjxpbWc+XCIpLmF0dHIoJ3NyYycsIFwiaW1nL2d1aS9pbXBvcnQuc3ZnXCIpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuYXBwZW5kKFwiIGltcG9ydCBmcm9tIEpTT05cIilcbiAgICAgICAgICAgIC5vbignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGE7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZSgkKCcjJyArIHRleHRhcmVhSWQpLnZhbCgpKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRTVkcubWVzc2FnZXMubmV3RXJyb3JNZXNzYWdlKFwiVGhlIGltcG9ydGVkIGZpbGUgaXMgbm90IGEgdmFsaWQgSlNPTiBmaWxlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgbGl0eUluc3RhbmNlLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm9jY2VzcyB0aGUgaW1wb3J0ZWQgZGF0YVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFNWRy5pbXBvcnREYXRhKFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgucm91bmQodGhpcy5wYXJlbnRTVkcudmlld2JveC50cmFuc2Zvcm1YKHRoaXMucG9zaXRpb24ueCkgLyB0aGlzLnBhcmVudFNWRy5ncmlkU2l6ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKHRoaXMucGFyZW50U1ZHLnZpZXdib3gudHJhbnNmb3JtWSh0aGlzLnBvc2l0aW9uLnkpIC8gdGhpcy5wYXJlbnRTVkcuZ3JpZFNpemUpXG4gICAgICAgICAgICAgICAgICAgICkudGhlbih3YXJuaW5ncyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHdhcm5pbmcgb2Ygd2FybmluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFNWRy5tZXNzYWdlcy5uZXdXYXJuaW5nTWVzc2FnZSh3YXJuaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpdHlJbnN0YW5jZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgbGl0eUluc3RhbmNlID0gbGl0eSgkcG9wdXApO1xuXG4gICAgICAgIC8vIGZvY3VzIG9uIHRoZSB0ZXh0YmxvY2tcbiAgICAgICAgJHRleHRibG9jay5mb2N1cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGRlY2lkZSB3aGV0aGVyIG9yIG5vdCB0byBkaXNwbGF5IHNwZWNpZmljIGNvbmRpdGlvbmFsIGl0ZW1zXG4gICAgICogQHBhcmFtICB7alF1ZXJ5LmVsZW1lbnR9ICR0YXJnZXQgalF1ZXJ5IHRhcmdldCBvZiBhIE1vdXNlRXZlbnQgKGVsZW1lbnQgdGhhdCB1c2VyIGNsaWNrZWQgb24pXG4gICAgICovXG4gICAgcmVzb2x2ZUNvbmRpdGlvbmFsSXRlbXMoJHRhcmdldCkge1xuICAgICAgICBmb3IobGV0IGl0ZW0gb2YgdGhpcy5jb25kaXRpb25hbEl0ZW1zKSB7XG4gICAgICAgICAgICBpZigkdGFyZ2V0Lmhhc0NsYXNzKGl0ZW0uaXRlbUNsYXNzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kSXRlbShcbiAgICAgICAgICAgICAgICAgICAgbmV3IENvbnRleHRNZW51SXRlbShcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udGV4dCwgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmNsaWNrRnVuY3Rpb24oJHRhcmdldC5hdHRyKCdpZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICkuYWRkQ2xhc3MoJ2NvbmRpdGlvbmFsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBoaWRlIGFsbCBjb25kaXRpb25hbCBpdGVtc1xuICAgICAqL1xuICAgIGhpZGVBbGxDb25kaXRpb25hbEl0ZW1zKCkge1xuICAgICAgICB0aGlzLiRlbC5jaGlsZHJlbignLmNvbmRpdGlvbmFsJykucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZGlzcGxheXMgdGhlIGNvbnRleHQgbWVudSB3aXRoIHRoZSByaWdodCBzZXQgb2YgY29uZGl0aW9uYWwgaXRlbXNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggICAgICAgaG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgY29udGV4dCBtZW51IGluIENTUyBwaXhlbHNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgICAgICAgdmVydGljYWwgcG9zaXRpb24gb2YgdGhlIGNvbnRleHQgbWVudSBpbiBDU1MgcGl4ZWxzXG4gICAgICogQHBhcmFtICB7alF1ZXJ5LmVsZW1lbnR9ICR0YXJnZXQgalF1ZXJ5IHRhcmdldCBvZiBhIE1vdXNlRXZlbnQgKGVsZW1lbnQgdGhhdCB1c2VyIGNsaWNrZWQgb24pXG4gICAgICovXG4gICAgZGlzcGxheSh4LCB5LCAkdGFyZ2V0KSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucmVzb2x2ZUNvbmRpdGlvbmFsSXRlbXMoJHRhcmdldCk7XG5cbiAgICAgICAgdGhpcy4kZWwuY3NzKHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgICAgICB0b3A6IHksXG4gICAgICAgICAgICBsZWZ0OiB4XG4gICAgICAgIH0pXG4gICAgICAgIC8vIHNldCB0aGUgd2lkdGggZXhwaWNpdGx5LCBvciBlbHNlIHRoZSBtZW51IHdpbGwgd2lkZW4gd2hlbiBkaXNwbGF5aW5nIGEgc3VibWVudVxuICAgICAgICAvLyAyIGlzIHRvIHByZXZlbnQgYSB3ZWlyZCB0ZXh0IHdyYXAgYnVnXG4gICAgICAgIC5jc3MoJ3dpZHRoJywgJ2F1dG8nKVxuICAgICAgICAuY3NzKCd3aWR0aCcsIHRoaXMuJGVsLmlubmVyV2lkdGgoKSArIDIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGhpZGUgdGhlIGNvbnRleHQgbWVudVxuICAgICAqL1xuICAgIGhpZGUoKSB7XG4gICAgICAgIHRoaXMuJGVsLmNzcyh7ZGlzcGxheTogJ25vbmUnfSk7XG4gICAgICAgICQoXCIuc3ViTGlzdFwiKS5jc3Moe2Rpc3BsYXk6ICdub25lJ30pO1xuICAgICAgICB0aGlzLmhpZGVBbGxDb25kaXRpb25hbEl0ZW1zKCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgZ2V0SlNPTlN0cmluZyB9IGZyb20gXCIuLi9vdGhlci9oZWxwZXJGdW5jdGlvbnNcIjtcblxuLyoqXG4gKiBGbG9hdGluZ0J1dHRvbiByZXByZXNlbnRzIGEgYnV0dG9uIHRoYXQgaXMgdXNlZCBpbiB0aGUgZmxvYXRpbmcgbWVudSBpbiB0aGUgcmlnaHQgYm90dG9tIGNvcm5lclxuICogb2YgdGhlIGFwcGxpY2F0aW9uLiBJdCBtYXkgaGF2ZSBhIGN1c3RvbSB0b29sdGlwIGFuZCBjYWxsYmFjayBvbiB0aGUgY2xpY2sgZXZlbnRcbiAqL1xuY2xhc3MgRmxvYXRpbmdCdXR0b24ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBidXR0b25DbGFzcyBDdXN0b20gc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGUgU1ZHIGljb24gdXNlZCBvbiB0aGlzIGJ1dHRvbi4gVGhpcyBzdHJpbmcgaXMgYWxzbyBhZGRlZCBhcyBhIENTUyBjbGFzcyB0byB0aGUgYnV0dG9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b29sdGlwICAgICB0b29sdGlwIGZvciB0aGUgYnV0dG9uLCB0aGF0IHdpbGwgYmUgZGlzcGxheWVkIG9uIGhvdmVyIGFuZCBhbHNvIHVzZWQgYXMgYWx0ZXJuYXRpdmUgdGl0bGUgZm9yIHRoZSBpbWFnZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNsaWNrRXZlbnQgIGN1c3RvbSBjYWxsYmFjayB3aGVuIHVzZXIgY2xpY2tzIHRoZSBidXR0b25cbiAgICAgKiBAcGFyYW0ge0NhbnZhc30gcGFyZW50U1ZHICAgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgU1ZHIGVsZW1lbnRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihidXR0b25DbGFzcywgdG9vbHRpcCwgY2xpY2tFdmVudCwgcGFyZW50U1ZHKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBqUXVlcnkgZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGJ1dHRvblxuICAgICAgICAgKiBAdHlwZSB7alF1ZXJ5LmVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiRlbCA9ICQoJzxhPicpXG5cbiAgICAgICAgLy8gYWRkIGNsYXNzZXMgdG8gdGhlIGVsZW1lbnRcbiAgICAgICAgdGhpcy4kZWwuYWRkQ2xhc3MoXCJidXR0b25cIik7XG4gICAgICAgIHRoaXMuJGVsLmFkZENsYXNzKGJ1dHRvbkNsYXNzKTtcblxuICAgICAgICAvLyBhZGQgdGhlIGljb25cbiAgICAgICAgdGhpcy4kZWwuYXBwZW5kKFxuICAgICAgICAgICAgJChcIjxpbWc+XCIpXG4gICAgICAgICAgICAuYXR0cihcInNyY1wiLCBgaW1nL2d1aS8ke2J1dHRvbkNsYXNzfS5zdmdgKVxuICAgICAgICAgICAgLmF0dHIoXCJhbHRcIiwgdG9vbHRpcClcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBhZGQgdGhlIHRvb2x0aXAgZWxlbWVudCBhbmQgYW4gZXZlbnQgbGlzdGVuZXIgaWYgdG9vbHRpcCBpcyBkZWZpbmVkXG4gICAgICAgIGlmICh0b29sdGlwKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGpRdWVyeSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgdG9vbHRpcFxuICAgICAgICAgICAgICogQHR5cGUge2pRdWVyeS5lbGVtZW50fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLiR0b29sdGlwID0gJChcIjxkaXY+XCIpO1xuICAgICAgICAgICAgdGhpcy4kdG9vbHRpcFxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcInRvb2x0aXBcIilcbiAgICAgICAgICAgICAgICAuaHRtbCh0b29sdGlwKTtcblxuICAgICAgICAgICAgcGFyZW50U1ZHLiRzdmcuYWZ0ZXIodGhpcy4kdG9vbHRpcCk7XG5cbiAgICAgICAgICAgIHRoaXMuJGVsLmhvdmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiR0b29sdGlwLmZhZGVJbigyMDApO1xuICAgICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuJHRvb2x0aXAuZmFkZU91dCgyMDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgYW4gZXZlbnQgbGlzdGVuZXIgb24gY2xpY2ssIGlmIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBkZWZpbmVkXG4gICAgICAgIGlmIChjbGlja0V2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLiRlbC5vbihcImNsaWNrXCIsIGNsaWNrRXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKiogQG1vZHVsZSBGbG9hdGluZ01lbnUgKi9cbi8qKlxuICogQ2xhc3MgdG8gcmVwcmVzZW50IHRoZSBmbG9hdGluZyBtZW51IGluIHRoZSByaWdodCBib3R0b20gY29ybmVyIG9mIHRoZSBwYWdlLlxuICogSXQgaW5zdGFudGlhdGVzIGFsbCB0aGUgYnV0dG9ucyBhbmQgdGhlaXIgY2FsbGJhY2tzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGbG9hdGluZ01lbnUge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzfSBwYXJlbnRTVkcgcmVmZXJlbmNlIHRvIHRoZSBDYW52YXMgZWxlbWVudCB0aGlzIG1lbnUgaXMgYXNzb2NpYXRlZCB3aXRoXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGFyZW50U1ZHKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aGUgalF1ZXJ5IGVsZW1lbnQgY29udGFpbmluZyBhbGwgYnV0dG9uc1xuICAgICAgICAgKiBAdHlwZSB7alF1ZXJ5LmVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiRlbCA9ICQoJzxkaXY+JylcblxuICAgICAgICBjb25zdCBpZCA9ICdmbG9hdGluZ01lbnUnO1xuXG4gICAgICAgIHRoaXMuJGVsLmF0dHIoXCJpZFwiLCBpZCk7XG5cbiAgICAgICAgLy8gY29uc3QgJGxvYWRlciA9ICQoXCI8ZGl2PlwiKS5hZGRDbGFzcyhcImxvYWRlclwiKS5hZGRDbGFzcyhcImhpZGRlblwiKTtcblxuXG4gICAgICAgIC8qIEVYUE9SVCAqL1xuICAgICAgICB0aGlzLmFwcGVuZChcbiAgICAgICAgICAgIG5ldyBGbG9hdGluZ0J1dHRvbihcImV4cG9ydFwiLCBcIkdldCBjb2RlIGZvciB0aGlzIG5ldHdvcmtcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgcG9wdXAgY29udGFpbmVyIGhvbGRpbmcgYWxsIHBvcHVwIGNvbnRlbnQgKHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gbGl0eSlcbiAgICAgICAgICAgICAgICBsZXQgJHBvcHVwID0gJChcIjxkaXY+XCIpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcImltcG9ydEV4cG9ydFwiKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJleHBvcnRcIik7XG5cbiAgICAgICAgICAgICAgICAvLyBnZW5lcmF0ZSB0aGUgYmxvY2sgd2l0aCBjb2RlIHRvIGJlIGRpc3BsYXllZCBhbmQgYXBwZW5kIGl0IHRvIHRoZSBwb3B1cCBlbGVtZW50XG4gICAgICAgICAgICAgICAgY29uc3QgJHRleHRibG9jayA9ICQoXCI8dGV4dGFyZWE+XCIpLnRleHQoXG4gICAgICAgICAgICAgICAgICAgIGdldEpTT05TdHJpbmcocGFyZW50U1ZHLmV4cG9ydERhdGEsIHRydWUpXG4gICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgICAgJHBvcHVwLmFwcGVuZCgkdGV4dGJsb2NrKTtcblxuICAgICAgICAgICAgICAgIC8vIGdlbmVyYXRlIHRoZSBsaW5rc1xuICAgICAgICAgICAgICAgICRwb3B1cC5hcHBlbmQoXG4gICAgICAgICAgICAgICAgICAgICQoXCI8YT5cIikuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImhyZWZcIjogZ2V0SlNPTlN0cmluZyhwYXJlbnRTVkcuZXhwb3J0RGF0YSwgdHJ1ZSwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBcImNsYXNzXCI6IFwiZG93bmxvYWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZG93bmxvYWRcIjogXCJuZXR3b3JrLmpzb25cIlxuICAgICAgICAgICAgICAgICAgICB9KS5hcHBlbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAkKFwiPGltZz5cIikuYXR0cignc3JjJywgXCJpbWcvZ3VpL2V4cG9ydC5zdmdcIilcbiAgICAgICAgICAgICAgICAgICAgKS5hcHBlbmQoXCIgZXhwYW5kZWQgSlNPTlwiKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgJHBvcHVwLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgJChcIjxhPlwiKS5hdHRyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaHJlZlwiOiBnZXRKU09OU3RyaW5nKHBhcmVudFNWRy5leHBvcnREYXRhLCBmYWxzZSwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBcImNsYXNzXCI6IFwiZG93bmxvYWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZG93bmxvYWRcIjogXCJuZXR3b3JrLm1pbi5qc29uXCJcbiAgICAgICAgICAgICAgICAgICAgfSkuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgJChcIjxpbWc+XCIpLmF0dHIoJ3NyYycsIFwiaW1nL2d1aS9leHBvcnQuc3ZnXCIpXG4gICAgICAgICAgICAgICAgICAgICkuYXBwZW5kKFwiIGNvbXBhY3QgSlNPTlwiKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBsaXR5KCRwb3B1cCk7XG5cbiAgICAgICAgICAgICAgICAvLyBoaWdobGlnaHQgdGhlIHRleHQgaW4gdGhlIHRleHRibG9ja1xuICAgICAgICAgICAgICAgICR0ZXh0YmxvY2suc2VsZWN0KCk7XG4gICAgICAgICAgICB9LCBwYXJlbnRTVkcpXG4gICAgICAgICk7XG5cbiAgICAgICAgLyogVHV0b3JpYWwgKi9cbiAgICAgICAgdGhpcy5hcHBlbmQoXG4gICAgICAgICAgICBuZXcgRmxvYXRpbmdCdXR0b24oXCJ0dXRvcmlhbFwiLCBcIlN0YXJ0IHRoZSB0dXRvcmlhbFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcGFyZW50U1ZHLnN0YXJ0VHV0b3JpYWwoKTtcbiAgICAgICAgICAgIH0sIHBhcmVudFNWRylcbiAgICAgICAgKTtcblxuICAgICAgICBwYXJlbnRTVkcuJHN2Zy5hZnRlcih0aGlzLiRlbCk7XG5cbiAgICAgICAgLyogSEVMUCAqL1xuXG4gICAgICAgIGxldCBoZWxwID0gbmV3IEZsb2F0aW5nQnV0dG9uKFwiaGVscFwiLCBcIkRpc3BsYXkgYSBoZWxwIHBhZ2VcIiwgZmFsc2UsIHBhcmVudFNWRyk7XG4gICAgICAgIGhlbHAuJGVsLmF0dHIoe1xuICAgICAgICAgICAgJ2hyZWYnOiAnLi9kb2NzL3VzZXIuaHRtbCcsXG4gICAgICAgICAgICAnZGF0YS1saXR5JzogJydcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXBwZW5kKGhlbHApO1xuXG4gICAgICAgIHBhcmVudFNWRy4kc3ZnLmFmdGVyKHRoaXMuJGVsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhcHBlbmQgYSBGbG9hdGluZ0J1dHRvbiB0byB0aGlzIG1lbnVcbiAgICAgKiBAcGFyYW0gIHtGbG9hdGluZ0J1dHRvbn0gbWVudUl0ZW0gYXBwZW5kIGFuIGluc3RhbmNlIG9mICB7QGxpbmsgRmxvYXRpbmdCdXR0b259IHRvIHRoaXMgbWVudVxuICAgICAqL1xuICAgIGFwcGVuZChtZW51SXRlbSkge1xuICAgICAgICB0aGlzLiRlbC5hcHBlbmQobWVudUl0ZW0uJGVsKTtcbiAgICB9XG59XG4iLCIvKiogQG1vZHVsZSBNZXNzYWdlcyAqL1xuXG4vKipcbiAqIGEgZ2VuZXJpYyBtZXNzYWdlIHRoYXQgY2FuIGJlIGRpc3BsYXllZCBpbiB0aGUge0BsaW5rIE1lc3NhZ2VzfSBib3hcbiAqL1xuY2xhc3MgTWVzc2FnZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgICAgICAgICAgICAgICB0ZXh0IG9mIHRoZSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uSGlkZV0gYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGBoaWRlKClgIG1ldGhvZCBpcyBjYWxsZWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBvbkhpZGUpIHtcbiAgICAgICAgdGhpcy4kZWwgPSAkKFwiPGRpdj5cIikuYWRkQ2xhc3MoXCJtZXNzYWdlXCIpLnRleHQodGV4dCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgYGhpZGUoKWAgbWV0aG9kIGlzIGNhbGxlZFxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uSGlkZSA9IG9uSGlkZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBoaWRlIHRoZSBtZXNzYWdlIChhbmQgY2FsbCB0aGUgb25IaWRlIGNhbGxiYWNrIGlmIHRoZXJlIGlzIGFueSlcbiAgICAgKi9cbiAgICBoaWRlKCkge1xuICAgICAgICB0aGlzLiRlbC5yZW1vdmUoKTtcblxuICAgICAgICBpZih0aGlzLm9uSGlkZSkge1xuICAgICAgICAgICAgdGhpcy5vbkhpZGUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBhIGxvYWRpbmcgbWVzc2FnZSB0aGF0IGNhbiBiZSBkaXNwbGF5ZWQgaW4gdGhlIHtAbGluayBNZXNzYWdlc30gYm94XG4gKiBAZXh0ZW5kcyBNZXNzYWdlXG4gKi9cbmNsYXNzIExvYWRpbmdNZXNzYWdlIGV4dGVuZHMgTWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3IodGV4dCwgb25IaWRlID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN1cGVyKHRleHQsIG9uSGlkZSk7XG5cbiAgICAgICAgdGhpcy4kZWwuYWRkQ2xhc3MoXCJsb2FkaW5nXCIpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBhIG1lc3NhZ2UgdGhhdCBoYXMgYSBjbG9zZSBidXR0b24gYW5kIHRoYXQgY2FuIGJlIGRpc3BsYXllZCBpbiB0aGUge0BsaW5rIE1lc3NhZ2VzfSBib3hcbiAqIEBleHRlbmRzIE1lc3NhZ2VcbiAqL1xuY2xhc3MgQ2xvc2FibGVNZXNzYWdlIGV4dGVuZHMgTWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3IodGV4dCwgb25IaWRlID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN1cGVyKHRleHQsIG9uSGlkZSk7XG5cbiAgICAgICAgdGhpcy4kZWwuYXBwZW5kKFxuICAgICAgICAgICAgJChcIjxzcGFuPlwiKS5hZGRDbGFzcyhcImNsb3NlXCIpLmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICB9XG59XG5cbi8qKlxuICogYW4gZXJyb3IgbWVzc2FnZSB0aGF0IGNhbiBiZSBkaXNwbGF5ZWQgaW4gdGhlIHtAbGluayBNZXNzYWdlc30gYm94XG4gKiBAZXh0ZW5kcyBDbG9zYWJsZU1lc3NhZ2VcbiAqL1xuY2xhc3MgRXJyb3JNZXNzYWdlIGV4dGVuZHMgQ2xvc2FibGVNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBvbkhpZGUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3VwZXIodGV4dCwgb25IaWRlKTtcblxuICAgICAgICB0aGlzLiRlbC5hZGRDbGFzcyhcImVycm9yXCIpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBhIHdhcm5pbmcgbWVzc2FnZSB0aGF0IGNhbiBiZSBkaXNwbGF5ZWQgaW4gdGhlIHtAbGluayBNZXNzYWdlc30gYm94XG4gKiBAZXh0ZW5kcyBDbG9zYWJsZU1lc3NhZ2VcbiAqL1xuY2xhc3MgV2FybmluZ01lc3NhZ2UgZXh0ZW5kcyBDbG9zYWJsZU1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIG9uSGlkZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBzdXBlcih0ZXh0LCBvbkhpZGUpO1xuXG4gICAgICAgIHRoaXMuJGVsLmFkZENsYXNzKFwid2FybmluZ1wiKTtcbiAgICB9XG59XG5cbi8qKlxuICogZGlzcGxheSBtZXNzYWdlcyB0byB0aGUgdXNlciBpbiBhIG5pY2UgVUlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWVzc2FnZXMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogalF1ZXJ5IGVsZW1lbnQgdGhhdCByZXByZXNlbnRzIHRoZSBtZXNzYWdlIGludGVyZmFjZS4gVGhpcyBlbGVtZW50IGNvbnRhaW5zIGFsbCB0aGUgY3VycmVudGx5IGRpc3BsYXllZCBtZXNzYWdlcy5cbiAgICAgICAgICogQHR5cGUge2pRdWVyeS5lbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy4kZWwgPSAkKFwiPGRpdj5cIikuYWRkQ2xhc3MoJ21lc3NhZ2VzJyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG51bWJlciBvZiBjdXJyZW50bHkgZGlzcGxheWVkIG1lc3NhZ2VzLCBoYXMgYSBzcGVjaWZpZWQgc2V0dGVyIGFuZCBnZXR0ZXJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuXG4gICAgICAgIC8vIHBsYWNlIHRoZSBwcm9ncmVzcyBpbmZvIGVsZW1lbnRcbiAgICAgICAgJCgnYm9keScpLmFwcGVuZCh0aGlzLiRlbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBudW1iZXIgb2YgY3VycmVudGx5IGRpc3BsYXllZCBtZXNzYWdlc1xuICAgICAqIEByZXR1cm4ge251bWJlcn0gW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgIGdldCBjb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZUNvdW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbnVtYmVyIG9mIGN1cnJlbnRseSBkaXNwbGF5ZWQgbWVzc2FnZXMuIFNob3VsZCBiZSBjYWxsZWQgb25seSB0aHJvdWdoIGZ1bmN0aW9ucyB0aGF0IGFkZCBtZXNzYWdlcy5cbiAgICAgKlxuICAgICAqIElmIHRoZSBtZXNzYWdlIGNvdW50IGlzID49IDEsIHRoZSBqUXVlcnkgZWxlbWVudCBmb3IgdGhlIFVJIGlzIGRpc3BsYXllZCwgaWYgdGhlIG1lc3NhZ2UgY291bnQgaXMgPDEsIHRoZSBVSSBpcyBoaWRkZW4uXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB2YWx1ZSBbZGVzY3JpcHRpb25dXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICBbZGVzY3JpcHRpb25dXG4gICAgICovXG4gICAgc2V0IGNvdW50KHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZUNvdW50ID0gdmFsdWU7XG5cbiAgICAgICAgaWYodGhpcy5tZXNzYWdlQ291bnQgPCAxKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGlkZSB0aGUgbWVzc2FnZSBib3ggYnkgYWRkaW5nIGEgYGhpZGRlbmAgY2xhc3MgdG8gdGhlIGVsZW1lbnRcbiAgICAgKi9cbiAgICBoaWRlKCkge1xuICAgICAgICB0aGlzLiRlbC5hZGRDbGFzcygnaGlkZGVuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZGlzcGxheSB0aGUgbWVzc2FnZSBib3ggYnkgcmVtb3ZpbmcgdGhlIGBoaWRkZW5gIGNsYXNzIHRvIHRoZSBlbGVtZW50XG4gICAgICovXG4gICAgZGlzcGxheSgpIHtcbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlQ2xhc3MoJ2hpZGRlbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFkZCBhIG5ldyBtZXNzYWdlIHRvIHRoZSBtZXNzYWdlIGJveFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gdGV4dCAgICAgICAgICAgICB0ZXh0IG9mIHRoZSBtZXNzYWdlXG4gICAgICogQHBhcmFtICB7TWVzc2FnZX0gW2NvbnN0cj1NZXNzYWdlXSBjb25zdHJ1Y3RvciBvZiB0aGUgbWVzc2FnZSwgbXVzdCBiZSBhIGRlcml2YXRlIG9mIHRoZSB7QGxpbmsgTWVzc2FnZX0gY2xhc3NcbiAgICAgKiBAcmV0dXJuIHtNZXNzYWdlfSAgICAgICAgICAgICAgICAgIHRoZSBuZXdseSBjb25zdHJ1Y3RlZCBtZXNzYWdlIChpbnN0YW5jZSBtYWRlIGJ5IHRoZSBzcGVjaWZpZWQgY29uc3RydWN0b3IpXG4gICAgICovXG4gICAgbmV3TWVzc2FnZSh0ZXh0LCBjb25zdHIgPSBNZXNzYWdlKSB7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgbWVzc2FnZSBieSBjYWxsaW5nIHRoZSBjb25zdHJ1Y3RvcixcbiAgICAgICAgLy8gcHJvdmlkZSBpdCB3aXRoIHRleHQgYW5kIGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIGhpZGluZyB0aGUgbWVzc2FnZS5cbiAgICAgICAgLy8gVGhpcyBjYWxsYmFjayBzdWJ0cmFjdHMgMSBmcm9tIHRoZVxuICAgICAgICBsZXQgbWVzc2FnZSA9IG5ldyBjb25zdHIodGV4dCwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb3VudC0tO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLiRlbC5hcHBlbmQobWVzc2FnZS4kZWwpO1xuICAgICAgICB0aGlzLmNvdW50Kys7XG5cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIGEgbmV3IGxvYWRpbmcgbWVzc2FnZSBhbmQgYWRkIGl0IHRvIHRoZSBtZXNzYWdlIGJveFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gdGV4dCB0ZXh0IG9mIHRoZSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7TG9hZGluZ01lc3NhZ2V9IHRoZSBuZXdseSBjb25zdHJ1Y3RlZCB7QGxpbmsgTG9hZGluZ01lc3NhZ2V9XG4gICAgICovXG4gICAgbmV3TG9hZGluZ01lc3NhZ2UodGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdNZXNzYWdlKHRleHQsIExvYWRpbmdNZXNzYWdlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgYSBuZXcgZXJyb3IgbWVzc2FnZSBhbmQgYWRkIGl0IHRvIHRoZSBtZXNzYWdlIGJveFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gdGV4dCB0ZXh0IG9mIHRoZSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7RXJyb3JNZXNzYWdlfSB0aGUgbmV3bHkgY29uc3RydWN0ZWQge0BsaW5rIEVycm9yTWVzc2FnZX1cbiAgICAgKi9cbiAgICBuZXdFcnJvck1lc3NhZ2UodGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdNZXNzYWdlKHRleHQsIEVycm9yTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIGEgbmV3IHdhcm5pbmcgbWVzc2FnZSBhbmQgYWRkIGl0IHRvIHRoZSBtZXNzYWdlIGJveFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gdGV4dCB0ZXh0IG9mIHRoZSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7V2FybmluZ01lc3NhZ2V9IHRoZSBuZXdseSBjb25zdHJ1Y3RlZCB7QGxpbmsgV2FybmluZ01lc3NhZ2V9XG4gICAgICovXG4gICAgbmV3V2FybmluZ01lc3NhZ2UodGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdNZXNzYWdlKHRleHQsIFdhcm5pbmdNZXNzYWdlKTtcbiAgICB9XG59XG4iLCIvKiogQG1vZHVsZSBUdXRvcmlhbCAqL1xuLyoqXG4gKiBEaXNwbGF5IGFuZCBtYW5hZ2UgdGhlIHR1dG9yaWFsXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR1dG9yaWFsIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0NhbnZhc30gcGFyZW50U1ZHIGluc3RhbmNlIG9mIFtDYW52YXNdKC4vbW9kdWxlLUNhbnZhcy5odG1sKSBmb3IgdGhpcyB0dXRvcmlhbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvblR1dG9yaWFsQ2xvc2VkXSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHVzZXIgY2xvc2VzIG9yIGZpbmlzaGVzIHRoZSB0dXRvcmlhbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudFNWRywgb25UdXRvcmlhbENsb3NlZCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogaW5zdGFuY2Ugb2YgW0NhbnZhc10oLi9tb2R1bGUtQ2FudmFzLmh0bWwpIGZvciB0aGlzIHR1dG9yaWFsXG4gICAgICAgICAqIEB0eXBlIHtDYW52YXN9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhcmVudFNWRyA9IHBhcmVudFNWRztcblxuICAgICAgICAvKipcbiAgICAgICAgICogaGVscGVyIHZhcmlhYmxlIGZvciB0aGUgYHN0ZXBgIHByb3BlcnR5LCBzdG9yZXMgY3VycmVudCBzdGF0ZSBvZiB0aGUgdHV0b3JpYWwgKHN0ZXAgYDBgIG1lYW5zIHRoYXQgdHV0b3JpYWwgaXMgY2xvc2VkKVxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXJyZW50U3RlcCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGpRdWVyeSBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIHR1dG9yaWFsIHBvcHVwXG4gICAgICAgICAqIEB0eXBlIHtqUXVlcnkuZWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuJHR1dG9yaWFsV2luZG93O1xuICAgICAgICAvKipcbiAgICAgICAgICogalF1ZXJ5IGVsZW1lbnQgZm9yIHRoZSBkeW5hbWljIHBhcnQgb2YgdGhlIHR1dG9yaWFsIHBvcHVwXG4gICAgICAgICAqICh0ZXh0IGFuZCBidXR0b25zIHRoYXQgYXJlIGRlcGVuZGVudCBvbiB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgdHV0b3JpYWwpXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuJHR1dG9yaWFsQ29udGVudDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogYXJyYXkgb2YgZnVuY3Rpb25zIHRoYXQgcmVwcmVzZW50IGludGl2aWR1YWwgc3RlcHMgaW4gdGhlIHR1dG9yaWFsXG4gICAgICAgICAqIGJ5IGRlZmF1bHQgcG9wdWxhdGVkIHdpdGggc3RlcCBgMGAgdGhhdCBjbG9zZXMgdGhlIHR1dG9yaWFsXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RlcHMgPSBbKCkgPT4geyB0aGlzLmNsb3NlV2luZG93KG9uVHV0b3JpYWxDbG9zZWQpIH1dO1xuXG4gICAgICAgIC8vIHNldCB1cCB0aGUgdHV0b3JpYWxcbiAgICAgICAgdGhpcy5zZXRVcFR1dG9yaWFsKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBjdXJyZW50IHN0ZXAgb2YgdGhlIHR1dG9yaWFsLCB0aGlzIG51bWJlciBjb3JyZXNwb25kcyB0byB0aGUgaW5kZXggaW4gdGhlIGB0aGlzLnN0ZXBzYCBhcnJheVxuICAgICAqIHRoYXQgY29udGFpbnMgdGhlIGZ1bmN0aW9uIGZvciB0aGUgbGFzdCBkaXNwbGF5ZWQgc3RlcFxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgc3RlcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFN0ZXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2hhbmdlIHRoZSBjdXJyZW50IHN0ZXAgb2YgdGhlIHR1dG9yaWFsLCBgMGAgbWVhbnMgXCJzdG9wIHRoZSB0dXRvcmlhbFwiXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB2YWx1ZSB0aGUgc3RlcCBvZiB0aGUgdHV0b3JpYWwgdG8gYmUgZGlzcGxheWVkXG4gICAgICovXG4gICAgc2V0IHN0ZXAodmFsdWUpIHtcbiAgICAgICAgLy8gcmVzZXQgYWxsIGhvb2tzXG4gICAgICAgIHRoaXMucmVzZXRIb29rcygpO1xuXG4gICAgICAgIHRoaXMuY3VycmVudFN0ZXAgPSB2YWx1ZTtcblxuICAgICAgICBpZih0aGlzLnN0ZXAgPCB0aGlzLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zdGVwc1t0aGlzLnN0ZXBdKCk7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuc3RlcCA9PT0gMSlcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlXaW5kb3coKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RlcCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXNldCBhbGwgdHV0b3JpYWwgaG9va3NcbiAgICAgKi9cbiAgICByZXNldEhvb2tzKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogX3R1dG9yaWFsIGhvb2tfLCBjYWxsZWQgd2hlbiB0aGUgY29udGV4dCBtZW51IGlzIG9wZW5lZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkNvbnRleHRNZW51T3BlbmVkID0gKCkgPT4ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIF90dXRvcmlhbCBob29rXywgY2FsbGVkIHdoZW4gYSBuZXcgZWxlbWVudCBpcyBhZGRlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkVsZW1lbnRBZGRlZCA9ICgpID0+IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBfdHV0b3JpYWwgaG9va18sIGNhbGxlZCB3aGVuIGEgYm94IGlzIG1vdmVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQm94TW92ZWQgPSAoKSA9PiB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogX3R1dG9yaWFsIGhvb2tfLCBjYWxsZWQgd2hlbiBhIGJveCBpcyByb3RhdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQm94Um90YXRlZCA9ICgpID0+IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBfdHV0b3JpYWwgaG9va18sIGNhbGxlZCB3aGVuIGFuIG91dHB1dCBib3ggdmFsdWUgaXMgc2V0IHRvIGBvbmBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25PdXRwdXRCb3hUcnVlID0gKCkgPT4ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIF90dXRvcmlhbCBob29rXywgY2FsbGVkIHdoZW4gdGhlIGNhbnZhcyBpcyBtb3ZlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkNhbnZhc01vdmVkID0gKCkgPT4ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIF90dXRvcmlhbCBob29rXywgY2FsbGVkIHdoZW4gdGhlIGNhbnZhcyBpcyB6b29tZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25DYW52YXNab29tZWQgPSAoKSA9PiB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogX3R1dG9yaWFsIGhvb2tfLCBjYWxsZWQgd2hlbiBhIGJveCBpcyByZW1vdmVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uRWxlbWVudFJlbW92ZWQgPSAoKSA9PiB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogX3R1dG9yaWFsIGhvb2tfLCBjYWxsZWQgd2hlbiB1c2VyIGNoYW5nZXMgdGhlIHN0YXRlIG9mIGFuIGlucHV0IGJveFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkNoYW5nZUlucHV0Qm94U3RhdGUgPSAoKSA9PiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdXAgdGhlIHR1dG9yaWFsOiByZXNldCBhbGwgdHV0b3JpYWwgaG9va3MgYW5kIGRlZmluZSB0aGUgb3JkZXIgb2YgdHV0b3JpYWwgc3RlcHNcbiAgICAgKi9cbiAgICBzZXRVcFR1dG9yaWFsKCkge1xuICAgICAgICB0aGlzLnJlc2V0SG9va3MoKTtcblxuICAgICAgICB0aGlzLnN0ZXBzLnB1c2goXG4gICAgICAgICAgICAoKSA9PiB7IHRoaXMuc3RlcFdlbGNvbWUoKSB9LFxuICAgICAgICAgICAgKCkgPT4geyB0aGlzLnN0ZXBBZGRCb3hlcygpIH0sXG4gICAgICAgICAgICAoKSA9PiB7IHRoaXMuc3RlcE1vdmVDYW52YXMoKSB9LFxuICAgICAgICAgICAgKCkgPT4geyB0aGlzLnN0ZXBab29tQ2FudmFzKCkgfSxcbiAgICAgICAgICAgICgpID0+IHsgdGhpcy5zdGVwTW92ZUJveGVzKCkgfSxcbiAgICAgICAgICAgICgpID0+IHsgdGhpcy5zdGVwV2lyaW5nKCkgfSxcbiAgICAgICAgICAgICgpID0+IHsgdGhpcy5zd2l0Y2hJbnB1dEJveCgpIH0sXG4gICAgICAgICAgICAoKSA9PiB7IHRoaXMuc3RlcFJlbW92ZUJveCgpIH0sXG4gICAgICAgICAgICAoKSA9PiB7IHRoaXMuc3RlcEZpbmlzaCgpIH1cbiAgICAgICAgKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIF90dXRvcmlhbCBzdGVwXzogZGlzcGxheSBjb250ZXh0IG1lbnVcbiAgICAgKi9cbiAgICBzdGVwV2VsY29tZSgpIHtcbiAgICAgICAgdGhpcy53aW5kb3dDb250ZW50KFxuICAgICAgICAgICAgYFdlbGNvbWUgdG8gSHJhZGxhISBUbyBnZXQgc3RhcnRlZCwgY2xpY2sgYW55d2hlcmUgb24gdGhlIGVkaXRpbmcgYXJlYSB3aXRoIHlvdXIgcmlnaHQgbW91c2UgYnV0dG9uLmBcbiAgICAgICAgKVxuXG4gICAgICAgIHRoaXMub25Db250ZXh0TWVudU9wZW5lZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogX3R1dG9yaWFsIHN0ZXBfOiBhZGQgaW5wdXQgYm94LCBvdXRwdXQgYm94IGFuZCBhIE5PVCBnYXRlXG4gICAgICovXG4gICAgc3RlcEFkZEJveGVzKCkge1xuICAgICAgICB0aGlzLndpbmRvd0NvbnRlbnQoXG4gICAgICAgICAgICBgR3JlYXQgam9iISBOb3cgeW91IGtub3csIGhvdyB0byBvcGVuIHRoZSBlZGl0b3IgbWVudS5cbiAgICAgICAgICAgIE5vdyB0cnkgdG8gYWRkIGFuIDxlbT5JbnB1dCBib3g8L2VtPiwgPGVtPk91dHB1dCBib3g8L2VtPiBhbmQgYSA8ZW0+Tk9UIGdhdGU8L2VtPlxuICAgICAgICAgICAgdG8gdGhlIGVkaXRpbmcgYXJlYS5gKVxuXG4gICAgICAgIGxldCBlbGVtZW50c0FkZGVkID0ge1xuICAgICAgICAgICAgaW5wdXRCb3g6IGZhbHNlLFxuICAgICAgICAgICAgb3V0cHV0Qm94OiBmYWxzZSxcbiAgICAgICAgICAgIG5vdEdhdGU6IGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uRWxlbWVudEFkZGVkID0gKG5hbWUpID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJpbnB1dFwiOlxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50c0FkZGVkLmlucHV0Qm94ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm91dHB1dFwiOlxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50c0FkZGVkLm91dHB1dEJveCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJub3RcIjpcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNBZGRlZC5ub3RHYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gYWN0aW9uIG9uIGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGVsZW1lbnRzQWRkZWQuaW5wdXRCb3ggJiYgZWxlbWVudHNBZGRlZC5vdXRwdXRCb3ggJiYgZWxlbWVudHNBZGRlZC5ub3RHYXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gcHJvY2VlZCB0byB0aGUgbmV4dCBzdGVwIG9mIHRoZSB0dXRvcmlhbFxuICAgICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIF90dXRvcmlhbCBzdGVwXzogbW92ZSB0aGUgY2FudmFzXG4gICAgICovXG4gICAgc3RlcE1vdmVDYW52YXMoKSB7XG4gICAgICAgIHRoaXMud2luZG93Q29udGVudChcbiAgICAgICAgICAgIGBZb3UgY2FuIG1vdmUgdGhlIGVkaXRpbmcgYXJlYSAoc29tZXRpbWVzIGNhbGxlZCBjYW52YXMpIGJ5IGRyYWdnaW5nXG4gICAgICAgICAgICB3aXRoIHRoZSBtaWRkbGUgbW91c2UgYnV0dG9uIG9yIGJ5IGhvbGRpbmcgdGhlIDxjb2RlPkN0cmw8L2NvZGU+IGtleVxuICAgICAgICAgICAgYW5kIGRyYWdnaW5nIHdpdGggdGhlIGxlZnQgbW91c2UgYnV0dG9uLiBDaGVjayBpdCBvdXQuYClcblxuICAgICAgICB0aGlzLm9uQ2FudmFzTW92ZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIF90dXRvcmlhbCBzdGVwXzogem9vbSB0aGUgY2FudmFzXG4gICAgICovXG4gICAgc3RlcFpvb21DYW52YXMoKSB7XG4gICAgICAgIHRoaXMud2luZG93Q29udGVudChcbiAgICAgICAgICAgIGBZb3UgY2FuIGFsc28gem9vbSBpbiBhbmQgb3V0IHVzaW5nIHRoZSBtb3VzZSB3aGVlbFxuICAgICAgICAgICAgb3Igd2l0aCB0aGUgPGNvZGU+KzwvY29kZT4mbmJzcDthbmQgPGNvZGU+4oiSPC9jb2RlPiZuYnNwO2tleXMuYFxuICAgICAgICApXG5cbiAgICAgICAgdGhpcy5vbkNhbnZhc1pvb21lZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogX3R1dG9yaWFsIHN0ZXBfOiBtb3ZlIHRoZSBib3hlc1xuICAgICAqL1xuICAgIHN0ZXBNb3ZlQm94ZXMoKSB7XG4gICAgICAgIHRoaXMud2luZG93Q29udGVudChgWW91IGNhbiBtb3ZlIHRoZSBlbGVtZW50cyBvbiB0aGUgZWRpdGluZyBjYW52YXMgYnkgZHJhZ2dpbmcgdGhlbVxuICAgICAgICAgICAgdXNpbmcgdGhlIGxlZnQgbW91c2UgYnV0dG9uLiBZb3UgY2FuIGFsc28gcm90YXRlIHRoZW0gdXNpbmcgbWlkZGxlIGNsaWNrLiBUcnkgaXQgb3V0LmApXG5cbiAgICAgICAgbGV0IGJveE1vdmVkID0gZmFsc2U7XG4gICAgICAgIGxldCBib3hSb3RhdGVkID0gZmFsc2U7XG5cbiAgICAgICAgbGV0IG1vdmVSb3RhdGVDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmKGJveE1vdmVkICYmIGJveFJvdGF0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub25Cb3hNb3ZlZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGJveE1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIG1vdmVSb3RhdGVDYWxsYmFjaygpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uQm94Um90YXRlZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGJveFJvdGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgbW92ZVJvdGF0ZUNhbGxiYWNrKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIF90dXRvcmlhbCBzdGVwXzogY3JlYXRlIGFuIGludmVydG9yXG4gICAgICovXG4gICAgc3RlcFdpcmluZygpIHtcbiAgICAgICAgdGhpcy53aW5kb3dDb250ZW50KGBFc3NlbnRpYWwgcGFydCBvZiBsb2dpYyBuZXR3b3JrcyBpcyB0aGUgd2lyaW5nLiBDcmVhdGUgYSB2ZXJ5IHNpbXBsZVxuICAgICAgICAgICAgaW52ZXJ0ZXIgYnkgY29ubmVjdGluZyB0aGUgPGVtPklucHV0IGJveDwvZW0+IHRvIHRoZSBpbnB1dCBvZiB0aGUgPGVtPk5PVCBnYXRlPC9lbT5cbiAgICAgICAgICAgIGFuZCB0aGUgb3V0cHV0IG9mIHRoZSA8ZW0+Tk9UIGdhdGU8L2VtPiB0byB0aGUgaW5wdXQgb2YgdGhlIDxlbT5PdXRwdXQgYm94PC9lbT4uYCxcbiAgICAgICAgICAgIGBUbyBjb25uZWN0IHR3byBlbGVtbnRzLCBzaW1wbHkgY2xpY2sgb24gYSBjb25uZWN0b3Igb2YgdGhlIGZpcnN0IGVsZW1lbnQsXG4gICAgICAgICAgICB0aGFuIGNsaWNrIG9uIGEgY29uZWN0b3Igb2YgdGhlIHNlY29uZCBlbGVtZW50LmApXG5cbiAgICAgICAgdGhpcy5vbk91dHB1dEJveFRydWUgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBfdHV0b3JpYWwgc3RlcF86IGNoYW5nZSB0aGUgc3RhdGUgb2YgYW4gaW5wdXQgYm94XG4gICAgICovXG4gICAgc3dpdGNoSW5wdXRCb3goKSB7XG4gICAgICAgIHRoaXMud2luZG93Q29udGVudChgXG4gICAgICAgICAgICBUaGUgaW5wdXQgYm94ZXMgY2FuIGJlIGluIHR3byBzdGF0ZXM6IDxlbT5PTjwvZW0+IGFuZCA8ZW0+T0ZGPC9lbT4sIHNpZ25hbGxlZFxuICAgICAgICAgICAgYnkgdGhlIGdyZWVuIGFuZCByZWQgY29sb3JzIHJlc3BlY3RpdmVseS4gWW91IGNhbiBsZWZ0IGNsaWNrIG9uIGFuIElucHV0IGJveCB0b1xuICAgICAgICAgICAgc3dpdGNoIGl0cyBzdGF0ZS4gVHJ5IGl0IG91dCFcbiAgICAgICAgYClcblxuICAgICAgICB0aGlzLm9uQ2hhbmdlSW5wdXRCb3hTdGF0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIF90dXRvcmlhbCBzdGVwXzogcmVtb3ZlIGEgYm94XG4gICAgICovXG4gICAgc3RlcFJlbW92ZUJveCgpIHtcbiAgICAgICAgdGhpcy53aW5kb3dDb250ZW50KFxuICAgICAgICAgICAgYFdoZW4geW91IHJpZ2h0IGNsaWNrIG9uIGFuIGVsZW1lbnQsIHlvdSBjYW4gZmluZCBhIG5ldyBpdGVtIGluIHRoZSBtZW51LFxuICAgICAgICAgICAgdGhhdCBhbGxvd3MgeW91IHRvIHJlbW92ZSB0aGUgZWxlbWVudC4gVGhpcyB3b3JrcyBmb3Igd2lyZXMgYXMgd2VsbCBhcyBmb3IgZ2F0ZXMgYW5kIG90aGVyIHR5cGVzIG9mIGJveGVzLlxuICAgICAgICAgICAgVHJ5IHRvIHJlbW92ZSBhbiBlbGVtZW50IWBcbiAgICAgICAgKVxuXG4gICAgICAgIHRoaXMub25FbGVtZW50UmVtb3ZlZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogX3R1dG9yaWFsIHN0ZXBfOiBhc2sgdGhlIHVzZXIgaWYgdGhleSB3YW50IHRvIGNsZWFuIHRoZSBjYW52YXMgYmVmb3JlIGNsb3NpbmcgdGhlIHR1dG9yaWFsXG4gICAgICovXG4gICAgc3RlcEZpbmlzaCgpIHtcbiAgICAgICAgdGhpcy53aW5kb3dDb250ZW50KGBZb3UncmUgYWxsIHNldCwgZW5qb3kgeW91ciBzdGF5IWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBgRG8geW91IHdpc2ggdG8gc3RhcnQgd2l0aCBlbXB0eSBjYW52YXM/YClcbiAgICAgICAgdGhpcy53aW5kb3dDaG9pY2UoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGV4dDogJ3llcywgY2xlYW4gdGhlIGNhbnZhcycsXG4gICAgICAgICAgICAgICAgZnVuYzogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFNWRy5jbGVhbkNhbnZhcygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRleHQ6ICdubywga2VlcCB0aGUgY2FudmFzIGFzIGl0IGlzJyxcbiAgICAgICAgICAgICAgICBmdW5jOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGRpc3BsYXkgdGhlIHR1dG9yaWFsIHdpbmRvd1xuICAgICAqL1xuICAgIGRpc3BsYXlXaW5kb3coKSB7XG4gICAgICAgIHRoaXMucGFyZW50U1ZHLiRzdmcuYWZ0ZXIodGhpcy4kdHV0b3JpYWxXaW5kb3cpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2xvc2UgdGhlIHR1dG9yaWFsIHdpbmRvd1xuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbb25UdXRvcmlhbENsb3NlZF0gY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgdHV0b3JpYWwgaXMgY2xvc2VkXG4gICAgICovXG4gICAgY2xvc2VXaW5kb3cob25UdXRvcmlhbENsb3NlZCkge1xuICAgICAgICB0aGlzLiR0dXRvcmlhbFdpbmRvdy5yZW1vdmUoKTtcblxuICAgICAgICBpZihvblR1dG9yaWFsQ2xvc2VkIT09dW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvblR1dG9yaWFsQ2xvc2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdGhlIHR1dG9yaWFsIHdpbmRvdyB0ZXh0IGNvbnRlbnRcbiAgICAgKiBAcGFyYW0gIHsuLi5zdHJpbmd9IHRleHQgZWFjaCBzdHJpbmcgaXMgYSBzZXBhcmF0ZSBwYXJhZ3JhcGhcbiAgICAgKi9cbiAgICB3aW5kb3dDb250ZW50KC4uLnRleHQpIHtcbiAgICAgICAgaWYoIXRoaXMuJHR1dG9yaWFsV2luZG93KSB7XG4gICAgICAgICAgICB0aGlzLiR0dXRvcmlhbFdpbmRvdyA9ICQoXCI8ZGl2PlwiKS5hdHRyKFwiaWRcIiwgXCJ0dXRvcmlhbFwiKTtcblxuICAgICAgICAgICAgdGhpcy4kdG9wQnV0dG9uc0xlZnQgPSAkKFwiPGRpdj5cIikuYWRkQ2xhc3MoXCJsZWZ0XCIpO1xuXG4gICAgICAgICAgICB0aGlzLiR0dXRvcmlhbFdpbmRvdy5hcHBlbmQoXG4gICAgICAgICAgICAgICAgJChcIjxkaXY+XCIpLmFkZENsYXNzKFwidG9wQnV0dG9uc1wiKVxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKHRoaXMuJHRvcEJ1dHRvbnNMZWZ0KVxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCAvLyB0aGUgLnJpZ2h0IGRpdiBjYW4gYmUgYWRkZWQgaGVyZSBiZWNhdXNlIGl0IGlzIG5vdCBtb2RpZmllZCBkdXJpbmcgdGhlIHR1dG9yaWFsXG4gICAgICAgICAgICAgICAgICAgICAgICAkKFwiPGRpdj5cIikuYWRkQ2xhc3MoXCJyaWdodFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKFwiPGE+XCIpLmF0dHIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBocmVmOiBcIiNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiY2xvc2UgdHV0b3JpYWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmFkZENsYXNzKFwiYnV0dG9uIGNsb3NlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICB0aGlzLiR0dXRvcmlhbFdpbmRvdy5hcHBlbmQodGhpcy4kdG9wQnV0dG9ucyk7XG5cbiAgICAgICAgICAgIHRoaXMuJHR1dG9yaWFsQ29udGVudCA9ICQoXCI8ZGl2PlwiKS5hZGRDbGFzcyhcImNvbnRlbnRcIik7XG4gICAgICAgICAgICB0aGlzLiR0dXRvcmlhbFdpbmRvdy5hcHBlbmQodGhpcy4kdHV0b3JpYWxDb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJHRvcEJ1dHRvbnNMZWZ0Lmh0bWwoXCJcIik7XG5cbiAgICAgICAgbGV0ICRwcmV2ID0gJChcIjxhPlwiKS5hdHRyKHtcbiAgICAgICAgICAgIGhyZWY6IFwiI1wiLFxuICAgICAgICAgICAgdGl0bGU6IFwiZ28gYmFja1wiXG4gICAgICAgIH0pLmFkZENsYXNzKFwiYnV0dG9uIHByZXZcIik7XG5cbiAgICAgICAgaWYodGhpcy5zdGVwPjEpIHtcbiAgICAgICAgICAgICRwcmV2LmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXYoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHByZXYuYWRkQ2xhc3MoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCAkbmV4dCA9ICQoXCI8YT5cIikuYXR0cih7XG4gICAgICAgICAgICBocmVmOiBcIiNcIixcbiAgICAgICAgICAgIHRpdGxlOiBcImdvIGZvcndhcmRcIlxuICAgICAgICB9KS5hZGRDbGFzcyhcImJ1dHRvbiBuZXh0XCIpO1xuXG4gICAgICAgIGlmKHRoaXMuc3RlcCA8IHRoaXMuc3RlcHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgJG5leHQuY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkbmV4dC5hZGRDbGFzcyhcImRpc2FibGVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4kdG9wQnV0dG9uc0xlZnQuYXBwZW5kKCRwcmV2KS5hcHBlbmQoJG5leHQpO1xuXG4gICAgICAgIC8vIHNldCB0aGUgdGV4dCBjb250ZW50XG5cbiAgICAgICAgdGhpcy4kdHV0b3JpYWxDb250ZW50Lmh0bWwoXCJcIik7XG4gICAgICAgIGZvciAoY29uc3QgcGFyYWdyYXBoIG9mIHRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuJHR1dG9yaWFsQ29udGVudC5hcHBlbmQoXG4gICAgICAgICAgICAgICAgJChcIjxwPlwiKS5odG1sKHBhcmFncmFwaClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAvLyByZW5kZXIgdGhlIGJ1dHRvbnMgaW4gZWFjaCBzdGVwICh0byByZW1vdmUgZm9jdXMgYW5kIHRvXG4gICAgICAgIC8vIC8vIGVuc3VyZSB0aGVyZSBpcyBubyBcImJhY2tcIiBidXR0b24gb24gdGhlIGZpcnN0IHN0ZXAgb3IgXCJuZXh0XCIgYnV0dG9uIG9uIHRoZSBsYXN0IHN0ZXApXG4gICAgICAgIC8vIGlmKHRoaXMuJHByZXZOZXh0KSB7XG4gICAgICAgIC8vICAgICB0aGlzLiRwcmV2TmV4dC5yZW1vdmUoKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvL1xuICAgICAgICAvLyB0aGlzLiRwcmV2TmV4dCA9ICQoXCI8ZGl2PlwiKS5hZGRDbGFzcyhcImJvdHRvbUJ1dHRvbnNcIik7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIGlmKHRoaXMuc3RlcD4xKSB7XG4gICAgICAgIC8vICAgICB0aGlzLiRwcmV2TmV4dC5hcHBlbmQoXG4gICAgICAgIC8vICAgICAgICAgJChcIjxhPlwiKS5hdHRyKFwiaHJlZlwiLCBcIiNcIikuYWRkQ2xhc3MoXCJidXR0b24gcHJldlwiKVxuICAgICAgICAvLyAgICAgICAgIC8vIC50ZXh0KFwiYmFja1wiKVxuICAgICAgICAvLyAgICAgICAgIC5jbGljaygoKSA9PiB7XG4gICAgICAgIC8vICAgICAgICAgICAgIHRoaXMuc3RlcC0tO1xuICAgICAgICAvLyAgICAgICAgIH0pXG4gICAgICAgIC8vICAgICApXG4gICAgICAgIC8vIH1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gaWYodGhpcy5zdGVwIDwgdGhpcy5zdGVwcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIC8vICAgICB0aGlzLiRwcmV2TmV4dC5hcHBlbmQoXG4gICAgICAgIC8vICAgICAgICAgJChcIjxhPlwiKS5hdHRyKFwiaHJlZlwiLCBcIiNcIikuYWRkQ2xhc3MoXCJidXR0b24gbmV4dFwiKVxuICAgICAgICAvLyAgICAgICAgIC8vIC50ZXh0KFwibmV4dFwiKVxuICAgICAgICAvLyAgICAgICAgIC5jbGljaygoKSA9PiB7XG4gICAgICAgIC8vICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAvLyAgICAgICAgIH0pXG4gICAgICAgIC8vICAgICApXG4gICAgICAgIC8vIH1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gdGhpcy4kdHV0b3JpYWxXaW5kb3cuYXBwZW5kKHRoaXMuJHByZXZOZXh0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhZGQgYnV0dG9ucyB3aXRoIGNob2ljZXMgdG8gdGhlIHR1dG9yaWFsIHdpbmRvd1xuICAgICAqIEBwYXJhbSAgey4uLm9iamVjdH0gY2hvaWNlcyBlYWNoIGNob2ljZSBpcyBhbiBvYmplY3QgaW4gd2l0aCBhIGBzdHJpbmdgIHByb3BlcnR5IF90ZXh0XyBhbmQgYSBgZnVuY3Rpb25gIHByb3BlcnR5IF9mdW5jX1xuICAgICAqL1xuICAgIHdpbmRvd0Nob2ljZSguLi5jaG9pY2VzKSB7XG4gICAgICAgIGxldCAkY2hvaWNlcyA9ICQoXCI8b2w+XCIpLmFkZENsYXNzKFwiY2hvaWNlc1wiKTtcbiAgICAgICAgZm9yIChjb25zdCBjaG9pY2Ugb2YgY2hvaWNlcykge1xuICAgICAgICAgICAgJGNob2ljZXMuYXBwZW5kKFxuICAgICAgICAgICAgICAgICQoXCI8bGk+XCIpLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgJChcIjxhPlwiKS5hdHRyKFwiaHJlZlwiLCBcIiNcIikuY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hvaWNlLmZ1bmMoKVxuICAgICAgICAgICAgICAgICAgICB9KS5odG1sKGNob2ljZS50ZXh0KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiR0dXRvcmlhbENvbnRlbnQuYXBwZW5kKCRjaG9pY2VzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzdGFydCB0aGUgdHV0b3JpYWxcbiAgICAgKi9cbiAgICBzdGFydCgpIHsgdGhpcy5zdGVwID0gMTsgfVxuXG4gICAgLyoqXG4gICAgICogZ28gdG8gdGhlIG5leHQgc3RlcCBvZiB0aGUgdHV0b3JpYWxcbiAgICAgKi9cbiAgICBuZXh0KCkgeyB0aGlzLnN0ZXArKzsgfVxuXG4gICAgLyoqXG4gICAgICogZ28gdG8gdGhlIHByZXZpb3VzIHN0ZXAgb2YgdGhlIHR1dG9yaWFsXG4gICAgICovXG4gICAgcHJldigpIHsgdGhpcy5zdGVwLS07IH1cblxuICAgIC8qKlxuICAgICAqIHN0b3AgdGhlIHR1dG9yaWFsXG4gICAgICovXG4gICAgc3RvcCgpIHsgdGhpcy5zdGVwID0gMCB9XG59XG4iLCIvKiogQG1vZHVsZSBWaWV3Qm94ICovXG4vKipcbiAqIFZpZXdCb3ggcHJvdmlkZXMgYW4gYXBpIGZvciBvcHJlcmF0aW5nIHdpdGggdGhlIHZpZXdCb3ggYXJndW1lbnQgb2YgdGhlIDxzdmc+IERPTSBlbGVtZW50LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaWV3Qm94IHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHZpZXdCb3hcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVmdCAgIGRpc3RhbmNlIG9mIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIHZpZXdib3ggZnJvbSBkb2N1bWVudCdzIHkgYXhpcyBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvcCAgICBkaXN0YW5jZSBvZiB0aGUgdG9wIGVkZ2Ugb2YgdGhlIHZpZXdib3ggZnJvbSB0aGUgZG9jdW1lbnQncyB4IGF4aXMgaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAgd2lkdGggb2YgdGhlIHZpZXdib3ggaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgaGVpZ2h0IG9mIHRoZSB2aWV3Ym94IGluIFNWRyBwaXhlbHNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZpZXdCb3ggYXR0cmlidXRlcyBiZWZvcmUgYXBwbHlpbmcgem9vbSBhbmQgc2hpZnRcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVhbCA9IHsgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGltdW0gYW1vdW50IG9mIHpvb20gb24gdGhlIHZpZXdib3hcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWF4Wm9vbSA9IDg7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWluaW11bSBhbW91bnQgb2Ygem9vbSBvbiB0aGUgdmlld2JveFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5taW5ab29tID0gMC4xO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbW91bnQgb2Ygem9vbSBvbiB0aGUgdmlld2JveCwgYWx3YXlzIGJldHdlZW4gdGhpcy5taW5ab29tIGFuZCB0aGlzLm1heFpvb21cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVhbFpvb20gPSAxXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFtb3VudCBvZiBob3Jpem9udGFsIHNoaWZ0IG9mIHRoZSBkb2N1bWVudFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sZWZ0U2hpZnQgPSAwXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhbW91bnQgb2YgdmVydGljYWwgc2hpZnQgb2YgdGhlIGRvY3VtZW50XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRvcFNoaWZ0ID0gMFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSB0aGUgZGltZW5zaW9ucyBvZiB0aGUgdmlld2JveCAodXNlZCBvbiB3aW5kb3cgcmVzaXplKVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gd2lkdGggIG5ldyB3aWR0aCBvZiB0aGUgdmlld2JveCBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBoZWlnaHQgbmV3IGhlaWdodCBvZiB0aGUgdmlld2JveCBpbiBTVkcgcGl4ZWxzXG4gICAgICovXG4gICAgbmV3RGltZW5zaW9ucyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIC8vIGtlZXAgdGhlIHZpZXdib3ggY2VudGVyZWRcbiAgICAgICAgdGhpcy5yZWFsLmxlZnQgKz0gKHRoaXMucmVhbC53aWR0aCAtIHdpZHRoKS8yXG4gICAgICAgIHRoaXMucmVhbC50b3AgKz0gKHRoaXMucmVhbC5oZWlnaHQgLSBoZWlnaHQpLzJcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGRpbWVuc2lvbnNcbiAgICAgICAgdGhpcy5yZWFsLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMucmVhbC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBhbW91bnQgb2Ygem9vbSBvbiB0aGUgdmlld2JveFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgem9vbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhbFpvb207XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0IHRoZSBhbW91bnQgb2Ygem9vbSBvbiB0aGUgdmlld2JveFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSB0aGUgbmV3IGFtb3VudCBvZiB6b29tXG4gICAgICovXG4gICAgc2V0IHpvb20odmFsdWUpIHtcbiAgICAgICAgLy8gZml0IHRoaXMucmVhbFpvb20gdG8gZml0IGJldHdlZW4gdGhpcy5taW5ab29tIGFuZCB0aGlzLm1heFpvb21cbiAgICAgICAgdGhpcy5yZWFsWm9vbSA9IE1hdGgubWF4KE1hdGgubWluKHZhbHVlLCB0aGlzLm1heFpvb20pLCB0aGlzLm1pblpvb20pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgd2lkdGggb2YgdGhlIHZpZXdib3ggd2l0aCB0aGUgY3VycmVudCB6b29tIGFwcGxpZWRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBmaW5hbCB3aWR0aCBvZiB0aGUgdmlld2JveFxuICAgICAqL1xuICAgIGdldCB3aWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhbC53aWR0aCAvIHRoaXMuem9vbVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgaGVpZ2h0IG9mIHRoZSB2aWV3Ym94IHdpdGggdGhlIGN1cnJlbnQgem9vbSBhcHBsaWVkXG4gICAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgZmluYWwgaGVpZ2h0IG9mIHRoZSB2aWV3Ym94XG4gICAgICovXG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhbC5oZWlnaHQgLyB0aGlzLnpvb21cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIGhvcml6b250YWwgZGlzdGFuY2UgZnJvbSB0aGUgeSBheGlzIG9mIHRoZSBkb2N1bWVudCB3aXRoIHpvb20gYW5kIHNoaWZ0IHZhbHVlIGFwcGxpZWRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGxlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWwubGVmdCAtICh0aGlzLmxlZnRTaGlmdCAvIHRoaXMuem9vbSkgKyAoKHRoaXMucmVhbC53aWR0aCAtIHRoaXMud2lkdGgpIC8gMilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIHZlcnRpY2FsIGRpc3RhbmNlIGZyb20gdGhlIHggYXhpcyBvZiB0aGUgZG9jdW1lbnQgd2l0aCB6b29tIGFuZCBzaGlmdCB2YWx1ZSBhcHBsaWVkXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCB0b3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWwudG9wIC0gKHRoaXMudG9wU2hpZnQgLyB0aGlzLnpvb20pICsgKCh0aGlzLnJlYWwuaGVpZ2h0IC0gdGhpcy5oZWlnaHQpIC8gMilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIGNvbXB1dGVkIHZpZXdib3ggdmFsdWVzIGFzIGEgc3RyaW5nIGluIHRoZSBjb3JyZWN0IGZvcm1hdCB0aGF0IGNhbiBiZSB1c2VkIGluIHRoZSB2aWV3Qm94IGF0dHJpYnV0ZSBvZiB0aGUgU1ZHIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0cmluZyBpbiBmb3JtYXQgXCJsZWZ0IHRvcCB3aWR0aCBoZWlnaHRcIlxuICAgICAqL1xuICAgIGdldCBzdHIoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmxlZnR9ICR7dGhpcy50b3B9ICR7dGhpcy53aWR0aH0gJHt0aGlzLmhlaWdodH1gXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdHJhbnNmb3JtIGhvcml6b250YWwgdW5pdHMgdG8gdGhlIHNjYWxlIGFuZCBzaGlmdCBvZiB0aGUgZWRpdG9yXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB4IG9yaWdpbmFsIGhvcml6b250YWwgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgdHJhbnNmb3JtZWQgaG9yaXpvbnRhbCB2YWx1ZVxuICAgICAqL1xuICAgIHRyYW5zZm9ybVgoeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0ICsgKHggLyB0aGlzLnpvb20pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdHJhbnNmb3JtIHZlcnRpY2FsIHVuaXRzIHRvIHRoZSBzY2FsZSBhbmQgc2hpZnQgb2YgdGhlIGVkaXRvclxuICAgICAqIEBwYXJhbSAge251bWJlcn0geSBvcmlnaW5hbCB2ZXJ0aWNhbCB2YWx1ZVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gICB0cmFuc2Zvcm1lZCB2ZXJ0aWNhbCB2YWx1ZVxuICAgICAqL1xuICAgIHRyYW5zZm9ybVkoeSkge1xuICAgICAgICByZXR1cm4gdGhpcy50b3AgKyAoeSAvIHRoaXMuem9vbSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0cmFuc2Zvcm0gcGFnZVggYW5kIHBhZ2VZIHBhcmFtZXRlcnMgb2YgdGhlIGpxdWVyeSBldmVudCB0byBtYXRjaCB0aGUgem9vbSBhbmQgc2hpZnQgb2YgdGhlIHZpZXdib3hcbiAgICAgKiBAcGFyYW0gIHtqcXVlcnkuTW91c2VFdmVudH0gZXZlbnQgb3JpZ2luYWwgZXZlbnRcbiAgICAgKiBAcmV0dXJuIHtqcXVlcnkuTW91c2VFdmVudH0gICAgICAgdGhlIHNhbWUgZXZlbnQgYnV0IHdpdGggdHJhbnNmb3JtZWQgcGFnZVggYW5kIHBhZ2VZIG1lbWJlcnNcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1FdmVudChldmVudCkge1xuICAgICAgICBldmVudC5wYWdlWCA9IHRoaXMudHJhbnNmb3JtWChldmVudC5wYWdlWClcbiAgICAgICAgZXZlbnQucGFnZVkgPSB0aGlzLnRyYW5zZm9ybVkoZXZlbnQucGFnZVkpXG5cbiAgICAgICAgcmV0dXJuIGV2ZW50XG4gICAgfVxufVxuIiwiLyoqXG4gKiBAbW9kdWxlIExpYnJhcnlcbiAqL1xuXG5jb25zdCBsaWJyYXJ5RGlyID0gJy4vbGlicmFyeS8nXG5cbi8qKlxuICogZ2V0IGxpc3Qgb2YgbmV0d29ya3MgZnJvbSB0aGUgbGlicmFyeVxuICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSwgdGhlIHJlc29sdXRpb24gaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYSBsaXN0IG9mIGxpYnJhcmllc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGlicmFyeSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBsaWJyYXJ5RmlsZSA9IGxpYnJhcnlEaXIgKyAnbmV0d29ya0xpc3QuanNvbic7XG5cbiAgICAgICAgbGV0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYodGhpcy5yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5yZXNwb25zZS5uZXR3b3Jrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihbXCJlcnJvclwiLCBcImFib3J0XCJdLCAoKSA9PiB7XG4gICAgICAgICAgICByZWplY3QoXCJGYWlsZWQgbG9hZGluZyBsaWJyYXJpZXMuXCIpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlcXVlc3Qub3BlbignR0VUJywgbGlicmFyeUZpbGUsIHRydWUpO1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogZ2V0IGEgbmV0d29yayBmcm9tIHRoZSBsaWJyYXJ5LCBzcGVjaWZpZWQgYnkgZmlsZW5hbWVcbiAqIEBwYXJhbSAge3N0cmluZ30gbmV0d29ya05hbWUgbGlicmFyeSBmaWxlIG5hbWUgd2l0aG91dCB0aGUgZXh0ZW5zaW9uXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlLCB0aGUgcmVzb2x1dGlvbiBpcyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgbGlicmFyeSBpbXBvcnQgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TmV0d29ya0Zyb21MaWJyYXJ5KG5ldHdvcmtOYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYodGhpcy5yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihbXCJlcnJvclwiLCBcImFib3J0XCJdLCAoKSA9PiB7XG4gICAgICAgICAgICByZWplY3QoYEZhaWxlZCBsb2FkaW5nIGxpYnJhcnkgJHtuZXR3b3JrTmFtZX0uYClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVxdWVzdC5vcGVuKCdHRVQnLCBsaWJyYXJ5RGlyICsgbmV0d29ya05hbWUgKyAnLmpzb24nLCB0cnVlKTtcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnanNvbic7XG4gICAgICAgIHJlcXVlc3Quc2VuZCgpO1xuICAgIH0pO1xufVxuIl19"}