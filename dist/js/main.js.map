{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/json-stringify-pretty-compact/index.js","node_modules/libstl/Datastructures/DoublyLinkedList.js","node_modules/libstl/Datastructures/Heap.js","node_modules/libstl/Datastructures/MaxHeap.js","node_modules/libstl/Datastructures/MinHeap.js","node_modules/libstl/Datastructures/PriorityQueue.js","node_modules/libstl/Datastructures/Queue.js","node_modules/libstl/Datastructures/Stack.js","node_modules/libstl/node-module.js","src/es6/main.js","src/es6/modules/App.js","src/es6/modules/Logic.js","src/es6/modules/Simulation.js","src/es6/modules/editorElements.js","src/es6/modules/editorElements/Blackbox.js","src/es6/modules/editorElements/Box.js","src/es6/modules/editorElements/Connector.js","src/es6/modules/editorElements/Gate.js","src/es6/modules/editorElements/HelperWire.js","src/es6/modules/editorElements/InputBox.js","src/es6/modules/editorElements/InputConnector.js","src/es6/modules/editorElements/NetworkElement.js","src/es6/modules/editorElements/OutputBox.js","src/es6/modules/editorElements/OutputConnector.js","src/es6/modules/editorElements/Transform.js","src/es6/modules/editorElements/Wire.js","src/es6/modules/editorElements/stateClasses.js","src/es6/modules/findPath.js","src/es6/modules/other/helperFunctions.js","src/es6/modules/other/id.js","src/es6/modules/other/mapWithDefaultValue.js","src/es6/modules/svgObjects.js","src/es6/modules/svgObjects/Group.js","src/es6/modules/svgObjects/MultiLineText.js","src/es6/modules/svgObjects/Pattern.js","src/es6/modules/svgObjects/PolyLine.js","src/es6/modules/svgObjects/PolyLinePoint.js","src/es6/modules/svgObjects/PolyLinePoints.js","src/es6/modules/svgObjects/Rectangle.js","src/es6/modules/svgObjects/SvgElement.js","src/es6/modules/svgObjects/SvgImage.js","src/es6/modules/svgObjects/Tag.js","src/es6/modules/svgObjects/Text.js","src/es6/modules/ui/ContextMenu.js","src/es6/modules/ui/FloatingMenu.js","src/es6/modules/ui/Messages.js","src/es6/modules/ui/Tutorial.js","src/es6/modules/ui/ViewBox.js","src/es6/modules/ui/networkLibrary.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;;AAEA;;;;;;AAEA;;;AAGA,EAAE,YAAM;AACJ,MAAI,aAAJ,CAAQ,SAAR,EAAmB,EAAnB;AACH,CAFD;;;;;;;;;;;qjBCPA;;;AAGA;;;AAGA;;;AAKA;;;AAOA;;;AAGA;AACA;;;AArBA;;IAAY,c;;AAGZ;;AAG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","file":"main.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","function stringify (obj, options) {\n  options = options || {}\n  var indent = JSON.stringify([1], null, get(options, 'indent', 2)).slice(2, -3)\n  var addMargin = get(options, 'margins', false)\n  var maxLength = (indent === '' ? Infinity : get(options, 'maxLength', 80))\n\n  return (function _stringify (obj, currentIndent, reserved) {\n    if (obj && typeof obj.toJSON === 'function') {\n      obj = obj.toJSON()\n    }\n\n    var string = JSON.stringify(obj)\n\n    if (string === undefined) {\n      return string\n    }\n\n    var length = maxLength - currentIndent.length - reserved\n\n    if (string.length <= length) {\n      var prettified = prettify(string, addMargin)\n      if (prettified.length <= length) {\n        return prettified\n      }\n    }\n\n    if (typeof obj === 'object' && obj !== null) {\n      var nextIndent = currentIndent + indent\n      var items = []\n      var delimiters\n      var comma = function (array, index) {\n        return (index === array.length - 1 ? 0 : 1)\n      }\n\n      if (Array.isArray(obj)) {\n        for (var index = 0; index < obj.length; index++) {\n          items.push(\n            _stringify(obj[index], nextIndent, comma(obj, index)) || 'null'\n          )\n        }\n        delimiters = '[]'\n      } else {\n        Object.keys(obj).forEach(function (key, index, array) {\n          var keyPart = JSON.stringify(key) + ': '\n          var value = _stringify(obj[key], nextIndent,\n                                 keyPart.length + comma(array, index))\n          if (value !== undefined) {\n            items.push(keyPart + value)\n          }\n        })\n        delimiters = '{}'\n      }\n\n      if (items.length > 0) {\n        return [\n          delimiters[0],\n          indent + items.join(',\\n' + nextIndent),\n          delimiters[1]\n        ].join('\\n' + currentIndent)\n      }\n    }\n\n    return string\n  }(obj, '', 0))\n}\n\n// Note: This regex matches even invalid JSON strings, but since we’re\n// working on the output of `JSON.stringify` we know that only valid strings\n// are present (unless the user supplied a weird `options.indent` but in\n// that case we don’t care since the output would be invalid anyway).\nvar stringOrChar = /(\"(?:[^\\\\\"]|\\\\.)*\")|[:,\\][}{]/g\n\nfunction prettify (string, addMargin) {\n  var m = addMargin ? ' ' : ''\n  var tokens = {\n    '{': '{' + m,\n    '[': '[' + m,\n    '}': m + '}',\n    ']': m + ']',\n    ',': ', ',\n    ':': ': '\n  }\n  return string.replace(stringOrChar, function (match, string) {\n    return string ? match : tokens[match]\n  })\n}\n\nfunction get (options, name, defaultValue) {\n  return (name in options ? options[name] : defaultValue)\n}\n\nmodule.exports = stringify\n","/**\n * The DoublyLinkedList class provides the main functionality of a doubly linked list.\n *\n * @class DoublyLinkedList\n */\nvar DoublyLinkedList = (function () {\n    function DoublyLinkedList() {\n        /**\n         * Count of elements in list\n         *\n         * @property _length\n         * @type number\n         * @private\n         */\n        this._length = 0;\n        /**\n         * Iteration pointer\n         *\n         * @property _key\n         * @type number\n         * @private\n         */\n        this._key = 0;\n        /**\n         * Reference to head(first) element in list\n         *\n         * @property _head\n         * @type DoublyLinkedListNode\n         * @private\n         */\n        this._head = null;\n        /**\n         * Reference to tail(last) element in list\n         *\n         * @property _tail\n         * @type DoublyLinkedListNode\n         * @private\n         */\n        this._tail = null;\n        /**\n         * Reference to iterated element in list\n         *\n         * @property _current\n         * @type DoublyLinkedListNode\n         * @private\n         */\n        this._current = null;\n    }\n    /**\n     * Insert a new value at the specified index\n     *\n     * @method add\n     * @param index The index where the new value is to be inserted.\n     * @param value The new value for the index.\n     * @return void\n     */\n    DoublyLinkedList.prototype.add = function (index, value) {\n        if (index < 0 || index >= this._length) {\n            throw new Error(\"Out of bounds\");\n        }\n        var i = 0;\n        var current = this._head;\n        while (i < index) {\n            current = current.next;\n            i++;\n        }\n        current.value = value;\n    };\n    /**\n     * Pops a node from the end of the doubly linked list\n     *\n     * @method pop\n     * @return any  The value of the popped node.\n     */\n    DoublyLinkedList.prototype.pop = function () {\n        if (this._length === 0) {\n            throw new Error(\"Can't pop from an empty data structure\");\n        }\n        var value = this._tail.value;\n        this._tail = this._tail.prev;\n        if (this._tail) {\n            delete this._tail.next;\n            this._tail.next = null;\n        }\n        this._length--;\n        if (this._length === 0) {\n            delete this._head;\n            this._head = null;\n        }\n        return value;\n    };\n    /**\n     * Shifts a node from the beginning of the doubly linked list\n     *\n     * @method shift\n     * @return any  The value of the shifted node.\n     */\n    DoublyLinkedList.prototype.shift = function () {\n        if (this._length === 0) {\n            throw new Error(\"Can't shift from an empty data structure\");\n        }\n        var value = this._head.value;\n        this._head = this._head.next;\n        if (this._head) {\n            delete this._head.prev;\n            this._head.prev = null;\n        }\n        this._length--;\n        return value;\n    };\n    /**\n     * Pushes an element at the end of the doubly linked list\n     *\n     * @method push\n     * @param value The value to push.\n     * @return void\n     */\n    DoublyLinkedList.prototype.push = function (value) {\n        // allocate new node\n        var node = {\n            value: value,\n            prev: this._tail,\n            next: null\n        };\n        if (this._length === 0) {\n            this._head = this._tail = node;\n        }\n        else {\n            this._tail.next = node;\n            this._tail = this._tail.next;\n        }\n        this._length++;\n    };\n    /**\n     * Prepends the doubly linked list with an element\n     *\n     * @method unshift\n     * @param value The value to unshift.\n     * @return void\n     */\n    DoublyLinkedList.prototype.unshift = function (value) {\n        // allocate new node\n        var node = {\n            value: value,\n            prev: null,\n            next: this._head\n        };\n        if (this._length === 0) {\n            this._head = this._tail = node;\n        }\n        else {\n            this._head.prev = node;\n            this._head = this._head.prev;\n        }\n        this._length++;\n    };\n    /**\n     * Peeks at the node from the end of the doubly linked list\n     *\n     * @method top\n     * @return any  The value of the last node.\n     */\n    DoublyLinkedList.prototype.top = function () {\n        if (this._tail)\n            return this._tail.value;\n    };\n    /**\n     * Peeks at the node from the beginning of the doubly linked list\n     *\n     * @method bottom\n     * @return any  The value of the first node.\n     */\n    DoublyLinkedList.prototype.bottom = function () {\n        if (this._head)\n            return this._head.value;\n    };\n    /**\n     * Counts the number of elements in the doubly linked list\n     *\n     * @method count\n     * @return number the number of elements in the doubly linked list.\n     */\n    DoublyLinkedList.prototype.count = function () {\n        return this._length;\n    };\n    /**\n     * Checks whether the doubly linked list is empty\n     *\n     * @method isEmpty\n     * @return boolean whether the doubly linked list is empty.\n     */\n    DoublyLinkedList.prototype.isEmpty = function () {\n        return (this._length === 0);\n    };\n    /**\n     * Rewind iterator back to the start\n     *\n     * @method rewind\n     * @return void\n     */\n    DoublyLinkedList.prototype.rewind = function () {\n        this._key = 0;\n        this._current = this._head;\n    };\n    /**\n     * Return current list entry\n     *\n     * @method current\n     * @return any  The current node value.\n     */\n    DoublyLinkedList.prototype.current = function () {\n        if (this._current) {\n            return this._current.value;\n        }\n        return null;\n    };\n    /**\n     * Return current node index\n     *\n     * @method key\n     * @return any  The current node index.\n     */\n    DoublyLinkedList.prototype.key = function () {\n        return this._key;\n    };\n    /**\n     * Move to next entry\n     *\n     * @method next\n     * @return void\n     */\n    DoublyLinkedList.prototype.next = function () {\n        this._current = this._current.next;\n        this._key++;\n    };\n    /**\n     * Move to previous entry\n     *\n     * @method prev\n     * @return void\n     */\n    DoublyLinkedList.prototype.prev = function () {\n        this._current = this._current.prev;\n        this._key--;\n    };\n    /**\n     * Check whether the doubly linked list contains more nodes\n     *\n     * @method valid\n     * @return boolean true if the doubly linked list contains any more nodes, false otherwise.\n     */\n    DoublyLinkedList.prototype.valid = function () {\n        return (this._key >= 0 && this._key < this._length);\n    };\n    /**\n     * Export the list to array\n     *\n     * @method toArray\n     * @return Array   The exported array\n     */\n    DoublyLinkedList.prototype.toArray = function () {\n        var list = [];\n        var current = this._head;\n        while (current) {\n            list.push(current.value);\n            current = current.next;\n        }\n        return list;\n    };\n    /**\n     * Serializes the list to string\n     *\n     * @method toString\n     * @return string   The serialized string.\n     */\n    DoublyLinkedList.prototype.toString = function () {\n        return \"{\" + this.toArray().join(\"->\") + \"}\";\n    };\n    return DoublyLinkedList;\n})();\nmodule.exports = DoublyLinkedList;\n//# sourceMappingURL=DoublyLinkedList.js.map","/**\n * The Heap class provides the main functionality of a Heap.\n *\n * @class Heap\n */\nvar Heap = (function () {\n    function Heap() {\n        /**\n         * Binary tree storage array\n         *\n         * @property _tree\n         * @type Array\n         * @private\n         */\n        this._tree = [];\n        /**\n         * Heap type\n         *\n         * @property _type\n         * @type number\n         * @private\n         */\n        this._type = Heap.MAX;\n        /**\n         * Iteration pointer\n         *\n         * @property _key\n         * @type number\n         * @private\n         */\n        this._key = 0;\n    }\n    /**\n     * Get index of left child element in binary tree stored in array\n     *\n     * @method _child\n     * @param n\n     * @return number\n     * @private\n     */\n    Heap.prototype._child = function (n) {\n        return 2 * n + 1;\n    };\n    /**\n     * Get index of parent element in binary tree stored in array\n     *\n     * @method _parent\n     * @param n\n     * @return number\n     * @private\n     */\n    Heap.prototype._parent = function (n) {\n        //console.log('n=', n, Math.floor(n / 2));\n        return Math.floor(n / 2);\n    };\n    /**\n     * Swap 2 elements in binary tree\n     *\n     * @method _swap\n     * @param first\n     * @param second\n     * @private\n     */\n    Heap.prototype._swap = function (first, second) {\n        var swap = this._tree[first];\n        this._tree[first] = this._tree[second];\n        this._tree[second] = swap;\n    };\n    /**\n     * Sift elements in binary tree\n     *\n     * @method _siftUp\n     * @param i\n     * @private\n     */\n    Heap.prototype._siftUp = function (i) {\n        while (i > 0) {\n            var parent = this._parent(i);\n            if (this.compare(this._tree[i], this._tree[parent]) * this._type > 0) {\n                this._swap(i, parent);\n                i = parent;\n            }\n            else {\n                break;\n            }\n        }\n    };\n    /**\n     * Sift down elements in binary tree\n     *\n     * @method _siftDown\n     * @param i\n     * @private\n     */\n    Heap.prototype._siftDown = function (i) {\n        while (i < this._tree.length) {\n            var left = this._child(i);\n            var right = left + 1;\n            if ((left < this._tree.length) && (right < this._tree.length) &&\n                (this.compare(this._tree[i], this._tree[left]) * this._type < 0 ||\n                    this.compare(this._tree[i], this._tree[right]) * this._type < 0)) {\n                // there is 2 children and one of them must be swapped\n                // get correct element to sift down\n                var sift = left;\n                if (this.compare(this._tree[left], this._tree[right]) * this._type < 0) {\n                    sift = right;\n                }\n                this._swap(i, sift);\n                i = sift;\n            }\n            else if (left < this._tree.length &&\n                this.compare(this._tree[i], this._tree[left]) * this._type < 0) {\n                // only one child exists\n                this._swap(i, left);\n                i = left;\n            }\n            else {\n                break;\n            }\n        }\n    };\n    /**\n     * Extracts a node from top of the heap and sift up\n     *\n     * @method extract\n     * @return any The value of the extracted node.\n     */\n    Heap.prototype.extract = function () {\n        if (this._tree.length === 0) {\n            throw new Error(\"Can't extract from an empty data structure\");\n        }\n        var extracted = this._tree[0];\n        if (this._tree.length === 1) {\n            this._tree = [];\n        }\n        else {\n            this._tree[0] = this._tree.pop();\n            this._siftDown(0);\n        }\n        return extracted;\n    };\n    /**\n     * Inserts an element in the heap by sifting it up\n     *\n     * @method insert\n     * @param value The value to insert.\n     * @return void\n     */\n    Heap.prototype.insert = function (value) {\n        this._tree.push(value);\n        this._siftUp(this._tree.length - 1);\n    };\n    /**\n     * Peeks at the node from the top of the heap\n     *\n     * @method top\n     * @return any The value of the node on the top.\n     */\n    Heap.prototype.top = function () {\n        if (this._tree.length === 0) {\n            throw new Error(\"Can't peek at an empty heap\");\n        }\n        return this._tree[0];\n    };\n    /**\n     * Counts the number of elements in the heap\n     *\n     * @method count\n     * @return number the number of elements in the heap.\n     */\n    Heap.prototype.count = function () {\n        return this._tree.length;\n    };\n    /**\n     * Checks whether the heap is empty\n     *\n     * @method isEmpty\n     * @return boolean whether the heap is empty.\n     */\n    Heap.prototype.isEmpty = function () {\n        return (this._tree.length === 0);\n    };\n    /**\n     * Rewind iterator back to the start (no-op)\n     *\n     * @method rewind\n     * @return void\n     */\n    Heap.prototype.rewind = function () {\n        this._key = 0;\n    };\n    /**\n     * Return current node pointed by the iterator\n     *\n     * @method current\n     * @return any The current node value.\n     */\n    Heap.prototype.current = function () {\n        return this._tree[this._key];\n    };\n    /**\n     * Return current node index\n     *\n     * @method key\n     * @return any The current node index.\n     */\n    Heap.prototype.key = function () {\n        return this._key;\n    };\n    /**\n     * Move to the next node\n     *\n     * @method next\n     * @return void\n     */\n    Heap.prototype.next = function () {\n        this._key++;\n    };\n    /**\n     * Move to previous entry\n     *\n     * @method prev\n     * @return void\n     */\n    Heap.prototype.prev = function () {\n        this._key--;\n    };\n    /**\n     * Check whether the heap contains more nodes\n     *\n     * @method valid\n     * @return boolean true if the heap contains any more nodes, false otherwise.\n     */\n    Heap.prototype.valid = function () {\n        return (this._key >= 0 && this._key < this._tree.length);\n    };\n    /**\n     * Compare elements in order to place them correctly in the heap while sifting up.\n     *\n     * @method compare\n     * @param first The value of the first node being compared.\n     * @param second The value of the second node being compared.\n     * @return number Result of the comparison, positive integer if first is greater than second, 0 if they are equal, negative integer otherwise.\n     * Having multiple elements with the same value in a Heap is not recommended. They will end up in an arbitrary relative position.\n     */\n    Heap.prototype.compare = function (first, second) {\n        if (first > second) {\n            return 1;\n        }\n        else if (first == second) {\n            return 0;\n        }\n        else {\n            return -1;\n        }\n    };\n    /**\n     * Visually display heap tree\n     *\n     * @method _displayNode\n     * @param node\n     * @param prefix\n     * @param last\n     * @return String\n     * @private\n     */\n    Heap.prototype._displayNode = function (node, prefix, last) {\n        if (prefix === void 0) { prefix = ''; }\n        if (last === void 0) { last = true; }\n        var line = prefix;\n        // get child indexes\n        var left = this._child(node);\n        var right = left + 1;\n        if (last) {\n            line += (prefix ? '└─' : '  ');\n        }\n        else {\n            line += '├─';\n        }\n        line += this._tree[node];\n        prefix += (last ? '  ' : '│ ');\n        if (left < this._tree.length) {\n            line += '\\n' + this._displayNode(left, prefix, (this._tree[right] == undefined ? true : false));\n        }\n        if (right < this._tree.length) {\n            line += '\\n' + this._displayNode(right, prefix, true);\n        }\n        return line;\n    };\n    /**\n     * Serializes the heap to string\n     *\n     * @method toString\n     * @return string   The serialized string.\n     */\n    Heap.prototype.toString = function () {\n        // start with root and recursively goes to each node\n        return this._displayNode(0);\n    };\n    /**\n     * Serializes the heap to array\n     *\n     * @method toArray\n     * @return Array   The serialized array.\n     */\n    Heap.prototype.toArray = function () {\n        return this._tree;\n    };\n    /**\n     * Max heap flag\n     *\n     * @property MAX\n     * @type number\n     * @static\n     */\n    Heap.MAX = 1;\n    /**\n     * Min heap flag\n     *\n     * @property MIN\n     * @type number\n     * @static\n     */\n    Heap.MIN = -1;\n    return Heap;\n})();\nmodule.exports = Heap;\n//# sourceMappingURL=Heap.js.map","var __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\nvar Heap = require('./Heap');\n/**\n * The MaxHeap class provides the main functionality of a heap, keeping the maximum on the top.\n *\n * @class MaxHeap\n * @extends Heap\n */\nvar MaxHeap = (function (_super) {\n    __extends(MaxHeap, _super);\n    function MaxHeap() {\n        _super.apply(this, arguments);\n        this._type = Heap.MAX;\n    }\n    return MaxHeap;\n})(Heap);\nmodule.exports = MaxHeap;\n//# sourceMappingURL=MaxHeap.js.map","var __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\nvar Heap = require('./Heap');\n/**\n * The MinHeap class provides the main functionality of a heap, keeping the minimum on the top.\n *\n * @class MinHeap\n * @extends Heap\n */\nvar MinHeap = (function (_super) {\n    __extends(MinHeap, _super);\n    function MinHeap() {\n        _super.apply(this, arguments);\n        this._type = Heap.MIN;\n    }\n    return MinHeap;\n})(Heap);\nmodule.exports = MinHeap;\n//# sourceMappingURL=MinHeap.js.map","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Heap = require('./Heap');\n/**\n * The PriorityQueue class provides the main functionality of an prioritized queue, implemented using a max heap.\n *\n * @class PriorityQueue\n * @extends Heap\n */\nvar PriorityQueue = (function (_super) {\n    __extends(PriorityQueue, _super);\n    function PriorityQueue() {\n        _super.apply(this, arguments);\n        this._type = Heap.MAX;\n    }\n    /**\n     * Adds an element to the queue\n     *\n     * @method enqueue\n     * @param value The value to enqueue.\n     * @param priority The priority of value.\n     * @return void\n     */\n    PriorityQueue.prototype.enqueue = function (value, priority) {\n        return this.insert(new PriorityQueueNode(value, priority));\n    };\n    /**\n     * Dequeues a node from the queue\n     *\n     * @method dequeue\n     * @return any  The value of the dequeued node.\n     */\n    PriorityQueue.prototype.dequeue = function () {\n        return this.extract().value;\n    };\n    /**\n     * Peeks at the node from the top of the heap\n     *\n     * @method top\n     * @return any The value of the node on the top.\n     */\n    PriorityQueue.prototype.top = function () {\n        return _super.prototype.top.call(this).value;\n    };\n    /**\n     * Compare elements in order to place them correctly in the heap while sifting up.\n     *\n     * @method compare\n     * @param first The value of the first node being compared.\n     * @param second The value of the second node being compared.\n     * @return number Result of the comparison, positive integer if first is greater than second, 0 if they are equal, negative integer otherwise.\n     * Having multiple elements with the same value in a Heap is not recommended. They will end up in an arbitrary relative position.\n     */\n    PriorityQueue.prototype.compare = function (first, second) {\n        if (first.priority > second.priority) {\n            return 1;\n        }\n        else if (first.priority == second.priority) {\n            return 0;\n        }\n        else {\n            return -1;\n        }\n    };\n    return PriorityQueue;\n})(Heap);\n/**\n * PriorityQueue Node\n *\n * @class PriorityQueueNode\n */\nvar PriorityQueueNode = (function () {\n    /**\n     * Constructor\n     *\n     * @method constructor\n     * @param value\n     * @param priority\n     */\n    function PriorityQueueNode(value, priority) {\n        this.value = value;\n        this.priority = priority;\n    }\n    /**\n     * Serializes the node to string\n     *\n     * @method toString\n     * @return string   The serialized string.\n     */\n    PriorityQueueNode.prototype.toString = function () {\n        return this.value + \" [\" + this.priority + \"]\";\n    };\n    return PriorityQueueNode;\n})();\nmodule.exports = PriorityQueue;\n//# sourceMappingURL=PriorityQueue.js.map","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DoublyLinkedList = require('./DoublyLinkedList');\n/**\n * The Queue class provides the main functionality of a queue implemented using a doubly linked list.\n *\n * @class Queue\n * @extends DoublyLinkedList\n */\nvar Queue = (function (_super) {\n    __extends(Queue, _super);\n    function Queue() {\n        _super.apply(this, arguments);\n    }\n    /**\n     * Adds an element to the queue\n     *\n     * @method enqueue\n     * @param value The value to enqueue.\n     * @return void\n     */\n    Queue.prototype.enqueue = function (value) {\n        return this.push(value);\n    };\n    /**\n     * Dequeues a node from the queue\n     *\n     * @method dequeue\n     * @return any  The value of the dequeued node.\n     */\n    Queue.prototype.dequeue = function () {\n        return this.shift();\n    };\n    return Queue;\n})(DoublyLinkedList);\nmodule.exports = Queue;\n//# sourceMappingURL=Queue.js.map","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DoublyLinkedList = require('./DoublyLinkedList');\n/**\n * The Stack class provides the main functionality of a stack implemented using a doubly linked list.\n *\n * @class Stack\n * @extends DoublyLinkedList\n */\nvar Stack = (function (_super) {\n    __extends(Stack, _super);\n    function Stack() {\n        _super.apply(this, arguments);\n    }\n    return Stack;\n})(DoublyLinkedList);\nmodule.exports = Stack;\n//# sourceMappingURL=Stack.js.map","/**\n * STL\n * @type {{DoublyLinkedList: exports, Stack: exports, Queue: exports, Heap: exports, MaxHeap: exports, MinHeap: exports, PriorityQueue: exports}}\n */\nmodule.exports = {\n\tDoublyLinkedList: require('./Datastructures/DoublyLinkedList'),\n\tStack: require('./Datastructures/Stack'),\n\tQueue: require('./Datastructures/Queue'),\n\tHeap: require('./Datastructures/Heap'),\n\tMaxHeap: require('./Datastructures/MaxHeap'),\n\tMinHeap: require('./Datastructures/MinHeap'),\n\tPriorityQueue: require('./Datastructures/PriorityQueue')\n};","'use strict';\n\nimport App from './modules/App';\n\n/**\n * When the document is ready, initialize the application\n */\n$(() => {\n    new App('#canvas', 10);\n});\n","// editor elements (gates, wires...)\nimport * as editorElements from './editorElements';\n\n// svg elements\nimport { Pattern, Rectangle, PolyLinePoint, PolyLinePoints, PolyLine } from './svgObjects';\n\n// network logic and simulation\nimport Logic from './Logic';\nimport Simulation from './Simulation';\nimport { SimulationDummy } from './Simulation';\n\n// ui stuff\nimport ContextMenu from './ui/ContextMenu';\nimport FloatingMenu from './ui/FloatingMenu';\nimport Tutorial from './ui/Tutorial';\nimport Messages from './ui/Messages';\nimport ViewBox from './ui/ViewBox';\n\n// mouse scroll event listerer for ui, manhattan distance for importData\nimport { addMouseScrollEventListener, manhattanDistance } from './other/helperFunctions';\n\n// used in importData\n// note: imported from a node module\nimport { PriorityQueue } from 'libstl';\n\nconst ctrlKey = 17,\n    cmdKey = 91;\n\n/** @module App */\n/**\n * Main class of the application. It represents an instance of the whole editor and holds\n * references to all its elements.\n */\nexport default class App {\n    /**\n     * Initialize the Svg class\n     * @param {string} canvas   query selector of the SVG element, that will contain all SVG content of the application\n     * @param {number} gridSize initial size of the grid in SVG pixels\n     */\n    constructor(canvas, gridSize) {\n        /**\n         * jQuery element for the SVG document\n         */\n        this.$svg = $(canvas);\n\n        /**\n         * space between grid lines in SVG pixels\n         * @type {number}\n         */\n        this.gridSize = gridSize;\n\n        /**\n         * Array of all boxes (instances of objects derived from editorElements.Box) used on canvas\n         * @type {Array}\n         */\n        this.boxes = []; // stores all boxes\n\n        /**\n         * Array of all wires (instances of editorElements.Wire) used on canvas\n         * @type {Array}\n         */\n        this.wires = []; // stores all wires\n\n        /**\n         * Interface for showing messages to the user\n         * @type {Messages}\n         */\n        this.messages = new Messages();\n\n        this.simulationEnabled = true;\n        this.simulation = new SimulationDummy(); // dummy, will be overwritten on startNewSimulation\n\n        /**\n         * distance from the left top corner to the first element in the imported network\n         * and distance from the left top corner to the imported black box _in grid pixels_\n         * @type {number}\n         */\n        this.leftTopPadding = 4;\n\n        // create the defs element, used for patterns\n        this.$defs = $('<defs>');\n        this.$svg.prepend(this.$defs);\n\n        // BACKGROUND PATTERN\n        let pattern = new Pattern('grid', this.gridSize, this.gridSize);\n\n        let patternPoints = new PolyLinePoints()\n            .append(new PolyLinePoint(0, 0))\n            .append(new PolyLinePoint(this.gridSize, 0))\n            .append(new PolyLinePoint(this.gridSize, this.gridSize));\n\n        pattern.addChild(new PolyLine(patternPoints, 2, '#c2c3e4'));\n        this.addPattern(pattern.get());\n\n        this.background = new Rectangle(0, 0, this.width, this.height, 'url(#grid)', 'none');\n        this.appendJQueryObject(this.background.get());\n        this.refresh();\n\n        // set the viewbox for future zooming and moving of the canvas\n        this.$svg.attr('preserveAspectRatio', 'xMinYMin slice');\n        this.viewbox = new ViewBox(0, 0, this.width, this.height);\n        this.applyViewbox();\n\n        // CONSTRUCT CONTEXT MENU\n        this.contextMenu = new ContextMenu(this);\n\n        // CONSTRUCT FLOATING MENU\n        this.floatingMenu = new FloatingMenu(this);\n\n        let target;\n\n        // ALL EVENT CALLBACKS\n        this.$svg\n            .on('mousedown', event => {\n                target = this.getRealTarget(event.target);\n\n                if (target !== undefined) {\n                    // propagate mousedown to the real target\n                    target.onMouseDown(event);\n                } else {\n                    // mousedown happened directly on the svg\n                    this.onMouseDown(event);\n                }\n\n                this.hideContextMenu();\n                event.preventDefault();\n            })\n            .on('mousemove', event => {\n                if (target !== undefined) {\n                    target.onMouseMove(event);\n                } else {\n                    // mousemove happened directly on the svg\n                    this.onMouseMove(event);\n                }\n\n                event.preventDefault();\n            })\n            .on('mouseup', event => {\n                if (target !== undefined) {\n                    target.onMouseUp(event);\n                } else {\n                    // mouseup happened directly on the svg\n                    this.onMouseUp(event);\n                }\n\n                target = undefined;\n\n                event.preventDefault();\n            })\n            .on('contextmenu', event => {\n                this.displayContextMenu(\n                    event.pageX,\n                    event.pageY,\n                    this.getRealJQueryTarget(event.target)\n                );\n                event.preventDefault();\n            });\n\n        $(document)\n            .on('keydown', event => {\n                this.onKeyDown(event);\n            })\n            .on('keyup', event => {\n                this.onKeyUp(event);\n            });\n\n        // update the viewbox on window resize\n        $(window).on('resize', () => {\n            this.viewbox.newDimensions(this.width, this.height);\n            this.applyViewbox();\n        });\n\n        addMouseScrollEventListener(canvas, event => {\n            // zoom only if the ctrl key is not pressed\n            if (!event.ctrlKey) {\n                this.zoom += event.delta * 0.1;\n\n                event.preventDefault();\n            }\n        });\n\n        $(window).on('keydown', event => {\n            const actions = {\n                '+': 0.1,\n                '-': -0.1\n            };\n\n            if (actions[event.key]) {\n                this.zoom += actions[event.key];\n            }\n        });\n\n        /**\n         * property containing an instance of [Tutorial](./module-Tutorial.html), if there is any\n         * @type {Tutorial}\n         */\n        this.tutorial;\n\n        // check if the user visits for the first time, if so, start the tutorial\n        try {\n            if (!localStorage.userHasVisited) {\n                this.startTutorial();\n            }\n        } catch (e) {\n            console.warn(e);\n        }\n    }\n\n    /**\n     * Get the width of the main SVG element\n     * @return {number} width of the SVG element in pixels\n     */\n    get width() {\n        return this.$svg.width();\n    }\n\n    /**\n     * Get the height of the main SVG element\n     * @return {number} height of the SVG element in pixels\n     */\n    get height() {\n        return this.$svg.height();\n    }\n\n    /**\n     * Process all keydown events that are connected to the app\n     * @param  {jquery.KeyboardEvent} event KeyboardEvent generated by a listener\n     */\n    onKeyDown(event) {\n        if (event.keyCode === ctrlKey || event.keyCode === cmdKey) {\n            this.$svg.addClass('grabbable');\n        }\n    }\n\n    /**\n     * Process all keyup events that are connected to the app\n     * @param  {jquery.KeyboardEvent} event KeyboardEvent generated by a listener\n     */\n    onKeyUp(event) {\n        if (event.keyCode === ctrlKey || event.keyCode === cmdKey) {\n            this.$svg.removeClass('grabbable');\n        }\n    }\n\n    /**\n     * Process all mousedown events that are happening directly on the canvas\n     * @param  {jquery.MouseEvent} event MouseEvent generated by a listener\n     */\n    onMouseDown(event) {\n        // any click on canvas cancels the wire creation\n        this.cancelWireCreation();\n\n        // middle mouse or left mouse + ctrl moves the canvas\n        if (event.which === 2 || (event.which === 1 && event.ctrlKey)) {\n            this.$svg.addClass('grabbed');\n            this.moveCanvas = {\n                left: event.pageX,\n                top: event.pageY\n            };\n        }\n    }\n\n    /**\n     * Process all mousemove events that are happening directly on the canvas\n     * @param  {jquery.MouseEvent} event MouseEvent generated by a listener\n     */\n    onMouseMove(event) {\n        if (this.moveCanvas) {\n            let left = event.pageX - this.moveCanvas.left;\n            let top = event.pageY - this.moveCanvas.top;\n\n            this.viewbox.move(left, top);\n\n            this.applyViewbox();\n\n            this.moveCanvas = {\n                left: event.pageX,\n                top: event.pageY\n            };\n        }\n    }\n\n    /**\n     * Process all mouseup events that are happening directly on the canvas\n     */\n    onMouseUp() {\n        if (this.moveCanvas) {\n            this.$svg.removeClass('grabbed');\n            this.moveCanvas = undefined;\n\n            // if tutorial exists, call tutorial callback\n            if (this.tutorial) {\n                this.tutorial.onCanvasMoved();\n            }\n        }\n    }\n\n    /**\n     * Set the viewBox attribute of the SVG element and size and position attributes\n     * of the rectangle with the background grid to match the values in this.viewbox\n     */\n    applyViewbox() {\n        // adjust background\n        this.background.addAttr({\n            x: this.viewbox.left,\n            y: this.viewbox.top,\n            width: this.viewbox.width,\n            height: this.viewbox.height\n        });\n\n        // set the viewBox attribute\n        this.$svg.attr('viewBox', this.viewbox.str);\n    }\n\n    /**\n     * Get the current zoom multiplier of the canvas\n     * @return {number}\n     */\n    get zoom() {\n        return this.viewbox.zoom;\n    }\n\n    /**\n     * Set the zoom multiplier of the canvas.\n     * I sets the viewbox zoom and then applies the new value by calling this.applyViewbox()\n     * @param  {number} value set the zoom to this value\n     */\n    set zoom(value) {\n        this.viewbox.zoom = value;\n        this.applyViewbox();\n\n        // if tutorial exists, call tutorial callback\n        if (this.tutorial) {\n            this.tutorial.onCanvasZoomed();\n        }\n    }\n\n    /**\n     * start the tutorial\n     */\n    startTutorial() {\n        // instantiate the tutorial\n        this.tutorial = new Tutorial(this, () => {\n            // set userHasVisited to true when user closes (or finishes) the tutorial\n            localStorage.userHasVisited = true;\n\n            // unset the this.tutorial property\n            this.tutorial = undefined;\n        });\n\n        // start the tutorial\n        this.tutorial.start();\n    }\n\n    /**\n     * Generate an object containing export data for the canvas and all elements.\n     * Data from this function should cover all important information needed to import the\n     * network in a different session.\n     * @return {object} object containing infomration about the network\n     */\n    get exportData() {\n        this.exportWireIdMap = new Map();\n        this.exportWireId = 0;\n\n        let data = {\n            boxes: []\n        };\n\n        for (const box of this.boxes) {\n            data.boxes.push(box.exportData);\n        }\n\n        return data;\n    }\n\n    /**\n     * Recreate a logic network from the data provided\n     * @param  {object} data object containing information about the imported network\n     * @param  {number} [x]  horizontal position of the left top corner of the network in grid pixels\n     * @param  {number} [y]  vertical position of the left top corner of the network in grid pixels\n     */\n    importData(data, x, y) {\n        return new Promise(resolve => {\n            let warnings = [];\n\n            // if the x or y is undefined, set it to leftTopPadding instead\n            // (cannot use x || leftTopPadding because of 0)\n            x = x !== undefined ? x : this.leftTopPadding;\n            y = y !== undefined ? y : this.leftTopPadding;\n\n            this.simulationEnabled = false;\n\n            // list of wires to be added\n            let newWires = new Map();\n\n            // find the leftmost and topmost coordinate of any box, save them to leftTopCorner\n            let leftTopCorner = {\n                x: 0,\n                y: 0\n            };\n\n            for (const boxData of data.boxes) {\n                if (boxData.transform && boxData.transform.items) {\n                    for (const transformInfo of boxData.transform.items) {\n                        if (transformInfo.name === 'translate') {\n                            if (leftTopCorner) {\n                                leftTopCorner = {\n                                    x: Math.min(leftTopCorner.x, transformInfo.args[0]),\n                                    y: Math.min(leftTopCorner.y, transformInfo.args[1])\n                                };\n                            } else {\n                                leftTopCorner = {\n                                    x: transformInfo.args[0],\n                                    y: transformInfo.args[1]\n                                };\n                            }\n                        }\n                    }\n                }\n            }\n\n            for (let boxData of data.boxes) {\n                // mapping of dataBox.name of the objects that have category \"other\"\n                const otherMap = {\n                    input: () => this.newInput(0, 0, boxData.isOn, false),\n                    output: () => this.newOutput(0, 0, false)\n                };\n\n                // mapping of dataBox.category\n                const boxMap = {\n                    gate: () => this.newGate(boxData.name, 0, 0, false),\n                    blackbox: () =>\n                        this.newBlackbox(\n                            boxData.inputs,\n                            boxData.outputs,\n                            boxData.table,\n                            boxData.name,\n                            0,\n                            0,\n                            false\n                        ),\n                    other: () => {\n                        if (!boxData.name) throw `This network contains a box without a name.`;\n\n                        if (!otherMap[boxData.name])\n                            throw `This network contains unknown box names. (${boxData.name})`;\n\n                        return otherMap[boxData.name]();\n                    }\n                };\n\n                const createBox = () => {\n                    if (!boxData.category) throw `This network a box without a category.`;\n\n                    if (!boxMap[boxData.category])\n                        throw `This network contains unknown box categories. (${boxData.category})`;\n\n                    return boxMap[boxData.category]();\n                };\n\n                let box;\n\n                try {\n                    box = createBox();\n                } catch (e) {\n                    warnings.push(e);\n                }\n\n                if (box) {\n                    // proccess box transforms (translation and rotation)\n                    let transform = new editorElements.Transform();\n                    let rotationCount = 0;\n\n                    const transformItemMap = {\n                        translate: args => {\n                            transform.setTranslate(\n                                args[0] -\n                                leftTopCorner.x + // make it the relative distance from the leftmost element\n                                    x, // apply the position\n                                args[1] -\n                                leftTopCorner.y + // make it the relative distance from the topmost element\n                                    y // apply the position\n                            );\n                        },\n                        rotate: args => {\n                            rotationCount = (args[0] % 360) / 90;\n                        }\n                    };\n\n                    if (boxData.transform && boxData.transform.items) {\n                        for (const transformItem of boxData.transform.items) {\n                            const { name, args } = transformItem;\n\n                            if (!name) {\n                                warnings.push(\n                                    `This network contains unnamed transform properties.`\n                                );\n                                break;\n                            }\n\n                            if (!transformItemMap[name]) {\n                                warnings.push(\n                                    `This network contains unknown transform properties. (${\n                                        transformItem.name\n                                    })`\n                                );\n                                break;\n                            }\n\n                            transformItemMap[name](args);\n                        }\n                    }\n\n                    transform.toSVGPixels(this);\n                    box.setTransform(transform);\n\n                    for (let i = 0; i < rotationCount; ++i) {\n                        box.rotate(true);\n                    }\n\n                    // add all wires to the list of wires to be added\n                    if (boxData.connections) {\n                        for (const connection of boxData.connections) {\n                            // get the artificial wire id\n                            let wireId = connection.wireId;\n\n                            // pass the values got from json into a variable that will be added into the map\n                            let value = {\n                                index: connection.index,\n                                boxId: box.id\n                            };\n\n                            // add the value to the map\n                            if (newWires.has(wireId)) {\n                                // if there already is a wire with this id in the map,\n                                // add the value to the end of the array of values\n                                let mapValue = newWires.get(wireId);\n                                mapValue.push(value);\n                                newWires.set(wireId, mapValue);\n                            } else {\n                                // if there is no wire with this id in the map\n                                // add the wire and set the value to be the first element in the array\n                                newWires.set(wireId, [value]);\n                            }\n                        }\n                    }\n                }\n            }\n\n            // refresh the SVG document (needed for wiring)\n            this.refresh();\n\n            // with all boxes added, we can now connect them with wires\n\n            // priority queue for the new wires, priority being (1 / manhattanDistance) between the conenctors, higher is better\n            let wireQueue = new PriorityQueue();\n\n            // get all ids for lal the\n            for (const wireInfo of newWires.values()) {\n                let connectorIds = [];\n\n                // create an array [connector1Id, connector2Id]\n                for (const { boxId, index } of wireInfo) {\n                    connectorIds.push(this.getBoxById(boxId).connectors[index].id);\n                }\n\n                // create and array [{x, y}, {x, y}] containing positions for connectors 1 and 2\n                const connectorsPositions = connectorIds.map(connectorId =>\n                    this.getConnectorPosition(this.getConnectorById(connectorId), true)\n                );\n\n                if (connectorsPositions.length === 2) {\n                    let wire = this.newWire(...connectorIds, false, false);\n\n                    // get the manhattan distance between these two connectors\n                    const distance = manhattanDistance(...connectorsPositions);\n\n                    // add connectorids to the priority queue\n                    wireQueue.enqueue(wire, 1 / distance);\n                } else {\n                    warnings.push(\n                        `Found a wire that does not have two endings. (It had ${\n                            connectorsPositions.length\n                        } instead.)`\n                    );\n                }\n            }\n\n            if (window.Worker) {\n                let wirePoints = [];\n                let wireReferences = [];\n\n                // convert the queue to an array (this is needed by the web worker)\n                while (!wireQueue.isEmpty()) {\n                    const wire = wireQueue.dequeue();\n\n                    let wireStart = this.getConnectorPosition(wire.connection.from.connector, true);\n                    let wireEnd = this.getConnectorPosition(wire.connection.to.connector, true);\n\n                    wirePoints.push([\n                        {\n                            x: wireStart.x / this.gridSize,\n                            y: wireStart.y / this.gridSize\n                        },\n                        {\n                            x: wireEnd.x / this.gridSize,\n                            y: wireEnd.y / this.gridSize\n                        }\n                    ]);\n\n                    wireReferences.push(wire);\n                }\n\n                // [routeWorkerFileName] replaced in the build process (defined in gulpfile) depending on devel / prod build\n                let myWorker = new Worker('js/[routeWorkerFileName]');\n\n                let loadingMessage = this.messages.newLoadingMessage(\n                    'looking for the best wiring…'\n                );\n\n                myWorker.onmessage = event => {\n                    const { paths } = event.data;\n                    // iterate wireReferences and paths synchronously\n                    wireReferences.forEach((wire, key) => {\n                        wire.setWirePath(wire.pathToPolyLine(paths[key]));\n                        wire.updateWireState();\n                    });\n\n                    loadingMessage.hide();\n                };\n\n                const message = {\n                    wires: wirePoints,\n                    nonRoutableNodes: this.getNonRoutableNodes(),\n                    inconvenientNodes: this.getInconvenientNodes()\n                };\n\n                myWorker.postMessage(message);\n            } else {\n                // web worker is not supported: use an interval to make the import a bit slower\n                // by dividing it into chunks, so the browser window is not entirely frozen when the wiring is happening\n\n                const wiresToBeRoutedAtOnce = 10;\n                const delayBetweenIterations = 200;\n\n                // add wires in the order from short to long\n                let wirePlacingInterval = window.setInterval(() => {\n                    if (!wireQueue.isEmpty()) {\n                        for (let i = 0; i < wiresToBeRoutedAtOnce; ++i) {\n                            if (wireQueue.isEmpty()) {\n                                break;\n                            }\n\n                            const wire = wireQueue.dequeue();\n                            wire.routeWire(true, false);\n                            wire.updateWireState();\n                        }\n                    } else {\n                        console.log('finished');\n                        clearInterval(wirePlacingInterval);\n                    }\n                }, delayBetweenIterations);\n            }\n\n            // refresh the SVG document\n            this.refresh();\n\n            this.simulationEnabled = true;\n\n            resolve(warnings);\n        });\n    }\n\n    /**\n     * When user clicks on a connector, remember it until they click on some other connector.\n     * Than call newWire with the last two connectors ids as arguments.\n     * Visualize the process by displaying a grey wire between the first conenctor and the mouse pointer.\n     * @param  {string} connectorId id of the connector that the user clicked on\n     */\n    wireCreationHelper(connectorId, mousePosition) {\n        if (!this.wireCreation) {\n            this.wireCreation = {\n                fromId: connectorId\n            };\n\n            this.displayCreatedWire(mousePosition);\n        } else {\n            if (this.wireCreation.fromId !== connectorId) {\n                this.hideCreatedWire();\n\n                this.newWire(this.wireCreation.fromId, connectorId);\n\n                this.wireCreation = undefined;\n            }\n        }\n    }\n\n    /**\n     * helper for wireCreationHelper that displays a grey wire between the first connector and the specified mousePosition\n     * @param  {Object} mousePosition object with x and y coordinates in SVG pixels\n     */\n    displayCreatedWire(mousePosition) {\n        this.wireCreation.tempWire = new editorElements.HelperWire(\n            this,\n            this.wireCreation.fromId,\n            mousePosition\n        );\n\n        $(window).on('mousemove.wireCreation', event => {\n            event = this.viewbox.transformEvent(event);\n\n            mousePosition = {\n                x: event.pageX,\n                y: event.pageY\n            };\n\n            this.wireCreation.tempWire.updateMousePosition(mousePosition);\n        });\n\n        this.appendElement(this.wireCreation.tempWire);\n        this.moveToBackById(this.wireCreation.tempWire.id);\n    }\n\n    /**\n     * helper for wireCreationHelper that hides the temporary wire when wire creation is done\n     */\n    hideCreatedWire() {\n        $(window).off('mousemove.wireCreation');\n\n        this.wireCreation.tempWire.get().remove();\n        this.wireCreation.tempWire = undefined;\n    }\n\n    /**\n     * helper for wireCreationHelper that cancels the wire creation process\n     */\n    cancelWireCreation() {\n        if (this.wireCreation) {\n            this.hideCreatedWire();\n            this.wireCreation = undefined;\n        }\n    }\n\n    /**\n     * Run a logic simulation from the startingConnector.\n     * This refreshes the states of all elements in the network whose inputs are\n     * directly (or by transition) connected to startingConnector's output\n     * @param  {OutputConnector} startingConnector run simulation from this output connector\n     * @param  {Logic.state} state new state of the startingConnector\n     */\n    startNewSimulation(startingConnector, state) {\n        if (this.simulationEnabled) {\n            this.simulation = new Simulation(this);\n            this.simulation.notifyChange(startingConnector.id, state);\n            this.simulation.run();\n        }\n    }\n\n    /**\n     * Create a new gate on the specified position\n     * @param  {string}  name           type of the gate (and, or ...)\n     * @param  {number}  x              horizontal position of the gate in SVG pixels\n     * @param  {number}  y              vertical position of the gate in SVG pixels\n     * @param  {boolean} [refresh=true] if true, this.refresh() will be called after adding the gate\n     * @return {editorElements.Gate}    instance of Gate that has been newly added\n     */\n    newGate(name, x, y, refresh = true) {\n        return this.newBox(x, y, new editorElements.Gate(this, name, x, y), refresh);\n    }\n\n    /**\n     * Create an input box on the specified position\n     * @param  {number}  x              horizontal position of the gate in SVG pixels\n     * @param  {number}  y              vertical position of the gate in SVG pixels\n     * @param  {boolean} [isOn=false]   state of the input box (default is false (off))\n     * @param  {boolean} [refresh=true] if true, this.refresh() will be called after adding the input box\n     * @return {editorElements.InputBox}    instance of the InputBox that has been newly added\n     */\n    newInput(x, y, isOn = false, refresh = true) {\n        return this.newBox(x, y, new editorElements.InputBox(this, isOn), refresh);\n    }\n\n    /**\n     * Create an output box on the specified position\n     * @param  {number}  x              horizontal position of the gate in SVG pixels\n     * @param  {number}  y              vertical position of the gate in SVG pixels\n     * @param  {boolean} [refresh=true] if true, this.refresh() will be called after adding the output box\n     * @return {editorElements.InputBox}    instance of the OutputBox that has been newly added\n     */\n    newOutput(x, y, refresh = true) {\n        return this.newBox(x, y, new editorElements.OutputBox(this), refresh);\n    }\n\n    /**\n     * Add a new Box to the canvas\n     * @param  {number}  x              horizontal position of the box in SVG pixels\n     * @param  {number}  y              vertical position of the box in SVG pixels\n     * @param  {editorElements.Box}  object         instance of an object derived from the editorElements.Box class\n     * @param  {Boolean} [refresh=true] if true, this.refresh() will be called after adding the box\n     * @return {editorElements.Box}                 return the instance of the newly added object\n     */\n    newBox(x, y, object, refresh = true) {\n        let index = this.boxes.length;\n\n        this.boxes[index] = object;\n\n        // translate the gate if x and y has been specified\n        if (x && y) {\n            let tr = new editorElements.Transform();\n            tr.setTranslate(x, y);\n\n            this.boxes[index].svgObj.addAttr({ transform: tr.get() });\n        }\n\n        this.appendElement(this.boxes[index], refresh);\n\n        // if tutorial exists, call tutorial callback\n        if (this.tutorial) {\n            this.tutorial.onElementAdded(this.boxes[index].name);\n        }\n\n        return this.boxes[index];\n    }\n\n    /**\n     * Remove a box from canvas based on the provided ID\n     * @param {string} boxId id of the box that should be removed\n     */\n    removeBox(boxId) {\n        let $gate = $('#' + boxId);\n\n        // find the gate in svg's list of gates\n        let gateIndex = -1;\n        for (let i = 0; i < this.boxes.length; i++) {\n            if (this.boxes[i].svgObj.id === boxId) {\n                gateIndex = i;\n                break;\n            }\n        }\n\n        if (gateIndex > -1) {\n            // remove all wires connected to this gate\n            for (let i = 0; i < this.boxes[gateIndex].connectors.length; i++) {\n                this.removeWiresByConnectorId(this.boxes[gateIndex].connectors[i].id);\n            }\n\n            // remove the gate\n            this.boxes.splice(gateIndex, 1);\n            $gate.remove();\n\n            // if tutorial exists, call tutorial callback\n            if (this.tutorial) {\n                this.tutorial.onElementRemoved();\n            }\n        } else {\n            console.error('Trying to remove an nonexisting box. Box id:', boxId);\n        }\n    }\n\n    /**\n     * Remove all boxes from the canvas\n     */\n    cleanCanvas() {\n        // cannot simply iterate through the array because removeBox works with it\n\n        // create an array of ids\n        const ids = this.boxes.map(box => box.id);\n\n        // remove all boxes by their ids\n        for (const id of ids) {\n            this.removeBox(id);\n        }\n    }\n\n    /**\n     * Create a new wire connecting the provided connectors\n     * @param  {string}  fromId         id of the connector that the wire is attached to\n     * @param  {string}  toId           id of the connector that the wire is attached to\n     * @param  {Boolean} [refresh=true] if refresh is set to true, the SVG document will be reloaded after adding the wire\n     * @return {editorElements.Wire}    instance of editorElements.Wire that has been added to the canvas\n     */\n    newWire(fromId, toId, refresh = true, route = true) {\n        // wire must connect two distinct connectors\n        if (fromId === toId) return undefined;\n\n        let connectors = [this.getConnectorById(fromId), this.getConnectorById(toId)];\n\n        // input connectors can be connected to one wire max\n        connectors.forEach(conn => {\n            if (conn.isInputConnector) this.removeWiresByConnectorId(conn.id);\n        });\n        let index = this.wires.length;\n\n        try {\n            this.wires[index] = new editorElements.Wire(this, fromId, toId, refresh, route);\n        } catch (e) {\n            this.messages.newErrorMessage(e);\n            return undefined;\n        }\n\n        connectors.forEach(conn => {\n            conn.addWireId(this.wires[index].svgObj.id);\n        });\n\n        this.appendElement(this.wires[index], refresh);\n        this.moveToBackById(this.wires[index].svgObj.id);\n\n        if (refresh) this.wires[index].updateWireState();\n\n        return this.wires[index];\n    }\n\n    /**\n     * get the coordinates of the specified connector\n     * @param  {Connector}  connector      instance of {@link Connector}\n     * @param  {Boolean} [snapToGrid=true] if true, the connector position will be snapped to the grid\n     * @return {Object}                    point - object containing numeric attributes `x` and `y`\n     */\n    getConnectorPosition(connector, snapToGrid = true) {\n        // connector.svgObj.id has to be called, else the getCoordinates does not work on the first call in Firefox 55\n        const dummy = connector.svgObj.id; // eslint-disable-line no-unused-vars\n\n        let $connector = connector.svgObj.$el;\n\n        let position = $connector.position();\n\n        position.left = this.viewbox.transformX(position.left);\n        position.top = this.viewbox.transformY(position.top);\n\n        let width = $connector.attr('width');\n        let height = $connector.attr('height');\n\n        let x = position.left + width / 2;\n        let y = position.top + height / 2;\n        if (snapToGrid) {\n            x = this.snapToGrid(x);\n            y = this.snapToGrid(y);\n        }\n\n        return { x: x, y: y };\n    }\n\n    /**\n     * creates a new blackbox\n     * @param  {number} x       horizontal position of the blackbox in SVG pixels\n     * @param  {number} y       vertical position of the gate in SVG pixels\n     * @param  {number} inputs  number of input pins of this blackbox\n     * @param  {number} outputs number of output pins of this blackbox\n     * @param  {Array} table   Array of arrays, each inner array contains list of [Logic.state](./module-Logic.html#.state)s,\n     *                          that describe the combination of input pin and output pin states in the order from the top to bottom for both input and output connectors.\n     *                          If we had an AND array as a blackbox, one of the states could be `[Logic.state.on, Logic.state.off, Logic.state.off]`\n     *                          which means that if the first input connector is in the `on` state and the second connector is in the `off` state,\n     *                          the state of the output connector will be `off`.\n     *                          The array can be described as `[state for input conn 1, state for input conn 2, ..., state for output conn 1, state for output conn 2 ...]`.\n     * @param  {string}  name   a name that will be displayed on the blackbox\n     * @param  {boolean} [refresh=true] if true, this.refresh() will be called after adding the gate\n     *\n     * @return {editorElements.Blackbox} instance of {@link Blackbox} that has been added to the canvas\n     */\n    newBlackbox(inputs, outputs, table, name, x, y, refresh = true) {\n        const index = this.boxes.length;\n\n        this.boxes[index] = new editorElements.Blackbox(\n            this,\n            inputs,\n            outputs,\n            (...inputStates) => {\n                for (const line of table) {\n                    const lineInputStates = line.slice(0, inputs);\n\n                    // if every input state matches the corresponding input state in this line of the truth table\n                    if (inputStates.every((value, index) => value === lineInputStates[index])) {\n                        // return the rest of the line as output\n                        return line.slice(inputs);\n                    }\n                }\n                // if nothing matches, set all outputs to undefined\n                return Array.from(new Array(outputs), () => Logic.state.unknown);\n            },\n            name\n        );\n\n        if (x && y) {\n            let tr = new editorElements.Transform();\n            tr.setTranslate(x, y);\n\n            this.boxes[index].svgObj.addAttr({ transform: tr.get() });\n        }\n\n        this.appendElement(this.boxes[index], refresh);\n\n        return this.boxes[index];\n    }\n\n    /**\n     * Find the correct instance of editorElements.Wire in the app's wires by the provided id\n     * @param  {string} wireId id of the wire\n     * @return {editorElements.Wire} instance of the wire\n     */\n    getWireById(wireId) {\n        for (const wire of this.wires) {\n            if (wire.svgObj.id === wireId) {\n                return wire;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Find all wires that are connected to the specified connector\n     * @param  {string} connectorId id of the connector\n     * @return {Set} set of ID's of the wires connected to this connector\n     */\n    getWiresByConnectorId(connectorId) {\n        let connector = this.getConnectorById(connectorId);\n        return connector.wireIds;\n    }\n\n    /**\n     * Remove wire that has the provided ID\n     * @param  {string} wireId ID of the wire that should be removed\n     */\n    removeWireById(wireId) {\n        for (let i = 0; i < this.wires.length; ++i) {\n            if (this.wires[i].svgObj.id === wireId) {\n                let { connectors } = this.wires[i];\n\n                for (let connector of connectors) {\n                    connector.removeWireIdAndUpdate(wireId);\n                }\n\n                // start simulation from the input connector to\n                // refresh the network after this wire\n\n                let inputConnector = this.wires[i].connection.to.connector;\n                this.startNewSimulation(inputConnector, inputConnector.state);\n\n                this.wires[i].svgObj.$el.remove();\n                this.wires.splice(i, 1);\n\n                break;\n            }\n        }\n    }\n\n    /**\n     * Remove all wires that are connected to the connector provided by its ID\n     * @param  {string} connectorId ID of the connector\n     */\n    removeWiresByConnectorId(connectorId) {\n        let connector = this.getConnectorById(connectorId);\n\n        connector.wireIds.forEach(wireId => {\n            let wire = this.getWireById(wireId);\n\n            let { from, to } = wire.connection;\n\n            // get the other connector that is the wire connected to\n            let otherConnector = connectorId === from.id ? to.connector : from.connector;\n\n            // delete the wire record from the other connector\n            otherConnector.wireIds.delete(wireId);\n\n            // remove the wire representation using jQuery\n            $('#' + wireId).remove();\n\n            // if otherConnector is an input connector, set its state to unknown\n            if (otherConnector.isInputConnector) {\n                otherConnector.setState(Logic.state.unknown);\n                this.startNewSimulation(otherConnector, Logic.state.unknown);\n            }\n        });\n\n        // clear the list of wire Ids\n        connector.wireIds.clear();\n        // if connector is an input connector, set its state to unknown\n        if (connector.isInputConnector) {\n            connector.setState(Logic.state.unknown);\n            this.startNewSimulation(connector, Logic.state.unknown);\n        }\n    }\n\n    /**\n     * Find the correct instance of editorElements.Box in the app's boxes by the provided id\n     * @param  {string} boxId id of the box\n     * @return {editorElements.Box} instance of the box\n     */\n    getBoxById(boxId) {\n        for (let i = 0; i < this.boxes.length; i++) {\n            if (this.boxes[i].svgObj.id === boxId) {\n                return this.boxes[i];\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * Find the correct instance of editorElements.Box in the app's boxes by ID of a connector that belongs to this box\n     * @param  {string} boxId id of the connector\n     * @return {editorElements.Box} instance of the box\n     */\n    getBoxByConnectorId(connectorId) {\n        for (let i = 0; i < this.boxes.length; i++) {\n            if (this.boxes[i].getConnectorById(connectorId) !== undefined) {\n                return this.boxes[i];\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Get instance of a connector based on it's ID (and also on an instance of editorElements.Wire if provided)\n     *\n     * The wire variable is used as heuristic: When we know the wire, we have to check only\n     * two gates instead of all of them\n     * @param  {string} connectorId id of the connector\n     * @param  {editorElements.Wire} [wire]      instance of the Wire that is connected to this connector\n     * @return {editorElements.Connector}        instance of the connector\n     */\n    getConnectorById(connectorId, wire = undefined) {\n        if (wire !== undefined) {\n            // we know the wire -- we can check only gates at the ends of this wire\n            const { from, to } = wire.connection;\n\n            if (from.id === connectorId) return from.connector;\n\n            if (to.id === connectorId) return to.connector;\n        } else {\n            // we do not know the wire -- we have to check all gates\n            for (const box of this.boxes) {\n                const connector = box.getConnectorById(connectorId);\n                if (connector) {\n                    return connector;\n                }\n            }\n        }\n\n        return undefined;\n    }\n\n    /**\n     * Get the logical jQuery target based on the factual jQuery target.\n     *\n     * If the object, that user interacted with, is not a connector and is in a group,\n     * return the group jQuery object instead of the original jQuery object.\n     * @param  {target} target jQuery target of the object user interacted with\n     * @return {target}        jQuery target of the object user wanted to interact with\n     */\n    getRealJQueryTarget(target) {\n        let $target = $(target);\n        if (!$target.hasClass('connector') && $target.parents('g').length > 0) {\n            $target = $target.parent();\n            while ($target.prop('tagName') !== 'G' && $target.prop('tagName') !== 'g') {\n                $target = $target.parent();\n            }\n        }\n        return $target;\n    }\n\n    // returns the editorElement that user interacted with, the \"target\" argument is a jQuery element\n    /**\n     * Get instance of some object from editorElement based on the jQuery target\n     * @param  {target} target jQuery target that user interacted with\n     * @return {editorElements.NetworkElement} instance of an object derived from editorElements.NetworkElement that the user interacted with\n     */\n    getRealTarget(target) {\n        if (target === undefined) {\n            return undefined;\n        }\n\n        // eventy se museji zpracovat tady, protoze v SVG se eventy nepropaguji\n        let $target = $(target);\n\n        if ($target.hasClass('connector')) {\n            // this is a connector, don't traverse groups\n            return this.getConnectorById($target.attr('id'));\n        } else if ($target.parents('g').length > 0) {\n            // this element is in a group and it is not a connector\n\n            // traversing up the DOM tree until we find the closest group\n            let $parentGroup = $target.parent();\n            while ($parentGroup.prop('tagName') !== 'G' && $parentGroup.prop('tagName') !== 'g') {\n                $parentGroup = $parentGroup.parent();\n            }\n\n            // try to match the jQuery element to the logical element using DOM classes\n\n            if ($parentGroup.hasClass('box')) {\n                // return the corresponding box\n                return this.getBoxById($parentGroup.attr('id'));\n            } else if ($parentGroup.hasClass('wire')) {\n                // return the corresponding wire\n                return this.getWireById($parentGroup.attr('id'));\n            } else {\n                // found a group that contains the target, but this group does not match any known element types\n                return undefined;\n            }\n        } else {\n            // element does not match any known element types\n            return undefined;\n        }\n    }\n\n    /**\n     * Add an element to the canvas\n     * @param  {editorElements.NetworkElement}  element Element that will be added on the canvas\n     * @param  {Boolean} [refresh=true] if true, the SVG document will be reloaded after adding this element\n     */\n    appendElement(element, refresh = true) {\n        this.appendJQueryObject(element.get(), refresh);\n    }\n\n    /**\n     * Append a jQuery element to the SVG document (helper for this.appendElement)\n     * @param  {object}  object         jQuery element that will be added to the SVG document\n     * @param  {Boolean} [refresh=true] if true, the SVG document will be reloaded after adding this element\n     */\n    appendJQueryObject(object, refresh = true) {\n        this.$svg.append(object);\n        if (refresh) this.refresh();\n    }\n\n    /**\n     * Add a new pattern to the definitions element in the SVG document\n     * @param {svgObj.Pattern} pattern pattern that will be added to the <devs> element in the SVG document\n     */\n    addPattern(pattern) {\n        this.$defs.append(pattern);\n        this.refresh();\n    }\n\n    /**\n     * Reload the SVG document (needed to display a newly appended jQuery object)\n     */\n    refresh() {\n        this.$svg.html(this.$svg.html());\n        console.log('SVG document has been reloaded.');\n    }\n\n    /**\n     * Display the context menu on the specified position\n     * @param  {number} x       horizontal position in CSS pixels\n     * @param  {number} y       vertical position in CSS pixels\n     * @param  {jQuery.element} $target the item user clicked on (used to display \"remove this element\"-type items in the menu)\n     */\n    displayContextMenu(x, y, $target) {\n        this.contextMenu.display(x, y, $target);\n\n        // if tutorial exists, call tutorial callback\n        if (this.tutorial) {\n            this.tutorial.onContextMenuOpened();\n        }\n    }\n\n    /**\n     * hide the context menu\n     */\n    hideContextMenu() {\n        this.contextMenu.hide();\n    }\n\n    /**\n     * snap a value to a grid\n     * @param  {number} value value in SVG pixels\n     * @return {number}       the value rounded to the closest number divisible by the grid size\n     */\n    snapToGrid(value) {\n        return Math.round(value / this.gridSize) * this.gridSize;\n    }\n\n    /**\n     * convert grid pixels to SVG pixels\n     * @param  {number} value distance in grid pixels\n     * @return {number}       distance in SVG pixels\n     */\n    gridToSVG(value) {\n        return value * this.gridSize;\n    }\n\n    /**\n     * convert SVG pixels to grid pixels\n     * @param {number} value distance in SVG pixels\n     * @return {number}      distance in grud pixels\n     */\n    SVGToGrid(value) {\n        return value / this.gridSize;\n    }\n\n    /**\n     * static function for snapping a value to a grid\n     * @param  {number} value value in SVG pixels\n     * @param  {number} gridSize size of the grid in SVG pixels\n     * @return {number}       the value rounded to the closest number divisible by the grid size\n     */\n    static snapToGrid(value, gridSize) {\n        return Math.round(value / gridSize) * gridSize;\n    }\n\n    /**\n     * move an element to the front in the canvas\n     * @param  {string} objId id of the element\n     */\n    moveToFrontById(objId) {\n        this.$svg.append($('#' + objId));\n    }\n\n    /**\n     * move an element to the back in the canvas\n     * @param  {string} objId id of the element\n     */\n    moveToBackById(objId) {\n        $('#' + this.background.id).after($('#' + objId));\n    }\n\n    /**\n     * get set of nodes, that cannot be used for wiring at any circumstances\n     * @return {Set} set of nodes (objects containing x and y coordinates) that are not suitable for wiring\n     */\n    getNonRoutableNodes() {\n        let blockedNodes = new Set();\n        // for each box\n        for (const box of this.boxes) {\n            const translate = box.getGridPixelTransform().getTranslate();\n\n            // for each item in blockedNodes (set of blocked nodes with coordinates relative\n            // to the left upper corner of rect; unit used is \"one gridSize\") convert the coordinates\n            // to absolute (multiple with gridSize and add position of rect) and add the result to the set\n            for (const node of box.blockedNodes) {\n                blockedNodes.add({\n                    x: translate.x + node.x,\n                    y: translate.y + node.y\n                });\n            }\n        }\n\n        // FOR DEBUG ONLY: display the non routable nodes\n        /*\n\n        if(this.nodeDisplay) {\n            for (const rectangleId of this.nodeDisplay) {\n                $(`#${rectangleId}`).remove();\n            }\n        }\n\n        this.nodeDisplay = [];\n\n        let first = true;\n\n        for (const node of blockedNodes) {\n            const x = this.gridToSVG(node.x);\n            const y = this.gridToSVG(node.y);\n\n            const w = 4;\n            const p = w / 2;\n\n            const nodeRectangle = new Rectangle(x - p, y - p, w, w, first ? \"blue\" : \"red\", \"none\")\n            this.nodeDisplay.push(nodeRectangle.id);\n            this.appendElement(nodeRectangle, false);\n\n            first = false;\n        }\n\n        this.refresh();\n\n        // */\n        // END FOR DEBUG ONLY\n\n        // return the set\n        return blockedNodes;\n    }\n\n    /**\n     * get set of nodes, that are inconvenient for wiring, but can be used, just are not preferred\n     * @return {Set} set of nodes (objects containing x and y coordinates) that are not preferred for wiring\n     */\n    getInconvenientNodes(ignoreWireId) {\n        let inconvenientNodes = new Set();\n        // for each wire\n\n        for (const wire of this.wires) {\n            if (ignoreWireId === undefined || ignoreWireId !== wire.id) {\n                if (wire.inconvenientNodes) {\n                    for (const node of wire.inconvenientNodes) {\n                        inconvenientNodes.add(node);\n                    }\n                }\n            }\n        }\n\n        // FOR DEBUG ONLY: display the inconvenient nodes\n        /*\n\n        if(this.inconvenientNodeDisplay) {\n            for (const rectangleId of this.inconvenientNodeDisplay) {\n                $(`#${rectangleId}`).remove();\n            }\n        }\n\n        this.inconvenientNodeDisplay = [];\n\n        for (const node of inconvenientNodes) {\n            const x = this.gridToSVG(node.x);\n            const y = this.gridToSVG(node.y);\n\n            const w = 4;\n            const p = w / 2;\n\n            const nodeRectangle = new Rectangle(x - p, y - p, w, w, \"orange\", \"none\")\n            this.inconvenientNodeDisplay.push(nodeRectangle.id);\n            this.appendElement(nodeRectangle, false);\n        }\n\n        this.refresh();\n\n        // */\n        // END FOR DEBUG ONLY\n\n        // return the set\n        return inconvenientNodes;\n    }\n}\n","/** @module Logic */\n/**\n * definitions of logic states and basic logic functions used in the simulation\n */\nexport default class Logic {\n    /**\n     * Enum for logic states.\n     *\n     * States:\n     * - `off`\n     * - `on`\n     * - `unknown`\n     * - `oscillating`\n     * @type {Number}\n     */\n    static get state() {\n        return {\n            off: 0,\n            on: 1,\n            unknown: 2,\n            oscillating: 3\n        };\n    }\n\n    /**\n     * list of all states that can be used in the simulation\n     *\n     * This getter iterates over Logic.state and returns an array containing all values of Logic.state's members\n     * @type {Array}\n     */\n    static get stateList() {\n        let states = [];\n\n        // iterate over all defined states and add their values to the states array\n        Object.keys(Logic.state).forEach(key => {\n            states.push(Logic.state[key]);\n        });\n\n        return states;\n    }\n\n    /**\n     * Logic AND\n     * @param  {Logic.state} a first input state\n     * @param  {Logic.state} b second input state\n     * @return {Logic.state}   output state\n     */\n    static and(a, b) {\n        return Logic.runSymmetricRules(a, b, [\n            [Logic.state.on, Logic.state.on, Logic.state.on],\n            [Logic.state.on, Logic.state.off, Logic.state.off],\n            [Logic.state.on, Logic.state.unknown, Logic.state.unknown],\n            [Logic.state.on, Logic.state.oscillating, Logic.state.oscillating],\n\n            [Logic.state.off, Logic.state.off, Logic.state.off],\n            [Logic.state.off, Logic.state.unknown, Logic.state.off],\n            [Logic.state.off, Logic.state.oscillating, Logic.state.off],\n\n            [Logic.state.unknown, Logic.state.unknown, Logic.state.unknown],\n            [Logic.state.unknown, Logic.state.oscillating, Logic.state.unknown],\n\n            [Logic.state.oscillating, Logic.state.oscillating, Logic.state.oscillating]\n        ]);\n    }\n    /**\n     * Logic NAND\n     * @param  {Logic.state} a first input state\n     * @param  {Logic.state} b second input state\n     * @return {Logic.state}   output state\n     */\n    static nand(a, b) {\n        return Logic.not(Logic.and(a, b));\n    }\n\n    /**\n     * Logic NOR\n     * @param  {Logic.state} a first input state\n     * @param  {Logic.state} b second input state\n     * @return {Logic.state}   output state\n     */\n    static nor(a, b) {\n        return Logic.not(Logic.or(a, b));\n    }\n\n    /**\n     * Logic NOT\n     * @param  {Logic.state} a first input state\n     * @return {Logic.state}   output state\n     */\n    static not(a) {\n        if (a === Logic.state.on) {\n            return Logic.state.off;\n        } else if (a === Logic.state.off) {\n            return Logic.state.on;\n        } else {\n            return a;\n        }\n    }\n\n    /**\n     * Logic OR\n     * @param  {Logic.state} a first input state\n     * @param  {Logic.state} b second input state\n     * @return {Logic.state}   output state\n     */\n    static or(a, b) {\n        return Logic.runSymmetricRules(a, b, [\n            [Logic.state.on, Logic.state.on, Logic.state.on],\n            [Logic.state.on, Logic.state.off, Logic.state.on],\n            [Logic.state.on, Logic.state.unknown, Logic.state.on],\n            [Logic.state.on, Logic.state.oscillating, Logic.state.on],\n\n            [Logic.state.off, Logic.state.off, Logic.state.off],\n            [Logic.state.off, Logic.state.unknown, Logic.state.unknown],\n            [Logic.state.off, Logic.state.oscillating, Logic.state.oscillating],\n\n            [Logic.state.unknown, Logic.state.unknown, Logic.state.unknown],\n            [Logic.state.unknown, Logic.state.oscillating, Logic.state.unknown],\n\n            [Logic.state.oscillating, Logic.state.oscillating, Logic.state.oscillating]\n        ]);\n    }\n\n    /**\n     * Logic XNOR\n     * @param  {Logic.state} a first input state\n     * @param  {Logic.state} b second input state\n     * @return {Logic.state}   output state\n     */\n    static xnor(a, b) {\n        return Logic.not(Logic.xor(a, b));\n    }\n\n    /**\n     * Logic XOR\n     * @param  {Logic.state} a first input state\n     * @param  {Logic.state} b second input state\n     * @return {Logic.state}   output state\n     */\n    static xor(a, b) {\n        return Logic.runSymmetricRules(a, b, [\n            [Logic.state.on, Logic.state.on, Logic.state.off],\n            [Logic.state.on, Logic.state.off, Logic.state.on],\n            [Logic.state.on, Logic.state.unknown, Logic.state.unknown],\n            [Logic.state.on, Logic.state.oscillating, Logic.state.oscillating],\n\n            [Logic.state.off, Logic.state.off, Logic.state.off],\n            [Logic.state.off, Logic.state.unknown, Logic.state.unknown],\n            [Logic.state.off, Logic.state.oscillating, Logic.state.oscillating],\n\n            [Logic.state.unknown, Logic.state.unknown, Logic.state.unknown],\n            [Logic.state.unknown, Logic.state.oscillating, Logic.state.unknown],\n\n            [Logic.state.oscillating, Logic.state.oscillating, Logic.state.oscillating]\n        ]);\n    }\n\n    /**\n     * Finds the correct rule in the array of rules and returns the corresponding return value.\n     * This function expects rules to be symmetric (so `a RULE b` should returns the same value as `b RULE a`),\n     * which allows to cut down on the `rules` array quite a bit\n     * @param  {Logic.state} a     first input state\n     * @param  {Logic.state} b     second input state\n     * @param  {Array} rules       Array of arrays. Each inner array represents a rule in the format [input1, input2, output].\n     *                             The function finds an array, where `a === input1` and `b === input1` (or `a === input2` and `b === input1`)\n     *                             and returns `output` from this array.\n     * @return {Logic.state}       output state\n     */\n    static runSymmetricRules(a, b, rules) {\n        // iterate through all the rules\n        for (const rule of rules) {\n            if ((rule[0] === a && rule[1] === b) || (rule[0] === b && rule[1] === a)) {\n                return rule[2];\n            }\n        }\n\n        // if no rule matches, the output state is unknown\n        return Logic.state.unknown;\n    }\n}\n","import Logic from './Logic';\n\n/**\n * @module Simulation\n */\n\nclass stateChange {\n    constructor(connectorId, state, whoCausedIt) {\n        this.connectorId = connectorId;\n        this.state = state;\n        this.whoCausedIt = whoCausedIt;\n    }\n}\n\n/**\n * This is a dummy that does nothing, just logs the function calls.\n *\n * Used on networks that has not been yet simulated but user tries to change logic values.\n */\nexport class SimulationDummy {\n    notifyChange() {\n        console.log('SimulationDummy.notifyChange() has been called.');\n    }\n\n    run() {\n        console.log('SimulationDummy.run() has been called.');\n    }\n}\n\n/**\n * This class runs the network simulation.\n *\n * _note: all connectors that are used in this class are **output connectors**_\n */\nexport default class Simulation {\n    /**\n     * @param {App} appInstance instance of [App](./module-App.html)\n     */\n    constructor(appInstance) {\n        /**\n         * instance of App this Simulation belongs to\n         * @type {App}\n         */\n        this.appInstance = appInstance;\n\n        /**\n         * maps each affected output connector to it's directly preceeding output connectors\n         * @type {Map}\n         */\n        this.predecessors = new Map();\n\n        /**\n         * maps waveId to an array of affected outputConnectors\n         * @type {Map}\n         */\n        this.waves = new Map();\n        this.wave = 0;\n\n        /**\n         * maps cycled connector id to set of states this connector was in\n         * @type {Map}\n         */\n        this.cycledConnectors = new Map();\n\n        /**\n         * set of cycled connectors that have been already resolved\n         * @type {Set}\n         */\n        this.resolvedCycledConnectors = new Set();\n    }\n\n    /**\n     * run the simulation\n     */\n    run() {\n        this.wave++;\n        while (this.waves.has(this.wave)) {\n            this.step();\n            this.waves.delete(this.wave); // clean old waves on the go\n            this.wave++;\n        }\n    }\n\n    /**\n     * one step/wave of the simulation\n     *\n     * determines states of the connectors in the current wave, detects cycles\n     */\n    step() {\n        for (let { connectorId, state, whoCausedIt } of this.waves.get(this.wave)) {\n            // skip resolved cycles\n            if (this.resolvedCycledConnectors.has(connectorId)) {\n                continue;\n            }\n\n            // skip connector that are cycles\n            if (this.cycledConnectors.has(connectorId)) {\n                // get the set of states that this connector appeared from the moment the signal first cycled\n                let states = this.cycledConnectors.get(connectorId);\n\n                // if the connector already had this state in this cycle, resolve the cycle\n                if (states.has(state)) {\n                    // if there are more states in the set, the connector is oscillating\n                    // (else it keeps its state and we just break the cycle)\n                    if (states.size > 1) {\n                        state = Logic.state.oscillating;\n                    }\n\n                    // mark this connector as resolved\n                    this.resolvedCycledConnectors.add(connectorId);\n\n                    // this is a new, unseen state, add it to the set and continue simulating the cycle\n                } else {\n                    states.add(state);\n                }\n\n                // map the modified set of states to the connector\n                this.cycledConnectors.set(connectorId, states);\n            }\n\n            this.whoCausedIt = connectorId;\n            /*  process all outputConnectors by setting their state\n                this will trigger a following event chain:\n                    outputConnector changes\n                    -> all connected wires change\n                    -> all inputConnectors connected to these wires change\n                    -> all elements that contain these inputConnectors change\n                    -> these elements compute the new state of their output connectors and call notifyChange()\n            */\n\n            if (whoCausedIt) {\n                this.addPredecessor(connectorId, whoCausedIt);\n            }\n\n            if (\n                !this.cycledConnectors.has(connectorId) &&\n                this.getAllPredecessors(connectorId).has(connectorId)\n            ) {\n                this.cycledConnectors.set(connectorId, new Set([state]));\n            }\n\n            // reflect the changes in SVG\n            let connector = this.appInstance.getConnectorById(connectorId);\n            if (connector) {\n                connector.setState(state);\n            }\n        }\n        this.whoCausedIt = undefined;\n    }\n\n    /**\n     * mark a predecessorConnectorId as a predecessor of connectorId\n     * @param {string} connectorId ID of a connector\n     * @param {string} predecessorConnectorId predecessor of `connectorId`\n     */\n    addPredecessor(connectorId, predecessorConnectorId) {\n        if (!this.predecessors.has(connectorId)) {\n            this.predecessors.set(connectorId, new Set());\n        }\n\n        this.predecessors.get(connectorId).add(predecessorConnectorId);\n    }\n\n    /**\n     * get set of all output connectors that are before this output connector\n     * @param  {string} connectorId ID of a connector\n     * @return {Set}                set of connector ids that are before this output connector\n     */\n    getAllPredecessors(connectorId) {\n        if (!this.predecessors.has(connectorId)) {\n            this.predecessors.set(connectorId, new Set());\n        }\n\n        let all = new Set();\n\n        this.predecessors.get(connectorId).forEach(all.add, all);\n\n        let prevSize = 0;\n        let size = all.size;\n        while (prevSize < size) {\n            for (let connector of all) {\n                if (this.predecessors.has(connector)) {\n                    this.predecessors.get(connector).forEach(all.add, all);\n                }\n            }\n            prevSize = size;\n            size = all.size;\n        }\n\n        return all;\n    }\n\n    /**\n     * Notify a change in the network. This function adds the changed connector to the next wave\n     * @param  {string} connectorId ID of the changed connector\n     * @param  {Logic.state} state  new [Logic.state](./module-Logic.html#.state) of the connector\n     */\n    notifyChange(connectorId, state) {\n        let waveId = this.wave + 1;\n\n        if (!this.waves.has(waveId)) {\n            this.waves.set(waveId, []);\n        }\n\n        this.waves.get(waveId).push(new stateChange(connectorId, state, this.whoCausedIt));\n    }\n}\n","/** @module editorElements */\n\n// transform\nexport { default as Transform } from './editorElements/Transform';\n\n// connectors\nexport { default as InputConnector } from './editorElements/InputConnector';\nexport { default as OutputConnector } from './editorElements/OutputConnector';\n\n// boxes\nexport { default as InputBox } from './editorElements/InputBox';\nexport { default as OutputBox } from './editorElements/OutputBox';\nexport { default as Gate } from './editorElements/Gate';\nexport { default as Blackbox } from './editorElements/Blackbox';\n\n// helper wire\nexport { default as HelperWire } from './editorElements/HelperWire';\n\n// wire\nexport { default as Wire } from './editorElements/Wire';\n","import {\n    Group,\n    Rectangle,\n    MultiLineText,\n    PolyLine,\n    PolyLinePoints,\n    PolyLinePoint\n} from '../svgObjects';\nimport Logic from '../Logic';\n\nimport Box from './Box';\n\n/** @module editorElements.Blackbox */\n\n/**\n * Blackbox is a box that is defined by its evaluation function\n * @extends Box\n */\nexport default class Blackbox extends Box {\n    /**\n     * @param {App} appInstance  instance of [App](./module-App.html)\n     * @param {number} inputConnectors  number of input connectors\n     * @param {number} outputConnectors number of output connectors\n     * @param {Function} evalFunction   function that takes `inputConnectors` [Logic.state](./module-Logic.html#.state)s\n     *                                  and returns `outputConnectors` Logic.states.\n     * @param {String} [name]        name that will be displayed on the blackbox\n     */\n    constructor(appInstance, inputConnectors, outputConnectors, evalFunction, name = '') {\n        const width = 11;\n        const height = Math.max(inputConnectors, outputConnectors) * 2;\n\n        super(appInstance, name, 'blackbox', width, height);\n\n        const connectorPinLenght = 2.5 * this.gridSize;\n\n        // override default svgObj structure\n        this.svgObj = new Group();\n\n        // transparent background rectangle\n        let hitbox = new Rectangle(0, 0, this.width, this.height, 'none', 'none');\n        hitbox.$el.addClass('rect');\n\n        this.svgObj.addChild(hitbox);\n\n        // main rectangle\n        const bodyWidth = this.width - 2 * connectorPinLenght;\n\n        let rectangle = new Rectangle(\n            connectorPinLenght,\n            0,\n            bodyWidth,\n            this.height,\n            'white',\n            'black'\n        );\n        rectangle.addAttr({ 'stroke-width': '2.5' });\n        rectangle.$el.addClass('rect');\n\n        this.svgObj.addChild(rectangle);\n\n        // text description of the box\n        const textWidth = bodyWidth - this.gridSize;\n        const textHeight = this.height - this.gridSize;\n        let text = new MultiLineText(\n            (this.width - textWidth) / 2, // horizontal centering\n            (this.height - textHeight) / 2, // vertical centering\n            textWidth,\n            textHeight,\n            name.toUpperCase(),\n            this.gridSize * 1.2\n        );\n        this.svgObj.addChild(text);\n\n        // add input connectors\n        for (let i = 0; i < inputConnectors; ++i) {\n            const gridPosition = i * 2 + 1;\n            const pixelPosition = gridPosition * this.gridSize;\n\n            let pin = new PolyLine(\n                new PolyLinePoints([\n                    new PolyLinePoint(0, pixelPosition),\n                    new PolyLinePoint(connectorPinLenght, pixelPosition)\n                ]),\n                1,\n                'black'\n            );\n\n            this.svgObj.addChild(pin);\n\n            // add the connector\n            this.addInputConnector(0, gridPosition);\n        }\n\n        // add output connectors\n        for (let i = 0; i < outputConnectors; ++i) {\n            const gridPosition = i * 2 + 1;\n            const pixelPosition = gridPosition * this.gridSize;\n\n            let pin = new PolyLine(\n                new PolyLinePoints([\n                    new PolyLinePoint(this.width - connectorPinLenght, pixelPosition),\n                    new PolyLinePoint(this.width, pixelPosition)\n                ]),\n                1,\n                'black'\n            );\n\n            this.svgObj.addChild(pin);\n\n            this.addOutputConnector(width, gridPosition);\n        }\n\n        this.svgObj.$el.addClass('box');\n\n        /**\n         * function that takes `inputConnectors` [Logic.state](./module-Logic.html#.state)s\n         * and returns `outputConnectors` Logic.states.\n         */\n        this.evalFunction = evalFunction;\n\n        // regenerate the blocked nodes after adding all the connectors\n        this.generateBlockNodes();\n    }\n\n    /**\n     * get data of this blackbox as a JSON-ready object\n     * @return {Object} javascript object containing essential data for this blackbox\n     */\n    get exportData() {\n        let data = super.exportData;\n        data.inputs = this.inputConnectors.length;\n        data.outputs = this.outputConnectors.length;\n\n        // generate the truth table\n\n        data.table = [];\n\n        // array of tested input states\n        const stateList = Logic.stateList;\n\n        // recursive function that generates all possible inputs\n        const getPermutations = length => {\n            let permutations = [];\n            switch (length) {\n                case 0:\n                    return [];\n                case 1:\n                    for (const state of stateList) {\n                        permutations.push([state]);\n                    }\n                    return permutations;\n                default:\n                    for (const state of stateList) {\n                        for (const perm of getPermutations(length - 1)) {\n                            permutations.push([state, ...perm]);\n                        }\n                    }\n                    return permutations;\n            }\n        };\n\n        // generate outputs for all the possible inputs\n        for (const inputValues of getPermutations(data.inputs)) {\n            const outputValues = this.evalFunction(...inputValues);\n\n            // if there is an output value that is not Logic.state.unknown, add this line to the\n            // truthtable, otherwise don't add it (if all output values are Logic.state.unknown,\n            // the input combination does not have to be defines, because Logic.state.unknown is the default value)\n            if (\n                outputValues.reduce((accumulator, current) => {\n                    return accumulator || current !== Logic.state.unknown;\n                })\n            ) {\n                data.table.push([...inputValues, ...outputValues]);\n            }\n        }\n\n        return data;\n    }\n\n    /**\n     * proccess the input connector states and reflect them in the output connector states according\n     * to the logic defined by this.evalFunction\n     */\n    refreshState() {\n        const inputStates = this.inputConnectors.map(conn => conn.state);\n        // call the evalFunction to get the output states\n        const outputStates = this.evalFunction(...inputStates);\n\n        // apply the outputStates to the outputConnectors\n        for (let i = 0; i < outputStates.length; ++i) {\n            this.outputConnectors[i].setState(outputStates[i]);\n        }\n    }\n\n    generateBlockNodes() {\n        // add blocked nodes on the connectors and between them as well\n\n        let specialNodes = [];\n        for (let i = 1; i < this.inputConnectors.length * 2; ++i) {\n            specialNodes.push({\n                x: 0,\n                y: i\n            });\n        }\n        for (let i = 1; i < this.outputConnectors.length * 2; ++i) {\n            specialNodes.push({\n                x: this.gridWidth,\n                y: i\n            });\n        }\n\n        super.generateBlockNodes(0, 1, 0, 1, ...specialNodes);\n    }\n}\n","import { Group, Rectangle, SvgImage } from '../svgObjects';\n\nimport NetworkElement from './NetworkElement';\nimport InputConnector from './InputConnector';\nimport OutputConnector from './OutputConnector';\nimport Transform from './Transform';\n\n/** @module editorElements.Box */\n\n/**\n * Parent class for gates and input and output boxes. Defines all the factors\n * that the boxes have in common (svgObj structure, draggability and rotatability...)\n * @extends NetworkElement\n */\nexport default class Box extends NetworkElement {\n    /**\n     * @param {App} appInstance  instance of [App](./module-App.html)\n     * @param {string} name       name of the element (input, output, and, or, xor...)\n     * @param {string} category   type of the element (io, gate)\n     * @param {number} gridWidth  width of the element in grid pixels\n     * @param {number} gridHeight height of the element in grid pixels\n     */\n    constructor(appInstance, name, category, gridWidth, gridHeight) {\n        super(appInstance);\n\n        /**\n         * specifies the box type within the category (input/output in io, and/or/... in gate)\n         * @type {string}\n         */\n        this.name = name;\n\n        /**\n         * specifies the box category (io for input or output, gate for logic gates)\n         * @type {string}\n         */\n        this.category = category;\n\n        /**\n         * size of the grid in SVG pixels\n         * @type {number}\n         */\n        this.gridSize = this.appInstance.gridSize;\n\n        /**\n         * array of connectors of this box\n         * @type {Array}\n         */\n        this.connectors = [];\n\n        /**\n         * svgObj containing all SVG data used to display this box\n         * @type {svgObj}\n         */\n        this.svgObj = new Group();\n\n        /**\n         * width of this element in SVG pixels\n         * @type {number}\n         */\n        this.width = gridWidth * this.gridSize;\n        /**\n         * height of this element in SVG pixels\n         * @type {number}\n         */\n        this.height = gridHeight * this.gridSize;\n\n        /**\n         * width of this element in grid pixels\n         * @type {number}\n         */\n        this.gridWidth = gridWidth;\n        /**\n         * height of this element in grid pixels\n         * @type {number}\n         */\n        this.gridHeight = gridHeight;\n\n        // transparent background rectangle\n        let rectangle = new Rectangle(0, 0, this.width, this.height, 'none', 'none');\n        rectangle.$el.addClass('rect');\n\n        this.svgObj.addChild(rectangle);\n\n        // image of the element\n        this.image = new SvgImage(0, 0, this.width, this.height, this.url);\n        this.svgObj.addChild(this.image);\n\n        // add type=\"gate\", used in special callbacks in contextmenu\n        this.svgObj.addAttr({ type: category });\n\n        this.svgObj.$el.addClass('box');\n        this.svgObj.$el.addClass(category);\n    }\n\n    /**\n     * url of the image depicting this object\n     * @type {string}\n     */\n    get url() {\n        const category = this.category || '',\n            name = this.name || '',\n            suffix = this.imgSuffix || '';\n\n        return `img/svg/${category}/${name}${suffix}.svg`;\n    }\n\n    /**\n     * get all input connectors of this box\n     * @return {Array} array of input connectors\n     */\n    get inputConnectors() {\n        return this.connectors.filter(conn => conn.isInputConnector);\n    }\n\n    /**\n     * get all output connectors of this box\n     * @return {Array} array of output connectors\n     */\n    get outputConnectors() {\n        return this.connectors.filter(conn => conn.isOutputConnector);\n    }\n\n    /**\n     * get data of this box as a JSON-ready object\n     * @return {Object} javascript object containing essential data for this box\n     */\n    get exportData() {\n        let connections = [];\n\n        // go through all connectors\n        let counter = 0;\n        for (const conn of this.connectors) {\n            // go through each its wire id\n            for (const item of conn.wireIds) {\n                let thisWireId;\n                if (!this.appInstance.exportWireIdMap.has(item)) {\n                    // if the wire id is not in the map, add it and assign new arbitrary id\n                    this.appInstance.exportWireIdMap.set(item, this.appInstance.exportWireId);\n                    thisWireId = this.appInstance.exportWireId;\n                    this.appInstance.exportWireId++;\n                } else {\n                    // else get id from the map\n                    thisWireId = this.appInstance.exportWireIdMap.get(item);\n                }\n\n                // add this connection to the list\n                connections[connections.length] = {\n                    index: counter,\n                    type: conn.type,\n                    wireId: thisWireId\n                };\n            }\n            counter++;\n        }\n\n        return {\n            name: this.name,\n            category: this.category,\n            transform: this.getTransform(true),\n            connections: connections\n        };\n    }\n\n    /**\n     * get set of nodes that are not suitable for wire routing\n     * @param  {Number} [marginTop=0]    top margin of the element (distance from the element that should be also blocked)\n     * @param  {Number} [marginRight=0]  right margin of the element\n     * @param  {Number} [marginBottom=0] bottom margin of the element\n     * @param  {Number} [marginLeft=0]   left margin of the element\n     * @param  {Number} specialNodes     additional nodes that should be added to the set\n     * @return {Set}                     set of not suitable nodes\n     */\n    generateBlockNodes(\n        marginTop = 0,\n        marginRight = 0,\n        marginBottom = 0,\n        marginLeft = 0,\n        ...specialNodes\n    ) {\n        this.blockedNodes = new Set();\n        for (let x = marginLeft; x <= this.gridWidth - marginRight; x++) {\n            for (let y = marginTop; y <= this.gridHeight - marginBottom; y++) {\n                this.blockedNodes.add({\n                    x: x,\n                    y: y\n                });\n            }\n        }\n\n        for (let node of specialNodes) {\n            this.blockedNodes.add(node);\n        }\n    }\n\n    /**\n     * empty function, redefined in inherited elements\n     * refreshState takes input connector values and sets output values accordingly\n     */\n    refreshState() {\n        console.warn('Calling the virtual function refreshState has no effect.');\n    }\n\n    /**\n     * change image to another one that ends with a specified suffix\n     *\n     * *usage:* `changeImage(\"abc\")` changes image url to `image-abc.svg`,\n     * `changeImage()` changes image url to the default one (`image.svg`)\n     * @param  {string} [suffix] new suffix for the image\n     */\n    changeImage(suffix) {\n        if (suffix === undefined || suffix === '') {\n            this.imgSuffix = '';\n        } else {\n            this.imgSuffix = '-' + suffix;\n        }\n\n        this.image.changeUrl(this.url);\n    }\n\n    /**\n     * get a jQuery element representing this box\n     * @return {jQuery.element}\n     */\n    get() {\n        return this.svgObj.get();\n    }\n\n    /**\n     * rotate the set of blocked nodes by 90 degrees to the right or to the left, depending on the parameter\n     *\n     * used to rotate the nodes when the object itself is rotated\n     * @param  {boolean} right rotate clockwise if true, counterclockwise if false\n     */\n    rotateBlockedNodes(center, right) {\n        if (this.rotationParity === undefined) {\n            this.rotationParity = false;\n        }\n\n        this.rotationParity = !this.rotationParity;\n\n        let newBlockedNodes = new Set();\n\n        // rotate the node\n        console.log('center:', center);\n\n        for (const node of this.blockedNodes) {\n            let newNode;\n\n            const parityFactor = this.rotationParity ? 1 : -1;\n\n            if (right) {\n                newNode = {\n                    x: -node.y + this.gridHeight + (center.x - center.y) * parityFactor,\n                    y: node.x + (center.y - center.x) * parityFactor\n                };\n            } else {\n                newNode = {\n                    x: node.y + (center.x - center.y) * parityFactor\n                };\n\n                if (this.rotationParity) {\n                    newNode.y =\n                        -node.x +\n                        this.gridWidth +\n                        (this.gridHeight - center.y - (this.gridWidth - center.x));\n                } else {\n                    newNode.y = -node.x + this.gridHeight + (center.y - center.x);\n                }\n            }\n\n            newBlockedNodes.add(newNode);\n        }\n\n        this.blockedNodes = newBlockedNodes;\n    }\n\n    /**\n     * rotate the set of blocked nodes to the right\n     *\n     * used to rotate the nodes when the object itself is rotated\n     */\n    rotateBlockedNodesRight(center) {\n        this.rotateBlockedNodes(center, true);\n    }\n\n    /**\n     * rotate the set of blocked nodes to the right\n     *\n     * used to rotate the nodes when the object itself is rotated\n     */\n    rotateBlockedNodesLeft(center) {\n        this.rotateBlockedNodes(center, false);\n    }\n\n    rotate(clockWise) {\n        // get the transform value for this box and convert it to grid pixels\n        // (so we don't have to convert between SVG and grid pixels manually)\n        let transform = this.getTransform();\n        transform.toGridPixels(this.appInstance);\n\n        // calculate the center of the box\n        const realCenter = {\n            x: Math.round(this.gridWidth / 2),\n            y: Math.round(this.gridHeight / 2)\n        };\n\n        // swap the coordinates when the rotation parity is 1\n        const center = this.rotationParity\n            ? {\n                  x: realCenter.y,\n                  y: realCenter.x\n              }\n            : realCenter;\n\n        // apply the rotation to the transform object\n        if (clockWise) {\n            transform.rotateRight(center.x, center.y);\n        } else {\n            transform.rotateLeft(center.x, center.y);\n        }\n\n        // rotate the blocked nodes as well\n        if (clockWise) {\n            this.rotateBlockedNodesRight(center);\n        } else {\n            this.rotateBlockedNodesLeft(center);\n        }\n\n        // convert the modified transform back to SVG pixels\n        // and apply it to the svgObj\n        transform.toSVGPixels(this.appInstance);\n        this.svgObj.addAttr({ transform: transform.get() });\n\n        // update the wires\n        this.updateWires();\n\n        // if tutorial exists, call the tutorial callback\n        if (this.appInstance.tutorial) {\n            this.appInstance.tutorial.onBoxRotated();\n        }\n    }\n\n    /**\n     * add a connector to the element on the specified position\n     * @param {number}  left             horizontal distance from the left edge of the element\n     * @param {number}  top              vertical distance from the top edge of the element\n     * @param {Boolean} isInputConnector whether or not should this connector an input connector (`true` for input connector, `false` for output connector)\n     */\n    addConnector(left, top, isInputConnector) {\n        let index = this.connectors.length;\n        if (isInputConnector) {\n            this.connectors[index] = new InputConnector(this.appInstance, left, top);\n        } else {\n            this.connectors[index] = new OutputConnector(this.appInstance, left, top);\n        }\n        this.svgObj.addChild(this.connectors[index].get());\n    }\n\n    /**\n     * add an input connector to the element on the specified position\n     * @param {number} left horizontal distance from the left edge of the element\n     * @param {number} top  vertical distance from the top edge of the element\n     */\n    addInputConnector(left, top) {\n        return this.addConnector(left, top, true);\n    }\n\n    /**\n     * add an output connector to the element on the specified position\n     * @param {number} left horizontal distance from the left edge of the element\n     * @param {number} top  vertical distance from the top edge of the element\n     */\n    addOutputConnector(left, top) {\n        return this.addConnector(left, top, false);\n    }\n\n    /**\n     * get the connector object based on its id\n     * @param  {string} connectorId ID of the {@link Connector}\n     * @return {Connector}             instance of the {@link Connector} or `undefined` if not found\n     */\n    getConnectorById(connectorId) {\n        for (let i = 0; i < this.connectors.length; i++) {\n            if (this.connectors[i].id === connectorId) {\n                return this.connectors[i];\n            }\n        }\n        // if connector not found, return undefined\n        return undefined;\n    }\n\n    /**\n     * get the instance of {@link Transform} representing the state of the transform attribute of this element\n     * @param  {Boolean} [gridPixels=false] if `true`, function will return the result in grid pixels instead of SVG pixels\n     * @return {Transform}                  {@link Transform} of the element\n     */\n    getTransform(gridPixels = false) {\n        let transform;\n        if (!this.svgObj.$el.attr('transform')) {\n            // the element does not have a \"transform\" property --> create it\n            transform = new Transform();\n            transform.setTranslate(0, 0);\n            this.svgObj.addAttr({ transform: transform.get() });\n        } else {\n            // the element does have a \"transform\" property --> change it\n            transform = new Transform(this.svgObj.$el.attr('transform'));\n        }\n\n        // convert values to grid pixels\n        if (gridPixels) {\n            transform.toGridPixels(this.appInstance);\n        }\n\n        return transform;\n    }\n\n    /**\n     * get the instance of {@link Transform} representing the state of the transform attribute of this element _with lenght units in grid pixels_\n     * @return {Transform} {@link Transform} of the element\n     */\n    getGridPixelTransform() {\n        return this.getTransform(true);\n    }\n\n    /**\n     * set the transform attribute of this element\n     * @param {Transform} transform {@link Transform} of the element (with lengths specified in SVG pixels)\n     */\n    setTransform(transform) {\n        this.svgObj.addAttr({ transform: transform.get() });\n    }\n\n    /**\n     * function that is called on every mouse down on this element\n     *\n     * moves the element to the front and calls onMouseDownLeft if applicable\n     * @param  {jQuery.MouseEvent} event\n     */\n    onMouseDown(event) {\n        this.mouseLeft = false;\n        if (event.which === 1) {\n            this.mouseLeft = true;\n            this.onMouseDownLeft(event);\n\n            // move the DOM element to front\n            this.appInstance.moveToFrontById(this.svgObj.id);\n        }\n    }\n\n    /**\n     * function that is called on every left mouse down on this element\n     *\n     * prepares element for the \"click\" and \"drag and drop\" actions\n     * @param  {jQuery.MouseEvent} event\n     */\n    onMouseDownLeft(event) {\n        this.mouseMoved = false;\n\n        let transform = this.getTransform();\n\n        // save the current item position into a variable\n        let currentPosition = transform.getTranslate();\n\n        let { pageX, pageY } = this.appInstance.viewbox.transformEvent(event);\n\n        // calculate mouse offset from the object origin\n        this.offset = {\n            x: pageX - currentPosition.x,\n            y: pageY - currentPosition.y\n        };\n    }\n\n    /**\n     * function that is called on every left mouse move with this element\n     * applies the correct transform values to provide the \"drag and drop\" functionality\n     * @param  {jQuery.MouseEvent} event\n     */\n    onMouseMove(event) {\n        if (this.mouseLeft) {\n            this.svgObj.$el.addClass('grabbed');\n\n            this.mouseMoved = true;\n\n            let { pageX, pageY } = this.appInstance.viewbox.transformEvent(event);\n\n            const left = pageX - this.offset.x;\n            const top = pageY - this.offset.y;\n\n            let transform = this.getTransform();\n            transform.setTranslate(left, top);\n\n            this.setTransform(transform);\n\n            this.updateWires(true);\n        }\n    }\n\n    /**\n     * function that is called on every mouse up on this element\n     * provides the \"click\" functionality and calls the onDrop handler for the \"drag and drop\" functionality\n     * @param  {jQuery.MouseEvent} event\n     */\n    onMouseUp(event) {\n        if (event.which === 1) {\n            if (this.mouseMoved) {\n                this.onDrop(event);\n            } else {\n                this.onClick();\n            }\n        } else if (event.which === 2) {\n            this.onClickMiddle(event);\n        }\n\n        this.svgObj.$el.removeClass('grabbed');\n    }\n\n    /**\n     * called by onMouseUp when the mouse has been moved between onMouseDown and onMouseUp\n     *\n     * applies grid snapping of the element on the end of the \"drag and drop\" action\n     * @param  {jQuery.MouseEvent} event\n     */\n    onDrop(event) {\n        let { pageX, pageY } = this.appInstance.viewbox.transformEvent(event);\n\n        let left = pageX - this.offset.x;\n        let top = pageY - this.offset.y;\n\n        left = this.appInstance.snapToGrid(left);\n        top = this.appInstance.snapToGrid(top);\n\n        let transform = this.getTransform();\n        transform.setTranslate(left, top);\n\n        this.setTransform(transform);\n\n        this.updateWires();\n\n        // if tutorial exists, call tutorial callback\n        if (this.appInstance.tutorial) {\n            this.appInstance.tutorial.onBoxMoved();\n        }\n    }\n\n    /**\n     * empty function, will be redefined in InputBox\n     */\n    onClick() {}\n\n    /**\n     * custom callback function for middle click that rotates the box by 90 degrees to the right\n     */\n    onClickMiddle(event) {\n        if (event.ctrlKey) {\n            this.rotate(false);\n        } else {\n            this.rotate(true);\n        }\n    }\n\n    /**\n     * Updates all wires connected to this box. Iterates over all wires that are connected to this box\n     * and calls routeWire (or temporaryWire if the `temporary` parameter is set to true) to update the wire routing\n     * @param  {Boolean} [temporary=false] [description]\n     */\n    updateWires(temporary = false) {\n        this.connectors.forEach(conn => {\n            conn.wireIds.forEach(wireId => {\n                let wire = this.appInstance.getWireById(wireId);\n                if (temporary) {\n                    wire.temporaryWire();\n                } else {\n                    wire.routeWire();\n                }\n            });\n        });\n    }\n}\n","import NetworkElement from './NetworkElement';\nimport { Rectangle } from '../svgObjects';\nimport Logic from '../Logic';\n\nimport stateClasses from './stateClasses';\n\n/** @module editorElements.Connector */\n\n/**\n * parent class for input and output connectors\n * @extends NetworkElement\n */\nexport default class Connector extends NetworkElement {\n    /**\n     * @param {App} appInstance link to the [App](./module-App.html) instance that this connector will belong to\n     * @param {number} gridSize  size of the grid in SVG pixels\n     * @param {number} left      horizontal position defined in grid units (SVG pixels divided by the grid size)\n     * @param {number} top       vertical position defined in grid units (SVG pixels divided by the grid size)\n     */\n    constructor(appInstance, left, top) {\n        super(appInstance);\n\n        /**\n         * size of the grid in SVG pixels\n         * @type {number}\n         */\n        this.gridSize = appInstance.gridSize;\n        /**\n         * size of the connector in SVG pixels\n         * @type {number}\n         */\n        this.connectorSize = appInstance.gridSize;\n        /**\n         * offset of the connector from the grid in SVG pixels\n         * @type {number}\n         */\n        this.connectorOffset = this.connectorSize / 2;\n\n        /**\n         * instance of {@link svgObjects.svgObj} that holds all SVG information about this connector\n         * @type {svgObj}\n         */\n        this.svgObj = new Rectangle(\n            left * this.gridSize - this.connectorOffset,\n            top * this.gridSize - this.connectorOffset,\n            this.connectorSize,\n            this.connectorSize,\n            'none',\n            'black'\n        );\n\n        this.svgObj.$el.addClass('connector');\n\n        /**\n         * this flag describes whether this connector is an input connector\n         * @type {Boolean}\n         */\n        this.isInputConnector = false;\n\n        /**\n         * current logical state of this connector\n         * @type {Logic.state}\n         */\n        this.elementState = Logic.state.unknown;\n        this.svgObj.addClass(stateClasses[Logic.state.unknown]);\n\n        /**\n         * set of ids of all wires connected to this connector\n         * @type {Set}\n         */\n        this.wireIds = new Set();\n    }\n\n    /**\n     * whether this connector is an output connector\n     * @return {Boolean}\n     */\n    get isOutputConnector() {\n        return !this.isInputConnector;\n    }\n\n    /**\n     * whether this connector is an output connector\n     * @return {Boolean}\n     */\n    set isOutputConnector(value) {\n        this.isInputConnector = !value;\n    }\n\n    /**\n     * add a wire id to the list of wire ids\n     * @param {string} wireId\n     */\n    addWireId(wireId) {\n        this.wireIds.add(wireId);\n    }\n\n    /**\n     * remove a wire id from the list of wire ids\n     * @param {string} wireId\n     */\n    removeWireId(wireId) {\n        this.wireIds.delete(wireId);\n    }\n\n    /**\n     * remove a wire specified by ID and update the connector\n     * @param  {string} wireId ID of the wire to be removed\n     */\n    removeWireIdAndUpdate(wireId) {\n        this.removeWireId(wireId);\n    }\n\n    /**\n     * set logical state of the connector\n     * @param {Logic.state} state new state of the connector\n     */\n    setState(state) {\n        this.svgObj.removeClasses(...stateClasses);\n        this.svgObj.addClass(stateClasses[state]);\n\n        this.elementState = state;\n    }\n\n    /**\n     * get state of this connector\n     * @return {Logic.state}\n     */\n    get state() {\n        return this.elementState;\n    }\n\n    /**\n     * get svgObj instance content of this connector\n     * @return {svgObjects.Rectangle}\n     */\n    get() {\n        return this.svgObj;\n    }\n\n    /**\n     * call [wireCreationHelper](./module-App.html#wireCreationHelper) on mouse up\n     */\n    onMouseUp(event) {\n        // only left click counts\n        if (event.which === 1) {\n            event = this.appInstance.viewbox.transformEvent(event);\n\n            const mousePosition = {\n                x: event.pageX,\n                y: event.pageY\n            };\n\n            this.appInstance.wireCreationHelper(this.svgObj.id, mousePosition);\n        }\n    }\n}\n","import Logic from '../Logic';\n\nimport Box from './Box';\n\n/** @module editorElements.Gate */\n\n/**\n * Gate is a box that processes the states of its input connectors and returns the result in its output connectors.\n * @extends Box\n */\nexport default class Gate extends Box {\n    /**\n     * @param {App} appInstance  instance of [App](./module-App.html)\n     * @param {string} name       name of the gate (and, not, xor...)\n     */\n    constructor(appInstance, name) {\n        const width = 9;\n        const height = 4;\n\n        super(appInstance, name, 'gate', width, height);\n\n        // ADD CONNECTORS\n\n        let specialNodes = [];\n\n        // output\n        this.addConnector(width, height / 2, false);\n\n        // block the output connector\n        specialNodes.push({\n            x: width,\n            y: height / 2\n        });\n\n        if (this.name === 'not' || this.name === 'repeater') {\n            // input\n            this.addConnector(0, height / 2, true);\n            // block the input connector\n            specialNodes.push({\n                x: 0,\n                y: height / 2\n            });\n        } else {\n            // input\n            this.addConnector(0, height / 4, true);\n            this.addConnector(0, height / (4 / 3), true);\n\n            // block the input connectors\n            specialNodes.push({\n                x: 0,\n                y: height / 4\n            });\n            specialNodes.push({\n                x: 0,\n                y: height / (4 / 3)\n            });\n\n            // add one blocked node between the inputs (for better looking wiring)\n            specialNodes.push({\n                x: 0,\n                y: height / 2\n            });\n        }\n\n        this.generateBlockNodes(...specialNodes);\n\n        this.refreshState();\n    }\n\n    /**\n     * array of valid gate names\n     * @type {Set}\n     */\n    static get validGates() {\n        // return new Set([\"not\", \"and\", \"or\", \"nand\", \"nor\", \"xor\", \"xnor\", \"repeater\"]);\n        return new Set(['not', 'and', 'or', 'nand', 'nor', 'xor', 'xnor']);\n    }\n\n    generateBlockNodes(...specialNodes) {\n        if (specialNodes !== undefined) {\n            super.generateBlockNodes(0, 1, 0, 1, ...specialNodes);\n        } else {\n            super.generateBlockNodes(0, 1, 0, 1);\n        }\n    }\n\n    /**\n     * proccess the input connector states and reflect them in the output connector states according\n     * to the logic corresponding to this gate's name\n     */\n    refreshState() {\n        // map gate names to their logic functions\n        const stateMap = {\n            and: () => Logic.and(this.connectors[1].state, this.connectors[2].state),\n            nand: () => Logic.nand(this.connectors[1].state, this.connectors[2].state),\n            nor: () => Logic.nor(this.connectors[1].state, this.connectors[2].state),\n            not: () => Logic.not(this.connectors[1].state),\n            or: () => Logic.or(this.connectors[1].state, this.connectors[2].state),\n            xnor: () => Logic.xnor(this.connectors[1].state, this.connectors[2].state),\n            xor: () => Logic.xor(this.connectors[1].state, this.connectors[2].state),\n            repeater: () => this.connectors[1].state\n        };\n\n        let state = Logic.state.unknown;\n\n        if (stateMap[this.name]) {\n            state = stateMap[this.name]();\n        }\n\n        // notify the simulator about this change\n        this.appInstance.simulation.notifyChange(this.connectors[0].id, state);\n    }\n}\n","import { PolyLine, PolyLinePoints, PolyLinePoint } from '../svgObjects';\n\nimport NetworkElement from './NetworkElement';\n\n/** @module editorElements.HelperWire */\n\n/**\n * A temporary wire that is connecting a {@link Connector} with a mouse pointer when user creates a wire.\n * @extends NetworkElement\n */\nexport default class HelperWire extends NetworkElement {\n    constructor(appInstance, fromId, mousePosition) {\n        super(appInstance);\n\n        const connector = this.appInstance.getConnectorById(fromId);\n        this.connectorPosition = this.appInstance.getConnectorPosition(connector, true);\n\n        const from = new PolyLinePoint(this.connectorPosition.x, this.connectorPosition.y);\n        const to = new PolyLinePoint(mousePosition.x, mousePosition.y);\n\n        const points = new PolyLinePoints([from, to]);\n\n        this.svgObj = new PolyLine(points, 2, '#8b8b8b');\n    }\n\n    updateMousePosition(mousePosition) {\n        const from = new PolyLinePoint(this.connectorPosition.x, this.connectorPosition.y);\n        const to = new PolyLinePoint(mousePosition.x, mousePosition.y);\n\n        const points = new PolyLinePoints([from, to]);\n\n        this.svgObj.updatePoints(points);\n    }\n\n    /**\n     * get the jQuery element for this helper wire\n     * @return {jQuery.element}\n     */\n    get() {\n        return this.svgObj.get();\n    }\n}\n","import Logic from '../Logic';\n\nimport Box from './Box';\n\n/** @module editorElements.InputBox */\n\n/**\n * InputBox has only output connectors and is used to set the input states for the logic network.\n * @extends Box\n */\nexport default class InputBox extends Box {\n    /**\n     * @param {App} appInstance  instance of [App](./module-App.html)\n     * @param {Boolean} [isOn=false] the initial state of the inputbox (`true` is *on*, `false` is *off*)\n     */\n    constructor(appInstance, isOn = false) {\n        const gridWidth = 7;\n        const gridHeight = 4;\n\n        super(appInstance, 'input', 'other', gridWidth, gridHeight);\n\n        this.addConnector(gridWidth, gridHeight / 2, false);\n\n        this.on = isOn;\n\n        this.generateBlockNodes();\n    }\n\n    /**\n     * get data of this input box as a JSON-ready object\n     * @return {Object} javascript object containing essential data for this input box\n     */\n    get exportData() {\n        let data = super.exportData;\n        data.isOn = this.isOn;\n\n        return data;\n    }\n\n    generateBlockNodes() {\n        // block the input connector node\n        const specialNode = {\n            x: this.gridWidth,\n            y: this.gridHeight / 2\n        };\n        super.generateBlockNodes(0, 1, 1, 0, specialNode);\n    }\n\n    /**\n     * start a new simulation from the output connector\n     */\n    refreshState() {\n        this.appInstance.startNewSimulation(this.connectors[0], this.connectors[0].state);\n    }\n\n    /**\n     * set the state of the inputbox to the corresponding value\n     * @param  {Boolean} isOn set to *on* if `true`, set to *off* if `false`\n     */\n    set on(isOn) {\n        if (isOn) {\n            // turn on\n            this.changeImage('on');\n            this.connectors[0].setState(Logic.state.on);\n            this.refreshState();\n        } else {\n            // turn off\n            this.changeImage();\n            this.connectors[0].setState(Logic.state.off);\n            this.refreshState();\n        }\n\n        this.isOn = isOn;\n    }\n\n    /**\n     * get the state of the inputbox (`true` if *on*, `false` if *off*)\n     * @return {Boolean} [description]\n     */\n    get on() {\n        return this.isOn;\n    }\n\n    /**\n     * toggle the state of the inputbox\n     */\n    onClick() {\n        this.on = !this.on;\n\n        if (this.appInstance.tutorial) {\n            this.appInstance.tutorial.onChangeInputBoxState();\n        }\n    }\n}\n","import Connector from './Connector';\nimport Logic from '../Logic';\n\n/** @module editorElements.InputConnector */\n\n/**\n * Connector that gets its state from a connected value and passes it through to the {@link Box} this connector belongs to.\n * @extends Connector\n */\nexport default class InputConnector extends Connector {\n    /**\n     * Call the constructor from the parent {@link Connector} class and set isInputConnector to true.\n     * @param {App} appInstance link to the [App](./module-App.html) instance that this connector will belong to\n     * @param {number} left      horizontal position defined in grid units (SVG pixels divided by the grid size)\n     * @param {number} top       vertical position defined in grid units (SVG pixels divided by the grid size)\n     */\n    constructor(appInstance, left, top) {\n        super(appInstance, left, top);\n\n        this.isInputConnector = true;\n    }\n\n    /**\n     * Call the setState method of {@link Connector} and than refresh the state of the connected {@link Box}\n     * @param {Logic.state} state new {@link Logic.state} of the connector\n     */\n    setState(state) {\n        super.setState(state);\n        // console.log(\"SET STATE ON IC\", this.id, \":\", state)\n\n        let box = this.appInstance.getBoxByConnectorId(this.svgObj.id);\n        box.refreshState();\n    }\n\n    /**\n     * remove the wire (by calling the removeWireIdAndUpdate of {@link Connector})\n     * and update state of this connector by setting it to undefined using the setState method\n     * @param  {string} wireId ID of the {@link Wire}\n     */\n    removeWireIdAndUpdate(wireId) {\n        super.removeWireIdAndUpdate(wireId);\n        this.setState(Logic.state.unknown);\n    }\n}\n","/** @module editorElements.NetworkElement */\n\n/**\n * parent class for all network elements\n */\nexport default class NetworkElement {\n    /**\n     * Basic constructor for NetworkElement\n     * @param {App} appInstance reference to the instance of [App](./module-App.html) that this element belongs to\n     */\n    constructor(appInstance) {\n        if (!appInstance) {\n            console.error('Parent SVG element has to be defined.');\n        }\n        this.appInstance = appInstance;\n\n        // used to store the svjObject's instance of this element\n        this.svgObj = undefined;\n    }\n\n    /**\n     * Get the unique ID of the SVG element tied to this logical element\n     * @return {string} ID of the SVG element\n     */\n    get id() {\n        return this.svgObj.id;\n    }\n\n    /**\n     * empty callback function to prevent error messages, function is implemented later in the {@link Box} class\n     */\n    onMouseDown() {}\n\n    /**\n     * empty function to prevent error messages, function is implemented later in the {@link Box} and {@link Connector} classes\n     */\n    onMouseUp() {}\n\n    /**\n     * empty function to prevent error messages, function is implemented later in the {@link Box} class\n     */\n    onMouseMove() {}\n\n    /**\n     * \"virtual\" getter for json data, prints an error that it has to be redefined in the derived classes\n     */\n    get exportData() {\n        console.error(\"'json' getter has not been defined for this element\", this);\n        return undefined;\n    }\n}\n","import Logic from '../Logic';\n\nimport Box from './Box';\n\n/** @module editorElements.OutputBox */\n\n/**\n * OutputBox has only input connectors and is used to visualize the output states of the logic network.\n * @extends Box\n */\nexport default class OutputBox extends Box {\n    /**\n     * @param {App} appInstance  instance of [App](./module-App.html)\n     */\n    constructor(appInstance) {\n        const gridHeight = 4;\n        const gridWidth = 5;\n\n        super(appInstance, 'output', 'other', gridWidth, gridHeight);\n\n        this.addConnector(0, gridHeight / 2, true);\n\n        this.generateBlockNodes();\n    }\n\n    /**\n     * set state of this output box to match the state of its input connector\n     */\n    refreshState() {\n        this.setState(this.connectors[0].state);\n    }\n\n    /**\n     * Reflect the input connector state in the appearance of the element - set\n     * the element image to represent the corresponding state\n     * @param {Logic.state} state new state of this outputBox\n     */\n    setState(state) {\n        if (state === Logic.state.on) {\n            if (this.appInstance.tutorial) {\n                this.appInstance.tutorial.onOutputBoxTrue();\n            }\n        }\n\n        let stateMap = {};\n        stateMap[Logic.state.on] = 'on';\n        stateMap[Logic.state.off] = 'off';\n        stateMap[Logic.state.unknown] = '';\n        stateMap[Logic.state.oscillating] = 'osc';\n\n        this.changeImage(stateMap[state]);\n    }\n\n    generateBlockNodes() {\n        // block the input connector node\n        const specialNode = {\n            x: 0,\n            y: this.gridHeight / 2\n        };\n        super.generateBlockNodes(0, 0, 0, 1, specialNode);\n    }\n}\n","import Connector from './Connector';\n\n/** @module editorElements.OutputConnector */\n\n/**\n * Connector that takes a state defined by the {@link Box} it belongs to and passes it to all connected wire\n * @extends Connector\n */\nexport default class OutputConnector extends Connector {\n    /**\n     * Call the constructor from the parent {@link Connector} class and set isOutputConnector to true.\n     * @param {App} appInstance link to the [App](./module-App.html) instance that this connector will belong to\n     * @param {number} left      horizontal position defined in grid units (SVG pixels divided by the grid size)\n     * @param {number} top       vertical position defined in grid units (SVG pixels divided by the grid size)\n     */\n    constructor(appInstance, left, top) {\n        super(appInstance, left, top);\n\n        this.isOutputConnector = true;\n    }\n\n    /**\n     * Call the setState method of {@link Connector} and than set the state of the connected {@link Wire}s\n     * @param {Logic.state} state new {@link Logic.state} of the connector\n     */\n    setState(state) {\n        super.setState(state);\n\n        for (const wireId of this.wireIds) {\n            this.appInstance.getWireById(wireId).setState(state);\n        }\n    }\n}\n","/** @module editorElements.Transform */\n\n/**\n * Helper class used by {@link Transform}.\n *\n * Represents one single property of the transform argument, for example `translate(360 150)`\n * that may be a part of longer transform argument like `transform=\"translate(360 150) rotate(90 30 20)\"`\n */\nclass Property {\n    /**\n     * Initialize the Property object\n     * @param {string} [string] string in the property format `propertyname(list of space separated values)`\n     */\n    constructor(string) {\n        if (string !== undefined) {\n            this.name = string.replace(/^[ ]*([^(]+).*/, '$1');\n            this.args = string.replace(/^[^(]+\\((.*)\\)/, '$1').split(' ');\n        }\n    }\n\n    /**\n     * set or replace the name of this property\n     * @param {string} name new name for this property\n     */\n    setName(name) {\n        this.name = name;\n    }\n\n    /**\n     * set arguments of this property\n     * @param {array} args array of arguments\n     */\n    setArguments(args) {\n        this.args = args;\n    }\n\n    /**\n     * get string representation of the property\n     * @return {string} property in the property format `name(arg1 arg2)`\n     */\n    get() {\n        return this.name + '(' + this.args.join(' ') + ')';\n    }\n}\n\n/**\n * API for manipulating the transform argument used in SVG\n */\nexport default class Transform {\n    /**\n     * Initialize the Transform object\n     * @param {string} [string] string in the format of the `transform` argument in SVG, for example `translate(360 150) rotate(90 30 20)`\n     */\n    constructor(string) {\n        /**\n         * array of {@link Property} instances\n         * @type {Array}\n         */\n        this.items = [];\n\n        if (string !== undefined) {\n            for (const item of string.split(')')) {\n                if (item) {\n                    // if not empty\n                    this.items.push(new Property(item + ')'));\n                }\n            }\n        }\n    }\n\n    /**\n     * convert distances from SVG pixels to grid pixels\n     * @param {App} appInstance instance of [App](./module-App.html)\n     */\n    toGridPixels(appInstance) {\n        this.pixelConversion(val => appInstance.SVGToGrid(val));\n    }\n\n    /**\n     * convert distances from grid pixels to SVG pixels\n     * @param {App} appInstance instance of [App](./module-App.html)\n     */\n    toSVGPixels(appInstance) {\n        this.pixelConversion(val => appInstance.gridToSVG(val));\n    }\n\n    /**\n     * Convert distances using a specified convertor. Used by toGridPixels and toSVGPixels\n     * @param  {Function} convertor function that converts int to int\n     */\n    pixelConversion(convertor) {\n        const propertyMap = {\n            translate: item => {\n                item.args = item.args.map(arg => convertor(arg));\n                return item;\n            },\n            rotate: item => {\n                item.args = [item.args[0], convertor(item.args[1]), convertor(item.args[2])];\n                return item;\n            }\n        };\n\n        this.items = this.items.map(item => {\n            return propertyMap[item.name] ? propertyMap[item.name](item) : item;\n        });\n    }\n\n    /**\n     * find a transform property by name and get its index in the [items](#items) array\n     * @param  {string} name name of the property\n     * @return {number}      index of the property in the array of properties or `-1` if not found\n     */\n    getIndex(name) {\n        for (let i = 0; i < this.items.length; i++) {\n            if (name === this.items[i].name) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    /**\n     * get the translate property\n     * @return {Object} object containing parameters of the translate attribute\n     */\n    getTranslate() {\n        let args = this.getArguments(this.getIndex('translate'));\n\n        return {\n            x: Number(args[0]),\n            y: Number(args[1])\n        };\n    }\n\n    /**\n     * get the rotate property\n     * @return {Object} object containing parameters of the rotate attribute\n     */\n    getRotate() {\n        let args = this.getArguments(this.getIndex('rotate'));\n\n        return {\n            deg: Number(args[0]),\n            centerX: Number(args[1]),\n            centerY: Number(args[2])\n        };\n    }\n\n    /**\n     * set translate to the specified values\n     * @param {number} x horizontal translation\n     * @param {number} y vertical translation\n     */\n    setTranslate(x, y) {\n        this.setParameter('translate', [x, y]);\n    }\n\n    /**\n     * set rotate to the specified values\n     * @param {number} deg     angle of the rotation in degrees\n     * @param {number} centerX horizontal position of the center of the rotation\n     * @param {number} centerY vertical position of the center of the rotation\n     */\n    setRotate(deg, centerX, centerY) {\n        this.setParameter('rotate', [deg, centerX, centerY]);\n    }\n\n    /**\n     * rotate by 90 degrees to the right or left, depending on the parameter `right`\n     * @param {number} centerX horizontal position of the center of the rotation\n     * @param {number} centerY vertical position of the center of the rotation\n     * @param {boolean} right rotate to the right if `true`, to the left if `false`\n     */\n    rotateRightAngle(centerX, centerY, right) {\n        const amount = right ? 90 : 270;\n\n        if (this.getIndex('rotate') === -1) {\n            this.setRotate(amount, centerX, centerY);\n        } else {\n            let newRotation = (parseInt(this.getRotate().deg) + amount) % 360;\n\n            if (newRotation === 180) {\n                // swap center coordinates\n                // because rotate(c, x, y) is defined like transform(-x, -y) rotate(c) transform(x, y)\n                let a = centerX;\n                centerX = centerY;\n                centerY = a;\n            }\n\n            this.setRotate(newRotation, centerX, centerY);\n        }\n    }\n\n    /**\n     * rotate by 90 degrees to the right\n     * @param  {number} centerX horizontal position of the center of the rotation\n     * @param  {number} centerY vertical position of the center of the rotation\n     */\n    rotateRight(centerX, centerY) {\n        this.rotateRightAngle(centerX, centerY, true);\n    }\n\n    /**\n     * rotate by 90 degrees to the left\n     * @param  {number} centerX horizontal position of the center of the rotation\n     * @param  {number} centerY vertical position of the center of the rotation\n     */\n    rotateLeft(centerX, centerY) {\n        this.rotateRightAngle(centerX, centerY, false);\n    }\n\n    /**\n     * get the transform values in a string\n     * @return {string} string that can be used as a value for the transform property of a SVG element\n     */\n    get() {\n        let retVal;\n        for (const item of this.items) {\n            if (retVal) {\n                retVal += ' ' + item.get();\n            } else {\n                retVal = item.get();\n            }\n        }\n        return retVal;\n    }\n\n    /**\n     * get arguments of a property specified by index\n     * @param  {number} index index of the property\n     * @return {array}       array of arguments of the specified property\n     */\n    getArguments(index) {\n        return this.items[index].args;\n    }\n\n    /**\n     * set argumets of a property specified by name\n     * @param {string} name name of the property\n     * @param {array} args array of arguments of the specified property\n     */\n    setParameter(name, args) {\n        // determine index of the parameter (if set), else index == -1\n        let index = this.getIndex(name);\n\n        // if the property has been already set, change it (rewrite the array in the right index)\n        // else create a new one (set index to the length of an array --> ad an item to the end)\n        if (index === -1) {\n            index = this.items.length;\n            this.items[index] = new Property();\n            this.items[index].setName(name);\n        }\n\n        // save args under the right index\n        this.items[index].setArguments(args);\n    }\n}\n","/** @module editorElements.Wire */\n\nimport { PolyLine, PolyLinePoints, PolyLinePoint, Group } from '../svgObjects';\nimport Logic from '../Logic';\nimport stateClasses from './stateClasses';\nimport findPath from '../findPath';\n\nimport NetworkElement from './NetworkElement';\n\n/**\n * Wire represents connection of two {@link Connector}s.\n * @extends NetworkElement\n */\nexport default class Wire extends NetworkElement {\n    /**\n     * @param {App} appInstance  instance of [App](./module-App.html)\n     * @param {string}  fromId    id of the first connector this wire will be connected to\n     * @param {string}  toId      id of the second connector this wire will be connected to\n     * @param {Boolean} [refresh=true] if `true`, the [App](./module-App.html) will refresh after creating this wire\n     */\n    constructor(appInstance, fromId, toId, refresh = true, route = true) {\n        super(appInstance);\n\n        this.gridSize = appInstance.gridSize;\n\n        this.connection = {\n            from: {\n                id: fromId,\n                box: this.appInstance.getBoxByConnectorId(fromId),\n                connector: this.appInstance.getConnectorById(fromId)\n            },\n            to: {\n                id: toId,\n                box: this.appInstance.getBoxByConnectorId(toId),\n                connector: this.appInstance.getConnectorById(toId)\n            }\n        };\n\n        if (this.connection.from.connector.isOutputConnector) {\n            if (this.connection.to.connector.isInputConnector) {\n                // desired state\n            } else {\n                // connecting two output connectors\n                throw 'Can not place wire between two output connectors';\n            }\n        } else {\n            if (this.connection.to.connector.isInputConnector) {\n                // connecting two input connectors\n                throw 'Can not place wire between two input connectors';\n            } else {\n                // swap them and we are ready to go\n                [this.connection.from, this.connection.to] = [\n                    this.connection.to,\n                    this.connection.from\n                ];\n            }\n        }\n\n        if (route) {\n            this.routeWire(true, refresh);\n        } else {\n            this.temporaryWire();\n        }\n\n        this.elementState = Logic.state.unknown;\n\n        this.setState(this.connection.from.connector.state);\n\n        if (refresh) {\n            const { connector } = this.connection.to;\n            this.appInstance.startNewSimulation(connector, connector.state);\n        }\n\n        this.svgObj.$el.addClass('wire');\n    }\n\n    get boxes() {\n        return [this.connection.from.box, this.connection.to.box];\n    }\n\n    get connectors() {\n        return [this.connection.from.connector, this.connection.to.connector];\n    }\n\n    /**\n     * get data of this wire as a JSON-ready object\n     * @return {Object} javascript object containing essential data for this wire\n     */\n    get exportData() {\n        return {\n            fromId: this.connection.from.id,\n            toId: this.connection.to.id\n        };\n    }\n\n    /**\n     * set the state of this wire to match the state of the input connector it is connected to\n     * @param {Logic.state} state [description]\n     */\n    setState(state) {\n        this.svgObj.removeClasses(...stateClasses);\n        this.svgObj.addClass(stateClasses[state]);\n\n        this.connection.to.connector.setState(state);\n\n        this.elementState = state;\n    }\n\n    /**\n     * get the current [Logic.state](./modules-Logic.html#.state) of this wire\n     * @return {Logic.state}\n     */\n    get state() {\n        return this.elementState;\n    }\n\n    /**\n     * update the state of this wire\n     */\n    updateWireState() {\n        for (const box of this.boxes) {\n            box.refreshState();\n        }\n    }\n\n    /**\n     * get the jQuery element for this wire\n     * @return {jQuery.element}\n     */\n    get() {\n        return this.svgObj.get();\n    }\n\n    /**\n     * get the PolyLine points for a temporary wire placement connecting the two connectors\n     * @return {PolyLinePoints} new instance of {@link PolyLinePoints}\n     */\n    getTemporaryWirePoints() {\n        let points = new PolyLinePoints();\n        points.append(new PolyLinePoint(this.wireStart.x, this.wireStart.y));\n        points.append(new PolyLinePoint(this.wireEnd.x, this.wireEnd.y));\n        return points;\n    }\n\n    /**\n     * route the wire using the temporary wire points\n     */\n    temporaryWire() {\n        this.wireStart = this.appInstance.getConnectorPosition(\n            this.connection.from.connector,\n            false\n        );\n        this.wireEnd = this.appInstance.getConnectorPosition(this.connection.to.connector, false);\n\n        this.setWirePath(this.getTemporaryWirePoints());\n    }\n\n    /**\n     * route the wire using the modified A* wire routing algorithm\n     */\n    routeWire(snapToGrid = true, refresh = true) {\n        this.wireStart = this.appInstance.getConnectorPosition(\n            this.connection.from.connector,\n            snapToGrid\n        );\n        this.wireEnd = this.appInstance.getConnectorPosition(\n            this.connection.to.connector,\n            snapToGrid\n        );\n\n        this.points = this.findRoute(\n            {\n                x: this.wireStart.x / this.gridSize,\n                y: this.wireStart.y / this.gridSize\n            },\n            {\n                x: this.wireEnd.x / this.gridSize,\n                y: this.wireEnd.y / this.gridSize\n            }\n        );\n\n        this.setWirePath(this.points);\n\n        if (refresh) this.updateWireState();\n\n        // regenerate inconvenient nodes\n        this.generateInconvenientNodes();\n    }\n\n    /**\n     * set the wire to follow the specified points\n     * @param {PolyLinePoints} points instance of {@link PolyLinePoints}\n     */\n    setWirePath(points) {\n        // set the line\n        if (this.svgObj !== undefined) {\n            // this.svgObj.updatePoints(points);\n            for (let child of this.svgObj.children) {\n                child.updatePoints(points);\n            }\n        } else {\n            this.svgObj = new Group();\n\n            let hitbox = new PolyLine(points, 10, 'white');\n            hitbox.addClass('hitbox');\n            hitbox.addAttr({ opacity: 0 });\n            this.svgObj.addChild(hitbox);\n\n            let mainLine = new PolyLine(points, 2);\n            mainLine.addClass('main', 'stateUnknown');\n            this.svgObj.addChild(mainLine);\n        }\n    }\n\n    pathToPolyLine(path) {\n        let totalPath = new PolyLinePoints();\n        for (const point of path) {\n            totalPath.append(new PolyLinePoint(point.x * this.gridSize, point.y * this.gridSize));\n        }\n        return totalPath;\n    }\n\n    /**\n     * find a nice route for the wire\n     * @param  {Object} start object containing numeric attributes `x` and `y` that represent the first endpoint of the wire in grid pixel\n     * @param  {Object} end   object containing numeric attributes `x` and `y` that represent the second endpoint of the wire in grid pixels\n     * @return {PolyLinePoints}       [description]\n     */\n    findRoute(start, end) {\n        let nonRoutable = this.appInstance.getNonRoutableNodes();\n\n        let punishedButRoutable;\n        if (this.svgObj === undefined) {\n            punishedButRoutable = this.appInstance.getInconvenientNodes();\n        } else {\n            punishedButRoutable = this.appInstance.getInconvenientNodes(this.svgObj.id);\n        }\n\n        let path = findPath(start, end, nonRoutable, punishedButRoutable, this.gridSize);\n\n        if (path) {\n            return this.pathToPolyLine(path);\n        }\n\n        // if a path was not found, try again but don't take into account the punished and non routable node\n        path = findPath(start, end, new Set(), new Set(), this.gridSize);\n\n        if (path) {\n            return this.pathToPolyLine(path);\n        }\n\n        // if the path was still not found, give up and return temporary points\n        return this.getTemporaryWirePoints();\n    }\n\n    /**\n     * generate a set of nodes, that are inconvenient for wiring, but can be used, just are not preferred\n     * @return {Set} set of nodes (objects containing x and y coordinates) that are not preferred for wiring\n     */\n    generateInconvenientNodes() {\n        this.inconvenientNodes = new Set();\n\n        let prevPoint;\n\n        this.points.forEach(point => {\n            const x = this.appInstance.SVGToGrid(point.x),\n                y = this.appInstance.SVGToGrid(point.y);\n\n            if (prevPoint === undefined) {\n                // if the prevPoint is undefined, add the first point\n                this.inconvenientNodes.add({ x, y });\n            } else {\n                // else add all the point between the prevPoint (excluded) and point (included)\n\n                if (prevPoint.x === x) {\n                    // if the line is horizontal\n                    let from = Math.min(prevPoint.y, y);\n                    let to = Math.max(prevPoint.y, y);\n\n                    while (from <= to) {\n                        this.inconvenientNodes.add({ x: x, y: from });\n                        from++;\n                    }\n                } else if (prevPoint.y === y) {\n                    // if the line is vertical\n                    let from = Math.min(prevPoint.x, x);\n                    let to = Math.max(prevPoint.x, x);\n\n                    while (from <= to) {\n                        this.inconvenientNodes.add({ x: from, y: y });\n                        from++;\n                    }\n                } else {\n                    // line is neither horizontal nor vertical, throw an error for better future debugging\n                    // console.error(\"getInconvenientNodes: line between two points is neither horizontal nor vertical\");\n                }\n            }\n\n            // set new prevPoint\n            prevPoint = { x, y };\n        });\n    }\n}\n","import Logic from '../Logic';\n\n/**\n * mapping of logical states to css classes\n * @type {Object}\n */\n\nlet map = []; // array so we can use the ...spread operator\n\nmap[Logic.state.on] = 'stateOn';\nmap[Logic.state.off] = 'stateOff';\nmap[Logic.state.unknown] = 'stateUnknown';\nmap[Logic.state.oscillating] = 'stateOscillating';\n\nexport default map;\n","import { manhattanDistance } from './other/helperFunctions';\nimport MapWithDefaultValue from './other/mapWithDefaultValue';\n\nimport { PriorityQueue } from 'libstl'; // note: imported from a node module\n\n/** @module findPath */\n\n/**\n * Heavily modified implementation of the A* algorithm\n * @param  {Object} start object containing numeric attributes `x` and `y` that represent the first endpoint of the wire in grid pixels\n * @param  {Object} end   object containing numeric attributes `x` and `y` that represent the second endpoint of the wire in grid pixels\n * @param  {Set} nonRoutable set of non routable nodes\n * @param  {Set} punishedButRoutable set of nodes that are not optimal for routing\n * @return {Array} array of objects containing numeric attributes `x` and `y`\n */\nexport default function findPath(start, end, nonRoutable, punishedButRoutable) {\n    const distanceFunction = manhattanDistance;\n\n    const wireCrossPunishment = 1;\n    const wireBendPunishment = 1;\n\n    // number of nodes, that can be opened at once\n    // once is this limit exceeded, aStar will fail and return undefined\n    const maxNodeLimit = 100000;\n\n    let closedNodes = new Set();\n    let openNodes = new Set();\n    let openNodeQueue = new PriorityQueue();\n\n    // functions for working with open nodes:\n\n    /**\n     * add a new open node to the structure\n     * @param {Object} node   object containing numeric attributes `x` and `y` that represent the first endpoint of the wire\n     * @param {number} fscore fScore of this node\n     */\n    const addOpenNode = (node, fscore) => {\n        openNodes.add(node);\n        // flip the fscore, because PriorityQueue uses max heap\n        openNodeQueue.enqueue(node, 1 / fscore);\n    };\n\n    /**\n     * get the open node with the lowest fScore and remove it\n     * @return {Object} object containing numeric attributes `x` and `y` that represent the first endpoint of the wire\n     */\n    const getOpenNode = () => {\n        const node = openNodeQueue.dequeue();\n        openNodes.delete(node);\n        return node;\n    };\n\n    let cameFrom = new Map();\n\n    // default value: infinity\n    let gScore = new MapWithDefaultValue(Infinity);\n    gScore.set(start, 0);\n\n    let startFScore = distanceFunction(start, end);\n\n    addOpenNode(start, startFScore);\n\n    openNodes.add(start);\n    openNodeQueue.enqueue(start, 1 / startFScore);\n\n    while (openNodes.size > 0) {\n        // get the value from openNodes that has the lowest fScore\n        const currentNode = getOpenNode();\n\n        // if we reached the end point, reconstruct the path and return it\n        if (currentNode.x == end.x && currentNode.y == end.y) {\n            return reconstructPath(cameFrom, currentNode);\n        }\n\n        // add this node to the closed nodes\n        closedNodes.add(currentNode);\n\n        // the farthest points accessible without avoiding obstacles in every direction\n        // (but max 50 in each direction)\n        for (let direction = 0; direction < 4; direction++) {\n            let newPoint = movePoint(currentNode, direction);\n\n            let wiresCrossed = 0;\n\n            for (let i = 0; i < 50; i++) {\n                // if newPoint is in the set of non routable points,\n                // don't add it and stop proceeding in this direction\n                if (setHasThisPoint(nonRoutable, newPoint)) {\n                    // if this not the end or start point, break\n                    if (\n                        !(newPoint.x === end.x && newPoint.y === end.y) &&\n                        !(newPoint.x === start.x && newPoint.y === start.y)\n                    ) {\n                        break;\n                    }\n                }\n\n                // skip this node, if it has been already closed\n                // or if it is on the list of non routable nodes\n                if (closedNodes.has(newPoint)) {\n                    continue;\n                }\n\n                // calculate possible GScore by applying a punishment for each node (\"bend\") in the path\n                let newGScore = wireBendPunishment + gScore.getWithDefault(currentNode);\n\n                if (setHasThisPoint(punishedButRoutable, newPoint)) {\n                    // if the node is in the set of punished nodes, apply the punishment\n                    wiresCrossed++;\n                }\n\n                // apply the punishment for each wire crossed in this direction\n                // note: we are counting the wires crossed when exporting this direction, not the wires\n                // crossed in the final path, there will be probably only at most of these nodes in the\n                // final path, not multiple\n                newGScore += wiresCrossed * wireCrossPunishment;\n\n                // skip this node if it has worst estimage gscore than in the gscore table\n                if (newGScore >= gScore.getWithDefault(newPoint)) {\n                    continue;\n                }\n\n                cameFrom.set(newPoint, currentNode);\n                gScore.set(newPoint, newGScore);\n\n                const newFScore = newGScore + distanceFunction(newPoint, end);\n\n                if (!openNodes.has(newPoint)) {\n                    // add the point to the list of points\n                    addOpenNode(newPoint, newFScore);\n                }\n\n                // move to the next point in the direciton\n                newPoint = movePoint(newPoint, direction);\n            }\n        }\n\n        if (openNodes.size > maxNodeLimit) {\n            console.log(\n                `aStar: Number of open nodes (${\n                    openNodes.size\n                }) exceeded the limit for open nodes (${maxNodeLimit}).`\n            );\n            break;\n        }\n    }\n    // if we got here, the path was not found\n\n    return undefined;\n}\n\n/**\n * returns `true` if the specified set of points contains the specified point (and returns `false` otherwise)\n * @param {Set} set set of points\n * @param {Object} point object containing numeric attributes `x` and `y`\n */\nfunction setHasThisPoint(set, point) {\n    for (let item of set) {\n        if (item.x === point.x && item.y === point.y) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Helper that moves the passed point in the specified direction. It simply adds or subtracts 1 from one of the coordinates depending on the direction attribute.\n * @param  {Object} point     object containing numeric attributes `x` and `y`\n * @param  {number} direction directions:\n *     - 0: up\n *     - 1: right\n *     - 2: down\n *     - 3: left\n * @return {Object}           object containing numeric attributes `x` and `y`\n */\nfunction movePoint({ x, y }, direction) {\n    // map direction do point coordinate modification\n    const dirMap = {\n        0: () => {\n            y -= 1;\n        },\n        1: () => {\n            x += 1;\n        },\n        2: () => {\n            y += 1;\n        },\n        3: () => {\n            x -= 1;\n        }\n    };\n\n    dirMap[direction]();\n\n    return { x, y };\n}\n\n/**\n * helper backtracking function used by the aStar algorithm to construct the final path\n * @param  {Object} cameFrom    object containing numeric attributes `x` and `y`\n * @param  {Object} currentNode object containing numeric attributes `x` and `y`\n * @return {Array} array of objects containing numeric attributes `x` and `y`\n */\nfunction reconstructPath(cameFrom, currentNode) {\n    let path = [];\n\n    path.push({\n        x: currentNode.x,\n        y: currentNode.y\n    });\n\n    while (cameFrom.has(currentNode)) {\n        currentNode = cameFrom.get(currentNode);\n        path.push({\n            x: currentNode.x,\n            y: currentNode.y\n        });\n    }\n\n    return path;\n}\n","/**\n * @module HelperFunctions\n */\n\nimport stringify from 'json-stringify-pretty-compact'; // note: imported from a module\n\n/**\n * add a cross browser event listener on a mouse scroll\n * @param {string} query DOM query of the element that the listener will be added to\n * @param {Function} func  Function that will be called when the event occurs. The function takes as a parameter an event object.\n */\nexport function addMouseScrollEventListener(query, func) {\n    let MouseWheelHandler = event => {\n        // redeclare for old IE support\n        var event = window.event || event; // eslint-disable-line no-redeclare\n\n        event.delta = Math.max(-1, Math.min(1, event.wheelDelta || -event.detail));\n\n        func(event);\n\n        return false;\n    };\n\n    let svgelement;\n\n    // if the query is a simple DOM id selector, we can use getElementById which has better backwards compatibility\n    if (query.match(/^#\\w+$/)) {\n        svgelement = document.getElementById(query.substr(1));\n    } else {\n        svgelement = document.querySelector(query);\n    }\n\n    if (svgelement.addEventListener) {\n        // IE9, Chrome, Safari, Opera\n        svgelement.addEventListener('mousewheel', MouseWheelHandler, false);\n        // Firefox\n        svgelement.addEventListener('DOMMouseScroll', MouseWheelHandler, false);\n    } else {\n        // IE 6/7/8\n        svgelement.attachEvent('onmousewheel', MouseWheelHandler);\n    }\n    svgelement.addEventListener(\n        'mousewheel',\n        function(e) {\n            console.log('event', e);\n        },\n        false\n    );\n}\n\n/**\n * convert a data object to JSON string or to a data URI containing a JSON string\n * @param  {Object}  data            object that will be serialized into a JSON string\n * @param  {Boolean} [pretty=false]  if `true`, the code will be proprerly indented, else a more compact syntax will be used\n * @param  {Boolean} [dataUri=false] return dataUri containing the JSON string instead of the pure JSON string\n * @return {string}\n */\nexport function getJSONString(data, pretty = false, dataUri = false) {\n    if (dataUri) {\n        return (\n            'data:application/json;charset=utf-8,' + encodeURIComponent(getJSONString(data, pretty))\n        );\n    } else {\n        if (pretty) return stringify(data, { maxLength: 50 });\n\n        return JSON.stringify(data);\n    }\n}\n\n/**\n * returns the Manhattan distance between the points _a_ and _b_\n * @param  {Object} a object containing numeric attributes `x` and `y`\n * @param  {Object} b object containing numeric attributes `x` and `y`\n * @return {number}\n */\nexport function manhattanDistance(a, b) {\n    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\n}\n","/** @module Id */\n\n/**\n * the current instance of Id\n * @type {Id}\n */\nlet existingIdInstance;\n\n/**\n * singleton to generate unique id's\n *\n * usage: `let id = new Id().unique`\n */\nexport default class Id {\n    constructor() {\n        if (!existingIdInstance) {\n            existingIdInstance = this;\n        }\n\n        /**\n         * prefix for the id, that is common in all the Ids\n         * @type {String}\n         */\n        this.prefix = 'id';\n\n        /**\n         * numeric part of the next id (the next id without the prefix)\n         * @type {number}\n         */\n        this.nextId = 0;\n\n        return existingIdInstance;\n    }\n\n    /**\n     * get unique ID\n     * @return {string} new unique ID\n     */\n    get unique() {\n        let retVal = this.prefix + this.nextId;\n\n        // find next unused idXXXX to prevent id collision that might be caused by some other component\n        // (it really should not happen, but this is a simple way to ensure it)\n        while ($('#' + retVal).length) {\n            this.nextId++;\n            retVal = this.generate();\n        }\n        // return this id\n        this.nextId++;\n\n        return retVal;\n    }\n}\n","/** @module MapWithDefaultValue */\n/**\n * Map that has a default value specified in the constructor.\n *\n * For the complete documentation of the Map see [Map in the MDN web docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\n *\n * Usage:\n * ```JavaScript\n let myMap = new MapWithDefaultValue(Infinity);\n const value = myMap.getWithDefault(key)\n ```\n *\n * _Note: This version is written specially for ES6 compiled into ES5. In non-compiled ES6 is the implementation far more elegant:_\n *\n * ```JavaScript\n export class MapWithDefaultValue extends Map {\n     constructor(defaultValue) {\n         super();\n\n         this.default = defaultValue;\n     }\n\n     get(key) {\n         if(this.has(key)) {\n             return super.get(key);\n         } else {\n             return this.default;\n         }\n     }\n }```\n * @class MapWithDefaultValue\n * @param defaultValue {any} default value that will be returned when the requested key is not found in the map\n */\nexport default function(defaultValue) {\n    let map = new Map();\n    /**\n     * @param  {any} key key of a requested item\n     * @return {any} value of the item with the corresponding key, or defaultValue if the key is not found in the map\n     */\n    map.getWithDefault = key => {\n        return map.has(key) ? map.get(key) : defaultValue;\n    };\n    return map;\n}\n","/** @module svgObjects */\n\n// non-svg classes used as helpers\nexport { default as PolyLinePoint } from './svgObjects/PolyLinePoint';\nexport { default as PolyLinePoints } from './svgObjects/PolyLinePoints';\n\n// virtual svg elements\nexport { default as Pattern } from './svgObjects/Pattern';\nexport { default as Group } from './svgObjects/Group';\n\n// \"physical/touchable\" svg elements\nexport { default as Rectangle } from './svgObjects/Rectangle';\nexport { default as SvgImage } from './svgObjects/SvgImage';\nexport { default as PolyLine } from './svgObjects/PolyLine';\n\nexport { default as Text } from './svgObjects/Text';\nexport { default as MultiLineText } from './svgObjects/MultiLineText';\n","import Tag from './Tag';\n\n/** @module svgObjects.Group */\n\n/**\n * SVG group, used for grouping elements, for example a gate is represented by many elements (rectangle, image, inivisible hitbox rectangle...),\n * but all of the elements need to be transformed together. Using groups the transform property can be set on the group which contains all the elements.\n * @extends Tag\n */\nexport default class Group extends Tag {\n    constructor() {\n        super('g');\n\n        this.children = [];\n    }\n\n    /**\n     * add an element to the group\n     * @param {SvgElement} el an instance of {@link SvgElement}\n     */\n    addChild(el) {\n        this.children.push(el);\n\n        this.$el.append(el.$el);\n        return el; // pro jednodussi \"let rect = g.addChild(new Rectangle(...\"\n    }\n}\n","import Tag from './Tag';\nimport Text from './Text';\n\n/** @module svgObjects.MultiLineText */\n\n/**\n * Multi line text element in SVG\n *\n * Multi line text is not natively supportend in SVG 1.1,\n * the workaround is to use the <foreignObject> element and display\n * a HTML paragraph inside of the SVG document.\n *\n * Because this technique is not supported by all of the browsers,\n * the foreignObject element is wrapped in <switch>, which\n * provides fallback for those cases.\n *\n * read more: [foreignObject on MDN web docs](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/foreignObject)\n *\n * @extends Tag\n */\nexport default class MultiLineText extends Tag {\n    /**\n     * @param {number} x       horizontal position in SVG pixels\n     * @param {number} y       vertical position in SVG pixels\n     * @param {number} w       width of the text box in SVG pixels\n     * @param {number} h       height of the text box in SVG pixels\n     * @param {number} text    text content of the text box\n     * @param {string} size    CSS font size of the text\n     * @param {String} [color=\"black\"] color of the text\n     *\n     */\n    constructor(x, y, w, h, text, size, color = 'black') {\n        super('switch');\n\n        let foreignObject = new Tag('foreignObject');\n        let alternativeText = new Text(x, y, w, h, text, size, color);\n\n        foreignObject.addAttr({\n            x,\n            y,\n            width: w,\n            height: h\n        });\n\n        let $wrapper = $('<div>')\n            .attr('xmlns', 'http://www.w3.org/1999/xhtml')\n            .addClass('multilinetext')\n            .css('height', h);\n\n        let $paragraph = $('<p>')\n            .attr('xmlns', 'http://www.w3.org/1999/xhtml')\n            .css('font-size', size)\n            .append(text);\n\n        $wrapper.append($paragraph);\n        foreignObject.$el.append($wrapper);\n\n        this.$el.append(foreignObject.$el).append(alternativeText.$el);\n    }\n}\n","import Tag from './Tag';\n\n/** @module svgObjects.Pattern */\n\n/**\n * pattern object in SVG\n * @extends Tag\n */\nexport default class Pattern extends Tag {\n    /**\n     * @param {string} id     unique id of this pattern\n     * @param {number} width  width of one pattern tile in SVG pixels\n     * @param {number} height height of one pattern tile in SVG pixels\n     */\n    constructor(id, width, height) {\n        super('pattern');\n\n        this.addAttr({\n            id: id,\n            x: 0,\n            y: 0,\n            width: width,\n            height: height,\n            patternUnits: 'userSpaceOnUse',\n            viewBox: '0 0 ' + width + ' ' + height\n        });\n    }\n\n    /**\n     * add a child to this pattern\n     *\n     * pattern behaves a little like {@link Group} - it contains child elements, which represent the content of one tile of the pattern\n     * and the whole package of the child elements is repeated on each tile of the pattern\n     * @param {SvgElement} el element that will be added to the pattern\n     */\n    addChild(el) {\n        this.$el.append(el.$el);\n        return el;\n    }\n}\n","import Tag from './Tag';\n\n/** @module svgObjects.PolyLine */\n\n/**\n * SVG PolyLine (a path defined by sequence of points on plane)\n * @extends Tag\n */\nexport default class PolyLine extends Tag {\n    /**\n     * @param {PolyLinePoints} points points describing this PolyLine\n     * @param {number} [strokeWidth] width of the stroke for this PolyLine in SVG pixels\n     * @param {string} [color] CSS color of this PolyLine\n     */\n    constructor(points, strokeWidth, color) {\n        super('PolyLine');\n\n        let attributes = {\n            points: points.string,\n            fill: 'none',\n            'stroke-width': strokeWidth\n        };\n\n        if (color !== undefined) {\n            attributes.stroke = color;\n        }\n\n        this.addAttr(attributes);\n    }\n\n    /**\n     * update points of this PolyLine\n     * @param {PolyLinePoints} points new set of points describing this PolyLine\n     */\n    updatePoints(points) {\n        this.addAttr({\n            points: points.string\n        });\n    }\n}\n","/** @module svgObjects.PolyLinePoint */\n\n/**\n * one point of {@link PolyLinePoints}, used in the {@link PolyLine} object\n */\nexport default class PolyLinePoint {\n    /**\n     * @param {number} x horizontal coordinate of the PolyLine point\n     * @param {number} y vertical coordinate of the PolyLine point\n     */\n    constructor(x, y) {\n        this.x = 0;\n        this.y = 0;\n        if (x !== undefined && y !== undefined) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    /**\n     * change the coordinates of this point\n     * @param {number} x horizontal coordinate of the PolyLine point\n     * @param {number} y vertical coordinate of the PolyLine point\n     */\n    set(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * create PolyLine from a comma separated string (e.g. from a string formatted like this: \"x,y\", for example \"15,8\")\n     * @param  {string} string string in the format \"x,y\" representing a point in the SVG PolyLine\n     * @return {PolyLinePoint} newly created instance of {@link PolyLinePoint}\n     */\n    static parseFromString(string) {\n        let arr = string.split(',');\n        return new PolyLinePoint(arr[0], arr[1]);\n    }\n\n    /**\n     * return a string representation of this PolyLine point\n     * @return {string} string in the format \"x,y\"\n     */\n    get string() {\n        return this.x + ',' + this.y;\n    }\n\n    /**\n     * compare PolyLine points, return `true` if they are equal, else return `false`\n     * @param  {PolyLinePoint} a\n     * @param  {PolyLinePoint} b\n     * @return {boolean}\n     */\n    static equals(a, b) {\n        return a.x === b.x && a.y === b.y;\n    }\n}\n","import PolyLinePoint from './PolyLinePoint';\n\n/** @module svgObjects.PolyLinePoints */\n\n/**\n * array-like structure used in {@link PolyLinePoints}\n */\nclass SmartArray {\n    /**\n     * @param {Array} [arr] if set, initialized SmartArray will contain these values\n     */\n    constructor(arr) {\n        if (arr !== undefined) {\n            this.arr = arr;\n        } else {\n            this.arr = [];\n        }\n    }\n\n    /**\n     * get a deep copy of this array\n     * @return {SmartArray}\n     */\n    copy() {\n        return SmartArray($.extend(true, [], this.arr));\n    }\n\n    /**\n     * append an item to the array\n     * @param item new item that will be appended to the array\n     */\n    append(item) {\n        return this.addWithIndex(item, this.arr.length);\n    }\n\n    /**\n     * prepend an item to the array\n     * @param item new item that will be prepended to the array\n     */\n    prepend(item) {\n        return this.addWithIndex(item, 0);\n    }\n\n    /**\n     * add a new item at the specified index, move all following items\n     * @param item new item that will be added at the specified index\n     * @param {number} index index of this item\n     */\n    addWithIndex(item, index) {\n        for (let i = this.arr.length; i > index; --i) {\n            this.arr[i] = this.arr[i - 1];\n        }\n        this.arr[index] = item;\n        return this; // to enable chaining of append / preppend / addWithIndex commands\n    }\n\n    /**\n     * get length of the array\n     * @return {number}\n     */\n    get length() {\n        return this.arr.length;\n    }\n\n    /**\n     * get item by index\n     * @param  {number} index index of the item\n     * @return contents of the array on the specified index\n     */\n    getItem(index) {\n        return this.arr[index];\n    }\n\n    /**\n     * @return last element of the array\n     */\n    get last() {\n        if (this.length !== 0) {\n            return this.arr[this.length - 1];\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @return first element of the array\n     */\n    get first() {\n        if (this.length !== 0) {\n            return this.arr[0];\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * remove an item from the array by index\n     * @param  {number} index index of the item that will be removed\n     */\n    remove(index) {\n        let length = this.length;\n\n        for (let i = index; i < length; ++i) {\n            this.arr[i] = this.arr[i + 1];\n        }\n        this.arr.pop();\n    }\n}\n\n/**\n * points of the {@link PolyLine}\n * @extends SmartArray\n */\nexport default class PolyLinePoints extends SmartArray {\n    /**\n     * @param {Array} [arr] array containing instances of {@link PolyLinePoint}\n     */\n    constructor(arr) {\n        super(arr);\n    }\n\n    /**\n     * get a deep copy of this object\n     * @return {PolyLinePoints}\n     */\n    copy() {\n        return new PolyLinePoints($.extend(true, [], this.arr));\n    }\n\n    /**\n     * append a point\n     * @param  {PolyLinePoint} point a new point\n     */\n    append(point) {\n        // call inherited function to handle the appending\n        super.append(point);\n\n        // if the second to last point is unnecessary, remove it\n        let length = this.length;\n        if (\n            length >= 3 &&\n            ((this.getItem(length - 3).x === this.getItem(length - 2).x &&\n                this.getItem(length - 2).x === this.getItem(length - 1).x) ||\n                (this.getItem(length - 3).y === this.getItem(length - 2).y &&\n                    this.getItem(length - 2).y === this.getItem(length - 1).y))\n        ) {\n            this.remove(length - 2);\n        }\n\n        // return this element (to allow chaining)\n        return this;\n    }\n\n    /**\n     * parse PolyLine from string\n     * @param  {string} string string in the PolyLine format (`x1,y1 x2,y2, x3,y3`)\n     * @return {PolyLinePoints} a new instance of {@link PolyLinePoints} created by parsing the string\n     */\n    static parseFromString(string) {\n        let pointStrings = string.split(' ');\n        let points = new PolyLinePoints();\n\n        for (let i = 0; i < pointStrings.length; ++i) {\n            points.append(PolyLinePoint.parseFromString(pointStrings[i]));\n        }\n\n        return points;\n    }\n\n    /**\n     * get a string representation of this PolyLine\n     * @return {string} string in the PolyLine format (`x1,y1 x2,y2, x3,y3`)\n     */\n    get string() {\n        let string = '';\n        for (let i = 0; i < this.length; ++i) {\n            if (i !== 0) {\n                string += ' ';\n            }\n            string += this.arr[i].string;\n        }\n        return string;\n    }\n\n    /**\n     * wrapper for foreach on the PolyLine points\n     * @param  {Function} func function that will be called on each element\n     */\n    forEach(func) {\n        for (let i = 0; i < this.arr.length; ++i) {\n            func(this.arr[i]);\n        }\n    }\n}\n","import SvgElement from './SvgElement';\n\n/** @module svgObjects.Rectangle */\n\n/**\n * a rectangle in SVG\n * @extends SvgElement\n */\nexport default class Rectangle extends SvgElement {\n    /**\n     * @param {number} x       horizontal position in SVG pixels\n     * @param {number} y       vertical position in SVG pixels\n     * @param {number} w       width in SVG pixels\n     * @param {number} h       height in SVG pixels\n     * @param {string} fill    filling color of the rectangle\n     * @param {string} stroke  stroke color of the rectangle\n     */\n    constructor(x, y, w, h, fill, stroke) {\n        super(x, y, w, h, 'rect');\n        this.addAttr({\n            fill: fill,\n            stroke: stroke,\n            'stroke-width': 0.5,\n            'pointer-events': 'all' // to trigger hover even with transparent background\n        });\n    }\n}\n","import Tag from './Tag';\n\n/** @module svgObjects.SvgElement */\n\n/**\n * represents visible element in SVG that has position and dimensions (for example `rectangle` is a SvgElement, but `pattern` is not, even though both are tags)\n * @extends Tag\n */\nexport default class SvgElement extends Tag {\n    /**\n     * @param {number} x       horizontal position in SVG pixels\n     * @param {number} y       vertical position in SVG pixels\n     * @param {number} w       width in SVG pixels\n     * @param {number} h       height in SVG pixels\n     * @param {string} tagName tag name of the element\n     */\n    constructor(x, y, w, h, tagName) {\n        super(tagName);\n\n        this.addAttr({\n            x: x,\n            y: y,\n            width: w,\n            height: h\n        });\n    }\n}\n","import SvgElement from './SvgElement';\n\n/** @module svgObjects.SvgImage */\n\n/**\n * an image in SVG\n * @extends SvgElement\n */\nexport default class SvgImage extends SvgElement {\n    constructor(x, y, w, h, url) {\n        super(x, y, w, h, 'image');\n        this.addAttr({\n            'xlink:href': url\n        });\n    }\n\n    /**\n     * change url of the image\n     * @param {string} url the new url of the image\n     */\n    changeUrl(url) {\n        this.addAttr({\n            'xlink:href': url\n        });\n    }\n}\n","import Id from '../other/id';\n\n/** @module svgObjects.Tag */\n\n/**\n * Parent class for all svgObjects\n */\nexport default class Tag {\n    /**\n     * @param {string} tagName SVG tag identifier (`rect`, `image`, `PolyLine`)\n     */\n    constructor(tagName) {\n        /**\n         * SVG tag identifier (`rect`, `image`, `PolyLine`)\n         * @type {string}\n         */\n        this.tagName = tagName;\n\n        /**\n         * jQuery element for this tag\n         * @type {jQuery.element}\n         */\n        this.$el = $('<' + this.tagName + '>');\n\n        /**\n         * unique ID of this SVG object\n         * @type {string}\n         */\n        this.id = new Id().unique;\n    }\n\n    /**\n     * add a class to this element\n     * @param {string} name class name to be added\n     */\n    addClass(name) {\n        this.$el.addClass(name);\n    }\n\n    /**\n     * remove class names from this element\n     * @param  {string} classes class names to be removed\n     */\n    removeClasses(...classes) {\n        for (let item of classes) {\n            this.$el.removeClass(item);\n        }\n    }\n\n    /**\n     * set attributes of this element\n     * @param {Object} assoc javascript object that will be mapped into attributes (`{key: value}` -> `key=\"value\"`)\n     */\n    addAttr(assoc) {\n        this.checkIfElementExistsInDOM();\n\n        // add attributes to the element\n        this.$el.attr(assoc);\n    }\n\n    /**\n     * get attribute value by name\n     * @param  {string} name name of the attribute\n     * @return {string}      value of the attribute\n     */\n    getAttr(name) {\n        this.checkIfElementExistsInDOM();\n\n        return this.$el.attr(name);\n    }\n\n    /**\n     * remove attribute by value\n     * @param  {string} name name of the attribute to be removed\n     */\n    removeAttr(name) {\n        this.checkIfElementExistsInDOM();\n\n        this.$el.removeAttr(name);\n    }\n\n    /**\n     * set id of this SVG object\n     * @param  {string} id new id for this object\n     */\n    set id(id) {\n        this.addAttr({ id: id });\n    }\n\n    /**\n     * get id of this SVG object\n     * @return {string}\n     */\n    get id() {\n        return this.getAttr('id');\n    }\n\n    /**\n     * get jQuery element for this SVG object\n     * @return {jQuery.element}\n     */\n    get() {\n        this.checkIfElementExistsInDOM();\n        return this.$el;\n    }\n\n    /**\n     * check if the element exists in dom, if so, refetch it from DOM using jQuery\n     */\n    checkIfElementExistsInDOM() {\n        let $jqElement = $('#' + this.$el.attr('id'));\n        if ($jqElement.length) {\n            this.$el = $jqElement;\n        }\n    }\n}\n","import Tag from './Tag';\n\n/** @module svgObjects.Text */\n\n/**\n * Text element in SVG\n * @extends Tag\n */\nexport default class Text extends Tag {\n    /**\n     * @param {number} x       horizontal position in SVG pixels\n     * @param {number} y       vertical position in SVG pixels\n     * @param {number} w       width of the text box in SVG pixels\n     * @param {number} h       height of the text box in SVG pixels\n     * @param {number} text    text content of the text box\n     * @param {string} size    CSS font size of the text\n     * @param {String} [color=\"black\"] color of the text\n     *\n     */\n    constructor(x, y, w, h, text, size, color = 'black') {\n        super('text');\n        this.addAttr({\n            x: x,\n            y: y,\n            width: w,\n            height: h,\n            fill: color\n        });\n\n        if (size) {\n            this.addAttr({\n                'font-size': size\n            });\n        }\n\n        this.$el.append(text);\n    }\n}\n","import { getLibrary, getNetworkFromLibrary } from './networkLibrary';\n\nimport { Gate } from '../editorElements';\n\n/**\n * Item in the [ContextMenu](./module-ContextMenu.html). ContextMenuItems can be nested using the appendItem function.\n */\nclass ContextMenuItem {\n    /**\n     * @param {string} text          text on the button\n     * @param {ContextMenu} contextMenu instance of the [ContextMenu](./module-ContextMenu.html) this item belongs to\n     * @param {Function} clickFunction callback function that will be called when user clicks this item\n     */\n    constructor(text, contextMenu, clickFunction) {\n        /**\n         * text on the button\n         * @type {string}\n         */\n        this.text = text;\n\n        /**\n         * instance of the [ContextMenu](./module-ContextMenu.html) this item belongs to\n         * @type {ContextMenu}\n         */\n        this.contextMenu = contextMenu;\n\n        /**\n         * jQuery element representing DOM content of this menu item\n         * @type {jQuery.element}\n         */\n        this.$el = $('<li>').text(text);\n\n        // set up click callback if clickFunction is defined\n        if (clickFunction !== undefined) {\n            $(this.$el).click(event => {\n                clickFunction();\n                contextMenu.hide();\n\n                event.stopPropagation();\n            });\n        }\n\n        /**\n         * jQuery element containing the submenu (or undefined, if item has no subitems)\n         * @type {jQuery.element}\n         */\n        this.$submenu = undefined;\n\n        /**\n         * submenu item counter\n         * @type {Number}\n         */\n        this.itemCount = 0;\n\n        // set hover callback\n        $(this.$el).hover(\n            event => {\n                // mouse on\n\n                if (this.length > 0) {\n                    this.$submenu.css({\n                        display: 'block',\n                        top: this.$el.offset().top,\n                        left: this.$el.parent().offset().left + this.$el.parent().width()\n                    });\n\n                    this.contextMenu.$el.after(this.$submenu);\n\n                    event.stopPropagation();\n                }\n            },\n            () => {\n                // mouse out\n                if (this.$submenu) {\n                    this.$submenu.css({\n                        display: 'none'\n                    });\n                }\n\n                // do not stop event propagation, here it is wanted\n                // (because submenu overrides display: none when user moves from this menu item to the submenu)\n            }\n        );\n    }\n\n    /**\n     * instance of [App](./module-App.html) this menu belongs to\n     * @type {App}\n     */\n    get appInstance() {\n        return this.contextMenu.appInstance;\n    }\n\n    /**\n     * number of items in the submenu\n     * @return {Number}\n     */\n    get length() {\n        return this.itemCount;\n    }\n\n    /**\n     * add a CSS class to this item\n     * @param {string} cls [description]\n     */\n    addClass(cls) {\n        this.$el.addClass(cls);\n        return this;\n    }\n\n    /**\n     * append a nested {@link ContextMenuItem} to this item\n     * @param  {ContextMenuItem} item item that will be appended\n     */\n    appendItem(item) {\n        if (!this.$submenu) {\n            this.$submenu = $('<ul>').addClass('subList');\n            this.$submenu.hover(\n                () => {\n                    this.$submenu.css('display', 'block');\n                },\n                () => {\n                    this.$submenu.css('display', 'none');\n                }\n            );\n        }\n        this.$submenu.append(item.$el);\n\n        this.itemCount++;\n\n        return item;\n    }\n\n    /**\n     * get jQuery element of this menu item\n     * @return {jQuery.element} jQuery element containing all DOM content for this menu item\n     */\n    get jQuery() {\n        return this.$el;\n    }\n\n    get jQuerySubmenu() {\n        return this.$submenu;\n    }\n}\n\n/**\n * Menu item that has a custom click callback function that adds a {@link Gate} of the specified type to the [App](./module-App.html)\n * @extends ContextMenuItem\n */\nclass GateMenuItem extends ContextMenuItem {\n    /**\n     * @param {string} type        type of the gate {@link Gate} (and, or, ...)\n     * @param {ContextMenu} contextMenu instance of the [ContextMenu](./module-ContextMenu.html) that this item belongs to\n     */\n    constructor(type, contextMenu) {\n        super(`${type.toUpperCase()} gate`, contextMenu, () => {\n            this.appInstance.newGate(\n                type,\n                this.appInstance.snapToGrid(\n                    this.appInstance.viewbox.transformX(contextMenu.position.x)\n                ),\n                this.appInstance.snapToGrid(\n                    this.appInstance.viewbox.transformY(contextMenu.position.y)\n                )\n            );\n        });\n    }\n}\n\n/**\n * Menu item that has a custom click callback function that adds a specified {@link Blackbox} to the [App](./module-App.html)\n * @extends ContextMenuItem\n */\nclass BlackboxMenuItem extends ContextMenuItem {\n    constructor(name, file, contextMenu) {\n        super(name, contextMenu, () => {\n            getNetworkFromLibrary(file)\n                .then(({ blackbox, name }) => {\n                    const { inputs, outputs, table } = blackbox;\n\n                    // use the name specified in the blackbox item, if it does not exist, use the name for the network\n                    let usedName = blackbox.name || name;\n\n                    this.appInstance.newBlackbox(\n                        inputs,\n                        outputs,\n                        table,\n                        usedName,\n                        this.appInstance.snapToGrid(\n                            this.appInstance.viewbox.transformX(contextMenu.position.x)\n                        ),\n                        this.appInstance.snapToGrid(\n                            this.appInstance.viewbox.transformY(contextMenu.position.y)\n                        )\n                    );\n                })\n                .catch(error => {\n                    console.error(error);\n                });\n        });\n    }\n}\n\n/**\n * Menu item that has a custom click callback function that adds a specified Network to the [App](./module-App.html)\n * @extends ContextMenuItem\n */\nclass NetworkMenuItem extends ContextMenuItem {\n    constructor(name, file, contextMenu) {\n        super(name, contextMenu, () => {\n            getNetworkFromLibrary(file)\n                .then(data => {\n                    this.appInstance\n                        .importData(\n                            data,\n                            Math.round(\n                                this.appInstance.viewbox.transformX(contextMenu.position.x) /\n                                    this.appInstance.gridSize\n                            ),\n                            Math.round(\n                                this.appInstance.viewbox.transformY(contextMenu.position.y) /\n                                    this.appInstance.gridSize\n                            )\n                        )\n                        .then(warnings => {\n                            for (const warning of warnings) {\n                                this.appInstance.messages.newWarningMessage(warning);\n                            }\n                        });\n                })\n                .catch(error => {\n                    this.appInstance.messages.newErrorMessage(error);\n                });\n        });\n    }\n}\n\n/** @module ContextMenu */\n/**\n * ContextMenu represents the menu that is displayed to the user when they right click on a canvas.\n * This menu allows user to add elements to the canvas and in the case that user rightclicked\n * on a specific element, this menu allows them to remove this element.\n */\nexport default class ContextMenu {\n    /**\n     * @param {App} appInstance instance of [App](./module-App.html) this menu belongs to\n     */\n    constructor(appInstance) {\n        /**\n         * instance of [App](./module-App.html) this menu belongs to\n         * @type {App}\n         */\n        this.appInstance = appInstance;\n\n        /**\n         * Position of the context menu. It is used to add the new elements to the correct position on the canvas.\n         * @type {Object}\n         */\n        this.position = {\n            x: 0,\n            y: 0\n        };\n\n        /**\n         * jQuery element containing the context menu\n         * @type {jQuery.element}\n         */\n        this.$el = $('<ul>');\n        this.$el.attr('id', 'contextMenu');\n\n        let special = new ContextMenuItem('Special elements', this);\n\n        // add input box\n        special.appendItem(\n            new ContextMenuItem('Input box', this, () => {\n                let position = {\n                    left: this.appInstance.snapToGrid(\n                        appInstance.viewbox.transformX(this.position.x)\n                    ),\n                    top: this.appInstance.snapToGrid(\n                        appInstance.viewbox.transformY(this.position.y)\n                    )\n                };\n\n                appInstance.newInput(position.left, position.top);\n            })\n        );\n\n        // add output box\n        special.appendItem(\n            new ContextMenuItem('Output box', this, () => {\n                let position = {\n                    left: this.appInstance.snapToGrid(\n                        appInstance.viewbox.transformX(this.position.x)\n                    ),\n                    top: this.appInstance.snapToGrid(\n                        appInstance.viewbox.transformY(this.position.y)\n                    )\n                };\n\n                appInstance.newOutput(position.left, position.top);\n            })\n        );\n\n        this.appendItem(special);\n\n        // list of gates that can be added\n        const gates = Gate.validGates;\n        let gateList = new ContextMenuItem('New gate', this, appInstance);\n        for (const name of gates) {\n            gateList.appendItem(new GateMenuItem(name, this));\n        }\n        this.appendItem(gateList);\n\n        // more options will be added in the getLibrary() callback below\n        let networkList = new ContextMenuItem('Add a network', this);\n        networkList.appendItem(\n            new ContextMenuItem('Paste a network', this, () => {\n                this.displayImportDialog();\n            })\n        );\n        this.appendItem(networkList); // always append\n\n        let blackboxList = new ContextMenuItem('Add a blackbox', this); // appends only if contains items (see the callback)\n\n        // network import (blackbox, network)\n        getLibrary()\n            .then(networks => {\n                for (const { name, file, hasTable, hasNetwork } of networks) {\n                    // add a network as a blackbox\n                    if (hasTable) {\n                        blackboxList.appendItem(new BlackboxMenuItem(name, file, this));\n                    }\n\n                    // load a network as a network of components connected with wires\n                    if (hasNetwork) {\n                        networkList.appendItem(new NetworkMenuItem(name, file, this));\n                    }\n                }\n\n                if (blackboxList.length > 0) {\n                    this.appendItem(blackboxList);\n                }\n            })\n            .catch(error => {\n                console.error(error);\n            });\n\n        // add conditional items for box and wire removal\n        this.appendConditionalItem('box', 'Remove this item', id => {\n            this.appInstance.removeBox(id);\n        });\n        this.appendConditionalItem('wire', 'Remove this wire', id => {\n            this.appInstance.removeWireById(id);\n        });\n\n        // add the context menu to the DOM\n        appInstance.$svg.before(this.$el);\n\n        /**\n         * Number of items in this menu (used in the .lenght getter). Conditional items do not count.\n         * @type {Number}\n         */\n        this.itemCount = 0;\n    }\n\n    get length() {\n        return this.itemCount;\n    }\n\n    /**\n     * append a context menu item to the context menu\n     * @param  {ContextMenuItem} item instance of {@link ContextMenuItem} that will be added to this menu\n     */\n    appendItem(item) {\n        this.$el.append(item.jQuery);\n\n        this.itemCount++;\n\n        return item;\n    }\n\n    /**\n     * appends an connditional item (that is shown only if the target has the class itemClass)\n     * @param  {string} itemClass     show the item only if the target has this class\n     * @param  {string} text          text of this menu item\n     * @param  {Function} clickFunction function with one argument (ID of the target) that will be called on click\n     */\n    appendConditionalItem(itemClass, text, clickFunction) {\n        if (!this.conditionalItems) {\n            this.conditionalItems = [];\n        }\n\n        this.conditionalItems[this.conditionalItems.length] = {\n            itemClass: itemClass,\n            text: text,\n            clickFunction: clickFunction\n        };\n    }\n\n    /**\n     * display the dialog for importing a network from a clipboard\n     */\n    displayImportDialog() {\n        let $popup = $('<div>')\n            .addClass('importExport')\n            .addClass('import');\n\n        let textareaId = 'importJSON';\n        let $textblock = $('<textarea>').attr('id', textareaId);\n\n        let lityInstance;\n\n        $popup.append($textblock).append(\n            $('<a>')\n                .attr({\n                    href: '#',\n                    class: 'upload'\n                })\n                .append($('<img>').attr('src', 'img/gui/import.svg'))\n                .append(' import from JSON')\n                .on('click', () => {\n                    let data;\n\n                    try {\n                        data = JSON.parse($('#' + textareaId).val());\n                    } catch (e) {\n                        this.appInstance.messages.newErrorMessage(\n                            'The imported file is not a valid JSON file.'\n                        );\n                        lityInstance.close();\n                    }\n\n                    if (data) {\n                        // proccess the imported data\n                        this.appInstance\n                            .importData(\n                                data,\n                                Math.round(\n                                    this.appInstance.viewbox.transformX(this.position.x) /\n                                        this.appInstance.gridSize\n                                ),\n                                Math.round(\n                                    this.appInstance.viewbox.transformY(this.position.y) /\n                                        this.appInstance.gridSize\n                                )\n                            )\n                            .then(warnings => {\n                                for (const warning of warnings) {\n                                    this.appInstance.messages.newWarningMessage(warning);\n                                }\n                            })\n                            .finally(() => {\n                                lityInstance.close();\n                            });\n                    }\n                })\n        );\n\n        lityInstance = lity($popup);\n\n        // focus on the textblock\n        $textblock.focus();\n    }\n\n    /**\n     * decide whether or not to display specific conditional items\n     * @param  {jQuery.element} $target jQuery target of a MouseEvent (element that user clicked on)\n     */\n    resolveConditionalItems($target) {\n        for (let item of this.conditionalItems) {\n            if ($target.hasClass(item.itemClass)) {\n                this.appendItem(\n                    new ContextMenuItem(item.text, this, () => {\n                        item.clickFunction($target.attr('id'));\n                    })\n                ).addClass('conditional');\n            }\n        }\n    }\n\n    /**\n     * hide all conditional items\n     */\n    hideAllConditionalItems() {\n        this.$el.children('.conditional').remove();\n    }\n\n    /**\n     * displays the context menu with the right set of conditional items\n     * @param  {number} x       horizontal position of the context menu in CSS pixels\n     * @param  {number} y       vertical position of the context menu in CSS pixels\n     * @param  {jQuery.element} $target jQuery target of a MouseEvent (element that user clicked on)\n     */\n    display(x, y, $target) {\n        this.position = {\n            x: x,\n            y: y\n        };\n\n        this.resolveConditionalItems($target);\n\n        this.$el\n            .css({\n                display: 'block',\n                top: y,\n                left: x\n            })\n            // set the width expicitly, or else the menu will widen when displaying a submenu\n            // 2 is to prevent a weird text wrap bug\n            .css('width', 'auto')\n            .css('width', this.$el.innerWidth() + 2);\n    }\n\n    /**\n     * hide the context menu\n     */\n    hide() {\n        this.$el.css({ display: 'none' });\n        $('.subList').css({ display: 'none' });\n        this.hideAllConditionalItems();\n    }\n}\n","import { getJSONString } from '../other/helperFunctions';\n\n/**\n * FloatingButton represents a button that is used in the floating menu in the right bottom corner\n * of the application. It may have a custom tooltip and callback on the click event\n */\nclass FloatingButton {\n    /**\n     * @param {string} buttonClass Custom string that identifies the SVG icon used on this button. This string is also added as a CSS class to the button.\n     * @param {string} tooltip     tooltip for the button, that will be displayed on hover and also used as alternative title for the image\n     * @param {Function} clickEvent  custom callback when user clicks the button\n     * @param {App} appInstance   reference to the parent SVG element\n     */\n    constructor(buttonClass, tooltip, clickEvent, appInstance) {\n        /**\n         * jQuery element representing the button\n         * @type {jQuery.element}\n         */\n        this.$el = $('<a>');\n\n        // add classes to the element\n        this.$el.addClass('button');\n        this.$el.addClass(buttonClass);\n\n        // add the icon\n        this.$el.append(\n            $('<img>')\n                .attr('src', `img/gui/${buttonClass}.svg`)\n                .attr('alt', tooltip)\n        );\n\n        // add the tooltip element and an event listener if tooltip is defined\n        if (tooltip) {\n            /**\n             * jQuery element representing the tooltip\n             * @type {jQuery.element}\n             */\n            this.$tooltip = $('<div>');\n            this.$tooltip.addClass('tooltip').html(tooltip);\n\n            appInstance.$svg.after(this.$tooltip);\n\n            this.$el.hover(\n                () => {\n                    this.$tooltip.fadeIn(200);\n                },\n                () => {\n                    this.$tooltip.fadeOut(200);\n                }\n            );\n        }\n\n        // add an event listener on click, if the callback function is defined\n        if (clickEvent) {\n            this.$el.on('click', clickEvent);\n        }\n    }\n}\n\n/** @module FloatingMenu */\n/**\n * Class to represent the floating menu in the right bottom corner of the page.\n * It instantiates all the buttons and their callbacks.\n */\nexport default class FloatingMenu {\n    /**\n     * @param {App} appInstance reference to the App element this menu is associated with\n     */\n    constructor(appInstance) {\n        /**\n         * the jQuery element containing all buttons\n         * @type {jQuery.element}\n         */\n        this.$el = $('<div>');\n\n        const id = 'floatingMenu';\n\n        this.$el.attr('id', id);\n\n        // const $loader = $(\"<div>\").addClass(\"loader\").addClass(\"hidden\");\n\n        /* EXPORT */\n        this.append(\n            new FloatingButton(\n                'export',\n                'Get code for this network',\n                () => {\n                    // create the popup container holding all popup content (that will be passed to lity)\n                    let $popup = $('<div>')\n                        .addClass('importExport')\n                        .addClass('export');\n\n                    // generate the block with code to be displayed and append it to the popup element\n                    const $textblock = $('<textarea>').text(\n                        getJSONString(appInstance.exportData, true)\n                    );\n\n                    $popup.append($textblock);\n\n                    // generate the links\n                    $popup.append(\n                        $('<a>')\n                            .attr({\n                                href: getJSONString(appInstance.exportData, true, true),\n                                class: 'download',\n                                download: 'network.json'\n                            })\n                            .append($('<img>').attr('src', 'img/gui/export.svg'))\n                            .append(' expanded JSON')\n                    );\n                    $popup.append(\n                        $('<a>')\n                            .attr({\n                                href: getJSONString(appInstance.exportData, false, true),\n                                class: 'download',\n                                download: 'network.min.json'\n                            })\n                            .append($('<img>').attr('src', 'img/gui/export.svg'))\n                            .append(' compact JSON')\n                    );\n\n                    lity($popup);\n\n                    // highlight the text in the textblock\n                    $textblock.select();\n                },\n                appInstance\n            )\n        );\n\n        /* Tutorial */\n        this.append(\n            new FloatingButton(\n                'tutorial',\n                'Start the tutorial',\n                () => {\n                    appInstance.startTutorial();\n                },\n                appInstance\n            )\n        );\n\n        appInstance.$svg.after(this.$el);\n\n        /* HELP */\n\n        let help = new FloatingButton('help', 'Display a help page', false, appInstance);\n        help.$el.attr({\n            href: './docs/user.html',\n            'data-lity': ''\n        });\n        this.append(help);\n\n        const github = new FloatingButton('github', 'Open the project repository', false, appInstance);\n        github.$el.attr({\n            href: 'https://github.com/janjaromirhorak/hradla',\n            target: '_blank'\n        });\n        this.append(github);\n\n        appInstance.$svg.after(this.$el);\n    }\n\n    /**\n     * append a FloatingButton to this menu\n     * @param  {FloatingButton} menuItem append an instance of  {@link FloatingButton} to this menu\n     */\n    append(menuItem) {\n        this.$el.append(menuItem.$el);\n    }\n}\n","/** @module Messages */\n\n/**\n * a generic message that can be displayed in the {@link Messages} box\n */\nclass Message {\n    /**\n     * @param {string} text               text of the message\n     * @param {Function} [onHide] a function that will be called when the `hide()` method is called\n     */\n    constructor(text, onHide) {\n        this.$el = $('<div>')\n            .addClass('message')\n            .text(text);\n\n        /**\n         * callback function that will be called when the `hide()` method is called\n         * @type {Function}\n         */\n        this.onHide = onHide;\n    }\n\n    /**\n     * hide the message (and call the onHide callback if there is any)\n     */\n    hide() {\n        this.$el.remove();\n\n        if (this.onHide) {\n            this.onHide();\n        }\n    }\n}\n\n/**\n * a loading message that can be displayed in the {@link Messages} box\n * @extends Message\n */\nclass LoadingMessage extends Message {\n    constructor(text, onHide = undefined) {\n        super(text, onHide);\n\n        this.$el.addClass('loading');\n    }\n}\n\n/**\n * a message that has a close button and that can be displayed in the {@link Messages} box\n * @extends Message\n */\nclass ClosableMessage extends Message {\n    constructor(text, onHide = undefined) {\n        super(text, onHide);\n\n        this.$el.append(\n            $('<span>')\n                .addClass('close')\n                .click(() => {\n                    this.hide();\n                })\n        );\n    }\n}\n\n/**\n * an error message that can be displayed in the {@link Messages} box\n * @extends ClosableMessage\n */\nclass ErrorMessage extends ClosableMessage {\n    constructor(text, onHide = undefined) {\n        super(text, onHide);\n\n        this.$el.addClass('error');\n    }\n}\n\n/**\n * a warning message that can be displayed in the {@link Messages} box\n * @extends ClosableMessage\n */\nclass WarningMessage extends ClosableMessage {\n    constructor(text, onHide = undefined) {\n        super(text, onHide);\n\n        this.$el.addClass('warning');\n    }\n}\n\n/**\n * display messages to the user in a nice UI\n */\nexport default class Messages {\n    constructor() {\n        /**\n         * jQuery element that represents the message interface. This element contains all the currently displayed messages.\n         * @type {jQuery.element}\n         */\n        this.$el = $('<div>').addClass('messages');\n\n        /**\n         * number of currently displayed messages, has a specified setter and getter\n         * @type {number}\n         */\n        this.count = 0;\n\n        // place the progress info element\n        $('body').append(this.$el);\n    }\n\n    /**\n     * get the number of currently displayed messages\n     * @return {number} [description]\n     */\n    get count() {\n        return this.messageCount;\n    }\n\n    /**\n     * Set the number of currently displayed messages. Should be called only through functions that add messages.\n     *\n     * If the message count is >= 1, the jQuery element for the UI is displayed, if the message count is <1, the UI is hidden.\n     * @param  {number} value [description]\n     * @return {number}       [description]\n     */\n    set count(value) {\n        this.messageCount = value;\n\n        if (this.messageCount < 1) {\n            this.hide();\n        } else {\n            this.display();\n        }\n    }\n\n    /**\n     * hide the message box by adding a `hidden` class to the element\n     */\n    hide() {\n        this.$el.addClass('hidden');\n    }\n\n    /**\n     * display the message box by removing the `hidden` class to the element\n     */\n    display() {\n        this.$el.removeClass('hidden');\n    }\n\n    /**\n     * add a new message to the message box\n     * @param  {string} text             text of the message\n     * @param  {Message} [constr=Message] constructor of the message, must be a derivate of the {@link Message} class\n     * @return {Message}                  the newly constructed message (instance made by the specified constructor)\n     */\n    newMessage(text, constr = Message) {\n        // Create the message by calling the constructor,\n        // provide it with text and a callback function that will be called when hiding the message.\n        // This callback subtracts 1 from the\n        let message = new constr(text, () => {\n            this.count--;\n        });\n\n        this.$el.append(message.$el);\n        this.count++;\n\n        return message;\n    }\n\n    /**\n     * create a new loading message and add it to the message box\n     * @param  {string} text text of the message\n     * @return {LoadingMessage} the newly constructed {@link LoadingMessage}\n     */\n    newLoadingMessage(text) {\n        return this.newMessage(text, LoadingMessage);\n    }\n\n    /**\n     * create a new error message and add it to the message box\n     * @param  {string} text text of the message\n     * @return {ErrorMessage} the newly constructed {@link ErrorMessage}\n     */\n    newErrorMessage(text) {\n        return this.newMessage(text, ErrorMessage);\n    }\n\n    /**\n     * create a new warning message and add it to the message box\n     * @param  {string} text text of the message\n     * @return {WarningMessage} the newly constructed {@link WarningMessage}\n     */\n    newWarningMessage(text) {\n        return this.newMessage(text, WarningMessage);\n    }\n}\n","/** @module Tutorial */\n/**\n * Display and manage the tutorial\n */\nexport default class Tutorial {\n    /**\n     * @param {App} appInstance instance of [App](./module-App.html) for this tutorial\n     * @param {Function} [onTutorialClosed] callback function when user closes or finishes the tutorial\n     */\n    constructor(appInstance, onTutorialClosed) {\n        /**\n         * instance of [App](./module-App.html) for this tutorial\n         * @type {App}\n         */\n        this.appInstance = appInstance;\n\n        /**\n         * helper variable for the `step` property, stores current state of the tutorial (step `0` means that tutorial is closed)\n         * @type {Number}\n         */\n        this.currentStep = 0;\n\n        /**\n         * jQuery element containing the tutorial popup\n         * @type {jQuery.element}\n         */\n        this.$tutorialWindow;\n        /**\n         * jQuery element for the dynamic part of the tutorial popup\n         * (text and buttons that are dependent on the current state of the tutorial)\n         * @type {Array}\n         */\n        this.$tutorialContent;\n\n        /**\n         * array of functions that represent intividual steps in the tutorial\n         * by default populated with step `0` that closes the tutorial\n         * @type {Array}\n         */\n        this.steps = [\n            () => {\n                this.closeWindow(onTutorialClosed);\n            }\n        ];\n\n        // set up the tutorial\n        this.setUpTutorial();\n    }\n\n    /**\n     * get the current step of the tutorial, this number corresponds to the index in the `this.steps` array\n     * that contains the function for the last displayed step\n     * @return {Number}\n     */\n    get step() {\n        return this.currentStep;\n    }\n\n    /**\n     * change the current step of the tutorial, `0` means \"stop the tutorial\"\n     * @param  {Number} value the step of the tutorial to be displayed\n     */\n    set step(value) {\n        // reset all hooks\n        this.resetHooks();\n\n        this.currentStep = value;\n\n        if (this.step < this.steps.length) {\n            this.steps[this.step]();\n\n            if (this.step === 1) this.displayWindow();\n        } else {\n            this.step = 0;\n        }\n    }\n\n    /**\n     * reset all tutorial hooks\n     */\n    resetHooks() {\n        /**\n         * _tutorial hook_, called when the context menu is opened\n         */\n        this.onContextMenuOpened = () => {};\n\n        /**\n         * _tutorial hook_, called when a new element is added\n         */\n        this.onElementAdded = () => {};\n\n        /**\n         * _tutorial hook_, called when a box is moved\n         */\n        this.onBoxMoved = () => {};\n\n        /**\n         * _tutorial hook_, called when a box is rotated\n         */\n        this.onBoxRotated = () => {};\n\n        /**\n         * _tutorial hook_, called when an output box value is set to `on`\n         */\n        this.onOutputBoxTrue = () => {};\n\n        /**\n         * _tutorial hook_, called when the canvas is moved\n         */\n        this.onCanvasMoved = () => {};\n\n        /**\n         * _tutorial hook_, called when the canvas is zoomed\n         */\n        this.onCanvasZoomed = () => {};\n\n        /**\n         * _tutorial hook_, called when a box is removed\n         */\n        this.onElementRemoved = () => {};\n\n        /**\n         * _tutorial hook_, called when user changes the state of an input box\n         */\n        this.onChangeInputBoxState = () => {};\n    }\n\n    /**\n     * set up the tutorial: reset all tutorial hooks and define the order of tutorial steps\n     */\n    setUpTutorial() {\n        this.resetHooks();\n\n        this.steps.push(\n            () => {\n                this.stepWelcome();\n            },\n            () => {\n                this.stepAddBoxes();\n            },\n            () => {\n                this.stepMoveCanvas();\n            },\n            () => {\n                this.stepZoomCanvas();\n            },\n            () => {\n                this.stepMoveBoxes();\n            },\n            () => {\n                this.stepWiring();\n            },\n            () => {\n                this.switchInputBox();\n            },\n            () => {\n                this.stepRemoveBox();\n            },\n            () => {\n                this.stepFinish();\n            }\n        );\n    }\n\n    /**\n     * _tutorial step_: display context menu\n     */\n    stepWelcome() {\n        this.windowContent(\n            `Welcome to Hradla! To get started, click anywhere on the editing area with your right mouse button.`\n        );\n\n        this.onContextMenuOpened = () => {\n            this.next();\n        };\n    }\n\n    /**\n     * _tutorial step_: add input box, output box and a NOT gate\n     */\n    stepAddBoxes() {\n        this.windowContent(\n            `Great job! Now you know, how to open the editor menu.\n            Now try to add an <em>Input box</em>, <em>Output box</em> and a <em>NOT gate</em>\n            to the editing area.`\n        );\n\n        let elementsAdded = {\n            inputBox: false,\n            outputBox: false,\n            notGate: false\n        };\n\n        this.onElementAdded = name => {\n            switch (name) {\n                case 'input':\n                    elementsAdded.inputBox = true;\n                    break;\n                case 'output':\n                    elementsAdded.outputBox = true;\n                    break;\n                case 'not':\n                    elementsAdded.notGate = true;\n                    break;\n                default:\n                    // no action on default\n                    break;\n            }\n\n            if (elementsAdded.inputBox && elementsAdded.outputBox && elementsAdded.notGate) {\n                // proceed to the next step of the tutorial\n                this.next();\n            }\n        };\n    }\n\n    /**\n     * _tutorial step_: move the canvas\n     */\n    stepMoveCanvas() {\n        this.windowContent(\n            `You can move the editing area (sometimes called canvas) by dragging\n            with the middle mouse button or by holding the <code>Ctrl</code> key\n            and dragging with the left mouse button. Check it out.`\n        );\n\n        this.onCanvasMoved = () => {\n            this.next();\n        };\n    }\n\n    /**\n     * _tutorial step_: zoom the canvas\n     */\n    stepZoomCanvas() {\n        this.windowContent(\n            `You can also zoom in and out using the mouse wheel\n            or with the <code>+</code>&nbsp;and <code>−</code>&nbsp;keys.`\n        );\n\n        this.onCanvasZoomed = () => {\n            this.next();\n        };\n    }\n\n    /**\n     * _tutorial step_: move the boxes\n     */\n    stepMoveBoxes() {\n        this.windowContent(`You can move the elements on the editing canvas by dragging them\n            using the left mouse button. You can also rotate them using middle click. Try it out.`);\n\n        let boxMoved = false;\n        let boxRotated = false;\n\n        let moveRotateCallback = () => {\n            if (boxMoved && boxRotated) {\n                this.next();\n            }\n        };\n\n        this.onBoxMoved = () => {\n            boxMoved = true;\n            moveRotateCallback();\n        };\n\n        this.onBoxRotated = () => {\n            boxRotated = true;\n            moveRotateCallback();\n        };\n    }\n\n    /**\n     * _tutorial step_: create an invertor\n     */\n    stepWiring() {\n        this.windowContent(\n            `Essential part of logic networks is the wiring. Create a very simple\n            inverter by connecting the <em>Input box</em> to the input of the <em>NOT gate</em>\n            and the output of the <em>NOT gate</em> to the input of the <em>Output box</em>.`,\n            `To connect two elemnts, simply click on a connector of the first element,\n            than click on a conector of the second element.`\n        );\n\n        this.onOutputBoxTrue = () => {\n            this.next();\n        };\n    }\n\n    /**\n     * _tutorial step_: change the state of an input box\n     */\n    switchInputBox() {\n        this.windowContent(`\n            The input boxes can be in two states: <em>ON</em> and <em>OFF</em>, signalled\n            by the green and red colors respectively. You can left click on an Input box to\n            switch its state. Try it out!\n        `);\n\n        this.onChangeInputBoxState = () => {\n            this.next();\n        };\n    }\n\n    /**\n     * _tutorial step_: remove a box\n     */\n    stepRemoveBox() {\n        this.windowContent(\n            `When you right click on an element, you can find a new item in the menu,\n            that allows you to remove the element. This works for wires as well as for gates and other types of boxes.\n            Try to remove an element!`\n        );\n\n        this.onElementRemoved = () => {\n            this.next();\n        };\n    }\n\n    /**\n     * _tutorial step_: ask the user if they want to clean the canvas before closing the tutorial\n     */\n    stepFinish() {\n        this.windowContent(\n            `You're all set, enjoy your stay!`,\n            `Do you wish to start with empty canvas?`\n        );\n        this.windowChoice(\n            {\n                text: 'yes, clean the canvas',\n                func: () => {\n                    this.appInstance.cleanCanvas();\n                    this.stop();\n                }\n            },\n            {\n                text: 'no, keep the canvas as it is',\n                func: () => {\n                    this.stop();\n                }\n            }\n        );\n    }\n\n    /**\n     * display the tutorial window\n     */\n    displayWindow() {\n        this.appInstance.$svg.after(this.$tutorialWindow);\n    }\n\n    /**\n     * close the tutorial window\n     * @param  {Function} [onTutorialClosed] callback function that is called when the tutorial is closed\n     */\n    closeWindow(onTutorialClosed) {\n        this.$tutorialWindow.remove();\n\n        if (onTutorialClosed !== undefined) {\n            onTutorialClosed();\n        }\n    }\n\n    /**\n     * set the tutorial window text content\n     * @param  {...string} text each string is a separate paragraph\n     */\n    windowContent(...text) {\n        if (!this.$tutorialWindow) {\n            this.$tutorialWindow = $('<div>').attr('id', 'tutorial');\n\n            this.$topButtonsLeft = $('<div>').addClass('left');\n\n            this.$tutorialWindow.append(\n                $('<div>')\n                    .addClass('topButtons')\n                    .append(this.$topButtonsLeft)\n                    .append(\n                        // the .right div can be added here because it is not modified during the tutorial\n                        $('<div>')\n                            .addClass('right')\n                            .append(\n                                $('<a>')\n                                    .attr({\n                                        href: '#',\n                                        title: 'close tutorial'\n                                    })\n                                    .addClass('button close')\n                                    .click(() => {\n                                        this.stop();\n                                    })\n                            )\n                    )\n            );\n\n            this.$tutorialWindow.append(this.$topButtons);\n\n            this.$tutorialContent = $('<div>').addClass('content');\n            this.$tutorialWindow.append(this.$tutorialContent);\n        }\n\n        this.$topButtonsLeft.html('');\n\n        let $prev = $('<a>')\n            .attr({\n                href: '#',\n                title: 'go back'\n            })\n            .addClass('button prev');\n\n        if (this.step > 1) {\n            $prev.click(() => {\n                this.prev();\n            });\n        } else {\n            $prev.addClass('disabled');\n        }\n\n        let $next = $('<a>')\n            .attr({\n                href: '#',\n                title: 'go forward'\n            })\n            .addClass('button next');\n\n        if (this.step < this.steps.length - 1) {\n            $next.click(() => {\n                this.next();\n            });\n        } else {\n            $next.addClass('disabled');\n        }\n\n        this.$topButtonsLeft.append($prev).append($next);\n\n        // set the text content\n\n        this.$tutorialContent.html('');\n        for (const paragraph of text) {\n            this.$tutorialContent.append($('<p>').html(paragraph));\n        }\n\n        // // render the buttons in each step (to remove focus and to\n        // // ensure there is no \"back\" button on the first step or \"next\" button on the last step)\n        // if(this.$prevNext) {\n        //     this.$prevNext.remove();\n        // }\n        //\n        // this.$prevNext = $(\"<div>\").addClass(\"bottomButtons\");\n        //\n        // if(this.step>1) {\n        //     this.$prevNext.append(\n        //         $(\"<a>\").attr(\"href\", \"#\").addClass(\"button prev\")\n        //         // .text(\"back\")\n        //         .click(() => {\n        //             this.step--;\n        //         })\n        //     )\n        // }\n        //\n        // if(this.step < this.steps.length - 1) {\n        //     this.$prevNext.append(\n        //         $(\"<a>\").attr(\"href\", \"#\").addClass(\"button next\")\n        //         // .text(\"next\")\n        //         .click(() => {\n        //             this.next();\n        //         })\n        //     )\n        // }\n        //\n        // this.$tutorialWindow.append(this.$prevNext);\n    }\n\n    /**\n     * add buttons with choices to the tutorial window\n     * @param  {...object} choices each choice is an object in with a `string` property _text_ and a `function` property _func_\n     */\n    windowChoice(...choices) {\n        let $choices = $('<ol>').addClass('choices');\n        for (const choice of choices) {\n            $choices.append(\n                $('<li>').append(\n                    $('<a>')\n                        .attr('href', '#')\n                        .click(() => {\n                            choice.func();\n                        })\n                        .html(choice.text)\n                )\n            );\n        }\n        this.$tutorialContent.append($choices);\n    }\n\n    /**\n     * start the tutorial\n     */\n    start() {\n        this.step = 1;\n    }\n\n    /**\n     * go to the next step of the tutorial\n     */\n    next() {\n        this.step++;\n    }\n\n    /**\n     * go to the previous step of the tutorial\n     */\n    prev() {\n        this.step--;\n    }\n\n    /**\n     * stop the tutorial\n     */\n    stop() {\n        this.step = 0;\n    }\n}\n","/** @module ViewBox */\n/**\n * ViewBox provides an api for oprerating with the viewBox argument of the <svg> DOM element.\n */\nexport default class ViewBox {\n    /**\n     * Initialize viewBox\n     * @param {number} left   distance of the left edge of the viewbox from document's y axis in SVG pixels\n     * @param {number} top    distance of the top edge of the viewbox from the document's x axis in SVG pixels\n     * @param {number} width  width of the viewbox in SVG pixels\n     * @param {number} height height of the viewbox in SVG pixels\n     */\n    constructor(left, top, width, height) {\n        /**\n         * ViewBox attributes before applying zoom and shift\n         * @type {object}\n         */\n        this.real = { left, top, width, height };\n\n        /**\n         * The maximum amount of zoom on the viewbox\n         * @type {number}\n         */\n        this.maxZoom = 8;\n        /**\n         * The minimum amount of zoom on the viewbox\n         * @type {number}\n         */\n        this.minZoom = 0.1;\n\n        /**\n         * Amount of zoom on the viewbox, always between this.minZoom and this.maxZoom\n         * @type {number}\n         */\n        this.realZoom = 1;\n\n        /**\n         * amount of horizontal shift of the document\n         * @type {number}\n         */\n        this.leftShift = 0;\n        /**\n         * amount of vertical shift of the document\n         * @type {number}\n         */\n        this.topShift = 0;\n    }\n\n    /**\n     * update the dimensions of the viewbox (used on window resize)\n     * @param  {Number} width  new width of the viewbox in SVG pixels\n     * @param  {Number} height new height of the viewbox in SVG pixels\n     */\n    newDimensions(width, height) {\n        // keep the viewbox centered\n        this.real.left += (this.real.width - width) / 2;\n        this.real.top += (this.real.height - height) / 2;\n\n        // update the dimensions\n        this.real.width = width;\n        this.real.height = height;\n    }\n\n    /**\n     * apply viewbox movement and take the zoom into account\n     * @param  {number} left horizontal movement\n     * @param  {number} top  vertical movement\n     */\n    move(left, top) {\n        this.leftShift += left / this.zoom;\n        this.topShift += top / this.zoom;\n    }\n\n    /**\n     * get the amount of zoom on the viewbox\n     * @return {number}\n     */\n    get zoom() {\n        return this.realZoom;\n    }\n\n    /**\n     * set the amount of zoom on the viewbox\n     * @param {number} value the new amount of zoom\n     */\n    set zoom(value) {\n        // fit this.realZoom to fit between this.minZoom and this.maxZoom\n        this.realZoom = Math.max(Math.min(value, this.maxZoom), this.minZoom);\n    }\n\n    /**\n     * get the width of the viewbox with the current zoom applied\n     * @return {number} the final width of the viewbox\n     */\n    get width() {\n        return this.real.width / this.zoom;\n    }\n\n    /**\n     * get the height of the viewbox with the current zoom applied\n     * @return {number} the final height of the viewbox\n     */\n    get height() {\n        return this.real.height / this.zoom;\n    }\n\n    /**\n     * get the horizontal distance from the y axis of the document with zoom and shift value applied\n     * @return {number}\n     */\n    get left() {\n        return this.real.left - this.leftShift + (this.real.width - this.width) / 2;\n    }\n\n    /**\n     * get the vertical distance from the x axis of the document with zoom and shift value applied\n     * @return {number}\n     */\n    get top() {\n        return this.real.top - this.topShift + (this.real.height - this.height) / 2;\n    }\n\n    /**\n     * get the computed viewbox values as a string in the correct format that can be used in the viewBox attribute of the SVG element\n     * @return {string} string in format \"left top width height\"\n     */\n    get str() {\n        return `${this.left} ${this.top} ${this.width} ${this.height}`;\n    }\n\n    /**\n     * transform horizontal units to the scale and shift of the editor\n     * @param  {number} x original horizontal value\n     * @return {number}   transformed horizontal value\n     */\n    transformX(x) {\n        return this.left + x / this.zoom;\n    }\n\n    /**\n     * transform vertical units to the scale and shift of the editor\n     * @param  {number} y original vertical value\n     * @return {number}   transformed vertical value\n     */\n    transformY(y) {\n        return this.top + y / this.zoom;\n    }\n\n    /**\n     * transform pageX and pageY parameters of the jquery event to match the zoom and shift of the viewbox\n     * @param  {jquery.MouseEvent} event original event\n     * @return {jquery.MouseEvent}       the same event but with transformed pageX and pageY members\n     */\n    transformEvent(event) {\n        event.pageX = this.transformX(event.pageX);\n        event.pageY = this.transformY(event.pageY);\n\n        return event;\n    }\n}\n","/**\n * @module Library\n */\n\nconst libraryDir = './library/';\n\n/**\n * get list of networks from the library\n * @return {Promise} promise, the resolution is an object containing a list of libraries\n */\nexport function getLibrary() {\n    return new Promise((resolve, reject) => {\n        const libraryFile = libraryDir + 'networkList.json';\n\n        let request = new XMLHttpRequest();\n\n        request.addEventListener('load', function() {\n            if (this.response) {\n                resolve(this.response.networks);\n            }\n        });\n\n        request.addEventListener(['error', 'abort'], () => {\n            reject('Failed loading libraries.');\n        });\n\n        request.open('GET', libraryFile, true);\n        request.responseType = 'json';\n        request.send();\n    });\n}\n\n/**\n * get a network from the library, specified by filename\n * @param  {string} networkName library file name without the extension\n * @return {Promise} promise, the resolution is an object containing the library import data\n */\nexport function getNetworkFromLibrary(networkName) {\n    return new Promise((resolve, reject) => {\n        let request = new XMLHttpRequest();\n\n        request.addEventListener('load', function() {\n            if (this.response) {\n                resolve(this.response);\n            }\n        });\n\n        request.addEventListener(['error', 'abort'], () => {\n            reject(`Failed loading library ${networkName}.`);\n        });\n\n        request.open('GET', libraryDir + networkName + '.json', true);\n        request.responseType = 'json';\n        request.send();\n    });\n}\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvanNvbi1zdHJpbmdpZnktcHJldHR5LWNvbXBhY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL0RvdWJseUxpbmtlZExpc3QuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL0hlYXAuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL01heEhlYXAuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL01pbkhlYXAuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL1ByaW9yaXR5UXVldWUuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL1F1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL2xpYnN0bC9EYXRhc3RydWN0dXJlcy9TdGFjay5qcyIsIm5vZGVfbW9kdWxlcy9saWJzdGwvbm9kZS1tb2R1bGUuanMiLCJzcmMvZXM2L21haW4uanMiLCJzcmMvZXM2L21vZHVsZXMvQXBwLmpzIiwic3JjL2VzNi9tb2R1bGVzL0xvZ2ljLmpzIiwic3JjL2VzNi9tb2R1bGVzL1NpbXVsYXRpb24uanMiLCJzcmMvZXM2L21vZHVsZXMvZWRpdG9yRWxlbWVudHMuanMiLCJzcmMvZXM2L21vZHVsZXMvZWRpdG9yRWxlbWVudHMvQmxhY2tib3guanMiLCJzcmMvZXM2L21vZHVsZXMvZWRpdG9yRWxlbWVudHMvQm94LmpzIiwic3JjL2VzNi9tb2R1bGVzL2VkaXRvckVsZW1lbnRzL0Nvbm5lY3Rvci5qcyIsInNyYy9lczYvbW9kdWxlcy9lZGl0b3JFbGVtZW50cy9HYXRlLmpzIiwic3JjL2VzNi9tb2R1bGVzL2VkaXRvckVsZW1lbnRzL0hlbHBlcldpcmUuanMiLCJzcmMvZXM2L21vZHVsZXMvZWRpdG9yRWxlbWVudHMvSW5wdXRCb3guanMiLCJzcmMvZXM2L21vZHVsZXMvZWRpdG9yRWxlbWVudHMvSW5wdXRDb25uZWN0b3IuanMiLCJzcmMvZXM2L21vZHVsZXMvZWRpdG9yRWxlbWVudHMvTmV0d29ya0VsZW1lbnQuanMiLCJzcmMvZXM2L21vZHVsZXMvZWRpdG9yRWxlbWVudHMvT3V0cHV0Qm94LmpzIiwic3JjL2VzNi9tb2R1bGVzL2VkaXRvckVsZW1lbnRzL091dHB1dENvbm5lY3Rvci5qcyIsInNyYy9lczYvbW9kdWxlcy9lZGl0b3JFbGVtZW50cy9UcmFuc2Zvcm0uanMiLCJzcmMvZXM2L21vZHVsZXMvZWRpdG9yRWxlbWVudHMvV2lyZS5qcyIsInNyYy9lczYvbW9kdWxlcy9lZGl0b3JFbGVtZW50cy9zdGF0ZUNsYXNzZXMuanMiLCJzcmMvZXM2L21vZHVsZXMvZmluZFBhdGguanMiLCJzcmMvZXM2L21vZHVsZXMvb3RoZXIvaGVscGVyRnVuY3Rpb25zLmpzIiwic3JjL2VzNi9tb2R1bGVzL290aGVyL2lkLmpzIiwic3JjL2VzNi9tb2R1bGVzL290aGVyL21hcFdpdGhEZWZhdWx0VmFsdWUuanMiLCJzcmMvZXM2L21vZHVsZXMvc3ZnT2JqZWN0cy5qcyIsInNyYy9lczYvbW9kdWxlcy9zdmdPYmplY3RzL0dyb3VwLmpzIiwic3JjL2VzNi9tb2R1bGVzL3N2Z09iamVjdHMvTXVsdGlMaW5lVGV4dC5qcyIsInNyYy9lczYvbW9kdWxlcy9zdmdPYmplY3RzL1BhdHRlcm4uanMiLCJzcmMvZXM2L21vZHVsZXMvc3ZnT2JqZWN0cy9Qb2x5TGluZS5qcyIsInNyYy9lczYvbW9kdWxlcy9zdmdPYmplY3RzL1BvbHlMaW5lUG9pbnQuanMiLCJzcmMvZXM2L21vZHVsZXMvc3ZnT2JqZWN0cy9Qb2x5TGluZVBvaW50cy5qcyIsInNyYy9lczYvbW9kdWxlcy9zdmdPYmplY3RzL1JlY3RhbmdsZS5qcyIsInNyYy9lczYvbW9kdWxlcy9zdmdPYmplY3RzL1N2Z0VsZW1lbnQuanMiLCJzcmMvZXM2L21vZHVsZXMvc3ZnT2JqZWN0cy9TdmdJbWFnZS5qcyIsInNyYy9lczYvbW9kdWxlcy9zdmdPYmplY3RzL1RhZy5qcyIsInNyYy9lczYvbW9kdWxlcy9zdmdPYmplY3RzL1RleHQuanMiLCJzcmMvZXM2L21vZHVsZXMvdWkvQ29udGV4dE1lbnUuanMiLCJzcmMvZXM2L21vZHVsZXMvdWkvRmxvYXRpbmdNZW51LmpzIiwic3JjL2VzNi9tb2R1bGVzL3VpL01lc3NhZ2VzLmpzIiwic3JjL2VzNi9tb2R1bGVzL3VpL1R1dG9yaWFsLmpzIiwic3JjL2VzNi9tb2R1bGVzL3VpL1ZpZXdCb3guanMiLCJzcmMvZXM2L21vZHVsZXMvdWkvbmV0d29ya0xpYnJhcnkuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTJCLE9BQS9DLEVBQXdELElBQXhEO0FBQ0EsZ0JBQVEsWUFBUixHQUF1QixNQUF2QjtBQUNBLGdCQUFRLElBQVI7QUFDSCxLQWhCTSxDQUFQO0FBaUJIIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiZnVuY3Rpb24gc3RyaW5naWZ5IChvYmosIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdmFyIGluZGVudCA9IEpTT04uc3RyaW5naWZ5KFsxXSwgbnVsbCwgZ2V0KG9wdGlvbnMsICdpbmRlbnQnLCAyKSkuc2xpY2UoMiwgLTMpXG4gIHZhciBhZGRNYXJnaW4gPSBnZXQob3B0aW9ucywgJ21hcmdpbnMnLCBmYWxzZSlcbiAgdmFyIG1heExlbmd0aCA9IChpbmRlbnQgPT09ICcnID8gSW5maW5pdHkgOiBnZXQob3B0aW9ucywgJ21heExlbmd0aCcsIDgwKSlcblxuICByZXR1cm4gKGZ1bmN0aW9uIF9zdHJpbmdpZnkgKG9iaiwgY3VycmVudEluZGVudCwgcmVzZXJ2ZWQpIHtcbiAgICBpZiAob2JqICYmIHR5cGVvZiBvYmoudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvYmogPSBvYmoudG9KU09OKClcbiAgICB9XG5cbiAgICB2YXIgc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkob2JqKVxuXG4gICAgaWYgKHN0cmluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gc3RyaW5nXG4gICAgfVxuXG4gICAgdmFyIGxlbmd0aCA9IG1heExlbmd0aCAtIGN1cnJlbnRJbmRlbnQubGVuZ3RoIC0gcmVzZXJ2ZWRcblxuICAgIGlmIChzdHJpbmcubGVuZ3RoIDw9IGxlbmd0aCkge1xuICAgICAgdmFyIHByZXR0aWZpZWQgPSBwcmV0dGlmeShzdHJpbmcsIGFkZE1hcmdpbilcbiAgICAgIGlmIChwcmV0dGlmaWVkLmxlbmd0aCA8PSBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHByZXR0aWZpZWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmV4dEluZGVudCA9IGN1cnJlbnRJbmRlbnQgKyBpbmRlbnRcbiAgICAgIHZhciBpdGVtcyA9IFtdXG4gICAgICB2YXIgZGVsaW1pdGVyc1xuICAgICAgdmFyIGNvbW1hID0gZnVuY3Rpb24gKGFycmF5LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gKGluZGV4ID09PSBhcnJheS5sZW5ndGggLSAxID8gMCA6IDEpXG4gICAgICB9XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IG9iai5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKFxuICAgICAgICAgICAgX3N0cmluZ2lmeShvYmpbaW5kZXhdLCBuZXh0SW5kZW50LCBjb21tYShvYmosIGluZGV4KSkgfHwgJ251bGwnXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGRlbGltaXRlcnMgPSAnW10nXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSwgaW5kZXgsIGFycmF5KSB7XG4gICAgICAgICAgdmFyIGtleVBhcnQgPSBKU09OLnN0cmluZ2lmeShrZXkpICsgJzogJ1xuICAgICAgICAgIHZhciB2YWx1ZSA9IF9zdHJpbmdpZnkob2JqW2tleV0sIG5leHRJbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlQYXJ0Lmxlbmd0aCArIGNvbW1hKGFycmF5LCBpbmRleCkpXG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goa2V5UGFydCArIHZhbHVlKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgZGVsaW1pdGVycyA9ICd7fSdcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBkZWxpbWl0ZXJzWzBdLFxuICAgICAgICAgIGluZGVudCArIGl0ZW1zLmpvaW4oJyxcXG4nICsgbmV4dEluZGVudCksXG4gICAgICAgICAgZGVsaW1pdGVyc1sxXVxuICAgICAgICBdLmpvaW4oJ1xcbicgKyBjdXJyZW50SW5kZW50KVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmdcbiAgfShvYmosICcnLCAwKSlcbn1cblxuLy8gTm90ZTogVGhpcyByZWdleCBtYXRjaGVzIGV2ZW4gaW52YWxpZCBKU09OIHN0cmluZ3MsIGJ1dCBzaW5jZSB3ZeKAmXJlXG4vLyB3b3JraW5nIG9uIHRoZSBvdXRwdXQgb2YgYEpTT04uc3RyaW5naWZ5YCB3ZSBrbm93IHRoYXQgb25seSB2YWxpZCBzdHJpbmdzXG4vLyBhcmUgcHJlc2VudCAodW5sZXNzIHRoZSB1c2VyIHN1cHBsaWVkIGEgd2VpcmQgYG9wdGlvbnMuaW5kZW50YCBidXQgaW5cbi8vIHRoYXQgY2FzZSB3ZSBkb27igJl0IGNhcmUgc2luY2UgdGhlIG91dHB1dCB3b3VsZCBiZSBpbnZhbGlkIGFueXdheSkuXG52YXIgc3RyaW5nT3JDaGFyID0gLyhcIig/OlteXFxcXFwiXXxcXFxcLikqXCIpfFs6LFxcXVt9e10vZ1xuXG5mdW5jdGlvbiBwcmV0dGlmeSAoc3RyaW5nLCBhZGRNYXJnaW4pIHtcbiAgdmFyIG0gPSBhZGRNYXJnaW4gPyAnICcgOiAnJ1xuICB2YXIgdG9rZW5zID0ge1xuICAgICd7JzogJ3snICsgbSxcbiAgICAnWyc6ICdbJyArIG0sXG4gICAgJ30nOiBtICsgJ30nLFxuICAgICddJzogbSArICddJyxcbiAgICAnLCc6ICcsICcsXG4gICAgJzonOiAnOiAnXG4gIH1cbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHN0cmluZ09yQ2hhciwgZnVuY3Rpb24gKG1hdGNoLCBzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nID8gbWF0Y2ggOiB0b2tlbnNbbWF0Y2hdXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGdldCAob3B0aW9ucywgbmFtZSwgZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiAobmFtZSBpbiBvcHRpb25zID8gb3B0aW9uc1tuYW1lXSA6IGRlZmF1bHRWYWx1ZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdpZnlcbiIsIi8qKlxuICogVGhlIERvdWJseUxpbmtlZExpc3QgY2xhc3MgcHJvdmlkZXMgdGhlIG1haW4gZnVuY3Rpb25hbGl0eSBvZiBhIGRvdWJseSBsaW5rZWQgbGlzdC5cbiAqXG4gKiBAY2xhc3MgRG91Ymx5TGlua2VkTGlzdFxuICovXG52YXIgRG91Ymx5TGlua2VkTGlzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRG91Ymx5TGlua2VkTGlzdCgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvdW50IG9mIGVsZW1lbnRzIGluIGxpc3RcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IF9sZW5ndGhcbiAgICAgICAgICogQHR5cGUgbnVtYmVyXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogSXRlcmF0aW9uIHBvaW50ZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IF9rZXlcbiAgICAgICAgICogQHR5cGUgbnVtYmVyXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9rZXkgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIGhlYWQoZmlyc3QpIGVsZW1lbnQgaW4gbGlzdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgX2hlYWRcbiAgICAgICAgICogQHR5cGUgRG91Ymx5TGlua2VkTGlzdE5vZGVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hlYWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIHRhaWwobGFzdCkgZWxlbWVudCBpbiBsaXN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfdGFpbFxuICAgICAgICAgKiBAdHlwZSBEb3VibHlMaW5rZWRMaXN0Tm9kZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdGFpbCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gaXRlcmF0ZWQgZWxlbWVudCBpbiBsaXN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfY3VycmVudFxuICAgICAgICAgKiBAdHlwZSBEb3VibHlMaW5rZWRMaXN0Tm9kZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydCBhIG5ldyB2YWx1ZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGFkZFxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggd2hlcmUgdGhlIG5ldyB2YWx1ZSBpcyB0byBiZSBpbnNlcnRlZC5cbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIGluZGV4LlxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk91dCBvZiBib3VuZHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIHdoaWxlIChpIDwgaW5kZXgpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudC52YWx1ZSA9IHZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUG9wcyBhIG5vZGUgZnJvbSB0aGUgZW5kIG9mIHRoZSBkb3VibHkgbGlua2VkIGxpc3RcbiAgICAgKlxuICAgICAqIEBtZXRob2QgcG9wXG4gICAgICogQHJldHVybiBhbnkgIFRoZSB2YWx1ZSBvZiB0aGUgcG9wcGVkIG5vZGUuXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwb3AgZnJvbSBhbiBlbXB0eSBkYXRhIHN0cnVjdHVyZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl90YWlsLnZhbHVlO1xuICAgICAgICB0aGlzLl90YWlsID0gdGhpcy5fdGFpbC5wcmV2O1xuICAgICAgICBpZiAodGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3RhaWwubmV4dDtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwubmV4dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGVuZ3RoLS07XG4gICAgICAgIGlmICh0aGlzLl9sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9oZWFkO1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2hpZnRzIGEgbm9kZSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRvdWJseSBsaW5rZWQgbGlzdFxuICAgICAqXG4gICAgICogQG1ldGhvZCBzaGlmdFxuICAgICAqIEByZXR1cm4gYW55ICBUaGUgdmFsdWUgb2YgdGhlIHNoaWZ0ZWQgbm9kZS5cbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgc2hpZnQgZnJvbSBhbiBlbXB0eSBkYXRhIHN0cnVjdHVyZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9oZWFkLnZhbHVlO1xuICAgICAgICB0aGlzLl9oZWFkID0gdGhpcy5faGVhZC5uZXh0O1xuICAgICAgICBpZiAodGhpcy5faGVhZCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2hlYWQucHJldjtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQucHJldiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGVuZ3RoLS07XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhbiBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIGRvdWJseSBsaW5rZWQgbGlzdFxuICAgICAqXG4gICAgICogQG1ldGhvZCBwdXNoXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBwdXNoLlxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gYWxsb2NhdGUgbmV3IG5vZGVcbiAgICAgICAgdmFyIG5vZGUgPSB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBwcmV2OiB0aGlzLl90YWlsLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5fbGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gdGhpcy5fdGFpbCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90YWlsLm5leHQgPSBub2RlO1xuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IHRoaXMuX3RhaWwubmV4dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sZW5ndGgrKztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByZXBlbmRzIHRoZSBkb3VibHkgbGlua2VkIGxpc3Qgd2l0aCBhbiBlbGVtZW50XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHVuc2hpZnRcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHVuc2hpZnQuXG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBhbGxvY2F0ZSBuZXcgbm9kZVxuICAgICAgICB2YXIgbm9kZSA9IHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHByZXY6IG51bGwsXG4gICAgICAgICAgICBuZXh0OiB0aGlzLl9oZWFkXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLl9sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSB0aGlzLl90YWlsID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQucHJldiA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gdGhpcy5faGVhZC5wcmV2O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xlbmd0aCsrO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGVla3MgYXQgdGhlIG5vZGUgZnJvbSB0aGUgZW5kIG9mIHRoZSBkb3VibHkgbGlua2VkIGxpc3RcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9wXG4gICAgICogQHJldHVybiBhbnkgIFRoZSB2YWx1ZSBvZiB0aGUgbGFzdCBub2RlLlxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLnRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RhaWwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGFpbC52YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBlZWtzIGF0IHRoZSBub2RlIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgZG91Ymx5IGxpbmtlZCBsaXN0XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGJvdHRvbVxuICAgICAqIEByZXR1cm4gYW55ICBUaGUgdmFsdWUgb2YgdGhlIGZpcnN0IG5vZGUuXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUuYm90dG9tID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5faGVhZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWFkLnZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ291bnRzIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGRvdWJseSBsaW5rZWQgbGlzdFxuICAgICAqXG4gICAgICogQG1ldGhvZCBjb3VudFxuICAgICAqIEByZXR1cm4gbnVtYmVyIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGRvdWJseSBsaW5rZWQgbGlzdC5cbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBkb3VibHkgbGlua2VkIGxpc3QgaXMgZW1wdHlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgaXNFbXB0eVxuICAgICAqIEByZXR1cm4gYm9vbGVhbiB3aGV0aGVyIHRoZSBkb3VibHkgbGlua2VkIGxpc3QgaXMgZW1wdHkuXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9sZW5ndGggPT09IDApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV3aW5kIGl0ZXJhdG9yIGJhY2sgdG8gdGhlIHN0YXJ0XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHJld2luZFxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLnJld2luZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fa2V5ID0gMDtcbiAgICAgICAgdGhpcy5fY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gY3VycmVudCBsaXN0IGVudHJ5XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGN1cnJlbnRcbiAgICAgKiBAcmV0dXJuIGFueSAgVGhlIGN1cnJlbnQgbm9kZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnQudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gY3VycmVudCBub2RlIGluZGV4XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGtleVxuICAgICAqIEByZXR1cm4gYW55ICBUaGUgY3VycmVudCBub2RlIGluZGV4LlxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLmtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1vdmUgdG8gbmV4dCBlbnRyeVxuICAgICAqXG4gICAgICogQG1ldGhvZCBuZXh0XG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudCA9IHRoaXMuX2N1cnJlbnQubmV4dDtcbiAgICAgICAgdGhpcy5fa2V5Kys7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNb3ZlIHRvIHByZXZpb3VzIGVudHJ5XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHByZXZcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fY3VycmVudC5wcmV2O1xuICAgICAgICB0aGlzLl9rZXktLTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGRvdWJseSBsaW5rZWQgbGlzdCBjb250YWlucyBtb3JlIG5vZGVzXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHZhbGlkXG4gICAgICogQHJldHVybiBib29sZWFuIHRydWUgaWYgdGhlIGRvdWJseSBsaW5rZWQgbGlzdCBjb250YWlucyBhbnkgbW9yZSBub2RlcywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLnZhbGlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2tleSA+PSAwICYmIHRoaXMuX2tleSA8IHRoaXMuX2xlbmd0aCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeHBvcnQgdGhlIGxpc3QgdG8gYXJyYXlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9BcnJheVxuICAgICAqIEByZXR1cm4gQXJyYXkgICBUaGUgZXhwb3J0ZWQgYXJyYXlcbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGlzdCA9IFtdO1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICBsaXN0LnB1c2goY3VycmVudC52YWx1ZSk7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgbGlzdCB0byBzdHJpbmdcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9TdHJpbmdcbiAgICAgKiBAcmV0dXJuIHN0cmluZyAgIFRoZSBzZXJpYWxpemVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwie1wiICsgdGhpcy50b0FycmF5KCkuam9pbihcIi0+XCIpICsgXCJ9XCI7XG4gICAgfTtcbiAgICByZXR1cm4gRG91Ymx5TGlua2VkTGlzdDtcbn0pKCk7XG5tb2R1bGUuZXhwb3J0cyA9IERvdWJseUxpbmtlZExpc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Eb3VibHlMaW5rZWRMaXN0LmpzLm1hcCIsIi8qKlxuICogVGhlIEhlYXAgY2xhc3MgcHJvdmlkZXMgdGhlIG1haW4gZnVuY3Rpb25hbGl0eSBvZiBhIEhlYXAuXG4gKlxuICogQGNsYXNzIEhlYXBcbiAqL1xudmFyIEhlYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhlYXAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCaW5hcnkgdHJlZSBzdG9yYWdlIGFycmF5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfdHJlZVxuICAgICAgICAgKiBAdHlwZSBBcnJheVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdHJlZSA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogSGVhcCB0eXBlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfdHlwZVxuICAgICAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3R5cGUgPSBIZWFwLk1BWDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0ZXJhdGlvbiBwb2ludGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfa2V5XG4gICAgICAgICAqIEB0eXBlIG51bWJlclxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fa2V5ID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGluZGV4IG9mIGxlZnQgY2hpbGQgZWxlbWVudCBpbiBiaW5hcnkgdHJlZSBzdG9yZWQgaW4gYXJyYXlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2NoaWxkXG4gICAgICogQHBhcmFtIG5cbiAgICAgKiBAcmV0dXJuIG51bWJlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUuX2NoaWxkID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIDIgKiBuICsgMTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBpbmRleCBvZiBwYXJlbnQgZWxlbWVudCBpbiBiaW5hcnkgdHJlZSBzdG9yZWQgaW4gYXJyYXlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3BhcmVudFxuICAgICAqIEBwYXJhbSBuXG4gICAgICogQHJldHVybiBudW1iZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLl9wYXJlbnQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICAvL2NvbnNvbGUubG9nKCduPScsIG4sIE1hdGguZmxvb3IobiAvIDIpKTtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobiAvIDIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3dhcCAyIGVsZW1lbnRzIGluIGJpbmFyeSB0cmVlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9zd2FwXG4gICAgICogQHBhcmFtIGZpcnN0XG4gICAgICogQHBhcmFtIHNlY29uZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUuX3N3YXAgPSBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICB2YXIgc3dhcCA9IHRoaXMuX3RyZWVbZmlyc3RdO1xuICAgICAgICB0aGlzLl90cmVlW2ZpcnN0XSA9IHRoaXMuX3RyZWVbc2Vjb25kXTtcbiAgICAgICAgdGhpcy5fdHJlZVtzZWNvbmRdID0gc3dhcDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNpZnQgZWxlbWVudHMgaW4gYmluYXJ5IHRyZWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3NpZnRVcFxuICAgICAqIEBwYXJhbSBpXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5fc2lmdFVwID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgd2hpbGUgKGkgPiAwKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50KGkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFyZSh0aGlzLl90cmVlW2ldLCB0aGlzLl90cmVlW3BhcmVudF0pICogdGhpcy5fdHlwZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zd2FwKGksIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgaSA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTaWZ0IGRvd24gZWxlbWVudHMgaW4gYmluYXJ5IHRyZWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3NpZnREb3duXG4gICAgICogQHBhcmFtIGlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLl9zaWZ0RG93biA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5fdHJlZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy5fY2hpbGQoaSk7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIGlmICgobGVmdCA8IHRoaXMuX3RyZWUubGVuZ3RoKSAmJiAocmlnaHQgPCB0aGlzLl90cmVlLmxlbmd0aCkgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5jb21wYXJlKHRoaXMuX3RyZWVbaV0sIHRoaXMuX3RyZWVbbGVmdF0pICogdGhpcy5fdHlwZSA8IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wYXJlKHRoaXMuX3RyZWVbaV0sIHRoaXMuX3RyZWVbcmlnaHRdKSAqIHRoaXMuX3R5cGUgPCAwKSkge1xuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIDIgY2hpbGRyZW4gYW5kIG9uZSBvZiB0aGVtIG11c3QgYmUgc3dhcHBlZFxuICAgICAgICAgICAgICAgIC8vIGdldCBjb3JyZWN0IGVsZW1lbnQgdG8gc2lmdCBkb3duXG4gICAgICAgICAgICAgICAgdmFyIHNpZnQgPSBsZWZ0O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhcmUodGhpcy5fdHJlZVtsZWZ0XSwgdGhpcy5fdHJlZVtyaWdodF0pICogdGhpcy5fdHlwZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2lmdCA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9zd2FwKGksIHNpZnQpO1xuICAgICAgICAgICAgICAgIGkgPSBzaWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGVmdCA8IHRoaXMuX3RyZWUubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wYXJlKHRoaXMuX3RyZWVbaV0sIHRoaXMuX3RyZWVbbGVmdF0pICogdGhpcy5fdHlwZSA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IG9uZSBjaGlsZCBleGlzdHNcbiAgICAgICAgICAgICAgICB0aGlzLl9zd2FwKGksIGxlZnQpO1xuICAgICAgICAgICAgICAgIGkgPSBsZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIGEgbm9kZSBmcm9tIHRvcCBvZiB0aGUgaGVhcCBhbmQgc2lmdCB1cFxuICAgICAqXG4gICAgICogQG1ldGhvZCBleHRyYWN0XG4gICAgICogQHJldHVybiBhbnkgVGhlIHZhbHVlIG9mIHRoZSBleHRyYWN0ZWQgbm9kZS5cbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fdHJlZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGV4dHJhY3QgZnJvbSBhbiBlbXB0eSBkYXRhIHN0cnVjdHVyZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXh0cmFjdGVkID0gdGhpcy5fdHJlZVswXTtcbiAgICAgICAgaWYgKHRoaXMuX3RyZWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLl90cmVlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90cmVlWzBdID0gdGhpcy5fdHJlZS5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuX3NpZnREb3duKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRyYWN0ZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIGVsZW1lbnQgaW4gdGhlIGhlYXAgYnkgc2lmdGluZyBpdCB1cFxuICAgICAqXG4gICAgICogQG1ldGhvZCBpbnNlcnRcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdHJlZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgdGhpcy5fc2lmdFVwKHRoaXMuX3RyZWUubGVuZ3RoIC0gMSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQZWVrcyBhdCB0aGUgbm9kZSBmcm9tIHRoZSB0b3Agb2YgdGhlIGhlYXBcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9wXG4gICAgICogQHJldHVybiBhbnkgVGhlIHZhbHVlIG9mIHRoZSBub2RlIG9uIHRoZSB0b3AuXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUudG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fdHJlZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHBlZWsgYXQgYW4gZW1wdHkgaGVhcFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdHJlZVswXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvdW50cyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBoZWFwXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGNvdW50XG4gICAgICogQHJldHVybiBudW1iZXIgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaGVhcC5cbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWUubGVuZ3RoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGhlYXAgaXMgZW1wdHlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgaXNFbXB0eVxuICAgICAqIEByZXR1cm4gYm9vbGVhbiB3aGV0aGVyIHRoZSBoZWFwIGlzIGVtcHR5LlxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fdHJlZS5sZW5ndGggPT09IDApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV3aW5kIGl0ZXJhdG9yIGJhY2sgdG8gdGhlIHN0YXJ0IChuby1vcClcbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmV3aW5kXG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUucmV3aW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9rZXkgPSAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGN1cnJlbnQgbm9kZSBwb2ludGVkIGJ5IHRoZSBpdGVyYXRvclxuICAgICAqXG4gICAgICogQG1ldGhvZCBjdXJyZW50XG4gICAgICogQHJldHVybiBhbnkgVGhlIGN1cnJlbnQgbm9kZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJlZVt0aGlzLl9rZXldO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGN1cnJlbnQgbm9kZSBpbmRleFxuICAgICAqXG4gICAgICogQG1ldGhvZCBrZXlcbiAgICAgKiBAcmV0dXJuIGFueSBUaGUgY3VycmVudCBub2RlIGluZGV4LlxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLmtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1vdmUgdG8gdGhlIG5leHQgbm9kZVxuICAgICAqXG4gICAgICogQG1ldGhvZCBuZXh0XG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fa2V5Kys7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNb3ZlIHRvIHByZXZpb3VzIGVudHJ5XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHByZXZcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9rZXktLTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGhlYXAgY29udGFpbnMgbW9yZSBub2Rlc1xuICAgICAqXG4gICAgICogQG1ldGhvZCB2YWxpZFxuICAgICAqIEByZXR1cm4gYm9vbGVhbiB0cnVlIGlmIHRoZSBoZWFwIGNvbnRhaW5zIGFueSBtb3JlIG5vZGVzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUudmFsaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fa2V5ID49IDAgJiYgdGhpcy5fa2V5IDwgdGhpcy5fdHJlZS5sZW5ndGgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcGFyZSBlbGVtZW50cyBpbiBvcmRlciB0byBwbGFjZSB0aGVtIGNvcnJlY3RseSBpbiB0aGUgaGVhcCB3aGlsZSBzaWZ0aW5nIHVwLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBjb21wYXJlXG4gICAgICogQHBhcmFtIGZpcnN0IFRoZSB2YWx1ZSBvZiB0aGUgZmlyc3Qgbm9kZSBiZWluZyBjb21wYXJlZC5cbiAgICAgKiBAcGFyYW0gc2Vjb25kIFRoZSB2YWx1ZSBvZiB0aGUgc2Vjb25kIG5vZGUgYmVpbmcgY29tcGFyZWQuXG4gICAgICogQHJldHVybiBudW1iZXIgUmVzdWx0IG9mIHRoZSBjb21wYXJpc29uLCBwb3NpdGl2ZSBpbnRlZ2VyIGlmIGZpcnN0IGlzIGdyZWF0ZXIgdGhhbiBzZWNvbmQsIDAgaWYgdGhleSBhcmUgZXF1YWwsIG5lZ2F0aXZlIGludGVnZXIgb3RoZXJ3aXNlLlxuICAgICAqIEhhdmluZyBtdWx0aXBsZSBlbGVtZW50cyB3aXRoIHRoZSBzYW1lIHZhbHVlIGluIGEgSGVhcCBpcyBub3QgcmVjb21tZW5kZWQuIFRoZXkgd2lsbCBlbmQgdXAgaW4gYW4gYXJiaXRyYXJ5IHJlbGF0aXZlIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICBpZiAoZmlyc3QgPiBzZWNvbmQpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpcnN0ID09IHNlY29uZCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFZpc3VhbGx5IGRpc3BsYXkgaGVhcCB0cmVlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9kaXNwbGF5Tm9kZVxuICAgICAqIEBwYXJhbSBub2RlXG4gICAgICogQHBhcmFtIHByZWZpeFxuICAgICAqIEBwYXJhbSBsYXN0XG4gICAgICogQHJldHVybiBTdHJpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLl9kaXNwbGF5Tm9kZSA9IGZ1bmN0aW9uIChub2RlLCBwcmVmaXgsIGxhc3QpIHtcbiAgICAgICAgaWYgKHByZWZpeCA9PT0gdm9pZCAwKSB7IHByZWZpeCA9ICcnOyB9XG4gICAgICAgIGlmIChsYXN0ID09PSB2b2lkIDApIHsgbGFzdCA9IHRydWU7IH1cbiAgICAgICAgdmFyIGxpbmUgPSBwcmVmaXg7XG4gICAgICAgIC8vIGdldCBjaGlsZCBpbmRleGVzXG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5fY2hpbGQobm9kZSk7XG4gICAgICAgIHZhciByaWdodCA9IGxlZnQgKyAxO1xuICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgbGluZSArPSAocHJlZml4ID8gJ+KUlOKUgCcgOiAnICAnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxpbmUgKz0gJ+KUnOKUgCc7XG4gICAgICAgIH1cbiAgICAgICAgbGluZSArPSB0aGlzLl90cmVlW25vZGVdO1xuICAgICAgICBwcmVmaXggKz0gKGxhc3QgPyAnICAnIDogJ+KUgiAnKTtcbiAgICAgICAgaWYgKGxlZnQgPCB0aGlzLl90cmVlLmxlbmd0aCkge1xuICAgICAgICAgICAgbGluZSArPSAnXFxuJyArIHRoaXMuX2Rpc3BsYXlOb2RlKGxlZnQsIHByZWZpeCwgKHRoaXMuX3RyZWVbcmlnaHRdID09IHVuZGVmaW5lZCA/IHRydWUgOiBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyaWdodCA8IHRoaXMuX3RyZWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBsaW5lICs9ICdcXG4nICsgdGhpcy5fZGlzcGxheU5vZGUocmlnaHQsIHByZWZpeCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBoZWFwIHRvIHN0cmluZ1xuICAgICAqXG4gICAgICogQG1ldGhvZCB0b1N0cmluZ1xuICAgICAqIEByZXR1cm4gc3RyaW5nICAgVGhlIHNlcmlhbGl6ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBzdGFydCB3aXRoIHJvb3QgYW5kIHJlY3Vyc2l2ZWx5IGdvZXMgdG8gZWFjaCBub2RlXG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwbGF5Tm9kZSgwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGhlYXAgdG8gYXJyYXlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9BcnJheVxuICAgICAqIEByZXR1cm4gQXJyYXkgICBUaGUgc2VyaWFsaXplZCBhcnJheS5cbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJlZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1heCBoZWFwIGZsYWdcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBNQVhcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgSGVhcC5NQVggPSAxO1xuICAgIC8qKlxuICAgICAqIE1pbiBoZWFwIGZsYWdcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBNSU5cbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgSGVhcC5NSU4gPSAtMTtcbiAgICByZXR1cm4gSGVhcDtcbn0pKCk7XG5tb2R1bGUuZXhwb3J0cyA9IEhlYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IZWFwLmpzLm1hcCIsInZhciBfX2V4dGVuZHMgPSB0aGlzLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlO1xuICAgIGQucHJvdG90eXBlID0gbmV3IF9fKCk7XG59O1xudmFyIEhlYXAgPSByZXF1aXJlKCcuL0hlYXAnKTtcbi8qKlxuICogVGhlIE1heEhlYXAgY2xhc3MgcHJvdmlkZXMgdGhlIG1haW4gZnVuY3Rpb25hbGl0eSBvZiBhIGhlYXAsIGtlZXBpbmcgdGhlIG1heGltdW0gb24gdGhlIHRvcC5cbiAqXG4gKiBAY2xhc3MgTWF4SGVhcFxuICogQGV4dGVuZHMgSGVhcFxuICovXG52YXIgTWF4SGVhcCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1heEhlYXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWF4SGVhcCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX3R5cGUgPSBIZWFwLk1BWDtcbiAgICB9XG4gICAgcmV0dXJuIE1heEhlYXA7XG59KShIZWFwKTtcbm1vZHVsZS5leHBvcnRzID0gTWF4SGVhcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1heEhlYXAuanMubWFwIiwidmFyIF9fZXh0ZW5kcyA9IHRoaXMuX19leHRlbmRzIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGU7XG4gICAgZC5wcm90b3R5cGUgPSBuZXcgX18oKTtcbn07XG52YXIgSGVhcCA9IHJlcXVpcmUoJy4vSGVhcCcpO1xuLyoqXG4gKiBUaGUgTWluSGVhcCBjbGFzcyBwcm92aWRlcyB0aGUgbWFpbiBmdW5jdGlvbmFsaXR5IG9mIGEgaGVhcCwga2VlcGluZyB0aGUgbWluaW11bSBvbiB0aGUgdG9wLlxuICpcbiAqIEBjbGFzcyBNaW5IZWFwXG4gKiBAZXh0ZW5kcyBIZWFwXG4gKi9cbnZhciBNaW5IZWFwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWluSGVhcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNaW5IZWFwKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fdHlwZSA9IEhlYXAuTUlOO1xuICAgIH1cbiAgICByZXR1cm4gTWluSGVhcDtcbn0pKEhlYXApO1xubW9kdWxlLmV4cG9ydHMgPSBNaW5IZWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWluSGVhcC5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBIZWFwID0gcmVxdWlyZSgnLi9IZWFwJyk7XG4vKipcbiAqIFRoZSBQcmlvcml0eVF1ZXVlIGNsYXNzIHByb3ZpZGVzIHRoZSBtYWluIGZ1bmN0aW9uYWxpdHkgb2YgYW4gcHJpb3JpdGl6ZWQgcXVldWUsIGltcGxlbWVudGVkIHVzaW5nIGEgbWF4IGhlYXAuXG4gKlxuICogQGNsYXNzIFByaW9yaXR5UXVldWVcbiAqIEBleHRlbmRzIEhlYXBcbiAqL1xudmFyIFByaW9yaXR5UXVldWUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQcmlvcml0eVF1ZXVlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByaW9yaXR5UXVldWUoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl90eXBlID0gSGVhcC5NQVg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZWxlbWVudCB0byB0aGUgcXVldWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZW5xdWV1ZVxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gZW5xdWV1ZS5cbiAgICAgKiBAcGFyYW0gcHJpb3JpdHkgVGhlIHByaW9yaXR5IG9mIHZhbHVlLlxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbiAodmFsdWUsIHByaW9yaXR5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc2VydChuZXcgUHJpb3JpdHlRdWV1ZU5vZGUodmFsdWUsIHByaW9yaXR5KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXF1ZXVlcyBhIG5vZGUgZnJvbSB0aGUgcXVldWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVxdWV1ZVxuICAgICAqIEByZXR1cm4gYW55ICBUaGUgdmFsdWUgb2YgdGhlIGRlcXVldWVkIG5vZGUuXG4gICAgICovXG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZGVxdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFjdCgpLnZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGVla3MgYXQgdGhlIG5vZGUgZnJvbSB0aGUgdG9wIG9mIHRoZSBoZWFwXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHRvcFxuICAgICAqIEByZXR1cm4gYW55IFRoZSB2YWx1ZSBvZiB0aGUgbm9kZSBvbiB0aGUgdG9wLlxuICAgICAqL1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLnRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUudG9wLmNhbGwodGhpcykudmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wYXJlIGVsZW1lbnRzIGluIG9yZGVyIHRvIHBsYWNlIHRoZW0gY29ycmVjdGx5IGluIHRoZSBoZWFwIHdoaWxlIHNpZnRpbmcgdXAuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGNvbXBhcmVcbiAgICAgKiBAcGFyYW0gZmlyc3QgVGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBub2RlIGJlaW5nIGNvbXBhcmVkLlxuICAgICAqIEBwYXJhbSBzZWNvbmQgVGhlIHZhbHVlIG9mIHRoZSBzZWNvbmQgbm9kZSBiZWluZyBjb21wYXJlZC5cbiAgICAgKiBAcmV0dXJuIG51bWJlciBSZXN1bHQgb2YgdGhlIGNvbXBhcmlzb24sIHBvc2l0aXZlIGludGVnZXIgaWYgZmlyc3QgaXMgZ3JlYXRlciB0aGFuIHNlY29uZCwgMCBpZiB0aGV5IGFyZSBlcXVhbCwgbmVnYXRpdmUgaW50ZWdlciBvdGhlcndpc2UuXG4gICAgICogSGF2aW5nIG11bHRpcGxlIGVsZW1lbnRzIHdpdGggdGhlIHNhbWUgdmFsdWUgaW4gYSBIZWFwIGlzIG5vdCByZWNvbW1lbmRlZC4gVGhleSB3aWxsIGVuZCB1cCBpbiBhbiBhcmJpdHJhcnkgcmVsYXRpdmUgcG9zaXRpb24uXG4gICAgICovXG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgIGlmIChmaXJzdC5wcmlvcml0eSA+IHNlY29uZC5wcmlvcml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmlyc3QucHJpb3JpdHkgPT0gc2Vjb25kLnByaW9yaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFByaW9yaXR5UXVldWU7XG59KShIZWFwKTtcbi8qKlxuICogUHJpb3JpdHlRdWV1ZSBOb2RlXG4gKlxuICogQGNsYXNzIFByaW9yaXR5UXVldWVOb2RlXG4gKi9cbnZhciBQcmlvcml0eVF1ZXVlTm9kZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKlxuICAgICAqIEBtZXRob2QgY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gcHJpb3JpdHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQcmlvcml0eVF1ZXVlTm9kZSh2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIG5vZGUgdG8gc3RyaW5nXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHRvU3RyaW5nXG4gICAgICogQHJldHVybiBzdHJpbmcgICBUaGUgc2VyaWFsaXplZCBzdHJpbmcuXG4gICAgICovXG4gICAgUHJpb3JpdHlRdWV1ZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSArIFwiIFtcIiArIHRoaXMucHJpb3JpdHkgKyBcIl1cIjtcbiAgICB9O1xuICAgIHJldHVybiBQcmlvcml0eVF1ZXVlTm9kZTtcbn0pKCk7XG5tb2R1bGUuZXhwb3J0cyA9IFByaW9yaXR5UXVldWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qcmlvcml0eVF1ZXVlLmpzLm1hcCIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIERvdWJseUxpbmtlZExpc3QgPSByZXF1aXJlKCcuL0RvdWJseUxpbmtlZExpc3QnKTtcbi8qKlxuICogVGhlIFF1ZXVlIGNsYXNzIHByb3ZpZGVzIHRoZSBtYWluIGZ1bmN0aW9uYWxpdHkgb2YgYSBxdWV1ZSBpbXBsZW1lbnRlZCB1c2luZyBhIGRvdWJseSBsaW5rZWQgbGlzdC5cbiAqXG4gKiBAY2xhc3MgUXVldWVcbiAqIEBleHRlbmRzIERvdWJseUxpbmtlZExpc3RcbiAqL1xudmFyIFF1ZXVlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUXVldWUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUXVldWUoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGVsZW1lbnQgdG8gdGhlIHF1ZXVlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGVucXVldWVcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGVucXVldWUuXG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgUXVldWUucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaCh2YWx1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXF1ZXVlcyBhIG5vZGUgZnJvbSB0aGUgcXVldWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVxdWV1ZVxuICAgICAqIEByZXR1cm4gYW55ICBUaGUgdmFsdWUgb2YgdGhlIGRlcXVldWVkIG5vZGUuXG4gICAgICovXG4gICAgUXVldWUucHJvdG90eXBlLmRlcXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoaWZ0KCk7XG4gICAgfTtcbiAgICByZXR1cm4gUXVldWU7XG59KShEb3VibHlMaW5rZWRMaXN0KTtcbm1vZHVsZS5leHBvcnRzID0gUXVldWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1RdWV1ZS5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBEb3VibHlMaW5rZWRMaXN0ID0gcmVxdWlyZSgnLi9Eb3VibHlMaW5rZWRMaXN0Jyk7XG4vKipcbiAqIFRoZSBTdGFjayBjbGFzcyBwcm92aWRlcyB0aGUgbWFpbiBmdW5jdGlvbmFsaXR5IG9mIGEgc3RhY2sgaW1wbGVtZW50ZWQgdXNpbmcgYSBkb3VibHkgbGlua2VkIGxpc3QuXG4gKlxuICogQGNsYXNzIFN0YWNrXG4gKiBAZXh0ZW5kcyBEb3VibHlMaW5rZWRMaXN0XG4gKi9cbnZhciBTdGFjayA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0YWNrLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN0YWNrKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0YWNrO1xufSkoRG91Ymx5TGlua2VkTGlzdCk7XG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RhY2suanMubWFwIiwiLyoqXG4gKiBTVExcbiAqIEB0eXBlIHt7RG91Ymx5TGlua2VkTGlzdDogZXhwb3J0cywgU3RhY2s6IGV4cG9ydHMsIFF1ZXVlOiBleHBvcnRzLCBIZWFwOiBleHBvcnRzLCBNYXhIZWFwOiBleHBvcnRzLCBNaW5IZWFwOiBleHBvcnRzLCBQcmlvcml0eVF1ZXVlOiBleHBvcnRzfX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG5cdERvdWJseUxpbmtlZExpc3Q6IHJlcXVpcmUoJy4vRGF0YXN0cnVjdHVyZXMvRG91Ymx5TGlua2VkTGlzdCcpLFxuXHRTdGFjazogcmVxdWlyZSgnLi9EYXRhc3RydWN0dXJlcy9TdGFjaycpLFxuXHRRdWV1ZTogcmVxdWlyZSgnLi9EYXRhc3RydWN0dXJlcy9RdWV1ZScpLFxuXHRIZWFwOiByZXF1aXJlKCcuL0RhdGFzdHJ1Y3R1cmVzL0hlYXAnKSxcblx0TWF4SGVhcDogcmVxdWlyZSgnLi9EYXRhc3RydWN0dXJlcy9NYXhIZWFwJyksXG5cdE1pbkhlYXA6IHJlcXVpcmUoJy4vRGF0YXN0cnVjdHVyZXMvTWluSGVhcCcpLFxuXHRQcmlvcml0eVF1ZXVlOiByZXF1aXJlKCcuL0RhdGFzdHJ1Y3R1cmVzL1ByaW9yaXR5UXVldWUnKVxufTsiLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBcHAgZnJvbSAnLi9tb2R1bGVzL0FwcCc7XG5cbi8qKlxuICogV2hlbiB0aGUgZG9jdW1lbnQgaXMgcmVhZHksIGluaXRpYWxpemUgdGhlIGFwcGxpY2F0aW9uXG4gKi9cbiQoKCkgPT4ge1xuICAgIG5ldyBBcHAoJyNjYW52YXMnLCAxMCk7XG59KTtcbiIsIi8vIGVkaXRvciBlbGVtZW50cyAoZ2F0ZXMsIHdpcmVzLi4uKVxuaW1wb3J0ICogYXMgZWRpdG9yRWxlbWVudHMgZnJvbSAnLi9lZGl0b3JFbGVtZW50cyc7XG5cbi8vIHN2ZyBlbGVtZW50c1xuaW1wb3J0IHsgUGF0dGVybiwgUmVjdGFuZ2xlLCBQb2x5TGluZVBvaW50LCBQb2x5TGluZVBvaW50cywgUG9seUxpbmUgfSBmcm9tICcuL3N2Z09iamVjdHMnO1xuXG4vLyBuZXR3b3JrIGxvZ2ljIGFuZCBzaW11bGF0aW9uXG5pbXBvcnQgTG9naWMgZnJvbSAnLi9Mb2dpYyc7XG5pbXBvcnQgU2ltdWxhdGlvbiBmcm9tICcuL1NpbXVsYXRpb24nO1xuaW1wb3J0IHsgU2ltdWxhdGlvbkR1bW15IH0gZnJvbSAnLi9TaW11bGF0aW9uJztcblxuLy8gdWkgc3R1ZmZcbmltcG9ydCBDb250ZXh0TWVudSBmcm9tICcuL3VpL0NvbnRleHRNZW51JztcbmltcG9ydCBGbG9hdGluZ01lbnUgZnJvbSAnLi91aS9GbG9hdGluZ01lbnUnO1xuaW1wb3J0IFR1dG9yaWFsIGZyb20gJy4vdWkvVHV0b3JpYWwnO1xuaW1wb3J0IE1lc3NhZ2VzIGZyb20gJy4vdWkvTWVzc2FnZXMnO1xuaW1wb3J0IFZpZXdCb3ggZnJvbSAnLi91aS9WaWV3Qm94JztcblxuLy8gbW91c2Ugc2Nyb2xsIGV2ZW50IGxpc3RlcmVyIGZvciB1aSwgbWFuaGF0dGFuIGRpc3RhbmNlIGZvciBpbXBvcnREYXRhXG5pbXBvcnQgeyBhZGRNb3VzZVNjcm9sbEV2ZW50TGlzdGVuZXIsIG1hbmhhdHRhbkRpc3RhbmNlIH0gZnJvbSAnLi9vdGhlci9oZWxwZXJGdW5jdGlvbnMnO1xuXG4vLyB1c2VkIGluIGltcG9ydERhdGFcbi8vIG5vdGU6IGltcG9ydGVkIGZyb20gYSBub2RlIG1vZHVsZVxuaW1wb3J0IHsgUHJpb3JpdHlRdWV1ZSB9IGZyb20gJ2xpYnN0bCc7XG5cbmNvbnN0IGN0cmxLZXkgPSAxNyxcbiAgICBjbWRLZXkgPSA5MTtcblxuLyoqIEBtb2R1bGUgQXBwICovXG4vKipcbiAqIE1haW4gY2xhc3Mgb2YgdGhlIGFwcGxpY2F0aW9uLiBJdCByZXByZXNlbnRzIGFuIGluc3RhbmNlIG9mIHRoZSB3aG9sZSBlZGl0b3IgYW5kIGhvbGRzXG4gKiByZWZlcmVuY2VzIHRvIGFsbCBpdHMgZWxlbWVudHMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFwcCB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgU3ZnIGNsYXNzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNhbnZhcyAgIHF1ZXJ5IHNlbGVjdG9yIG9mIHRoZSBTVkcgZWxlbWVudCwgdGhhdCB3aWxsIGNvbnRhaW4gYWxsIFNWRyBjb250ZW50IG9mIHRoZSBhcHBsaWNhdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncmlkU2l6ZSBpbml0aWFsIHNpemUgb2YgdGhlIGdyaWQgaW4gU1ZHIHBpeGVsc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNhbnZhcywgZ3JpZFNpemUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGpRdWVyeSBlbGVtZW50IGZvciB0aGUgU1ZHIGRvY3VtZW50XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiRzdmcgPSAkKGNhbnZhcyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNwYWNlIGJldHdlZW4gZ3JpZCBsaW5lcyBpbiBTVkcgcGl4ZWxzXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdyaWRTaXplID0gZ3JpZFNpemU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFycmF5IG9mIGFsbCBib3hlcyAoaW5zdGFuY2VzIG9mIG9iamVjdHMgZGVyaXZlZCBmcm9tIGVkaXRvckVsZW1lbnRzLkJveCkgdXNlZCBvbiBjYW52YXNcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ib3hlcyA9IFtdOyAvLyBzdG9yZXMgYWxsIGJveGVzXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFycmF5IG9mIGFsbCB3aXJlcyAoaW5zdGFuY2VzIG9mIGVkaXRvckVsZW1lbnRzLldpcmUpIHVzZWQgb24gY2FudmFzXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMud2lyZXMgPSBbXTsgLy8gc3RvcmVzIGFsbCB3aXJlc1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcmZhY2UgZm9yIHNob3dpbmcgbWVzc2FnZXMgdG8gdGhlIHVzZXJcbiAgICAgICAgICogQHR5cGUge01lc3NhZ2VzfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tZXNzYWdlcyA9IG5ldyBNZXNzYWdlcygpO1xuXG4gICAgICAgIHRoaXMuc2ltdWxhdGlvbkVuYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnNpbXVsYXRpb24gPSBuZXcgU2ltdWxhdGlvbkR1bW15KCk7IC8vIGR1bW15LCB3aWxsIGJlIG92ZXJ3cml0dGVuIG9uIHN0YXJ0TmV3U2ltdWxhdGlvblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkaXN0YW5jZSBmcm9tIHRoZSBsZWZ0IHRvcCBjb3JuZXIgdG8gdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGltcG9ydGVkIG5ldHdvcmtcbiAgICAgICAgICogYW5kIGRpc3RhbmNlIGZyb20gdGhlIGxlZnQgdG9wIGNvcm5lciB0byB0aGUgaW1wb3J0ZWQgYmxhY2sgYm94IF9pbiBncmlkIHBpeGVsc19cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGVmdFRvcFBhZGRpbmcgPSA0O1xuXG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgZGVmcyBlbGVtZW50LCB1c2VkIGZvciBwYXR0ZXJuc1xuICAgICAgICB0aGlzLiRkZWZzID0gJCgnPGRlZnM+Jyk7XG4gICAgICAgIHRoaXMuJHN2Zy5wcmVwZW5kKHRoaXMuJGRlZnMpO1xuXG4gICAgICAgIC8vIEJBQ0tHUk9VTkQgUEFUVEVSTlxuICAgICAgICBsZXQgcGF0dGVybiA9IG5ldyBQYXR0ZXJuKCdncmlkJywgdGhpcy5ncmlkU2l6ZSwgdGhpcy5ncmlkU2l6ZSk7XG5cbiAgICAgICAgbGV0IHBhdHRlcm5Qb2ludHMgPSBuZXcgUG9seUxpbmVQb2ludHMoKVxuICAgICAgICAgICAgLmFwcGVuZChuZXcgUG9seUxpbmVQb2ludCgwLCAwKSlcbiAgICAgICAgICAgIC5hcHBlbmQobmV3IFBvbHlMaW5lUG9pbnQodGhpcy5ncmlkU2l6ZSwgMCkpXG4gICAgICAgICAgICAuYXBwZW5kKG5ldyBQb2x5TGluZVBvaW50KHRoaXMuZ3JpZFNpemUsIHRoaXMuZ3JpZFNpemUpKTtcblxuICAgICAgICBwYXR0ZXJuLmFkZENoaWxkKG5ldyBQb2x5TGluZShwYXR0ZXJuUG9pbnRzLCAyLCAnI2MyYzNlNCcpKTtcbiAgICAgICAgdGhpcy5hZGRQYXR0ZXJuKHBhdHRlcm4uZ2V0KCkpO1xuXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCA9IG5ldyBSZWN0YW5nbGUoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsICd1cmwoI2dyaWQpJywgJ25vbmUnKTtcbiAgICAgICAgdGhpcy5hcHBlbmRKUXVlcnlPYmplY3QodGhpcy5iYWNrZ3JvdW5kLmdldCgpKTtcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG5cbiAgICAgICAgLy8gc2V0IHRoZSB2aWV3Ym94IGZvciBmdXR1cmUgem9vbWluZyBhbmQgbW92aW5nIG9mIHRoZSBjYW52YXNcbiAgICAgICAgdGhpcy4kc3ZnLmF0dHIoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCAneE1pbllNaW4gc2xpY2UnKTtcbiAgICAgICAgdGhpcy52aWV3Ym94ID0gbmV3IFZpZXdCb3goMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICB0aGlzLmFwcGx5Vmlld2JveCgpO1xuXG4gICAgICAgIC8vIENPTlNUUlVDVCBDT05URVhUIE1FTlVcbiAgICAgICAgdGhpcy5jb250ZXh0TWVudSA9IG5ldyBDb250ZXh0TWVudSh0aGlzKTtcblxuICAgICAgICAvLyBDT05TVFJVQ1QgRkxPQVRJTkcgTUVOVVxuICAgICAgICB0aGlzLmZsb2F0aW5nTWVudSA9IG5ldyBGbG9hdGluZ01lbnUodGhpcyk7XG5cbiAgICAgICAgbGV0IHRhcmdldDtcblxuICAgICAgICAvLyBBTEwgRVZFTlQgQ0FMTEJBQ0tTXG4gICAgICAgIHRoaXMuJHN2Z1xuICAgICAgICAgICAgLm9uKCdtb3VzZWRvd24nLCBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5nZXRSZWFsVGFyZ2V0KGV2ZW50LnRhcmdldCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvcGFnYXRlIG1vdXNlZG93biB0byB0aGUgcmVhbCB0YXJnZXRcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Lm9uTW91c2VEb3duKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBtb3VzZWRvd24gaGFwcGVuZWQgZGlyZWN0bHkgb24gdGhlIHN2Z1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTW91c2VEb3duKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVDb250ZXh0TWVudSgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5vbk1vdXNlTW92ZShldmVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbW91c2Vtb3ZlIGhhcHBlbmVkIGRpcmVjdGx5IG9uIHRoZSBzdmdcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk1vdXNlTW92ZShldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ21vdXNldXAnLCBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5vbk1vdXNlVXAoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdXNldXAgaGFwcGVuZWQgZGlyZWN0bHkgb24gdGhlIHN2Z1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTW91c2VVcChldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2NvbnRleHRtZW51JywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheUNvbnRleHRNZW51KFxuICAgICAgICAgICAgICAgICAgICBldmVudC5wYWdlWCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucGFnZVksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0UmVhbEpRdWVyeVRhcmdldChldmVudC50YXJnZXQpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgJChkb2N1bWVudClcbiAgICAgICAgICAgIC5vbigna2V5ZG93bicsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uS2V5RG93bihldmVudCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdrZXl1cCcsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uS2V5VXAoZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSB2aWV3Ym94IG9uIHdpbmRvdyByZXNpemVcbiAgICAgICAgJCh3aW5kb3cpLm9uKCdyZXNpemUnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZpZXdib3gubmV3RGltZW5zaW9ucyh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLmFwcGx5Vmlld2JveCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBhZGRNb3VzZVNjcm9sbEV2ZW50TGlzdGVuZXIoY2FudmFzLCBldmVudCA9PiB7XG4gICAgICAgICAgICAvLyB6b29tIG9ubHkgaWYgdGhlIGN0cmwga2V5IGlzIG5vdCBwcmVzc2VkXG4gICAgICAgICAgICBpZiAoIWV2ZW50LmN0cmxLZXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnpvb20gKz0gZXZlbnQuZGVsdGEgKiAwLjE7XG5cbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAkKHdpbmRvdykub24oJ2tleWRvd24nLCBldmVudCA9PiB7XG4gICAgICAgICAgICBjb25zdCBhY3Rpb25zID0ge1xuICAgICAgICAgICAgICAgICcrJzogMC4xLFxuICAgICAgICAgICAgICAgICctJzogLTAuMVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGFjdGlvbnNbZXZlbnQua2V5XSkge1xuICAgICAgICAgICAgICAgIHRoaXMuem9vbSArPSBhY3Rpb25zW2V2ZW50LmtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcm9wZXJ0eSBjb250YWluaW5nIGFuIGluc3RhbmNlIG9mIFtUdXRvcmlhbF0oLi9tb2R1bGUtVHV0b3JpYWwuaHRtbCksIGlmIHRoZXJlIGlzIGFueVxuICAgICAgICAgKiBAdHlwZSB7VHV0b3JpYWx9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR1dG9yaWFsO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSB1c2VyIHZpc2l0cyBmb3IgdGhlIGZpcnN0IHRpbWUsIGlmIHNvLCBzdGFydCB0aGUgdHV0b3JpYWxcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghbG9jYWxTdG9yYWdlLnVzZXJIYXNWaXNpdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFR1dG9yaWFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgd2lkdGggb2YgdGhlIG1haW4gU1ZHIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHdpZHRoIG9mIHRoZSBTVkcgZWxlbWVudCBpbiBwaXhlbHNcbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRzdmcud2lkdGgoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGhlaWdodCBvZiB0aGUgbWFpbiBTVkcgZWxlbWVudFxuICAgICAqIEByZXR1cm4ge251bWJlcn0gaGVpZ2h0IG9mIHRoZSBTVkcgZWxlbWVudCBpbiBwaXhlbHNcbiAgICAgKi9cbiAgICBnZXQgaGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kc3ZnLmhlaWdodCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgYWxsIGtleWRvd24gZXZlbnRzIHRoYXQgYXJlIGNvbm5lY3RlZCB0byB0aGUgYXBwXG4gICAgICogQHBhcmFtICB7anF1ZXJ5LktleWJvYXJkRXZlbnR9IGV2ZW50IEtleWJvYXJkRXZlbnQgZ2VuZXJhdGVkIGJ5IGEgbGlzdGVuZXJcbiAgICAgKi9cbiAgICBvbktleURvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IGN0cmxLZXkgfHwgZXZlbnQua2V5Q29kZSA9PT0gY21kS2V5KSB7XG4gICAgICAgICAgICB0aGlzLiRzdmcuYWRkQ2xhc3MoJ2dyYWJiYWJsZScpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhbGwga2V5dXAgZXZlbnRzIHRoYXQgYXJlIGNvbm5lY3RlZCB0byB0aGUgYXBwXG4gICAgICogQHBhcmFtICB7anF1ZXJ5LktleWJvYXJkRXZlbnR9IGV2ZW50IEtleWJvYXJkRXZlbnQgZ2VuZXJhdGVkIGJ5IGEgbGlzdGVuZXJcbiAgICAgKi9cbiAgICBvbktleVVwKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBjdHJsS2V5IHx8IGV2ZW50LmtleUNvZGUgPT09IGNtZEtleSkge1xuICAgICAgICAgICAgdGhpcy4kc3ZnLnJlbW92ZUNsYXNzKCdncmFiYmFibGUnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgYWxsIG1vdXNlZG93biBldmVudHMgdGhhdCBhcmUgaGFwcGVuaW5nIGRpcmVjdGx5IG9uIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0gIHtqcXVlcnkuTW91c2VFdmVudH0gZXZlbnQgTW91c2VFdmVudCBnZW5lcmF0ZWQgYnkgYSBsaXN0ZW5lclxuICAgICAqL1xuICAgIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICAgIC8vIGFueSBjbGljayBvbiBjYW52YXMgY2FuY2VscyB0aGUgd2lyZSBjcmVhdGlvblxuICAgICAgICB0aGlzLmNhbmNlbFdpcmVDcmVhdGlvbigpO1xuXG4gICAgICAgIC8vIG1pZGRsZSBtb3VzZSBvciBsZWZ0IG1vdXNlICsgY3RybCBtb3ZlcyB0aGUgY2FudmFzXG4gICAgICAgIGlmIChldmVudC53aGljaCA9PT0gMiB8fCAoZXZlbnQud2hpY2ggPT09IDEgJiYgZXZlbnQuY3RybEtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuJHN2Zy5hZGRDbGFzcygnZ3JhYmJlZCcpO1xuICAgICAgICAgICAgdGhpcy5tb3ZlQ2FudmFzID0ge1xuICAgICAgICAgICAgICAgIGxlZnQ6IGV2ZW50LnBhZ2VYLFxuICAgICAgICAgICAgICAgIHRvcDogZXZlbnQucGFnZVlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGFsbCBtb3VzZW1vdmUgZXZlbnRzIHRoYXQgYXJlIGhhcHBlbmluZyBkaXJlY3RseSBvbiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtICB7anF1ZXJ5Lk1vdXNlRXZlbnR9IGV2ZW50IE1vdXNlRXZlbnQgZ2VuZXJhdGVkIGJ5IGEgbGlzdGVuZXJcbiAgICAgKi9cbiAgICBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgICBpZiAodGhpcy5tb3ZlQ2FudmFzKSB7XG4gICAgICAgICAgICBsZXQgbGVmdCA9IGV2ZW50LnBhZ2VYIC0gdGhpcy5tb3ZlQ2FudmFzLmxlZnQ7XG4gICAgICAgICAgICBsZXQgdG9wID0gZXZlbnQucGFnZVkgLSB0aGlzLm1vdmVDYW52YXMudG9wO1xuXG4gICAgICAgICAgICB0aGlzLnZpZXdib3gubW92ZShsZWZ0LCB0b3ApO1xuXG4gICAgICAgICAgICB0aGlzLmFwcGx5Vmlld2JveCgpO1xuXG4gICAgICAgICAgICB0aGlzLm1vdmVDYW52YXMgPSB7XG4gICAgICAgICAgICAgICAgbGVmdDogZXZlbnQucGFnZVgsXG4gICAgICAgICAgICAgICAgdG9wOiBldmVudC5wYWdlWVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgYWxsIG1vdXNldXAgZXZlbnRzIHRoYXQgYXJlIGhhcHBlbmluZyBkaXJlY3RseSBvbiB0aGUgY2FudmFzXG4gICAgICovXG4gICAgb25Nb3VzZVVwKCkge1xuICAgICAgICBpZiAodGhpcy5tb3ZlQ2FudmFzKSB7XG4gICAgICAgICAgICB0aGlzLiRzdmcucmVtb3ZlQ2xhc3MoJ2dyYWJiZWQnKTtcbiAgICAgICAgICAgIHRoaXMubW92ZUNhbnZhcyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgLy8gaWYgdHV0b3JpYWwgZXhpc3RzLCBjYWxsIHR1dG9yaWFsIGNhbGxiYWNrXG4gICAgICAgICAgICBpZiAodGhpcy50dXRvcmlhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHV0b3JpYWwub25DYW52YXNNb3ZlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2aWV3Qm94IGF0dHJpYnV0ZSBvZiB0aGUgU1ZHIGVsZW1lbnQgYW5kIHNpemUgYW5kIHBvc2l0aW9uIGF0dHJpYnV0ZXNcbiAgICAgKiBvZiB0aGUgcmVjdGFuZ2xlIHdpdGggdGhlIGJhY2tncm91bmQgZ3JpZCB0byBtYXRjaCB0aGUgdmFsdWVzIGluIHRoaXMudmlld2JveFxuICAgICAqL1xuICAgIGFwcGx5Vmlld2JveCgpIHtcbiAgICAgICAgLy8gYWRqdXN0IGJhY2tncm91bmRcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kLmFkZEF0dHIoe1xuICAgICAgICAgICAgeDogdGhpcy52aWV3Ym94LmxlZnQsXG4gICAgICAgICAgICB5OiB0aGlzLnZpZXdib3gudG9wLFxuICAgICAgICAgICAgd2lkdGg6IHRoaXMudmlld2JveC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy52aWV3Ym94LmhlaWdodFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzZXQgdGhlIHZpZXdCb3ggYXR0cmlidXRlXG4gICAgICAgIHRoaXMuJHN2Zy5hdHRyKCd2aWV3Qm94JywgdGhpcy52aWV3Ym94LnN0cik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHpvb20gbXVsdGlwbGllciBvZiB0aGUgY2FudmFzXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCB6b29tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3Ym94Lnpvb207XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB6b29tIG11bHRpcGxpZXIgb2YgdGhlIGNhbnZhcy5cbiAgICAgKiBJIHNldHMgdGhlIHZpZXdib3ggem9vbSBhbmQgdGhlbiBhcHBsaWVzIHRoZSBuZXcgdmFsdWUgYnkgY2FsbGluZyB0aGlzLmFwcGx5Vmlld2JveCgpXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB2YWx1ZSBzZXQgdGhlIHpvb20gdG8gdGhpcyB2YWx1ZVxuICAgICAqL1xuICAgIHNldCB6b29tKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmlld2JveC56b29tID0gdmFsdWU7XG4gICAgICAgIHRoaXMuYXBwbHlWaWV3Ym94KCk7XG5cbiAgICAgICAgLy8gaWYgdHV0b3JpYWwgZXhpc3RzLCBjYWxsIHR1dG9yaWFsIGNhbGxiYWNrXG4gICAgICAgIGlmICh0aGlzLnR1dG9yaWFsKSB7XG4gICAgICAgICAgICB0aGlzLnR1dG9yaWFsLm9uQ2FudmFzWm9vbWVkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzdGFydCB0aGUgdHV0b3JpYWxcbiAgICAgKi9cbiAgICBzdGFydFR1dG9yaWFsKCkge1xuICAgICAgICAvLyBpbnN0YW50aWF0ZSB0aGUgdHV0b3JpYWxcbiAgICAgICAgdGhpcy50dXRvcmlhbCA9IG5ldyBUdXRvcmlhbCh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBzZXQgdXNlckhhc1Zpc2l0ZWQgdG8gdHJ1ZSB3aGVuIHVzZXIgY2xvc2VzIChvciBmaW5pc2hlcykgdGhlIHR1dG9yaWFsXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UudXNlckhhc1Zpc2l0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyB1bnNldCB0aGUgdGhpcy50dXRvcmlhbCBwcm9wZXJ0eVxuICAgICAgICAgICAgdGhpcy50dXRvcmlhbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc3RhcnQgdGhlIHR1dG9yaWFsXG4gICAgICAgIHRoaXMudHV0b3JpYWwuc3RhcnQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhbiBvYmplY3QgY29udGFpbmluZyBleHBvcnQgZGF0YSBmb3IgdGhlIGNhbnZhcyBhbmQgYWxsIGVsZW1lbnRzLlxuICAgICAqIERhdGEgZnJvbSB0aGlzIGZ1bmN0aW9uIHNob3VsZCBjb3ZlciBhbGwgaW1wb3J0YW50IGluZm9ybWF0aW9uIG5lZWRlZCB0byBpbXBvcnQgdGhlXG4gICAgICogbmV0d29yayBpbiBhIGRpZmZlcmVudCBzZXNzaW9uLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgaW5mb21yYXRpb24gYWJvdXQgdGhlIG5ldHdvcmtcbiAgICAgKi9cbiAgICBnZXQgZXhwb3J0RGF0YSgpIHtcbiAgICAgICAgdGhpcy5leHBvcnRXaXJlSWRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZXhwb3J0V2lyZUlkID0gMDtcblxuICAgICAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgICAgIGJveGVzOiBbXVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoY29uc3QgYm94IG9mIHRoaXMuYm94ZXMpIHtcbiAgICAgICAgICAgIGRhdGEuYm94ZXMucHVzaChib3guZXhwb3J0RGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWNyZWF0ZSBhIGxvZ2ljIG5ldHdvcmsgZnJvbSB0aGUgZGF0YSBwcm92aWRlZFxuICAgICAqIEBwYXJhbSAge29iamVjdH0gZGF0YSBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaW1wb3J0ZWQgbmV0d29ya1xuICAgICAqIEBwYXJhbSAge251bWJlcn0gW3hdICBob3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBsZWZ0IHRvcCBjb3JuZXIgb2YgdGhlIG5ldHdvcmsgaW4gZ3JpZCBwaXhlbHNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IFt5XSAgdmVydGljYWwgcG9zaXRpb24gb2YgdGhlIGxlZnQgdG9wIGNvcm5lciBvZiB0aGUgbmV0d29yayBpbiBncmlkIHBpeGVsc1xuICAgICAqL1xuICAgIGltcG9ydERhdGEoZGF0YSwgeCwgeSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBsZXQgd2FybmluZ3MgPSBbXTtcblxuICAgICAgICAgICAgLy8gaWYgdGhlIHggb3IgeSBpcyB1bmRlZmluZWQsIHNldCBpdCB0byBsZWZ0VG9wUGFkZGluZyBpbnN0ZWFkXG4gICAgICAgICAgICAvLyAoY2Fubm90IHVzZSB4IHx8IGxlZnRUb3BQYWRkaW5nIGJlY2F1c2Ugb2YgMClcbiAgICAgICAgICAgIHggPSB4ICE9PSB1bmRlZmluZWQgPyB4IDogdGhpcy5sZWZ0VG9wUGFkZGluZztcbiAgICAgICAgICAgIHkgPSB5ICE9PSB1bmRlZmluZWQgPyB5IDogdGhpcy5sZWZ0VG9wUGFkZGluZztcblxuICAgICAgICAgICAgdGhpcy5zaW11bGF0aW9uRW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBsaXN0IG9mIHdpcmVzIHRvIGJlIGFkZGVkXG4gICAgICAgICAgICBsZXQgbmV3V2lyZXMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIGxlZnRtb3N0IGFuZCB0b3Btb3N0IGNvb3JkaW5hdGUgb2YgYW55IGJveCwgc2F2ZSB0aGVtIHRvIGxlZnRUb3BDb3JuZXJcbiAgICAgICAgICAgIGxldCBsZWZ0VG9wQ29ybmVyID0ge1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBib3hEYXRhIG9mIGRhdGEuYm94ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYm94RGF0YS50cmFuc2Zvcm0gJiYgYm94RGF0YS50cmFuc2Zvcm0uaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB0cmFuc2Zvcm1JbmZvIG9mIGJveERhdGEudHJhbnNmb3JtLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtSW5mby5uYW1lID09PSAndHJhbnNsYXRlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0VG9wQ29ybmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRUb3BDb3JuZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBNYXRoLm1pbihsZWZ0VG9wQ29ybmVyLngsIHRyYW5zZm9ybUluZm8uYXJnc1swXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBNYXRoLm1pbihsZWZ0VG9wQ29ybmVyLnksIHRyYW5zZm9ybUluZm8uYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0VG9wQ29ybmVyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogdHJhbnNmb3JtSW5mby5hcmdzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogdHJhbnNmb3JtSW5mby5hcmdzWzFdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBib3hEYXRhIG9mIGRhdGEuYm94ZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBtYXBwaW5nIG9mIGRhdGFCb3gubmFtZSBvZiB0aGUgb2JqZWN0cyB0aGF0IGhhdmUgY2F0ZWdvcnkgXCJvdGhlclwiXG4gICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJNYXAgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiB0aGlzLm5ld0lucHV0KDAsIDAsIGJveERhdGEuaXNPbiwgZmFsc2UpLFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IHRoaXMubmV3T3V0cHV0KDAsIDAsIGZhbHNlKVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBtYXBwaW5nIG9mIGRhdGFCb3guY2F0ZWdvcnlcbiAgICAgICAgICAgICAgICBjb25zdCBib3hNYXAgPSB7XG4gICAgICAgICAgICAgICAgICAgIGdhdGU6ICgpID0+IHRoaXMubmV3R2F0ZShib3hEYXRhLm5hbWUsIDAsIDAsIGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgYmxhY2tib3g6ICgpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld0JsYWNrYm94KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJveERhdGEuaW5wdXRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJveERhdGEub3V0cHV0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3hEYXRhLnRhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJveERhdGEubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIG90aGVyOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJveERhdGEubmFtZSkgdGhyb3cgYFRoaXMgbmV0d29yayBjb250YWlucyBhIGJveCB3aXRob3V0IGEgbmFtZS5gO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW90aGVyTWFwW2JveERhdGEubmFtZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgYFRoaXMgbmV0d29yayBjb250YWlucyB1bmtub3duIGJveCBuYW1lcy4gKCR7Ym94RGF0YS5uYW1lfSlgO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXJNYXBbYm94RGF0YS5uYW1lXSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGNyZWF0ZUJveCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFib3hEYXRhLmNhdGVnb3J5KSB0aHJvdyBgVGhpcyBuZXR3b3JrIGEgYm94IHdpdGhvdXQgYSBjYXRlZ29yeS5gO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghYm94TWFwW2JveERhdGEuY2F0ZWdvcnldKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgYFRoaXMgbmV0d29yayBjb250YWlucyB1bmtub3duIGJveCBjYXRlZ29yaWVzLiAoJHtib3hEYXRhLmNhdGVnb3J5fSlgO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBib3hNYXBbYm94RGF0YS5jYXRlZ29yeV0oKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgbGV0IGJveDtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGJveCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZ3MucHVzaChlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYm94KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByb2NjZXNzIGJveCB0cmFuc2Zvcm1zICh0cmFuc2xhdGlvbiBhbmQgcm90YXRpb24pXG4gICAgICAgICAgICAgICAgICAgIGxldCB0cmFuc2Zvcm0gPSBuZXcgZWRpdG9yRWxlbWVudHMuVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCByb3RhdGlvbkNvdW50ID0gMDtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1JdGVtTWFwID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlOiBhcmdzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0uc2V0VHJhbnNsYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzWzBdIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdFRvcENvcm5lci54ICsgLy8gbWFrZSBpdCB0aGUgcmVsYXRpdmUgZGlzdGFuY2UgZnJvbSB0aGUgbGVmdG1vc3QgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCwgLy8gYXBwbHkgdGhlIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbMV0gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0VG9wQ29ybmVyLnkgKyAvLyBtYWtlIGl0IHRoZSByZWxhdGl2ZSBkaXN0YW5jZSBmcm9tIHRoZSB0b3Btb3N0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgLy8gYXBwbHkgdGhlIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICByb3RhdGU6IGFyZ3MgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uQ291bnQgPSAoYXJnc1swXSAlIDM2MCkgLyA5MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoYm94RGF0YS50cmFuc2Zvcm0gJiYgYm94RGF0YS50cmFuc2Zvcm0uaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdHJhbnNmb3JtSXRlbSBvZiBib3hEYXRhLnRyYW5zZm9ybS5pdGVtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgbmFtZSwgYXJncyB9ID0gdHJhbnNmb3JtSXRlbTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5ncy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFRoaXMgbmV0d29yayBjb250YWlucyB1bm5hbWVkIHRyYW5zZm9ybSBwcm9wZXJ0aWVzLmBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0cmFuc2Zvcm1JdGVtTWFwW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgVGhpcyBuZXR3b3JrIGNvbnRhaW5zIHVua25vd24gdHJhbnNmb3JtIHByb3BlcnRpZXMuICgke1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUl0ZW0ubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUl0ZW1NYXBbbmFtZV0oYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0udG9TVkdQaXhlbHModGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGJveC5zZXRUcmFuc2Zvcm0odHJhbnNmb3JtKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdGF0aW9uQ291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm94LnJvdGF0ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBhbGwgd2lyZXMgdG8gdGhlIGxpc3Qgb2Ygd2lyZXMgdG8gYmUgYWRkZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJveERhdGEuY29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29ubmVjdGlvbiBvZiBib3hEYXRhLmNvbm5lY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBhcnRpZmljaWFsIHdpcmUgaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgd2lyZUlkID0gY29ubmVjdGlvbi53aXJlSWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXNzIHRoZSB2YWx1ZXMgZ290IGZyb20ganNvbiBpbnRvIGEgdmFyaWFibGUgdGhhdCB3aWxsIGJlIGFkZGVkIGludG8gdGhlIG1hcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGNvbm5lY3Rpb24uaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJveElkOiBib3guaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSB2YWx1ZSB0byB0aGUgbWFwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1dpcmVzLmhhcyh3aXJlSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFscmVhZHkgaXMgYSB3aXJlIHdpdGggdGhpcyBpZCBpbiB0aGUgbWFwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIHZhbHVlIHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5IG9mIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWFwVmFsdWUgPSBuZXdXaXJlcy5nZXQod2lyZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwVmFsdWUucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1dpcmVzLnNldCh3aXJlSWQsIG1hcFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyB3aXJlIHdpdGggdGhpcyBpZCBpbiB0aGUgbWFwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgd2lyZSBhbmQgc2V0IHRoZSB2YWx1ZSB0byBiZSB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3V2lyZXMuc2V0KHdpcmVJZCwgW3ZhbHVlXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZWZyZXNoIHRoZSBTVkcgZG9jdW1lbnQgKG5lZWRlZCBmb3Igd2lyaW5nKVxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG5cbiAgICAgICAgICAgIC8vIHdpdGggYWxsIGJveGVzIGFkZGVkLCB3ZSBjYW4gbm93IGNvbm5lY3QgdGhlbSB3aXRoIHdpcmVzXG5cbiAgICAgICAgICAgIC8vIHByaW9yaXR5IHF1ZXVlIGZvciB0aGUgbmV3IHdpcmVzLCBwcmlvcml0eSBiZWluZyAoMSAvIG1hbmhhdHRhbkRpc3RhbmNlKSBiZXR3ZWVuIHRoZSBjb25lbmN0b3JzLCBoaWdoZXIgaXMgYmV0dGVyXG4gICAgICAgICAgICBsZXQgd2lyZVF1ZXVlID0gbmV3IFByaW9yaXR5UXVldWUoKTtcblxuICAgICAgICAgICAgLy8gZ2V0IGFsbCBpZHMgZm9yIGxhbCB0aGVcbiAgICAgICAgICAgIGZvciAoY29uc3Qgd2lyZUluZm8gb2YgbmV3V2lyZXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29ubmVjdG9ySWRzID0gW107XG5cbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYW4gYXJyYXkgW2Nvbm5lY3RvcjFJZCwgY29ubmVjdG9yMklkXVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyBib3hJZCwgaW5kZXggfSBvZiB3aXJlSW5mbykge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3JJZHMucHVzaCh0aGlzLmdldEJveEJ5SWQoYm94SWQpLmNvbm5lY3RvcnNbaW5kZXhdLmlkKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYW5kIGFycmF5IFt7eCwgeX0sIHt4LCB5fV0gY29udGFpbmluZyBwb3NpdGlvbnMgZm9yIGNvbm5lY3RvcnMgMSBhbmQgMlxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RvcnNQb3NpdGlvbnMgPSBjb25uZWN0b3JJZHMubWFwKGNvbm5lY3RvcklkID0+XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q29ubmVjdG9yUG9zaXRpb24odGhpcy5nZXRDb25uZWN0b3JCeUlkKGNvbm5lY3RvcklkKSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3RvcnNQb3NpdGlvbnMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB3aXJlID0gdGhpcy5uZXdXaXJlKC4uLmNvbm5lY3RvcklkcywgZmFsc2UsIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIG1hbmhhdHRhbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZXNlIHR3byBjb25uZWN0b3JzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gbWFuaGF0dGFuRGlzdGFuY2UoLi4uY29ubmVjdG9yc1Bvc2l0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGNvbm5lY3RvcmlkcyB0byB0aGUgcHJpb3JpdHkgcXVldWVcbiAgICAgICAgICAgICAgICAgICAgd2lyZVF1ZXVlLmVucXVldWUod2lyZSwgMSAvIGRpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3YXJuaW5ncy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgYEZvdW5kIGEgd2lyZSB0aGF0IGRvZXMgbm90IGhhdmUgdHdvIGVuZGluZ3MuIChJdCBoYWQgJHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3JzUG9zaXRpb25zLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBpbnN0ZWFkLilgXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAod2luZG93Lldvcmtlcikge1xuICAgICAgICAgICAgICAgIGxldCB3aXJlUG9pbnRzID0gW107XG4gICAgICAgICAgICAgICAgbGV0IHdpcmVSZWZlcmVuY2VzID0gW107XG5cbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHRoZSBxdWV1ZSB0byBhbiBhcnJheSAodGhpcyBpcyBuZWVkZWQgYnkgdGhlIHdlYiB3b3JrZXIpXG4gICAgICAgICAgICAgICAgd2hpbGUgKCF3aXJlUXVldWUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdpcmUgPSB3aXJlUXVldWUuZGVxdWV1ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCB3aXJlU3RhcnQgPSB0aGlzLmdldENvbm5lY3RvclBvc2l0aW9uKHdpcmUuY29ubmVjdGlvbi5mcm9tLmNvbm5lY3RvciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB3aXJlRW5kID0gdGhpcy5nZXRDb25uZWN0b3JQb3NpdGlvbih3aXJlLmNvbm5lY3Rpb24udG8uY29ubmVjdG9yLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICB3aXJlUG9pbnRzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHdpcmVTdGFydC54IC8gdGhpcy5ncmlkU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB3aXJlU3RhcnQueSAvIHRoaXMuZ3JpZFNpemVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogd2lyZUVuZC54IC8gdGhpcy5ncmlkU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB3aXJlRW5kLnkgLyB0aGlzLmdyaWRTaXplXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHdpcmVSZWZlcmVuY2VzLnB1c2god2lyZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gW3JvdXRlV29ya2VyRmlsZU5hbWVdIHJlcGxhY2VkIGluIHRoZSBidWlsZCBwcm9jZXNzIChkZWZpbmVkIGluIGd1bHBmaWxlKSBkZXBlbmRpbmcgb24gZGV2ZWwgLyBwcm9kIGJ1aWxkXG4gICAgICAgICAgICAgICAgbGV0IG15V29ya2VyID0gbmV3IFdvcmtlcignanMvW3JvdXRlV29ya2VyRmlsZU5hbWVdJyk7XG5cbiAgICAgICAgICAgICAgICBsZXQgbG9hZGluZ01lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VzLm5ld0xvYWRpbmdNZXNzYWdlKFxuICAgICAgICAgICAgICAgICAgICAnbG9va2luZyBmb3IgdGhlIGJlc3Qgd2lyaW5n4oCmJ1xuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBteVdvcmtlci5vbm1lc3NhZ2UgPSBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcGF0aHMgfSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGUgd2lyZVJlZmVyZW5jZXMgYW5kIHBhdGhzIHN5bmNocm9ub3VzbHlcbiAgICAgICAgICAgICAgICAgICAgd2lyZVJlZmVyZW5jZXMuZm9yRWFjaCgod2lyZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aXJlLnNldFdpcmVQYXRoKHdpcmUucGF0aFRvUG9seUxpbmUocGF0aHNba2V5XSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lyZS51cGRhdGVXaXJlU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZ01lc3NhZ2UuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgICAgICB3aXJlczogd2lyZVBvaW50cyxcbiAgICAgICAgICAgICAgICAgICAgbm9uUm91dGFibGVOb2RlczogdGhpcy5nZXROb25Sb3V0YWJsZU5vZGVzKCksXG4gICAgICAgICAgICAgICAgICAgIGluY29udmVuaWVudE5vZGVzOiB0aGlzLmdldEluY29udmVuaWVudE5vZGVzKClcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgbXlXb3JrZXIucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHdlYiB3b3JrZXIgaXMgbm90IHN1cHBvcnRlZDogdXNlIGFuIGludGVydmFsIHRvIG1ha2UgdGhlIGltcG9ydCBhIGJpdCBzbG93ZXJcbiAgICAgICAgICAgICAgICAvLyBieSBkaXZpZGluZyBpdCBpbnRvIGNodW5rcywgc28gdGhlIGJyb3dzZXIgd2luZG93IGlzIG5vdCBlbnRpcmVseSBmcm96ZW4gd2hlbiB0aGUgd2lyaW5nIGlzIGhhcHBlbmluZ1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgd2lyZXNUb0JlUm91dGVkQXRPbmNlID0gMTA7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsYXlCZXR3ZWVuSXRlcmF0aW9ucyA9IDIwMDtcblxuICAgICAgICAgICAgICAgIC8vIGFkZCB3aXJlcyBpbiB0aGUgb3JkZXIgZnJvbSBzaG9ydCB0byBsb25nXG4gICAgICAgICAgICAgICAgbGV0IHdpcmVQbGFjaW5nSW50ZXJ2YWwgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXdpcmVRdWV1ZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lyZXNUb0JlUm91dGVkQXRPbmNlOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2lyZVF1ZXVlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3aXJlID0gd2lyZVF1ZXVlLmRlcXVldWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXJlLnJvdXRlV2lyZSh0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lyZS51cGRhdGVXaXJlU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh3aXJlUGxhY2luZ0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGRlbGF5QmV0d2Vlbkl0ZXJhdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZWZyZXNoIHRoZSBTVkcgZG9jdW1lbnRcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuXG4gICAgICAgICAgICB0aGlzLnNpbXVsYXRpb25FbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgcmVzb2x2ZSh3YXJuaW5ncyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gdXNlciBjbGlja3Mgb24gYSBjb25uZWN0b3IsIHJlbWVtYmVyIGl0IHVudGlsIHRoZXkgY2xpY2sgb24gc29tZSBvdGhlciBjb25uZWN0b3IuXG4gICAgICogVGhhbiBjYWxsIG5ld1dpcmUgd2l0aCB0aGUgbGFzdCB0d28gY29ubmVjdG9ycyBpZHMgYXMgYXJndW1lbnRzLlxuICAgICAqIFZpc3VhbGl6ZSB0aGUgcHJvY2VzcyBieSBkaXNwbGF5aW5nIGEgZ3JleSB3aXJlIGJldHdlZW4gdGhlIGZpcnN0IGNvbmVuY3RvciBhbmQgdGhlIG1vdXNlIHBvaW50ZXIuXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBjb25uZWN0b3JJZCBpZCBvZiB0aGUgY29ubmVjdG9yIHRoYXQgdGhlIHVzZXIgY2xpY2tlZCBvblxuICAgICAqL1xuICAgIHdpcmVDcmVhdGlvbkhlbHBlcihjb25uZWN0b3JJZCwgbW91c2VQb3NpdGlvbikge1xuICAgICAgICBpZiAoIXRoaXMud2lyZUNyZWF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLndpcmVDcmVhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBmcm9tSWQ6IGNvbm5lY3RvcklkXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlDcmVhdGVkV2lyZShtb3VzZVBvc2l0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndpcmVDcmVhdGlvbi5mcm9tSWQgIT09IGNvbm5lY3RvcklkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlQ3JlYXRlZFdpcmUoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMubmV3V2lyZSh0aGlzLndpcmVDcmVhdGlvbi5mcm9tSWQsIGNvbm5lY3RvcklkKTtcblxuICAgICAgICAgICAgICAgIHRoaXMud2lyZUNyZWF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGVscGVyIGZvciB3aXJlQ3JlYXRpb25IZWxwZXIgdGhhdCBkaXNwbGF5cyBhIGdyZXkgd2lyZSBiZXR3ZWVuIHRoZSBmaXJzdCBjb25uZWN0b3IgYW5kIHRoZSBzcGVjaWZpZWQgbW91c2VQb3NpdGlvblxuICAgICAqIEBwYXJhbSAge09iamVjdH0gbW91c2VQb3NpdGlvbiBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvb3JkaW5hdGVzIGluIFNWRyBwaXhlbHNcbiAgICAgKi9cbiAgICBkaXNwbGF5Q3JlYXRlZFdpcmUobW91c2VQb3NpdGlvbikge1xuICAgICAgICB0aGlzLndpcmVDcmVhdGlvbi50ZW1wV2lyZSA9IG5ldyBlZGl0b3JFbGVtZW50cy5IZWxwZXJXaXJlKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIHRoaXMud2lyZUNyZWF0aW9uLmZyb21JZCxcbiAgICAgICAgICAgIG1vdXNlUG9zaXRpb25cbiAgICAgICAgKTtcblxuICAgICAgICAkKHdpbmRvdykub24oJ21vdXNlbW92ZS53aXJlQ3JlYXRpb24nLCBldmVudCA9PiB7XG4gICAgICAgICAgICBldmVudCA9IHRoaXMudmlld2JveC50cmFuc2Zvcm1FdmVudChldmVudCk7XG5cbiAgICAgICAgICAgIG1vdXNlUG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeDogZXZlbnQucGFnZVgsXG4gICAgICAgICAgICAgICAgeTogZXZlbnQucGFnZVlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMud2lyZUNyZWF0aW9uLnRlbXBXaXJlLnVwZGF0ZU1vdXNlUG9zaXRpb24obW91c2VQb3NpdGlvbik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYXBwZW5kRWxlbWVudCh0aGlzLndpcmVDcmVhdGlvbi50ZW1wV2lyZSk7XG4gICAgICAgIHRoaXMubW92ZVRvQmFja0J5SWQodGhpcy53aXJlQ3JlYXRpb24udGVtcFdpcmUuaWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGhlbHBlciBmb3Igd2lyZUNyZWF0aW9uSGVscGVyIHRoYXQgaGlkZXMgdGhlIHRlbXBvcmFyeSB3aXJlIHdoZW4gd2lyZSBjcmVhdGlvbiBpcyBkb25lXG4gICAgICovXG4gICAgaGlkZUNyZWF0ZWRXaXJlKCkge1xuICAgICAgICAkKHdpbmRvdykub2ZmKCdtb3VzZW1vdmUud2lyZUNyZWF0aW9uJyk7XG5cbiAgICAgICAgdGhpcy53aXJlQ3JlYXRpb24udGVtcFdpcmUuZ2V0KCkucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMud2lyZUNyZWF0aW9uLnRlbXBXaXJlID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGhlbHBlciBmb3Igd2lyZUNyZWF0aW9uSGVscGVyIHRoYXQgY2FuY2VscyB0aGUgd2lyZSBjcmVhdGlvbiBwcm9jZXNzXG4gICAgICovXG4gICAgY2FuY2VsV2lyZUNyZWF0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy53aXJlQ3JlYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZUNyZWF0ZWRXaXJlKCk7XG4gICAgICAgICAgICB0aGlzLndpcmVDcmVhdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1biBhIGxvZ2ljIHNpbXVsYXRpb24gZnJvbSB0aGUgc3RhcnRpbmdDb25uZWN0b3IuXG4gICAgICogVGhpcyByZWZyZXNoZXMgdGhlIHN0YXRlcyBvZiBhbGwgZWxlbWVudHMgaW4gdGhlIG5ldHdvcmsgd2hvc2UgaW5wdXRzIGFyZVxuICAgICAqIGRpcmVjdGx5IChvciBieSB0cmFuc2l0aW9uKSBjb25uZWN0ZWQgdG8gc3RhcnRpbmdDb25uZWN0b3IncyBvdXRwdXRcbiAgICAgKiBAcGFyYW0gIHtPdXRwdXRDb25uZWN0b3J9IHN0YXJ0aW5nQ29ubmVjdG9yIHJ1biBzaW11bGF0aW9uIGZyb20gdGhpcyBvdXRwdXQgY29ubmVjdG9yXG4gICAgICogQHBhcmFtICB7TG9naWMuc3RhdGV9IHN0YXRlIG5ldyBzdGF0ZSBvZiB0aGUgc3RhcnRpbmdDb25uZWN0b3JcbiAgICAgKi9cbiAgICBzdGFydE5ld1NpbXVsYXRpb24oc3RhcnRpbmdDb25uZWN0b3IsIHN0YXRlKSB7XG4gICAgICAgIGlmICh0aGlzLnNpbXVsYXRpb25FbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNpbXVsYXRpb24gPSBuZXcgU2ltdWxhdGlvbih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuc2ltdWxhdGlvbi5ub3RpZnlDaGFuZ2Uoc3RhcnRpbmdDb25uZWN0b3IuaWQsIHN0YXRlKTtcbiAgICAgICAgICAgIHRoaXMuc2ltdWxhdGlvbi5ydW4oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBnYXRlIG9uIHRoZSBzcGVjaWZpZWQgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBuYW1lICAgICAgICAgICB0eXBlIG9mIHRoZSBnYXRlIChhbmQsIG9yIC4uLilcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4ICAgICAgICAgICAgICBob3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBnYXRlIGluIFNWRyBwaXhlbHNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5ICAgICAgICAgICAgICB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgZ2F0ZSBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtICB7Ym9vbGVhbn0gW3JlZnJlc2g9dHJ1ZV0gaWYgdHJ1ZSwgdGhpcy5yZWZyZXNoKCkgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgYWRkaW5nIHRoZSBnYXRlXG4gICAgICogQHJldHVybiB7ZWRpdG9yRWxlbWVudHMuR2F0ZX0gICAgaW5zdGFuY2Ugb2YgR2F0ZSB0aGF0IGhhcyBiZWVuIG5ld2x5IGFkZGVkXG4gICAgICovXG4gICAgbmV3R2F0ZShuYW1lLCB4LCB5LCByZWZyZXNoID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdCb3goeCwgeSwgbmV3IGVkaXRvckVsZW1lbnRzLkdhdGUodGhpcywgbmFtZSwgeCwgeSksIHJlZnJlc2gpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBpbnB1dCBib3ggb24gdGhlIHNwZWNpZmllZCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSAge251bWJlcn0gIHggICAgICAgICAgICAgIGhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGdhdGUgaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkgICAgICAgICAgICAgIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBnYXRlIGluIFNWRyBwaXhlbHNcbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSBbaXNPbj1mYWxzZV0gICBzdGF0ZSBvZiB0aGUgaW5wdXQgYm94IChkZWZhdWx0IGlzIGZhbHNlIChvZmYpKVxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IFtyZWZyZXNoPXRydWVdIGlmIHRydWUsIHRoaXMucmVmcmVzaCgpIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGFkZGluZyB0aGUgaW5wdXQgYm94XG4gICAgICogQHJldHVybiB7ZWRpdG9yRWxlbWVudHMuSW5wdXRCb3h9ICAgIGluc3RhbmNlIG9mIHRoZSBJbnB1dEJveCB0aGF0IGhhcyBiZWVuIG5ld2x5IGFkZGVkXG4gICAgICovXG4gICAgbmV3SW5wdXQoeCwgeSwgaXNPbiA9IGZhbHNlLCByZWZyZXNoID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdCb3goeCwgeSwgbmV3IGVkaXRvckVsZW1lbnRzLklucHV0Qm94KHRoaXMsIGlzT24pLCByZWZyZXNoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gb3V0cHV0IGJveCBvbiB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSAgeCAgICAgICAgICAgICAgaG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgZ2F0ZSBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSAgeSAgICAgICAgICAgICAgdmVydGljYWwgcG9zaXRpb24gb2YgdGhlIGdhdGUgaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IFtyZWZyZXNoPXRydWVdIGlmIHRydWUsIHRoaXMucmVmcmVzaCgpIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGFkZGluZyB0aGUgb3V0cHV0IGJveFxuICAgICAqIEByZXR1cm4ge2VkaXRvckVsZW1lbnRzLklucHV0Qm94fSAgICBpbnN0YW5jZSBvZiB0aGUgT3V0cHV0Qm94IHRoYXQgaGFzIGJlZW4gbmV3bHkgYWRkZWRcbiAgICAgKi9cbiAgICBuZXdPdXRwdXQoeCwgeSwgcmVmcmVzaCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV3Qm94KHgsIHksIG5ldyBlZGl0b3JFbGVtZW50cy5PdXRwdXRCb3godGhpcyksIHJlZnJlc2gpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5ldyBCb3ggdG8gdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSAge251bWJlcn0gIHggICAgICAgICAgICAgIGhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJveCBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSAgeSAgICAgICAgICAgICAgdmVydGljYWwgcG9zaXRpb24gb2YgdGhlIGJveCBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtICB7ZWRpdG9yRWxlbWVudHMuQm94fSAgb2JqZWN0ICAgICAgICAgaW5zdGFuY2Ugb2YgYW4gb2JqZWN0IGRlcml2ZWQgZnJvbSB0aGUgZWRpdG9yRWxlbWVudHMuQm94IGNsYXNzXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gW3JlZnJlc2g9dHJ1ZV0gaWYgdHJ1ZSwgdGhpcy5yZWZyZXNoKCkgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgYWRkaW5nIHRoZSBib3hcbiAgICAgKiBAcmV0dXJuIHtlZGl0b3JFbGVtZW50cy5Cb3h9ICAgICAgICAgICAgICAgICByZXR1cm4gdGhlIGluc3RhbmNlIG9mIHRoZSBuZXdseSBhZGRlZCBvYmplY3RcbiAgICAgKi9cbiAgICBuZXdCb3goeCwgeSwgb2JqZWN0LCByZWZyZXNoID0gdHJ1ZSkge1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmJveGVzLmxlbmd0aDtcblxuICAgICAgICB0aGlzLmJveGVzW2luZGV4XSA9IG9iamVjdDtcblxuICAgICAgICAvLyB0cmFuc2xhdGUgdGhlIGdhdGUgaWYgeCBhbmQgeSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICAgICAgaWYgKHggJiYgeSkge1xuICAgICAgICAgICAgbGV0IHRyID0gbmV3IGVkaXRvckVsZW1lbnRzLlRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgdHIuc2V0VHJhbnNsYXRlKHgsIHkpO1xuXG4gICAgICAgICAgICB0aGlzLmJveGVzW2luZGV4XS5zdmdPYmouYWRkQXR0cih7IHRyYW5zZm9ybTogdHIuZ2V0KCkgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFwcGVuZEVsZW1lbnQodGhpcy5ib3hlc1tpbmRleF0sIHJlZnJlc2gpO1xuXG4gICAgICAgIC8vIGlmIHR1dG9yaWFsIGV4aXN0cywgY2FsbCB0dXRvcmlhbCBjYWxsYmFja1xuICAgICAgICBpZiAodGhpcy50dXRvcmlhbCkge1xuICAgICAgICAgICAgdGhpcy50dXRvcmlhbC5vbkVsZW1lbnRBZGRlZCh0aGlzLmJveGVzW2luZGV4XS5uYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmJveGVzW2luZGV4XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBib3ggZnJvbSBjYW52YXMgYmFzZWQgb24gdGhlIHByb3ZpZGVkIElEXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJveElkIGlkIG9mIHRoZSBib3ggdGhhdCBzaG91bGQgYmUgcmVtb3ZlZFxuICAgICAqL1xuICAgIHJlbW92ZUJveChib3hJZCkge1xuICAgICAgICBsZXQgJGdhdGUgPSAkKCcjJyArIGJveElkKTtcblxuICAgICAgICAvLyBmaW5kIHRoZSBnYXRlIGluIHN2ZydzIGxpc3Qgb2YgZ2F0ZXNcbiAgICAgICAgbGV0IGdhdGVJbmRleCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJveGVzW2ldLnN2Z09iai5pZCA9PT0gYm94SWQpIHtcbiAgICAgICAgICAgICAgICBnYXRlSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdhdGVJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgYWxsIHdpcmVzIGNvbm5lY3RlZCB0byB0aGlzIGdhdGVcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ib3hlc1tnYXRlSW5kZXhdLmNvbm5lY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVdpcmVzQnlDb25uZWN0b3JJZCh0aGlzLmJveGVzW2dhdGVJbmRleF0uY29ubmVjdG9yc1tpXS5pZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgZ2F0ZVxuICAgICAgICAgICAgdGhpcy5ib3hlcy5zcGxpY2UoZ2F0ZUluZGV4LCAxKTtcbiAgICAgICAgICAgICRnYXRlLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAvLyBpZiB0dXRvcmlhbCBleGlzdHMsIGNhbGwgdHV0b3JpYWwgY2FsbGJhY2tcbiAgICAgICAgICAgIGlmICh0aGlzLnR1dG9yaWFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50dXRvcmlhbC5vbkVsZW1lbnRSZW1vdmVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUcnlpbmcgdG8gcmVtb3ZlIGFuIG5vbmV4aXN0aW5nIGJveC4gQm94IGlkOicsIGJveElkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgYm94ZXMgZnJvbSB0aGUgY2FudmFzXG4gICAgICovXG4gICAgY2xlYW5DYW52YXMoKSB7XG4gICAgICAgIC8vIGNhbm5vdCBzaW1wbHkgaXRlcmF0ZSB0aHJvdWdoIHRoZSBhcnJheSBiZWNhdXNlIHJlbW92ZUJveCB3b3JrcyB3aXRoIGl0XG5cbiAgICAgICAgLy8gY3JlYXRlIGFuIGFycmF5IG9mIGlkc1xuICAgICAgICBjb25zdCBpZHMgPSB0aGlzLmJveGVzLm1hcChib3ggPT4gYm94LmlkKTtcblxuICAgICAgICAvLyByZW1vdmUgYWxsIGJveGVzIGJ5IHRoZWlyIGlkc1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGlkcykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVCb3goaWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHdpcmUgY29ubmVjdGluZyB0aGUgcHJvdmlkZWQgY29ubmVjdG9yc1xuICAgICAqIEBwYXJhbSAge3N0cmluZ30gIGZyb21JZCAgICAgICAgIGlkIG9mIHRoZSBjb25uZWN0b3IgdGhhdCB0aGUgd2lyZSBpcyBhdHRhY2hlZCB0b1xuICAgICAqIEBwYXJhbSAge3N0cmluZ30gIHRvSWQgICAgICAgICAgIGlkIG9mIHRoZSBjb25uZWN0b3IgdGhhdCB0aGUgd2lyZSBpcyBhdHRhY2hlZCB0b1xuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IFtyZWZyZXNoPXRydWVdIGlmIHJlZnJlc2ggaXMgc2V0IHRvIHRydWUsIHRoZSBTVkcgZG9jdW1lbnQgd2lsbCBiZSByZWxvYWRlZCBhZnRlciBhZGRpbmcgdGhlIHdpcmVcbiAgICAgKiBAcmV0dXJuIHtlZGl0b3JFbGVtZW50cy5XaXJlfSAgICBpbnN0YW5jZSBvZiBlZGl0b3JFbGVtZW50cy5XaXJlIHRoYXQgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIGNhbnZhc1xuICAgICAqL1xuICAgIG5ld1dpcmUoZnJvbUlkLCB0b0lkLCByZWZyZXNoID0gdHJ1ZSwgcm91dGUgPSB0cnVlKSB7XG4gICAgICAgIC8vIHdpcmUgbXVzdCBjb25uZWN0IHR3byBkaXN0aW5jdCBjb25uZWN0b3JzXG4gICAgICAgIGlmIChmcm9tSWQgPT09IHRvSWQpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAgICAgbGV0IGNvbm5lY3RvcnMgPSBbdGhpcy5nZXRDb25uZWN0b3JCeUlkKGZyb21JZCksIHRoaXMuZ2V0Q29ubmVjdG9yQnlJZCh0b0lkKV07XG5cbiAgICAgICAgLy8gaW5wdXQgY29ubmVjdG9ycyBjYW4gYmUgY29ubmVjdGVkIHRvIG9uZSB3aXJlIG1heFxuICAgICAgICBjb25uZWN0b3JzLmZvckVhY2goY29ubiA9PiB7XG4gICAgICAgICAgICBpZiAoY29ubi5pc0lucHV0Q29ubmVjdG9yKSB0aGlzLnJlbW92ZVdpcmVzQnlDb25uZWN0b3JJZChjb25uLmlkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMud2lyZXMubGVuZ3RoO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLndpcmVzW2luZGV4XSA9IG5ldyBlZGl0b3JFbGVtZW50cy5XaXJlKHRoaXMsIGZyb21JZCwgdG9JZCwgcmVmcmVzaCwgcm91dGUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VzLm5ld0Vycm9yTWVzc2FnZShlKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25uZWN0b3JzLmZvckVhY2goY29ubiA9PiB7XG4gICAgICAgICAgICBjb25uLmFkZFdpcmVJZCh0aGlzLndpcmVzW2luZGV4XS5zdmdPYmouaWQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFwcGVuZEVsZW1lbnQodGhpcy53aXJlc1tpbmRleF0sIHJlZnJlc2gpO1xuICAgICAgICB0aGlzLm1vdmVUb0JhY2tCeUlkKHRoaXMud2lyZXNbaW5kZXhdLnN2Z09iai5pZCk7XG5cbiAgICAgICAgaWYgKHJlZnJlc2gpIHRoaXMud2lyZXNbaW5kZXhdLnVwZGF0ZVdpcmVTdGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLndpcmVzW2luZGV4XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBzcGVjaWZpZWQgY29ubmVjdG9yXG4gICAgICogQHBhcmFtICB7Q29ubmVjdG9yfSAgY29ubmVjdG9yICAgICAgaW5zdGFuY2Ugb2Yge0BsaW5rIENvbm5lY3Rvcn1cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBbc25hcFRvR3JpZD10cnVlXSBpZiB0cnVlLCB0aGUgY29ubmVjdG9yIHBvc2l0aW9uIHdpbGwgYmUgc25hcHBlZCB0byB0aGUgZ3JpZFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgIHBvaW50IC0gb2JqZWN0IGNvbnRhaW5pbmcgbnVtZXJpYyBhdHRyaWJ1dGVzIGB4YCBhbmQgYHlgXG4gICAgICovXG4gICAgZ2V0Q29ubmVjdG9yUG9zaXRpb24oY29ubmVjdG9yLCBzbmFwVG9HcmlkID0gdHJ1ZSkge1xuICAgICAgICAvLyBjb25uZWN0b3Iuc3ZnT2JqLmlkIGhhcyB0byBiZSBjYWxsZWQsIGVsc2UgdGhlIGdldENvb3JkaW5hdGVzIGRvZXMgbm90IHdvcmsgb24gdGhlIGZpcnN0IGNhbGwgaW4gRmlyZWZveCA1NVxuICAgICAgICBjb25zdCBkdW1teSA9IGNvbm5lY3Rvci5zdmdPYmouaWQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAgICAgICBsZXQgJGNvbm5lY3RvciA9IGNvbm5lY3Rvci5zdmdPYmouJGVsO1xuXG4gICAgICAgIGxldCBwb3NpdGlvbiA9ICRjb25uZWN0b3IucG9zaXRpb24oKTtcblxuICAgICAgICBwb3NpdGlvbi5sZWZ0ID0gdGhpcy52aWV3Ym94LnRyYW5zZm9ybVgocG9zaXRpb24ubGVmdCk7XG4gICAgICAgIHBvc2l0aW9uLnRvcCA9IHRoaXMudmlld2JveC50cmFuc2Zvcm1ZKHBvc2l0aW9uLnRvcCk7XG5cbiAgICAgICAgbGV0IHdpZHRoID0gJGNvbm5lY3Rvci5hdHRyKCd3aWR0aCcpO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gJGNvbm5lY3Rvci5hdHRyKCdoZWlnaHQnKTtcblxuICAgICAgICBsZXQgeCA9IHBvc2l0aW9uLmxlZnQgKyB3aWR0aCAvIDI7XG4gICAgICAgIGxldCB5ID0gcG9zaXRpb24udG9wICsgaGVpZ2h0IC8gMjtcbiAgICAgICAgaWYgKHNuYXBUb0dyaWQpIHtcbiAgICAgICAgICAgIHggPSB0aGlzLnNuYXBUb0dyaWQoeCk7XG4gICAgICAgICAgICB5ID0gdGhpcy5zbmFwVG9HcmlkKHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZXMgYSBuZXcgYmxhY2tib3hcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggICAgICAgaG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmxhY2tib3ggaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSAge251bWJlcn0geSAgICAgICB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgZ2F0ZSBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBpbnB1dHMgIG51bWJlciBvZiBpbnB1dCBwaW5zIG9mIHRoaXMgYmxhY2tib3hcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IG91dHB1dHMgbnVtYmVyIG9mIG91dHB1dCBwaW5zIG9mIHRoaXMgYmxhY2tib3hcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gdGFibGUgICBBcnJheSBvZiBhcnJheXMsIGVhY2ggaW5uZXIgYXJyYXkgY29udGFpbnMgbGlzdCBvZiBbTG9naWMuc3RhdGVdKC4vbW9kdWxlLUxvZ2ljLmh0bWwjLnN0YXRlKXMsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgZGVzY3JpYmUgdGhlIGNvbWJpbmF0aW9uIG9mIGlucHV0IHBpbiBhbmQgb3V0cHV0IHBpbiBzdGF0ZXMgaW4gdGhlIG9yZGVyIGZyb20gdGhlIHRvcCB0byBib3R0b20gZm9yIGJvdGggaW5wdXQgYW5kIG91dHB1dCBjb25uZWN0b3JzLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB3ZSBoYWQgYW4gQU5EIGFycmF5IGFzIGEgYmxhY2tib3gsIG9uZSBvZiB0aGUgc3RhdGVzIGNvdWxkIGJlIGBbTG9naWMuc3RhdGUub24sIExvZ2ljLnN0YXRlLm9mZiwgTG9naWMuc3RhdGUub2ZmXWBcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpY2ggbWVhbnMgdGhhdCBpZiB0aGUgZmlyc3QgaW5wdXQgY29ubmVjdG9yIGlzIGluIHRoZSBgb25gIHN0YXRlIGFuZCB0aGUgc2Vjb25kIGNvbm5lY3RvciBpcyBpbiB0aGUgYG9mZmAgc3RhdGUsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBzdGF0ZSBvZiB0aGUgb3V0cHV0IGNvbm5lY3RvciB3aWxsIGJlIGBvZmZgLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgYXJyYXkgY2FuIGJlIGRlc2NyaWJlZCBhcyBgW3N0YXRlIGZvciBpbnB1dCBjb25uIDEsIHN0YXRlIGZvciBpbnB1dCBjb25uIDIsIC4uLiwgc3RhdGUgZm9yIG91dHB1dCBjb25uIDEsIHN0YXRlIGZvciBvdXRwdXQgY29ubiAyIC4uLl1gLlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gIG5hbWUgICBhIG5hbWUgdGhhdCB3aWxsIGJlIGRpc3BsYXllZCBvbiB0aGUgYmxhY2tib3hcbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSBbcmVmcmVzaD10cnVlXSBpZiB0cnVlLCB0aGlzLnJlZnJlc2goKSB3aWxsIGJlIGNhbGxlZCBhZnRlciBhZGRpbmcgdGhlIGdhdGVcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2VkaXRvckVsZW1lbnRzLkJsYWNrYm94fSBpbnN0YW5jZSBvZiB7QGxpbmsgQmxhY2tib3h9IHRoYXQgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIGNhbnZhc1xuICAgICAqL1xuICAgIG5ld0JsYWNrYm94KGlucHV0cywgb3V0cHV0cywgdGFibGUsIG5hbWUsIHgsIHksIHJlZnJlc2ggPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5ib3hlcy5sZW5ndGg7XG5cbiAgICAgICAgdGhpcy5ib3hlc1tpbmRleF0gPSBuZXcgZWRpdG9yRWxlbWVudHMuQmxhY2tib3goXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgaW5wdXRzLFxuICAgICAgICAgICAgb3V0cHV0cyxcbiAgICAgICAgICAgICguLi5pbnB1dFN0YXRlcykgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbGluZSBvZiB0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5lSW5wdXRTdGF0ZXMgPSBsaW5lLnNsaWNlKDAsIGlucHV0cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgZXZlcnkgaW5wdXQgc3RhdGUgbWF0Y2hlcyB0aGUgY29ycmVzcG9uZGluZyBpbnB1dCBzdGF0ZSBpbiB0aGlzIGxpbmUgb2YgdGhlIHRydXRoIHRhYmxlXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dFN0YXRlcy5ldmVyeSgodmFsdWUsIGluZGV4KSA9PiB2YWx1ZSA9PT0gbGluZUlucHV0U3RhdGVzW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGUgcmVzdCBvZiB0aGUgbGluZSBhcyBvdXRwdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5lLnNsaWNlKGlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgbm90aGluZyBtYXRjaGVzLCBzZXQgYWxsIG91dHB1dHMgdG8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20obmV3IEFycmF5KG91dHB1dHMpLCAoKSA9PiBMb2dpYy5zdGF0ZS51bmtub3duKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHggJiYgeSkge1xuICAgICAgICAgICAgbGV0IHRyID0gbmV3IGVkaXRvckVsZW1lbnRzLlRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgdHIuc2V0VHJhbnNsYXRlKHgsIHkpO1xuXG4gICAgICAgICAgICB0aGlzLmJveGVzW2luZGV4XS5zdmdPYmouYWRkQXR0cih7IHRyYW5zZm9ybTogdHIuZ2V0KCkgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFwcGVuZEVsZW1lbnQodGhpcy5ib3hlc1tpbmRleF0sIHJlZnJlc2gpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmJveGVzW2luZGV4XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBjb3JyZWN0IGluc3RhbmNlIG9mIGVkaXRvckVsZW1lbnRzLldpcmUgaW4gdGhlIGFwcCdzIHdpcmVzIGJ5IHRoZSBwcm92aWRlZCBpZFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gd2lyZUlkIGlkIG9mIHRoZSB3aXJlXG4gICAgICogQHJldHVybiB7ZWRpdG9yRWxlbWVudHMuV2lyZX0gaW5zdGFuY2Ugb2YgdGhlIHdpcmVcbiAgICAgKi9cbiAgICBnZXRXaXJlQnlJZCh3aXJlSWQpIHtcbiAgICAgICAgZm9yIChjb25zdCB3aXJlIG9mIHRoaXMud2lyZXMpIHtcbiAgICAgICAgICAgIGlmICh3aXJlLnN2Z09iai5pZCA9PT0gd2lyZUlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpcmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCBhbGwgd2lyZXMgdGhhdCBhcmUgY29ubmVjdGVkIHRvIHRoZSBzcGVjaWZpZWQgY29ubmVjdG9yXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBjb25uZWN0b3JJZCBpZCBvZiB0aGUgY29ubmVjdG9yXG4gICAgICogQHJldHVybiB7U2V0fSBzZXQgb2YgSUQncyBvZiB0aGUgd2lyZXMgY29ubmVjdGVkIHRvIHRoaXMgY29ubmVjdG9yXG4gICAgICovXG4gICAgZ2V0V2lyZXNCeUNvbm5lY3RvcklkKGNvbm5lY3RvcklkKSB7XG4gICAgICAgIGxldCBjb25uZWN0b3IgPSB0aGlzLmdldENvbm5lY3RvckJ5SWQoY29ubmVjdG9ySWQpO1xuICAgICAgICByZXR1cm4gY29ubmVjdG9yLndpcmVJZHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHdpcmUgdGhhdCBoYXMgdGhlIHByb3ZpZGVkIElEXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB3aXJlSWQgSUQgb2YgdGhlIHdpcmUgdGhhdCBzaG91bGQgYmUgcmVtb3ZlZFxuICAgICAqL1xuICAgIHJlbW92ZVdpcmVCeUlkKHdpcmVJZCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMud2lyZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndpcmVzW2ldLnN2Z09iai5pZCA9PT0gd2lyZUlkKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgY29ubmVjdG9ycyB9ID0gdGhpcy53aXJlc1tpXTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbm5lY3RvciBvZiBjb25uZWN0b3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5yZW1vdmVXaXJlSWRBbmRVcGRhdGUod2lyZUlkKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzdGFydCBzaW11bGF0aW9uIGZyb20gdGhlIGlucHV0IGNvbm5lY3RvciB0b1xuICAgICAgICAgICAgICAgIC8vIHJlZnJlc2ggdGhlIG5ldHdvcmsgYWZ0ZXIgdGhpcyB3aXJlXG5cbiAgICAgICAgICAgICAgICBsZXQgaW5wdXRDb25uZWN0b3IgPSB0aGlzLndpcmVzW2ldLmNvbm5lY3Rpb24udG8uY29ubmVjdG9yO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnROZXdTaW11bGF0aW9uKGlucHV0Q29ubmVjdG9yLCBpbnB1dENvbm5lY3Rvci5zdGF0ZSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLndpcmVzW2ldLnN2Z09iai4kZWwucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy53aXJlcy5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgd2lyZXMgdGhhdCBhcmUgY29ubmVjdGVkIHRvIHRoZSBjb25uZWN0b3IgcHJvdmlkZWQgYnkgaXRzIElEXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBjb25uZWN0b3JJZCBJRCBvZiB0aGUgY29ubmVjdG9yXG4gICAgICovXG4gICAgcmVtb3ZlV2lyZXNCeUNvbm5lY3RvcklkKGNvbm5lY3RvcklkKSB7XG4gICAgICAgIGxldCBjb25uZWN0b3IgPSB0aGlzLmdldENvbm5lY3RvckJ5SWQoY29ubmVjdG9ySWQpO1xuXG4gICAgICAgIGNvbm5lY3Rvci53aXJlSWRzLmZvckVhY2god2lyZUlkID0+IHtcbiAgICAgICAgICAgIGxldCB3aXJlID0gdGhpcy5nZXRXaXJlQnlJZCh3aXJlSWQpO1xuXG4gICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gd2lyZS5jb25uZWN0aW9uO1xuXG4gICAgICAgICAgICAvLyBnZXQgdGhlIG90aGVyIGNvbm5lY3RvciB0aGF0IGlzIHRoZSB3aXJlIGNvbm5lY3RlZCB0b1xuICAgICAgICAgICAgbGV0IG90aGVyQ29ubmVjdG9yID0gY29ubmVjdG9ySWQgPT09IGZyb20uaWQgPyB0by5jb25uZWN0b3IgOiBmcm9tLmNvbm5lY3RvcjtcblxuICAgICAgICAgICAgLy8gZGVsZXRlIHRoZSB3aXJlIHJlY29yZCBmcm9tIHRoZSBvdGhlciBjb25uZWN0b3JcbiAgICAgICAgICAgIG90aGVyQ29ubmVjdG9yLndpcmVJZHMuZGVsZXRlKHdpcmVJZCk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgd2lyZSByZXByZXNlbnRhdGlvbiB1c2luZyBqUXVlcnlcbiAgICAgICAgICAgICQoJyMnICsgd2lyZUlkKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgLy8gaWYgb3RoZXJDb25uZWN0b3IgaXMgYW4gaW5wdXQgY29ubmVjdG9yLCBzZXQgaXRzIHN0YXRlIHRvIHVua25vd25cbiAgICAgICAgICAgIGlmIChvdGhlckNvbm5lY3Rvci5pc0lucHV0Q29ubmVjdG9yKSB7XG4gICAgICAgICAgICAgICAgb3RoZXJDb25uZWN0b3Iuc2V0U3RhdGUoTG9naWMuc3RhdGUudW5rbm93bik7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydE5ld1NpbXVsYXRpb24ob3RoZXJDb25uZWN0b3IsIExvZ2ljLnN0YXRlLnVua25vd24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjbGVhciB0aGUgbGlzdCBvZiB3aXJlIElkc1xuICAgICAgICBjb25uZWN0b3Iud2lyZUlkcy5jbGVhcigpO1xuICAgICAgICAvLyBpZiBjb25uZWN0b3IgaXMgYW4gaW5wdXQgY29ubmVjdG9yLCBzZXQgaXRzIHN0YXRlIHRvIHVua25vd25cbiAgICAgICAgaWYgKGNvbm5lY3Rvci5pc0lucHV0Q29ubmVjdG9yKSB7XG4gICAgICAgICAgICBjb25uZWN0b3Iuc2V0U3RhdGUoTG9naWMuc3RhdGUudW5rbm93bik7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0TmV3U2ltdWxhdGlvbihjb25uZWN0b3IsIExvZ2ljLnN0YXRlLnVua25vd24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgY29ycmVjdCBpbnN0YW5jZSBvZiBlZGl0b3JFbGVtZW50cy5Cb3ggaW4gdGhlIGFwcCdzIGJveGVzIGJ5IHRoZSBwcm92aWRlZCBpZFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gYm94SWQgaWQgb2YgdGhlIGJveFxuICAgICAqIEByZXR1cm4ge2VkaXRvckVsZW1lbnRzLkJveH0gaW5zdGFuY2Ugb2YgdGhlIGJveFxuICAgICAqL1xuICAgIGdldEJveEJ5SWQoYm94SWQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJveGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ib3hlc1tpXS5zdmdPYmouaWQgPT09IGJveElkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm94ZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBjb3JyZWN0IGluc3RhbmNlIG9mIGVkaXRvckVsZW1lbnRzLkJveCBpbiB0aGUgYXBwJ3MgYm94ZXMgYnkgSUQgb2YgYSBjb25uZWN0b3IgdGhhdCBiZWxvbmdzIHRvIHRoaXMgYm94XG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBib3hJZCBpZCBvZiB0aGUgY29ubmVjdG9yXG4gICAgICogQHJldHVybiB7ZWRpdG9yRWxlbWVudHMuQm94fSBpbnN0YW5jZSBvZiB0aGUgYm94XG4gICAgICovXG4gICAgZ2V0Qm94QnlDb25uZWN0b3JJZChjb25uZWN0b3JJZCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJveGVzW2ldLmdldENvbm5lY3RvckJ5SWQoY29ubmVjdG9ySWQpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ib3hlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGluc3RhbmNlIG9mIGEgY29ubmVjdG9yIGJhc2VkIG9uIGl0J3MgSUQgKGFuZCBhbHNvIG9uIGFuIGluc3RhbmNlIG9mIGVkaXRvckVsZW1lbnRzLldpcmUgaWYgcHJvdmlkZWQpXG4gICAgICpcbiAgICAgKiBUaGUgd2lyZSB2YXJpYWJsZSBpcyB1c2VkIGFzIGhldXJpc3RpYzogV2hlbiB3ZSBrbm93IHRoZSB3aXJlLCB3ZSBoYXZlIHRvIGNoZWNrIG9ubHlcbiAgICAgKiB0d28gZ2F0ZXMgaW5zdGVhZCBvZiBhbGwgb2YgdGhlbVxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gY29ubmVjdG9ySWQgaWQgb2YgdGhlIGNvbm5lY3RvclxuICAgICAqIEBwYXJhbSAge2VkaXRvckVsZW1lbnRzLldpcmV9IFt3aXJlXSAgICAgIGluc3RhbmNlIG9mIHRoZSBXaXJlIHRoYXQgaXMgY29ubmVjdGVkIHRvIHRoaXMgY29ubmVjdG9yXG4gICAgICogQHJldHVybiB7ZWRpdG9yRWxlbWVudHMuQ29ubmVjdG9yfSAgICAgICAgaW5zdGFuY2Ugb2YgdGhlIGNvbm5lY3RvclxuICAgICAqL1xuICAgIGdldENvbm5lY3RvckJ5SWQoY29ubmVjdG9ySWQsIHdpcmUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHdpcmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gd2Uga25vdyB0aGUgd2lyZSAtLSB3ZSBjYW4gY2hlY2sgb25seSBnYXRlcyBhdCB0aGUgZW5kcyBvZiB0aGlzIHdpcmVcbiAgICAgICAgICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHdpcmUuY29ubmVjdGlvbjtcblxuICAgICAgICAgICAgaWYgKGZyb20uaWQgPT09IGNvbm5lY3RvcklkKSByZXR1cm4gZnJvbS5jb25uZWN0b3I7XG5cbiAgICAgICAgICAgIGlmICh0by5pZCA9PT0gY29ubmVjdG9ySWQpIHJldHVybiB0by5jb25uZWN0b3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSBkbyBub3Qga25vdyB0aGUgd2lyZSAtLSB3ZSBoYXZlIHRvIGNoZWNrIGFsbCBnYXRlc1xuICAgICAgICAgICAgZm9yIChjb25zdCBib3ggb2YgdGhpcy5ib3hlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RvciA9IGJveC5nZXRDb25uZWN0b3JCeUlkKGNvbm5lY3RvcklkKTtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0b3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGxvZ2ljYWwgalF1ZXJ5IHRhcmdldCBiYXNlZCBvbiB0aGUgZmFjdHVhbCBqUXVlcnkgdGFyZ2V0LlxuICAgICAqXG4gICAgICogSWYgdGhlIG9iamVjdCwgdGhhdCB1c2VyIGludGVyYWN0ZWQgd2l0aCwgaXMgbm90IGEgY29ubmVjdG9yIGFuZCBpcyBpbiBhIGdyb3VwLFxuICAgICAqIHJldHVybiB0aGUgZ3JvdXAgalF1ZXJ5IG9iamVjdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBqUXVlcnkgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge3RhcmdldH0gdGFyZ2V0IGpRdWVyeSB0YXJnZXQgb2YgdGhlIG9iamVjdCB1c2VyIGludGVyYWN0ZWQgd2l0aFxuICAgICAqIEByZXR1cm4ge3RhcmdldH0gICAgICAgIGpRdWVyeSB0YXJnZXQgb2YgdGhlIG9iamVjdCB1c2VyIHdhbnRlZCB0byBpbnRlcmFjdCB3aXRoXG4gICAgICovXG4gICAgZ2V0UmVhbEpRdWVyeVRhcmdldCh0YXJnZXQpIHtcbiAgICAgICAgbGV0ICR0YXJnZXQgPSAkKHRhcmdldCk7XG4gICAgICAgIGlmICghJHRhcmdldC5oYXNDbGFzcygnY29ubmVjdG9yJykgJiYgJHRhcmdldC5wYXJlbnRzKCdnJykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgJHRhcmdldCA9ICR0YXJnZXQucGFyZW50KCk7XG4gICAgICAgICAgICB3aGlsZSAoJHRhcmdldC5wcm9wKCd0YWdOYW1lJykgIT09ICdHJyAmJiAkdGFyZ2V0LnByb3AoJ3RhZ05hbWUnKSAhPT0gJ2cnKSB7XG4gICAgICAgICAgICAgICAgJHRhcmdldCA9ICR0YXJnZXQucGFyZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICR0YXJnZXQ7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJucyB0aGUgZWRpdG9yRWxlbWVudCB0aGF0IHVzZXIgaW50ZXJhY3RlZCB3aXRoLCB0aGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBpcyBhIGpRdWVyeSBlbGVtZW50XG4gICAgLyoqXG4gICAgICogR2V0IGluc3RhbmNlIG9mIHNvbWUgb2JqZWN0IGZyb20gZWRpdG9yRWxlbWVudCBiYXNlZCBvbiB0aGUgalF1ZXJ5IHRhcmdldFxuICAgICAqIEBwYXJhbSAge3RhcmdldH0gdGFyZ2V0IGpRdWVyeSB0YXJnZXQgdGhhdCB1c2VyIGludGVyYWN0ZWQgd2l0aFxuICAgICAqIEByZXR1cm4ge2VkaXRvckVsZW1lbnRzLk5ldHdvcmtFbGVtZW50fSBpbnN0YW5jZSBvZiBhbiBvYmplY3QgZGVyaXZlZCBmcm9tIGVkaXRvckVsZW1lbnRzLk5ldHdvcmtFbGVtZW50IHRoYXQgdGhlIHVzZXIgaW50ZXJhY3RlZCB3aXRoXG4gICAgICovXG4gICAgZ2V0UmVhbFRhcmdldCh0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZXZlbnR5IHNlIG11c2VqaSB6cHJhY292YXQgdGFkeSwgcHJvdG96ZSB2IFNWRyBzZSBldmVudHkgbmVwcm9wYWd1amlcbiAgICAgICAgbGV0ICR0YXJnZXQgPSAkKHRhcmdldCk7XG5cbiAgICAgICAgaWYgKCR0YXJnZXQuaGFzQ2xhc3MoJ2Nvbm5lY3RvcicpKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgY29ubmVjdG9yLCBkb24ndCB0cmF2ZXJzZSBncm91cHNcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbm5lY3RvckJ5SWQoJHRhcmdldC5hdHRyKCdpZCcpKTtcbiAgICAgICAgfSBlbHNlIGlmICgkdGFyZ2V0LnBhcmVudHMoJ2cnKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGVsZW1lbnQgaXMgaW4gYSBncm91cCBhbmQgaXQgaXMgbm90IGEgY29ubmVjdG9yXG5cbiAgICAgICAgICAgIC8vIHRyYXZlcnNpbmcgdXAgdGhlIERPTSB0cmVlIHVudGlsIHdlIGZpbmQgdGhlIGNsb3Nlc3QgZ3JvdXBcbiAgICAgICAgICAgIGxldCAkcGFyZW50R3JvdXAgPSAkdGFyZ2V0LnBhcmVudCgpO1xuICAgICAgICAgICAgd2hpbGUgKCRwYXJlbnRHcm91cC5wcm9wKCd0YWdOYW1lJykgIT09ICdHJyAmJiAkcGFyZW50R3JvdXAucHJvcCgndGFnTmFtZScpICE9PSAnZycpIHtcbiAgICAgICAgICAgICAgICAkcGFyZW50R3JvdXAgPSAkcGFyZW50R3JvdXAucGFyZW50KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRyeSB0byBtYXRjaCB0aGUgalF1ZXJ5IGVsZW1lbnQgdG8gdGhlIGxvZ2ljYWwgZWxlbWVudCB1c2luZyBET00gY2xhc3Nlc1xuXG4gICAgICAgICAgICBpZiAoJHBhcmVudEdyb3VwLmhhc0NsYXNzKCdib3gnKSkge1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyBib3hcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRCb3hCeUlkKCRwYXJlbnRHcm91cC5hdHRyKCdpZCcpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJHBhcmVudEdyb3VwLmhhc0NsYXNzKCd3aXJlJykpIHtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgd2lyZVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFdpcmVCeUlkKCRwYXJlbnRHcm91cC5hdHRyKCdpZCcpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZm91bmQgYSBncm91cCB0aGF0IGNvbnRhaW5zIHRoZSB0YXJnZXQsIGJ1dCB0aGlzIGdyb3VwIGRvZXMgbm90IG1hdGNoIGFueSBrbm93biBlbGVtZW50IHR5cGVzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgZG9lcyBub3QgbWF0Y2ggYW55IGtub3duIGVsZW1lbnQgdHlwZXNcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gZWxlbWVudCB0byB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtICB7ZWRpdG9yRWxlbWVudHMuTmV0d29ya0VsZW1lbnR9ICBlbGVtZW50IEVsZW1lbnQgdGhhdCB3aWxsIGJlIGFkZGVkIG9uIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBbcmVmcmVzaD10cnVlXSBpZiB0cnVlLCB0aGUgU1ZHIGRvY3VtZW50IHdpbGwgYmUgcmVsb2FkZWQgYWZ0ZXIgYWRkaW5nIHRoaXMgZWxlbWVudFxuICAgICAqL1xuICAgIGFwcGVuZEVsZW1lbnQoZWxlbWVudCwgcmVmcmVzaCA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRKUXVlcnlPYmplY3QoZWxlbWVudC5nZXQoKSwgcmVmcmVzaCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwZW5kIGEgalF1ZXJ5IGVsZW1lbnQgdG8gdGhlIFNWRyBkb2N1bWVudCAoaGVscGVyIGZvciB0aGlzLmFwcGVuZEVsZW1lbnQpXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgb2JqZWN0ICAgICAgICAgalF1ZXJ5IGVsZW1lbnQgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBTVkcgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBbcmVmcmVzaD10cnVlXSBpZiB0cnVlLCB0aGUgU1ZHIGRvY3VtZW50IHdpbGwgYmUgcmVsb2FkZWQgYWZ0ZXIgYWRkaW5nIHRoaXMgZWxlbWVudFxuICAgICAqL1xuICAgIGFwcGVuZEpRdWVyeU9iamVjdChvYmplY3QsIHJlZnJlc2ggPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuJHN2Zy5hcHBlbmQob2JqZWN0KTtcbiAgICAgICAgaWYgKHJlZnJlc2gpIHRoaXMucmVmcmVzaCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5ldyBwYXR0ZXJuIHRvIHRoZSBkZWZpbml0aW9ucyBlbGVtZW50IGluIHRoZSBTVkcgZG9jdW1lbnRcbiAgICAgKiBAcGFyYW0ge3N2Z09iai5QYXR0ZXJufSBwYXR0ZXJuIHBhdHRlcm4gdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSA8ZGV2cz4gZWxlbWVudCBpbiB0aGUgU1ZHIGRvY3VtZW50XG4gICAgICovXG4gICAgYWRkUGF0dGVybihwYXR0ZXJuKSB7XG4gICAgICAgIHRoaXMuJGRlZnMuYXBwZW5kKHBhdHRlcm4pO1xuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWxvYWQgdGhlIFNWRyBkb2N1bWVudCAobmVlZGVkIHRvIGRpc3BsYXkgYSBuZXdseSBhcHBlbmRlZCBqUXVlcnkgb2JqZWN0KVxuICAgICAqL1xuICAgIHJlZnJlc2goKSB7XG4gICAgICAgIHRoaXMuJHN2Zy5odG1sKHRoaXMuJHN2Zy5odG1sKCkpO1xuICAgICAgICBjb25zb2xlLmxvZygnU1ZHIGRvY3VtZW50IGhhcyBiZWVuIHJlbG9hZGVkLicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc3BsYXkgdGhlIGNvbnRleHQgbWVudSBvbiB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB4ICAgICAgIGhvcml6b250YWwgcG9zaXRpb24gaW4gQ1NTIHBpeGVsc1xuICAgICAqIEBwYXJhbSAge251bWJlcn0geSAgICAgICB2ZXJ0aWNhbCBwb3NpdGlvbiBpbiBDU1MgcGl4ZWxzXG4gICAgICogQHBhcmFtICB7alF1ZXJ5LmVsZW1lbnR9ICR0YXJnZXQgdGhlIGl0ZW0gdXNlciBjbGlja2VkIG9uICh1c2VkIHRvIGRpc3BsYXkgXCJyZW1vdmUgdGhpcyBlbGVtZW50XCItdHlwZSBpdGVtcyBpbiB0aGUgbWVudSlcbiAgICAgKi9cbiAgICBkaXNwbGF5Q29udGV4dE1lbnUoeCwgeSwgJHRhcmdldCkge1xuICAgICAgICB0aGlzLmNvbnRleHRNZW51LmRpc3BsYXkoeCwgeSwgJHRhcmdldCk7XG5cbiAgICAgICAgLy8gaWYgdHV0b3JpYWwgZXhpc3RzLCBjYWxsIHR1dG9yaWFsIGNhbGxiYWNrXG4gICAgICAgIGlmICh0aGlzLnR1dG9yaWFsKSB7XG4gICAgICAgICAgICB0aGlzLnR1dG9yaWFsLm9uQ29udGV4dE1lbnVPcGVuZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGhpZGUgdGhlIGNvbnRleHQgbWVudVxuICAgICAqL1xuICAgIGhpZGVDb250ZXh0TWVudSgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0TWVudS5oaWRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc25hcCBhIHZhbHVlIHRvIGEgZ3JpZFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdmFsdWUgdmFsdWUgaW4gU1ZHIHBpeGVsc1xuICAgICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgdGhlIHZhbHVlIHJvdW5kZWQgdG8gdGhlIGNsb3Nlc3QgbnVtYmVyIGRpdmlzaWJsZSBieSB0aGUgZ3JpZCBzaXplXG4gICAgICovXG4gICAgc25hcFRvR3JpZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAvIHRoaXMuZ3JpZFNpemUpICogdGhpcy5ncmlkU2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0IGdyaWQgcGl4ZWxzIHRvIFNWRyBwaXhlbHNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlIGRpc3RhbmNlIGluIGdyaWQgcGl4ZWxzXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICBkaXN0YW5jZSBpbiBTVkcgcGl4ZWxzXG4gICAgICovXG4gICAgZ3JpZFRvU1ZHKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAqIHRoaXMuZ3JpZFNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29udmVydCBTVkcgcGl4ZWxzIHRvIGdyaWQgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIGRpc3RhbmNlIGluIFNWRyBwaXhlbHNcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgZGlzdGFuY2UgaW4gZ3J1ZCBwaXhlbHNcbiAgICAgKi9cbiAgICBTVkdUb0dyaWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIC8gdGhpcy5ncmlkU2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzdGF0aWMgZnVuY3Rpb24gZm9yIHNuYXBwaW5nIGEgdmFsdWUgdG8gYSBncmlkXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB2YWx1ZSB2YWx1ZSBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBncmlkU2l6ZSBzaXplIG9mIHRoZSBncmlkIGluIFNWRyBwaXhlbHNcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgIHRoZSB2YWx1ZSByb3VuZGVkIHRvIHRoZSBjbG9zZXN0IG51bWJlciBkaXZpc2libGUgYnkgdGhlIGdyaWQgc2l6ZVxuICAgICAqL1xuICAgIHN0YXRpYyBzbmFwVG9HcmlkKHZhbHVlLCBncmlkU2l6ZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAvIGdyaWRTaXplKSAqIGdyaWRTaXplO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG1vdmUgYW4gZWxlbWVudCB0byB0aGUgZnJvbnQgaW4gdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSAge3N0cmluZ30gb2JqSWQgaWQgb2YgdGhlIGVsZW1lbnRcbiAgICAgKi9cbiAgICBtb3ZlVG9Gcm9udEJ5SWQob2JqSWQpIHtcbiAgICAgICAgdGhpcy4kc3ZnLmFwcGVuZCgkKCcjJyArIG9iaklkKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbW92ZSBhbiBlbGVtZW50IHRvIHRoZSBiYWNrIGluIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IG9iaklkIGlkIG9mIHRoZSBlbGVtZW50XG4gICAgICovXG4gICAgbW92ZVRvQmFja0J5SWQob2JqSWQpIHtcbiAgICAgICAgJCgnIycgKyB0aGlzLmJhY2tncm91bmQuaWQpLmFmdGVyKCQoJyMnICsgb2JqSWQpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgc2V0IG9mIG5vZGVzLCB0aGF0IGNhbm5vdCBiZSB1c2VkIGZvciB3aXJpbmcgYXQgYW55IGNpcmN1bXN0YW5jZXNcbiAgICAgKiBAcmV0dXJuIHtTZXR9IHNldCBvZiBub2RlcyAob2JqZWN0cyBjb250YWluaW5nIHggYW5kIHkgY29vcmRpbmF0ZXMpIHRoYXQgYXJlIG5vdCBzdWl0YWJsZSBmb3Igd2lyaW5nXG4gICAgICovXG4gICAgZ2V0Tm9uUm91dGFibGVOb2RlcygpIHtcbiAgICAgICAgbGV0IGJsb2NrZWROb2RlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLy8gZm9yIGVhY2ggYm94XG4gICAgICAgIGZvciAoY29uc3QgYm94IG9mIHRoaXMuYm94ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZSA9IGJveC5nZXRHcmlkUGl4ZWxUcmFuc2Zvcm0oKS5nZXRUcmFuc2xhdGUoKTtcblxuICAgICAgICAgICAgLy8gZm9yIGVhY2ggaXRlbSBpbiBibG9ja2VkTm9kZXMgKHNldCBvZiBibG9ja2VkIG5vZGVzIHdpdGggY29vcmRpbmF0ZXMgcmVsYXRpdmVcbiAgICAgICAgICAgIC8vIHRvIHRoZSBsZWZ0IHVwcGVyIGNvcm5lciBvZiByZWN0OyB1bml0IHVzZWQgaXMgXCJvbmUgZ3JpZFNpemVcIikgY29udmVydCB0aGUgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgIC8vIHRvIGFic29sdXRlIChtdWx0aXBsZSB3aXRoIGdyaWRTaXplIGFuZCBhZGQgcG9zaXRpb24gb2YgcmVjdCkgYW5kIGFkZCB0aGUgcmVzdWx0IHRvIHRoZSBzZXRcbiAgICAgICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBib3guYmxvY2tlZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgYmxvY2tlZE5vZGVzLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgIHg6IHRyYW5zbGF0ZS54ICsgbm9kZS54LFxuICAgICAgICAgICAgICAgICAgICB5OiB0cmFuc2xhdGUueSArIG5vZGUueVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRk9SIERFQlVHIE9OTFk6IGRpc3BsYXkgdGhlIG5vbiByb3V0YWJsZSBub2Rlc1xuICAgICAgICAvKlxuXG4gICAgICAgIGlmKHRoaXMubm9kZURpc3BsYXkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVjdGFuZ2xlSWQgb2YgdGhpcy5ub2RlRGlzcGxheSkge1xuICAgICAgICAgICAgICAgICQoYCMke3JlY3RhbmdsZUlkfWApLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ub2RlRGlzcGxheSA9IFtdO1xuXG4gICAgICAgIGxldCBmaXJzdCA9IHRydWU7XG5cbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGJsb2NrZWROb2Rlcykge1xuICAgICAgICAgICAgY29uc3QgeCA9IHRoaXMuZ3JpZFRvU1ZHKG5vZGUueCk7XG4gICAgICAgICAgICBjb25zdCB5ID0gdGhpcy5ncmlkVG9TVkcobm9kZS55KTtcblxuICAgICAgICAgICAgY29uc3QgdyA9IDQ7XG4gICAgICAgICAgICBjb25zdCBwID0gdyAvIDI7XG5cbiAgICAgICAgICAgIGNvbnN0IG5vZGVSZWN0YW5nbGUgPSBuZXcgUmVjdGFuZ2xlKHggLSBwLCB5IC0gcCwgdywgdywgZmlyc3QgPyBcImJsdWVcIiA6IFwicmVkXCIsIFwibm9uZVwiKVxuICAgICAgICAgICAgdGhpcy5ub2RlRGlzcGxheS5wdXNoKG5vZGVSZWN0YW5nbGUuaWQpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRFbGVtZW50KG5vZGVSZWN0YW5nbGUsIGZhbHNlKTtcblxuICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xuXG4gICAgICAgIC8vICovXG4gICAgICAgIC8vIEVORCBGT1IgREVCVUcgT05MWVxuXG4gICAgICAgIC8vIHJldHVybiB0aGUgc2V0XG4gICAgICAgIHJldHVybiBibG9ja2VkTm9kZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHNldCBvZiBub2RlcywgdGhhdCBhcmUgaW5jb252ZW5pZW50IGZvciB3aXJpbmcsIGJ1dCBjYW4gYmUgdXNlZCwganVzdCBhcmUgbm90IHByZWZlcnJlZFxuICAgICAqIEByZXR1cm4ge1NldH0gc2V0IG9mIG5vZGVzIChvYmplY3RzIGNvbnRhaW5pbmcgeCBhbmQgeSBjb29yZGluYXRlcykgdGhhdCBhcmUgbm90IHByZWZlcnJlZCBmb3Igd2lyaW5nXG4gICAgICovXG4gICAgZ2V0SW5jb252ZW5pZW50Tm9kZXMoaWdub3JlV2lyZUlkKSB7XG4gICAgICAgIGxldCBpbmNvbnZlbmllbnROb2RlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLy8gZm9yIGVhY2ggd2lyZVxuXG4gICAgICAgIGZvciAoY29uc3Qgd2lyZSBvZiB0aGlzLndpcmVzKSB7XG4gICAgICAgICAgICBpZiAoaWdub3JlV2lyZUlkID09PSB1bmRlZmluZWQgfHwgaWdub3JlV2lyZUlkICE9PSB3aXJlLmlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdpcmUuaW5jb252ZW5pZW50Tm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHdpcmUuaW5jb252ZW5pZW50Tm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY29udmVuaWVudE5vZGVzLmFkZChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZPUiBERUJVRyBPTkxZOiBkaXNwbGF5IHRoZSBpbmNvbnZlbmllbnQgbm9kZXNcbiAgICAgICAgLypcblxuICAgICAgICBpZih0aGlzLmluY29udmVuaWVudE5vZGVEaXNwbGF5KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlY3RhbmdsZUlkIG9mIHRoaXMuaW5jb252ZW5pZW50Tm9kZURpc3BsYXkpIHtcbiAgICAgICAgICAgICAgICAkKGAjJHtyZWN0YW5nbGVJZH1gKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5jb252ZW5pZW50Tm9kZURpc3BsYXkgPSBbXTtcblxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgaW5jb252ZW5pZW50Tm9kZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLmdyaWRUb1NWRyhub2RlLngpO1xuICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMuZ3JpZFRvU1ZHKG5vZGUueSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHcgPSA0O1xuICAgICAgICAgICAgY29uc3QgcCA9IHcgLyAyO1xuXG4gICAgICAgICAgICBjb25zdCBub2RlUmVjdGFuZ2xlID0gbmV3IFJlY3RhbmdsZSh4IC0gcCwgeSAtIHAsIHcsIHcsIFwib3JhbmdlXCIsIFwibm9uZVwiKVxuICAgICAgICAgICAgdGhpcy5pbmNvbnZlbmllbnROb2RlRGlzcGxheS5wdXNoKG5vZGVSZWN0YW5nbGUuaWQpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRFbGVtZW50KG5vZGVSZWN0YW5nbGUsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xuXG4gICAgICAgIC8vICovXG4gICAgICAgIC8vIEVORCBGT1IgREVCVUcgT05MWVxuXG4gICAgICAgIC8vIHJldHVybiB0aGUgc2V0XG4gICAgICAgIHJldHVybiBpbmNvbnZlbmllbnROb2RlcztcbiAgICB9XG59XG4iLCIvKiogQG1vZHVsZSBMb2dpYyAqL1xuLyoqXG4gKiBkZWZpbml0aW9ucyBvZiBsb2dpYyBzdGF0ZXMgYW5kIGJhc2ljIGxvZ2ljIGZ1bmN0aW9ucyB1c2VkIGluIHRoZSBzaW11bGF0aW9uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvZ2ljIHtcbiAgICAvKipcbiAgICAgKiBFbnVtIGZvciBsb2dpYyBzdGF0ZXMuXG4gICAgICpcbiAgICAgKiBTdGF0ZXM6XG4gICAgICogLSBgb2ZmYFxuICAgICAqIC0gYG9uYFxuICAgICAqIC0gYHVua25vd25gXG4gICAgICogLSBgb3NjaWxsYXRpbmdgXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb2ZmOiAwLFxuICAgICAgICAgICAgb246IDEsXG4gICAgICAgICAgICB1bmtub3duOiAyLFxuICAgICAgICAgICAgb3NjaWxsYXRpbmc6IDNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBsaXN0IG9mIGFsbCBzdGF0ZXMgdGhhdCBjYW4gYmUgdXNlZCBpbiB0aGUgc2ltdWxhdGlvblxuICAgICAqXG4gICAgICogVGhpcyBnZXR0ZXIgaXRlcmF0ZXMgb3ZlciBMb2dpYy5zdGF0ZSBhbmQgcmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIGFsbCB2YWx1ZXMgb2YgTG9naWMuc3RhdGUncyBtZW1iZXJzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgc3RhdGVMaXN0KCkge1xuICAgICAgICBsZXQgc3RhdGVzID0gW107XG5cbiAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIGFsbCBkZWZpbmVkIHN0YXRlcyBhbmQgYWRkIHRoZWlyIHZhbHVlcyB0byB0aGUgc3RhdGVzIGFycmF5XG4gICAgICAgIE9iamVjdC5rZXlzKExvZ2ljLnN0YXRlKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBzdGF0ZXMucHVzaChMb2dpYy5zdGF0ZVtrZXldKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2dpYyBBTkRcbiAgICAgKiBAcGFyYW0gIHtMb2dpYy5zdGF0ZX0gYSBmaXJzdCBpbnB1dCBzdGF0ZVxuICAgICAqIEBwYXJhbSAge0xvZ2ljLnN0YXRlfSBiIHNlY29uZCBpbnB1dCBzdGF0ZVxuICAgICAqIEByZXR1cm4ge0xvZ2ljLnN0YXRlfSAgIG91dHB1dCBzdGF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBhbmQoYSwgYikge1xuICAgICAgICByZXR1cm4gTG9naWMucnVuU3ltbWV0cmljUnVsZXMoYSwgYiwgW1xuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLm9uLCBMb2dpYy5zdGF0ZS5vbiwgTG9naWMuc3RhdGUub25dLFxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLm9uLCBMb2dpYy5zdGF0ZS5vZmYsIExvZ2ljLnN0YXRlLm9mZl0sXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUub24sIExvZ2ljLnN0YXRlLnVua25vd24sIExvZ2ljLnN0YXRlLnVua25vd25dLFxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLm9uLCBMb2dpYy5zdGF0ZS5vc2NpbGxhdGluZywgTG9naWMuc3RhdGUub3NjaWxsYXRpbmddLFxuXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUub2ZmLCBMb2dpYy5zdGF0ZS5vZmYsIExvZ2ljLnN0YXRlLm9mZl0sXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUub2ZmLCBMb2dpYy5zdGF0ZS51bmtub3duLCBMb2dpYy5zdGF0ZS5vZmZdLFxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLm9mZiwgTG9naWMuc3RhdGUub3NjaWxsYXRpbmcsIExvZ2ljLnN0YXRlLm9mZl0sXG5cbiAgICAgICAgICAgIFtMb2dpYy5zdGF0ZS51bmtub3duLCBMb2dpYy5zdGF0ZS51bmtub3duLCBMb2dpYy5zdGF0ZS51bmtub3duXSxcbiAgICAgICAgICAgIFtMb2dpYy5zdGF0ZS51bmtub3duLCBMb2dpYy5zdGF0ZS5vc2NpbGxhdGluZywgTG9naWMuc3RhdGUudW5rbm93bl0sXG5cbiAgICAgICAgICAgIFtMb2dpYy5zdGF0ZS5vc2NpbGxhdGluZywgTG9naWMuc3RhdGUub3NjaWxsYXRpbmcsIExvZ2ljLnN0YXRlLm9zY2lsbGF0aW5nXVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9naWMgTkFORFxuICAgICAqIEBwYXJhbSAge0xvZ2ljLnN0YXRlfSBhIGZpcnN0IGlucHV0IHN0YXRlXG4gICAgICogQHBhcmFtICB7TG9naWMuc3RhdGV9IGIgc2Vjb25kIGlucHV0IHN0YXRlXG4gICAgICogQHJldHVybiB7TG9naWMuc3RhdGV9ICAgb3V0cHV0IHN0YXRlXG4gICAgICovXG4gICAgc3RhdGljIG5hbmQoYSwgYikge1xuICAgICAgICByZXR1cm4gTG9naWMubm90KExvZ2ljLmFuZChhLCBiKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9naWMgTk9SXG4gICAgICogQHBhcmFtICB7TG9naWMuc3RhdGV9IGEgZmlyc3QgaW5wdXQgc3RhdGVcbiAgICAgKiBAcGFyYW0gIHtMb2dpYy5zdGF0ZX0gYiBzZWNvbmQgaW5wdXQgc3RhdGVcbiAgICAgKiBAcmV0dXJuIHtMb2dpYy5zdGF0ZX0gICBvdXRwdXQgc3RhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgbm9yKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIExvZ2ljLm5vdChMb2dpYy5vcihhLCBiKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9naWMgTk9UXG4gICAgICogQHBhcmFtICB7TG9naWMuc3RhdGV9IGEgZmlyc3QgaW5wdXQgc3RhdGVcbiAgICAgKiBAcmV0dXJuIHtMb2dpYy5zdGF0ZX0gICBvdXRwdXQgc3RhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgbm90KGEpIHtcbiAgICAgICAgaWYgKGEgPT09IExvZ2ljLnN0YXRlLm9uKSB7XG4gICAgICAgICAgICByZXR1cm4gTG9naWMuc3RhdGUub2ZmO1xuICAgICAgICB9IGVsc2UgaWYgKGEgPT09IExvZ2ljLnN0YXRlLm9mZikge1xuICAgICAgICAgICAgcmV0dXJuIExvZ2ljLnN0YXRlLm9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2dpYyBPUlxuICAgICAqIEBwYXJhbSAge0xvZ2ljLnN0YXRlfSBhIGZpcnN0IGlucHV0IHN0YXRlXG4gICAgICogQHBhcmFtICB7TG9naWMuc3RhdGV9IGIgc2Vjb25kIGlucHV0IHN0YXRlXG4gICAgICogQHJldHVybiB7TG9naWMuc3RhdGV9ICAgb3V0cHV0IHN0YXRlXG4gICAgICovXG4gICAgc3RhdGljIG9yKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIExvZ2ljLnJ1blN5bW1ldHJpY1J1bGVzKGEsIGIsIFtcbiAgICAgICAgICAgIFtMb2dpYy5zdGF0ZS5vbiwgTG9naWMuc3RhdGUub24sIExvZ2ljLnN0YXRlLm9uXSxcbiAgICAgICAgICAgIFtMb2dpYy5zdGF0ZS5vbiwgTG9naWMuc3RhdGUub2ZmLCBMb2dpYy5zdGF0ZS5vbl0sXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUub24sIExvZ2ljLnN0YXRlLnVua25vd24sIExvZ2ljLnN0YXRlLm9uXSxcbiAgICAgICAgICAgIFtMb2dpYy5zdGF0ZS5vbiwgTG9naWMuc3RhdGUub3NjaWxsYXRpbmcsIExvZ2ljLnN0YXRlLm9uXSxcblxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLm9mZiwgTG9naWMuc3RhdGUub2ZmLCBMb2dpYy5zdGF0ZS5vZmZdLFxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLm9mZiwgTG9naWMuc3RhdGUudW5rbm93biwgTG9naWMuc3RhdGUudW5rbm93bl0sXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUub2ZmLCBMb2dpYy5zdGF0ZS5vc2NpbGxhdGluZywgTG9naWMuc3RhdGUub3NjaWxsYXRpbmddLFxuXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUudW5rbm93biwgTG9naWMuc3RhdGUudW5rbm93biwgTG9naWMuc3RhdGUudW5rbm93bl0sXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUudW5rbm93biwgTG9naWMuc3RhdGUub3NjaWxsYXRpbmcsIExvZ2ljLnN0YXRlLnVua25vd25dLFxuXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUub3NjaWxsYXRpbmcsIExvZ2ljLnN0YXRlLm9zY2lsbGF0aW5nLCBMb2dpYy5zdGF0ZS5vc2NpbGxhdGluZ11cbiAgICAgICAgXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9naWMgWE5PUlxuICAgICAqIEBwYXJhbSAge0xvZ2ljLnN0YXRlfSBhIGZpcnN0IGlucHV0IHN0YXRlXG4gICAgICogQHBhcmFtICB7TG9naWMuc3RhdGV9IGIgc2Vjb25kIGlucHV0IHN0YXRlXG4gICAgICogQHJldHVybiB7TG9naWMuc3RhdGV9ICAgb3V0cHV0IHN0YXRlXG4gICAgICovXG4gICAgc3RhdGljIHhub3IoYSwgYikge1xuICAgICAgICByZXR1cm4gTG9naWMubm90KExvZ2ljLnhvcihhLCBiKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9naWMgWE9SXG4gICAgICogQHBhcmFtICB7TG9naWMuc3RhdGV9IGEgZmlyc3QgaW5wdXQgc3RhdGVcbiAgICAgKiBAcGFyYW0gIHtMb2dpYy5zdGF0ZX0gYiBzZWNvbmQgaW5wdXQgc3RhdGVcbiAgICAgKiBAcmV0dXJuIHtMb2dpYy5zdGF0ZX0gICBvdXRwdXQgc3RhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgeG9yKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIExvZ2ljLnJ1blN5bW1ldHJpY1J1bGVzKGEsIGIsIFtcbiAgICAgICAgICAgIFtMb2dpYy5zdGF0ZS5vbiwgTG9naWMuc3RhdGUub24sIExvZ2ljLnN0YXRlLm9mZl0sXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUub24sIExvZ2ljLnN0YXRlLm9mZiwgTG9naWMuc3RhdGUub25dLFxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLm9uLCBMb2dpYy5zdGF0ZS51bmtub3duLCBMb2dpYy5zdGF0ZS51bmtub3duXSxcbiAgICAgICAgICAgIFtMb2dpYy5zdGF0ZS5vbiwgTG9naWMuc3RhdGUub3NjaWxsYXRpbmcsIExvZ2ljLnN0YXRlLm9zY2lsbGF0aW5nXSxcblxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLm9mZiwgTG9naWMuc3RhdGUub2ZmLCBMb2dpYy5zdGF0ZS5vZmZdLFxuICAgICAgICAgICAgW0xvZ2ljLnN0YXRlLm9mZiwgTG9naWMuc3RhdGUudW5rbm93biwgTG9naWMuc3RhdGUudW5rbm93bl0sXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUub2ZmLCBMb2dpYy5zdGF0ZS5vc2NpbGxhdGluZywgTG9naWMuc3RhdGUub3NjaWxsYXRpbmddLFxuXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUudW5rbm93biwgTG9naWMuc3RhdGUudW5rbm93biwgTG9naWMuc3RhdGUudW5rbm93bl0sXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUudW5rbm93biwgTG9naWMuc3RhdGUub3NjaWxsYXRpbmcsIExvZ2ljLnN0YXRlLnVua25vd25dLFxuXG4gICAgICAgICAgICBbTG9naWMuc3RhdGUub3NjaWxsYXRpbmcsIExvZ2ljLnN0YXRlLm9zY2lsbGF0aW5nLCBMb2dpYy5zdGF0ZS5vc2NpbGxhdGluZ11cbiAgICAgICAgXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGNvcnJlY3QgcnVsZSBpbiB0aGUgYXJyYXkgb2YgcnVsZXMgYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmV0dXJuIHZhbHVlLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gZXhwZWN0cyBydWxlcyB0byBiZSBzeW1tZXRyaWMgKHNvIGBhIFJVTEUgYmAgc2hvdWxkIHJldHVybnMgdGhlIHNhbWUgdmFsdWUgYXMgYGIgUlVMRSBhYCksXG4gICAgICogd2hpY2ggYWxsb3dzIHRvIGN1dCBkb3duIG9uIHRoZSBgcnVsZXNgIGFycmF5IHF1aXRlIGEgYml0XG4gICAgICogQHBhcmFtICB7TG9naWMuc3RhdGV9IGEgICAgIGZpcnN0IGlucHV0IHN0YXRlXG4gICAgICogQHBhcmFtICB7TG9naWMuc3RhdGV9IGIgICAgIHNlY29uZCBpbnB1dCBzdGF0ZVxuICAgICAqIEBwYXJhbSAge0FycmF5fSBydWxlcyAgICAgICBBcnJheSBvZiBhcnJheXMuIEVhY2ggaW5uZXIgYXJyYXkgcmVwcmVzZW50cyBhIHJ1bGUgaW4gdGhlIGZvcm1hdCBbaW5wdXQxLCBpbnB1dDIsIG91dHB1dF0uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBmdW5jdGlvbiBmaW5kcyBhbiBhcnJheSwgd2hlcmUgYGEgPT09IGlucHV0MWAgYW5kIGBiID09PSBpbnB1dDFgIChvciBgYSA9PT0gaW5wdXQyYCBhbmQgYGIgPT09IGlucHV0MWApXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCByZXR1cm5zIGBvdXRwdXRgIGZyb20gdGhpcyBhcnJheS5cbiAgICAgKiBAcmV0dXJuIHtMb2dpYy5zdGF0ZX0gICAgICAgb3V0cHV0IHN0YXRlXG4gICAgICovXG4gICAgc3RhdGljIHJ1blN5bW1ldHJpY1J1bGVzKGEsIGIsIHJ1bGVzKSB7XG4gICAgICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBhbGwgdGhlIHJ1bGVzXG4gICAgICAgIGZvciAoY29uc3QgcnVsZSBvZiBydWxlcykge1xuICAgICAgICAgICAgaWYgKChydWxlWzBdID09PSBhICYmIHJ1bGVbMV0gPT09IGIpIHx8IChydWxlWzBdID09PSBiICYmIHJ1bGVbMV0gPT09IGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bGVbMl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBubyBydWxlIG1hdGNoZXMsIHRoZSBvdXRwdXQgc3RhdGUgaXMgdW5rbm93blxuICAgICAgICByZXR1cm4gTG9naWMuc3RhdGUudW5rbm93bjtcbiAgICB9XG59XG4iLCJpbXBvcnQgTG9naWMgZnJvbSAnLi9Mb2dpYyc7XG5cbi8qKlxuICogQG1vZHVsZSBTaW11bGF0aW9uXG4gKi9cblxuY2xhc3Mgc3RhdGVDaGFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGNvbm5lY3RvcklkLCBzdGF0ZSwgd2hvQ2F1c2VkSXQpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0b3JJZCA9IGNvbm5lY3RvcklkO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMud2hvQ2F1c2VkSXQgPSB3aG9DYXVzZWRJdDtcbiAgICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhIGR1bW15IHRoYXQgZG9lcyBub3RoaW5nLCBqdXN0IGxvZ3MgdGhlIGZ1bmN0aW9uIGNhbGxzLlxuICpcbiAqIFVzZWQgb24gbmV0d29ya3MgdGhhdCBoYXMgbm90IGJlZW4geWV0IHNpbXVsYXRlZCBidXQgdXNlciB0cmllcyB0byBjaGFuZ2UgbG9naWMgdmFsdWVzLlxuICovXG5leHBvcnQgY2xhc3MgU2ltdWxhdGlvbkR1bW15IHtcbiAgICBub3RpZnlDaGFuZ2UoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdTaW11bGF0aW9uRHVtbXkubm90aWZ5Q2hhbmdlKCkgaGFzIGJlZW4gY2FsbGVkLicpO1xuICAgIH1cblxuICAgIHJ1bigpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1NpbXVsYXRpb25EdW1teS5ydW4oKSBoYXMgYmVlbiBjYWxsZWQuJyk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoaXMgY2xhc3MgcnVucyB0aGUgbmV0d29yayBzaW11bGF0aW9uLlxuICpcbiAqIF9ub3RlOiBhbGwgY29ubmVjdG9ycyB0aGF0IGFyZSB1c2VkIGluIHRoaXMgY2xhc3MgYXJlICoqb3V0cHV0IGNvbm5lY3RvcnMqKl9cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2ltdWxhdGlvbiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcHB9IGFwcEluc3RhbmNlIGluc3RhbmNlIG9mIFtBcHBdKC4vbW9kdWxlLUFwcC5odG1sKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFwcEluc3RhbmNlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpbnN0YW5jZSBvZiBBcHAgdGhpcyBTaW11bGF0aW9uIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHR5cGUge0FwcH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXBwSW5zdGFuY2UgPSBhcHBJbnN0YW5jZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWFwcyBlYWNoIGFmZmVjdGVkIG91dHB1dCBjb25uZWN0b3IgdG8gaXQncyBkaXJlY3RseSBwcmVjZWVkaW5nIG91dHB1dCBjb25uZWN0b3JzXG4gICAgICAgICAqIEB0eXBlIHtNYXB9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZWRlY2Vzc29ycyA9IG5ldyBNYXAoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWFwcyB3YXZlSWQgdG8gYW4gYXJyYXkgb2YgYWZmZWN0ZWQgb3V0cHV0Q29ubmVjdG9yc1xuICAgICAgICAgKiBAdHlwZSB7TWFwfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53YXZlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy53YXZlID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWFwcyBjeWNsZWQgY29ubmVjdG9yIGlkIHRvIHNldCBvZiBzdGF0ZXMgdGhpcyBjb25uZWN0b3Igd2FzIGluXG4gICAgICAgICAqIEB0eXBlIHtNYXB9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN5Y2xlZENvbm5lY3RvcnMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCBvZiBjeWNsZWQgY29ubmVjdG9ycyB0aGF0IGhhdmUgYmVlbiBhbHJlYWR5IHJlc29sdmVkXG4gICAgICAgICAqIEB0eXBlIHtTZXR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc29sdmVkQ3ljbGVkQ29ubmVjdG9ycyA9IG5ldyBTZXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBydW4gdGhlIHNpbXVsYXRpb25cbiAgICAgKi9cbiAgICBydW4oKSB7XG4gICAgICAgIHRoaXMud2F2ZSsrO1xuICAgICAgICB3aGlsZSAodGhpcy53YXZlcy5oYXModGhpcy53YXZlKSkge1xuICAgICAgICAgICAgdGhpcy5zdGVwKCk7XG4gICAgICAgICAgICB0aGlzLndhdmVzLmRlbGV0ZSh0aGlzLndhdmUpOyAvLyBjbGVhbiBvbGQgd2F2ZXMgb24gdGhlIGdvXG4gICAgICAgICAgICB0aGlzLndhdmUrKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG9uZSBzdGVwL3dhdmUgb2YgdGhlIHNpbXVsYXRpb25cbiAgICAgKlxuICAgICAqIGRldGVybWluZXMgc3RhdGVzIG9mIHRoZSBjb25uZWN0b3JzIGluIHRoZSBjdXJyZW50IHdhdmUsIGRldGVjdHMgY3ljbGVzXG4gICAgICovXG4gICAgc3RlcCgpIHtcbiAgICAgICAgZm9yIChsZXQgeyBjb25uZWN0b3JJZCwgc3RhdGUsIHdob0NhdXNlZEl0IH0gb2YgdGhpcy53YXZlcy5nZXQodGhpcy53YXZlKSkge1xuICAgICAgICAgICAgLy8gc2tpcCByZXNvbHZlZCBjeWNsZXNcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc29sdmVkQ3ljbGVkQ29ubmVjdG9ycy5oYXMoY29ubmVjdG9ySWQpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNraXAgY29ubmVjdG9yIHRoYXQgYXJlIGN5Y2xlc1xuICAgICAgICAgICAgaWYgKHRoaXMuY3ljbGVkQ29ubmVjdG9ycy5oYXMoY29ubmVjdG9ySWQpKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBzZXQgb2Ygc3RhdGVzIHRoYXQgdGhpcyBjb25uZWN0b3IgYXBwZWFyZWQgZnJvbSB0aGUgbW9tZW50IHRoZSBzaWduYWwgZmlyc3QgY3ljbGVkXG4gICAgICAgICAgICAgICAgbGV0IHN0YXRlcyA9IHRoaXMuY3ljbGVkQ29ubmVjdG9ycy5nZXQoY29ubmVjdG9ySWQpO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGNvbm5lY3RvciBhbHJlYWR5IGhhZCB0aGlzIHN0YXRlIGluIHRoaXMgY3ljbGUsIHJlc29sdmUgdGhlIGN5Y2xlXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlcy5oYXMoc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBtb3JlIHN0YXRlcyBpbiB0aGUgc2V0LCB0aGUgY29ubmVjdG9yIGlzIG9zY2lsbGF0aW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIChlbHNlIGl0IGtlZXBzIGl0cyBzdGF0ZSBhbmQgd2UganVzdCBicmVhayB0aGUgY3ljbGUpXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZXMuc2l6ZSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gTG9naWMuc3RhdGUub3NjaWxsYXRpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBtYXJrIHRoaXMgY29ubmVjdG9yIGFzIHJlc29sdmVkXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWRDeWNsZWRDb25uZWN0b3JzLmFkZChjb25uZWN0b3JJZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhIG5ldywgdW5zZWVuIHN0YXRlLCBhZGQgaXQgdG8gdGhlIHNldCBhbmQgY29udGludWUgc2ltdWxhdGluZyB0aGUgY3ljbGVcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZXMuYWRkKHN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBtYXAgdGhlIG1vZGlmaWVkIHNldCBvZiBzdGF0ZXMgdG8gdGhlIGNvbm5lY3RvclxuICAgICAgICAgICAgICAgIHRoaXMuY3ljbGVkQ29ubmVjdG9ycy5zZXQoY29ubmVjdG9ySWQsIHN0YXRlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMud2hvQ2F1c2VkSXQgPSBjb25uZWN0b3JJZDtcbiAgICAgICAgICAgIC8qICBwcm9jZXNzIGFsbCBvdXRwdXRDb25uZWN0b3JzIGJ5IHNldHRpbmcgdGhlaXIgc3RhdGVcbiAgICAgICAgICAgICAgICB0aGlzIHdpbGwgdHJpZ2dlciBhIGZvbGxvd2luZyBldmVudCBjaGFpbjpcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0Q29ubmVjdG9yIGNoYW5nZXNcbiAgICAgICAgICAgICAgICAgICAgLT4gYWxsIGNvbm5lY3RlZCB3aXJlcyBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgLT4gYWxsIGlucHV0Q29ubmVjdG9ycyBjb25uZWN0ZWQgdG8gdGhlc2Ugd2lyZXMgY2hhbmdlXG4gICAgICAgICAgICAgICAgICAgIC0+IGFsbCBlbGVtZW50cyB0aGF0IGNvbnRhaW4gdGhlc2UgaW5wdXRDb25uZWN0b3JzIGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAtPiB0aGVzZSBlbGVtZW50cyBjb21wdXRlIHRoZSBuZXcgc3RhdGUgb2YgdGhlaXIgb3V0cHV0IGNvbm5lY3RvcnMgYW5kIGNhbGwgbm90aWZ5Q2hhbmdlKClcbiAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIGlmICh3aG9DYXVzZWRJdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkUHJlZGVjZXNzb3IoY29ubmVjdG9ySWQsIHdob0NhdXNlZEl0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICF0aGlzLmN5Y2xlZENvbm5lY3RvcnMuaGFzKGNvbm5lY3RvcklkKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0QWxsUHJlZGVjZXNzb3JzKGNvbm5lY3RvcklkKS5oYXMoY29ubmVjdG9ySWQpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN5Y2xlZENvbm5lY3RvcnMuc2V0KGNvbm5lY3RvcklkLCBuZXcgU2V0KFtzdGF0ZV0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVmbGVjdCB0aGUgY2hhbmdlcyBpbiBTVkdcbiAgICAgICAgICAgIGxldCBjb25uZWN0b3IgPSB0aGlzLmFwcEluc3RhbmNlLmdldENvbm5lY3RvckJ5SWQoY29ubmVjdG9ySWQpO1xuICAgICAgICAgICAgaWYgKGNvbm5lY3Rvcikge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5zZXRTdGF0ZShzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53aG9DYXVzZWRJdCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtYXJrIGEgcHJlZGVjZXNzb3JDb25uZWN0b3JJZCBhcyBhIHByZWRlY2Vzc29yIG9mIGNvbm5lY3RvcklkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbm5lY3RvcklkIElEIG9mIGEgY29ubmVjdG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByZWRlY2Vzc29yQ29ubmVjdG9ySWQgcHJlZGVjZXNzb3Igb2YgYGNvbm5lY3RvcklkYFxuICAgICAqL1xuICAgIGFkZFByZWRlY2Vzc29yKGNvbm5lY3RvcklkLCBwcmVkZWNlc3NvckNvbm5lY3RvcklkKSB7XG4gICAgICAgIGlmICghdGhpcy5wcmVkZWNlc3NvcnMuaGFzKGNvbm5lY3RvcklkKSkge1xuICAgICAgICAgICAgdGhpcy5wcmVkZWNlc3NvcnMuc2V0KGNvbm5lY3RvcklkLCBuZXcgU2V0KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcmVkZWNlc3NvcnMuZ2V0KGNvbm5lY3RvcklkKS5hZGQocHJlZGVjZXNzb3JDb25uZWN0b3JJZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHNldCBvZiBhbGwgb3V0cHV0IGNvbm5lY3RvcnMgdGhhdCBhcmUgYmVmb3JlIHRoaXMgb3V0cHV0IGNvbm5lY3RvclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gY29ubmVjdG9ySWQgSUQgb2YgYSBjb25uZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtTZXR9ICAgICAgICAgICAgICAgIHNldCBvZiBjb25uZWN0b3IgaWRzIHRoYXQgYXJlIGJlZm9yZSB0aGlzIG91dHB1dCBjb25uZWN0b3JcbiAgICAgKi9cbiAgICBnZXRBbGxQcmVkZWNlc3NvcnMoY29ubmVjdG9ySWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByZWRlY2Vzc29ycy5oYXMoY29ubmVjdG9ySWQpKSB7XG4gICAgICAgICAgICB0aGlzLnByZWRlY2Vzc29ycy5zZXQoY29ubmVjdG9ySWQsIG5ldyBTZXQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgYWxsID0gbmV3IFNldCgpO1xuXG4gICAgICAgIHRoaXMucHJlZGVjZXNzb3JzLmdldChjb25uZWN0b3JJZCkuZm9yRWFjaChhbGwuYWRkLCBhbGwpO1xuXG4gICAgICAgIGxldCBwcmV2U2l6ZSA9IDA7XG4gICAgICAgIGxldCBzaXplID0gYWxsLnNpemU7XG4gICAgICAgIHdoaWxlIChwcmV2U2l6ZSA8IHNpemUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbm5lY3RvciBvZiBhbGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcmVkZWNlc3NvcnMuaGFzKGNvbm5lY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmVkZWNlc3NvcnMuZ2V0KGNvbm5lY3RvcikuZm9yRWFjaChhbGwuYWRkLCBhbGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZTaXplID0gc2l6ZTtcbiAgICAgICAgICAgIHNpemUgPSBhbGwuc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhbGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm90aWZ5IGEgY2hhbmdlIGluIHRoZSBuZXR3b3JrLiBUaGlzIGZ1bmN0aW9uIGFkZHMgdGhlIGNoYW5nZWQgY29ubmVjdG9yIHRvIHRoZSBuZXh0IHdhdmVcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNvbm5lY3RvcklkIElEIG9mIHRoZSBjaGFuZ2VkIGNvbm5lY3RvclxuICAgICAqIEBwYXJhbSAge0xvZ2ljLnN0YXRlfSBzdGF0ZSAgbmV3IFtMb2dpYy5zdGF0ZV0oLi9tb2R1bGUtTG9naWMuaHRtbCMuc3RhdGUpIG9mIHRoZSBjb25uZWN0b3JcbiAgICAgKi9cbiAgICBub3RpZnlDaGFuZ2UoY29ubmVjdG9ySWQsIHN0YXRlKSB7XG4gICAgICAgIGxldCB3YXZlSWQgPSB0aGlzLndhdmUgKyAxO1xuXG4gICAgICAgIGlmICghdGhpcy53YXZlcy5oYXMod2F2ZUlkKSkge1xuICAgICAgICAgICAgdGhpcy53YXZlcy5zZXQod2F2ZUlkLCBbXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLndhdmVzLmdldCh3YXZlSWQpLnB1c2gobmV3IHN0YXRlQ2hhbmdlKGNvbm5lY3RvcklkLCBzdGF0ZSwgdGhpcy53aG9DYXVzZWRJdCkpO1xuICAgIH1cbn1cbiIsIi8qKiBAbW9kdWxlIGVkaXRvckVsZW1lbnRzICovXG5cbi8vIHRyYW5zZm9ybVxuZXhwb3J0IHsgZGVmYXVsdCBhcyBUcmFuc2Zvcm0gfSBmcm9tICcuL2VkaXRvckVsZW1lbnRzL1RyYW5zZm9ybSc7XG5cbi8vIGNvbm5lY3RvcnNcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSW5wdXRDb25uZWN0b3IgfSBmcm9tICcuL2VkaXRvckVsZW1lbnRzL0lucHV0Q29ubmVjdG9yJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgT3V0cHV0Q29ubmVjdG9yIH0gZnJvbSAnLi9lZGl0b3JFbGVtZW50cy9PdXRwdXRDb25uZWN0b3InO1xuXG4vLyBib3hlc1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBJbnB1dEJveCB9IGZyb20gJy4vZWRpdG9yRWxlbWVudHMvSW5wdXRCb3gnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBPdXRwdXRCb3ggfSBmcm9tICcuL2VkaXRvckVsZW1lbnRzL091dHB1dEJveCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEdhdGUgfSBmcm9tICcuL2VkaXRvckVsZW1lbnRzL0dhdGUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCbGFja2JveCB9IGZyb20gJy4vZWRpdG9yRWxlbWVudHMvQmxhY2tib3gnO1xuXG4vLyBoZWxwZXIgd2lyZVxuZXhwb3J0IHsgZGVmYXVsdCBhcyBIZWxwZXJXaXJlIH0gZnJvbSAnLi9lZGl0b3JFbGVtZW50cy9IZWxwZXJXaXJlJztcblxuLy8gd2lyZVxuZXhwb3J0IHsgZGVmYXVsdCBhcyBXaXJlIH0gZnJvbSAnLi9lZGl0b3JFbGVtZW50cy9XaXJlJztcbiIsImltcG9ydCB7XG4gICAgR3JvdXAsXG4gICAgUmVjdGFuZ2xlLFxuICAgIE11bHRpTGluZVRleHQsXG4gICAgUG9seUxpbmUsXG4gICAgUG9seUxpbmVQb2ludHMsXG4gICAgUG9seUxpbmVQb2ludFxufSBmcm9tICcuLi9zdmdPYmplY3RzJztcbmltcG9ydCBMb2dpYyBmcm9tICcuLi9Mb2dpYyc7XG5cbmltcG9ydCBCb3ggZnJvbSAnLi9Cb3gnO1xuXG4vKiogQG1vZHVsZSBlZGl0b3JFbGVtZW50cy5CbGFja2JveCAqL1xuXG4vKipcbiAqIEJsYWNrYm94IGlzIGEgYm94IHRoYXQgaXMgZGVmaW5lZCBieSBpdHMgZXZhbHVhdGlvbiBmdW5jdGlvblxuICogQGV4dGVuZHMgQm94XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJsYWNrYm94IGV4dGVuZHMgQm94IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FwcH0gYXBwSW5zdGFuY2UgIGluc3RhbmNlIG9mIFtBcHBdKC4vbW9kdWxlLUFwcC5odG1sKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbnB1dENvbm5lY3RvcnMgIG51bWJlciBvZiBpbnB1dCBjb25uZWN0b3JzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG91dHB1dENvbm5lY3RvcnMgbnVtYmVyIG9mIG91dHB1dCBjb25uZWN0b3JzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZhbEZ1bmN0aW9uICAgZnVuY3Rpb24gdGhhdCB0YWtlcyBgaW5wdXRDb25uZWN0b3JzYCBbTG9naWMuc3RhdGVdKC4vbW9kdWxlLUxvZ2ljLmh0bWwjLnN0YXRlKXNcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgcmV0dXJucyBgb3V0cHV0Q29ubmVjdG9yc2AgTG9naWMuc3RhdGVzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZV0gICAgICAgIG5hbWUgdGhhdCB3aWxsIGJlIGRpc3BsYXllZCBvbiB0aGUgYmxhY2tib3hcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhcHBJbnN0YW5jZSwgaW5wdXRDb25uZWN0b3JzLCBvdXRwdXRDb25uZWN0b3JzLCBldmFsRnVuY3Rpb24sIG5hbWUgPSAnJykge1xuICAgICAgICBjb25zdCB3aWR0aCA9IDExO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1heChpbnB1dENvbm5lY3RvcnMsIG91dHB1dENvbm5lY3RvcnMpICogMjtcblxuICAgICAgICBzdXBlcihhcHBJbnN0YW5jZSwgbmFtZSwgJ2JsYWNrYm94Jywgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgY29uc3QgY29ubmVjdG9yUGluTGVuZ2h0ID0gMi41ICogdGhpcy5ncmlkU2l6ZTtcblxuICAgICAgICAvLyBvdmVycmlkZSBkZWZhdWx0IHN2Z09iaiBzdHJ1Y3R1cmVcbiAgICAgICAgdGhpcy5zdmdPYmogPSBuZXcgR3JvdXAoKTtcblxuICAgICAgICAvLyB0cmFuc3BhcmVudCBiYWNrZ3JvdW5kIHJlY3RhbmdsZVxuICAgICAgICBsZXQgaGl0Ym94ID0gbmV3IFJlY3RhbmdsZSgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgJ25vbmUnLCAnbm9uZScpO1xuICAgICAgICBoaXRib3guJGVsLmFkZENsYXNzKCdyZWN0Jyk7XG5cbiAgICAgICAgdGhpcy5zdmdPYmouYWRkQ2hpbGQoaGl0Ym94KTtcblxuICAgICAgICAvLyBtYWluIHJlY3RhbmdsZVxuICAgICAgICBjb25zdCBib2R5V2lkdGggPSB0aGlzLndpZHRoIC0gMiAqIGNvbm5lY3RvclBpbkxlbmdodDtcblxuICAgICAgICBsZXQgcmVjdGFuZ2xlID0gbmV3IFJlY3RhbmdsZShcbiAgICAgICAgICAgIGNvbm5lY3RvclBpbkxlbmdodCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBib2R5V2lkdGgsXG4gICAgICAgICAgICB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgICd3aGl0ZScsXG4gICAgICAgICAgICAnYmxhY2snXG4gICAgICAgICk7XG4gICAgICAgIHJlY3RhbmdsZS5hZGRBdHRyKHsgJ3N0cm9rZS13aWR0aCc6ICcyLjUnIH0pO1xuICAgICAgICByZWN0YW5nbGUuJGVsLmFkZENsYXNzKCdyZWN0Jyk7XG5cbiAgICAgICAgdGhpcy5zdmdPYmouYWRkQ2hpbGQocmVjdGFuZ2xlKTtcblxuICAgICAgICAvLyB0ZXh0IGRlc2NyaXB0aW9uIG9mIHRoZSBib3hcbiAgICAgICAgY29uc3QgdGV4dFdpZHRoID0gYm9keVdpZHRoIC0gdGhpcy5ncmlkU2l6ZTtcbiAgICAgICAgY29uc3QgdGV4dEhlaWdodCA9IHRoaXMuaGVpZ2h0IC0gdGhpcy5ncmlkU2l6ZTtcbiAgICAgICAgbGV0IHRleHQgPSBuZXcgTXVsdGlMaW5lVGV4dChcbiAgICAgICAgICAgICh0aGlzLndpZHRoIC0gdGV4dFdpZHRoKSAvIDIsIC8vIGhvcml6b250YWwgY2VudGVyaW5nXG4gICAgICAgICAgICAodGhpcy5oZWlnaHQgLSB0ZXh0SGVpZ2h0KSAvIDIsIC8vIHZlcnRpY2FsIGNlbnRlcmluZ1xuICAgICAgICAgICAgdGV4dFdpZHRoLFxuICAgICAgICAgICAgdGV4dEhlaWdodCxcbiAgICAgICAgICAgIG5hbWUudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgIHRoaXMuZ3JpZFNpemUgKiAxLjJcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5zdmdPYmouYWRkQ2hpbGQodGV4dCk7XG5cbiAgICAgICAgLy8gYWRkIGlucHV0IGNvbm5lY3RvcnNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dENvbm5lY3RvcnM7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgZ3JpZFBvc2l0aW9uID0gaSAqIDIgKyAxO1xuICAgICAgICAgICAgY29uc3QgcGl4ZWxQb3NpdGlvbiA9IGdyaWRQb3NpdGlvbiAqIHRoaXMuZ3JpZFNpemU7XG5cbiAgICAgICAgICAgIGxldCBwaW4gPSBuZXcgUG9seUxpbmUoXG4gICAgICAgICAgICAgICAgbmV3IFBvbHlMaW5lUG9pbnRzKFtcbiAgICAgICAgICAgICAgICAgICAgbmV3IFBvbHlMaW5lUG9pbnQoMCwgcGl4ZWxQb3NpdGlvbiksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBQb2x5TGluZVBvaW50KGNvbm5lY3RvclBpbkxlbmdodCwgcGl4ZWxQb3NpdGlvbilcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICdibGFjaydcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRoaXMuc3ZnT2JqLmFkZENoaWxkKHBpbik7XG5cbiAgICAgICAgICAgIC8vIGFkZCB0aGUgY29ubmVjdG9yXG4gICAgICAgICAgICB0aGlzLmFkZElucHV0Q29ubmVjdG9yKDAsIGdyaWRQb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgb3V0cHV0IGNvbm5lY3RvcnNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRDb25uZWN0b3JzOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGdyaWRQb3NpdGlvbiA9IGkgKiAyICsgMTtcbiAgICAgICAgICAgIGNvbnN0IHBpeGVsUG9zaXRpb24gPSBncmlkUG9zaXRpb24gKiB0aGlzLmdyaWRTaXplO1xuXG4gICAgICAgICAgICBsZXQgcGluID0gbmV3IFBvbHlMaW5lKFxuICAgICAgICAgICAgICAgIG5ldyBQb2x5TGluZVBvaW50cyhbXG4gICAgICAgICAgICAgICAgICAgIG5ldyBQb2x5TGluZVBvaW50KHRoaXMud2lkdGggLSBjb25uZWN0b3JQaW5MZW5naHQsIHBpeGVsUG9zaXRpb24pLFxuICAgICAgICAgICAgICAgICAgICBuZXcgUG9seUxpbmVQb2ludCh0aGlzLndpZHRoLCBwaXhlbFBvc2l0aW9uKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgJ2JsYWNrJ1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdGhpcy5zdmdPYmouYWRkQ2hpbGQocGluKTtcblxuICAgICAgICAgICAgdGhpcy5hZGRPdXRwdXRDb25uZWN0b3Iod2lkdGgsIGdyaWRQb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN2Z09iai4kZWwuYWRkQ2xhc3MoJ2JveCcpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBmdW5jdGlvbiB0aGF0IHRha2VzIGBpbnB1dENvbm5lY3RvcnNgIFtMb2dpYy5zdGF0ZV0oLi9tb2R1bGUtTG9naWMuaHRtbCMuc3RhdGUpc1xuICAgICAgICAgKiBhbmQgcmV0dXJucyBgb3V0cHV0Q29ubmVjdG9yc2AgTG9naWMuc3RhdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ldmFsRnVuY3Rpb24gPSBldmFsRnVuY3Rpb247XG5cbiAgICAgICAgLy8gcmVnZW5lcmF0ZSB0aGUgYmxvY2tlZCBub2RlcyBhZnRlciBhZGRpbmcgYWxsIHRoZSBjb25uZWN0b3JzXG4gICAgICAgIHRoaXMuZ2VuZXJhdGVCbG9ja05vZGVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IGRhdGEgb2YgdGhpcyBibGFja2JveCBhcyBhIEpTT04tcmVhZHkgb2JqZWN0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGVzc2VudGlhbCBkYXRhIGZvciB0aGlzIGJsYWNrYm94XG4gICAgICovXG4gICAgZ2V0IGV4cG9ydERhdGEoKSB7XG4gICAgICAgIGxldCBkYXRhID0gc3VwZXIuZXhwb3J0RGF0YTtcbiAgICAgICAgZGF0YS5pbnB1dHMgPSB0aGlzLmlucHV0Q29ubmVjdG9ycy5sZW5ndGg7XG4gICAgICAgIGRhdGEub3V0cHV0cyA9IHRoaXMub3V0cHV0Q29ubmVjdG9ycy5sZW5ndGg7XG5cbiAgICAgICAgLy8gZ2VuZXJhdGUgdGhlIHRydXRoIHRhYmxlXG5cbiAgICAgICAgZGF0YS50YWJsZSA9IFtdO1xuXG4gICAgICAgIC8vIGFycmF5IG9mIHRlc3RlZCBpbnB1dCBzdGF0ZXNcbiAgICAgICAgY29uc3Qgc3RhdGVMaXN0ID0gTG9naWMuc3RhdGVMaXN0O1xuXG4gICAgICAgIC8vIHJlY3Vyc2l2ZSBmdW5jdGlvbiB0aGF0IGdlbmVyYXRlcyBhbGwgcG9zc2libGUgaW5wdXRzXG4gICAgICAgIGNvbnN0IGdldFBlcm11dGF0aW9ucyA9IGxlbmd0aCA9PiB7XG4gICAgICAgICAgICBsZXQgcGVybXV0YXRpb25zID0gW107XG4gICAgICAgICAgICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdGF0ZSBvZiBzdGF0ZUxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcm11dGF0aW9ucy5wdXNoKFtzdGF0ZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwZXJtdXRhdGlvbnM7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdGF0ZSBvZiBzdGF0ZUxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGVybSBvZiBnZXRQZXJtdXRhdGlvbnMobGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJtdXRhdGlvbnMucHVzaChbc3RhdGUsIC4uLnBlcm1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGVybXV0YXRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGdlbmVyYXRlIG91dHB1dHMgZm9yIGFsbCB0aGUgcG9zc2libGUgaW5wdXRzXG4gICAgICAgIGZvciAoY29uc3QgaW5wdXRWYWx1ZXMgb2YgZ2V0UGVybXV0YXRpb25zKGRhdGEuaW5wdXRzKSkge1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0VmFsdWVzID0gdGhpcy5ldmFsRnVuY3Rpb24oLi4uaW5wdXRWYWx1ZXMpO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbiBvdXRwdXQgdmFsdWUgdGhhdCBpcyBub3QgTG9naWMuc3RhdGUudW5rbm93biwgYWRkIHRoaXMgbGluZSB0byB0aGVcbiAgICAgICAgICAgIC8vIHRydXRodGFibGUsIG90aGVyd2lzZSBkb24ndCBhZGQgaXQgKGlmIGFsbCBvdXRwdXQgdmFsdWVzIGFyZSBMb2dpYy5zdGF0ZS51bmtub3duLFxuICAgICAgICAgICAgLy8gdGhlIGlucHV0IGNvbWJpbmF0aW9uIGRvZXMgbm90IGhhdmUgdG8gYmUgZGVmaW5lcywgYmVjYXVzZSBMb2dpYy5zdGF0ZS51bmtub3duIGlzIHRoZSBkZWZhdWx0IHZhbHVlKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG91dHB1dFZhbHVlcy5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBjdXJyZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bXVsYXRvciB8fCBjdXJyZW50ICE9PSBMb2dpYy5zdGF0ZS51bmtub3duO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBkYXRhLnRhYmxlLnB1c2goWy4uLmlucHV0VmFsdWVzLCAuLi5vdXRwdXRWYWx1ZXNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHByb2NjZXNzIHRoZSBpbnB1dCBjb25uZWN0b3Igc3RhdGVzIGFuZCByZWZsZWN0IHRoZW0gaW4gdGhlIG91dHB1dCBjb25uZWN0b3Igc3RhdGVzIGFjY29yZGluZ1xuICAgICAqIHRvIHRoZSBsb2dpYyBkZWZpbmVkIGJ5IHRoaXMuZXZhbEZ1bmN0aW9uXG4gICAgICovXG4gICAgcmVmcmVzaFN0YXRlKCkge1xuICAgICAgICBjb25zdCBpbnB1dFN0YXRlcyA9IHRoaXMuaW5wdXRDb25uZWN0b3JzLm1hcChjb25uID0+IGNvbm4uc3RhdGUpO1xuICAgICAgICAvLyBjYWxsIHRoZSBldmFsRnVuY3Rpb24gdG8gZ2V0IHRoZSBvdXRwdXQgc3RhdGVzXG4gICAgICAgIGNvbnN0IG91dHB1dFN0YXRlcyA9IHRoaXMuZXZhbEZ1bmN0aW9uKC4uLmlucHV0U3RhdGVzKTtcblxuICAgICAgICAvLyBhcHBseSB0aGUgb3V0cHV0U3RhdGVzIHRvIHRoZSBvdXRwdXRDb25uZWN0b3JzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0U3RhdGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dENvbm5lY3RvcnNbaV0uc2V0U3RhdGUob3V0cHV0U3RhdGVzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdlbmVyYXRlQmxvY2tOb2RlcygpIHtcbiAgICAgICAgLy8gYWRkIGJsb2NrZWQgbm9kZXMgb24gdGhlIGNvbm5lY3RvcnMgYW5kIGJldHdlZW4gdGhlbSBhcyB3ZWxsXG5cbiAgICAgICAgbGV0IHNwZWNpYWxOb2RlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuaW5wdXRDb25uZWN0b3JzLmxlbmd0aCAqIDI7ICsraSkge1xuICAgICAgICAgICAgc3BlY2lhbE5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogaVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLm91dHB1dENvbm5lY3RvcnMubGVuZ3RoICogMjsgKytpKSB7XG4gICAgICAgICAgICBzcGVjaWFsTm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgeDogdGhpcy5ncmlkV2lkdGgsXG4gICAgICAgICAgICAgICAgeTogaVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdXBlci5nZW5lcmF0ZUJsb2NrTm9kZXMoMCwgMSwgMCwgMSwgLi4uc3BlY2lhbE5vZGVzKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBHcm91cCwgUmVjdGFuZ2xlLCBTdmdJbWFnZSB9IGZyb20gJy4uL3N2Z09iamVjdHMnO1xuXG5pbXBvcnQgTmV0d29ya0VsZW1lbnQgZnJvbSAnLi9OZXR3b3JrRWxlbWVudCc7XG5pbXBvcnQgSW5wdXRDb25uZWN0b3IgZnJvbSAnLi9JbnB1dENvbm5lY3Rvcic7XG5pbXBvcnQgT3V0cHV0Q29ubmVjdG9yIGZyb20gJy4vT3V0cHV0Q29ubmVjdG9yJztcbmltcG9ydCBUcmFuc2Zvcm0gZnJvbSAnLi9UcmFuc2Zvcm0nO1xuXG4vKiogQG1vZHVsZSBlZGl0b3JFbGVtZW50cy5Cb3ggKi9cblxuLyoqXG4gKiBQYXJlbnQgY2xhc3MgZm9yIGdhdGVzIGFuZCBpbnB1dCBhbmQgb3V0cHV0IGJveGVzLiBEZWZpbmVzIGFsbCB0aGUgZmFjdG9yc1xuICogdGhhdCB0aGUgYm94ZXMgaGF2ZSBpbiBjb21tb24gKHN2Z09iaiBzdHJ1Y3R1cmUsIGRyYWdnYWJpbGl0eSBhbmQgcm90YXRhYmlsaXR5Li4uKVxuICogQGV4dGVuZHMgTmV0d29ya0VsZW1lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQm94IGV4dGVuZHMgTmV0d29ya0VsZW1lbnQge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXBwfSBhcHBJbnN0YW5jZSAgaW5zdGFuY2Ugb2YgW0FwcF0oLi9tb2R1bGUtQXBwLmh0bWwpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgICAgICAgbmFtZSBvZiB0aGUgZWxlbWVudCAoaW5wdXQsIG91dHB1dCwgYW5kLCBvciwgeG9yLi4uKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjYXRlZ29yeSAgIHR5cGUgb2YgdGhlIGVsZW1lbnQgKGlvLCBnYXRlKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncmlkV2lkdGggIHdpZHRoIG9mIHRoZSBlbGVtZW50IGluIGdyaWQgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdyaWRIZWlnaHQgaGVpZ2h0IG9mIHRoZSBlbGVtZW50IGluIGdyaWQgcGl4ZWxzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYXBwSW5zdGFuY2UsIG5hbWUsIGNhdGVnb3J5LCBncmlkV2lkdGgsIGdyaWRIZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwSW5zdGFuY2UpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzcGVjaWZpZXMgdGhlIGJveCB0eXBlIHdpdGhpbiB0aGUgY2F0ZWdvcnkgKGlucHV0L291dHB1dCBpbiBpbywgYW5kL29yLy4uLiBpbiBnYXRlKVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogc3BlY2lmaWVzIHRoZSBib3ggY2F0ZWdvcnkgKGlvIGZvciBpbnB1dCBvciBvdXRwdXQsIGdhdGUgZm9yIGxvZ2ljIGdhdGVzKVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYXRlZ29yeSA9IGNhdGVnb3J5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzaXplIG9mIHRoZSBncmlkIGluIFNWRyBwaXhlbHNcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JpZFNpemUgPSB0aGlzLmFwcEluc3RhbmNlLmdyaWRTaXplO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhcnJheSBvZiBjb25uZWN0b3JzIG9mIHRoaXMgYm94XG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29ubmVjdG9ycyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzdmdPYmogY29udGFpbmluZyBhbGwgU1ZHIGRhdGEgdXNlZCB0byBkaXNwbGF5IHRoaXMgYm94XG4gICAgICAgICAqIEB0eXBlIHtzdmdPYmp9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN2Z09iaiA9IG5ldyBHcm91cCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB3aWR0aCBvZiB0aGlzIGVsZW1lbnQgaW4gU1ZHIHBpeGVsc1xuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53aWR0aCA9IGdyaWRXaWR0aCAqIHRoaXMuZ3JpZFNpemU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBoZWlnaHQgb2YgdGhpcyBlbGVtZW50IGluIFNWRyBwaXhlbHNcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gZ3JpZEhlaWdodCAqIHRoaXMuZ3JpZFNpemU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHdpZHRoIG9mIHRoaXMgZWxlbWVudCBpbiBncmlkIHBpeGVsc1xuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ncmlkV2lkdGggPSBncmlkV2lkdGg7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBoZWlnaHQgb2YgdGhpcyBlbGVtZW50IGluIGdyaWQgcGl4ZWxzXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdyaWRIZWlnaHQgPSBncmlkSGVpZ2h0O1xuXG4gICAgICAgIC8vIHRyYW5zcGFyZW50IGJhY2tncm91bmQgcmVjdGFuZ2xlXG4gICAgICAgIGxldCByZWN0YW5nbGUgPSBuZXcgUmVjdGFuZ2xlKDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAnbm9uZScsICdub25lJyk7XG4gICAgICAgIHJlY3RhbmdsZS4kZWwuYWRkQ2xhc3MoJ3JlY3QnKTtcblxuICAgICAgICB0aGlzLnN2Z09iai5hZGRDaGlsZChyZWN0YW5nbGUpO1xuXG4gICAgICAgIC8vIGltYWdlIG9mIHRoZSBlbGVtZW50XG4gICAgICAgIHRoaXMuaW1hZ2UgPSBuZXcgU3ZnSW1hZ2UoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMudXJsKTtcbiAgICAgICAgdGhpcy5zdmdPYmouYWRkQ2hpbGQodGhpcy5pbWFnZSk7XG5cbiAgICAgICAgLy8gYWRkIHR5cGU9XCJnYXRlXCIsIHVzZWQgaW4gc3BlY2lhbCBjYWxsYmFja3MgaW4gY29udGV4dG1lbnVcbiAgICAgICAgdGhpcy5zdmdPYmouYWRkQXR0cih7IHR5cGU6IGNhdGVnb3J5IH0pO1xuXG4gICAgICAgIHRoaXMuc3ZnT2JqLiRlbC5hZGRDbGFzcygnYm94Jyk7XG4gICAgICAgIHRoaXMuc3ZnT2JqLiRlbC5hZGRDbGFzcyhjYXRlZ29yeSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdXJsIG9mIHRoZSBpbWFnZSBkZXBpY3RpbmcgdGhpcyBvYmplY3RcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCB1cmwoKSB7XG4gICAgICAgIGNvbnN0IGNhdGVnb3J5ID0gdGhpcy5jYXRlZ29yeSB8fCAnJyxcbiAgICAgICAgICAgIG5hbWUgPSB0aGlzLm5hbWUgfHwgJycsXG4gICAgICAgICAgICBzdWZmaXggPSB0aGlzLmltZ1N1ZmZpeCB8fCAnJztcblxuICAgICAgICByZXR1cm4gYGltZy9zdmcvJHtjYXRlZ29yeX0vJHtuYW1lfSR7c3VmZml4fS5zdmdgO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCBhbGwgaW5wdXQgY29ubmVjdG9ycyBvZiB0aGlzIGJveFxuICAgICAqIEByZXR1cm4ge0FycmF5fSBhcnJheSBvZiBpbnB1dCBjb25uZWN0b3JzXG4gICAgICovXG4gICAgZ2V0IGlucHV0Q29ubmVjdG9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdG9ycy5maWx0ZXIoY29ubiA9PiBjb25uLmlzSW5wdXRDb25uZWN0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCBhbGwgb3V0cHV0IGNvbm5lY3RvcnMgb2YgdGhpcyBib3hcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgb2Ygb3V0cHV0IGNvbm5lY3RvcnNcbiAgICAgKi9cbiAgICBnZXQgb3V0cHV0Q29ubmVjdG9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdG9ycy5maWx0ZXIoY29ubiA9PiBjb25uLmlzT3V0cHV0Q29ubmVjdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgZGF0YSBvZiB0aGlzIGJveCBhcyBhIEpTT04tcmVhZHkgb2JqZWN0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGVzc2VudGlhbCBkYXRhIGZvciB0aGlzIGJveFxuICAgICAqL1xuICAgIGdldCBleHBvcnREYXRhKCkge1xuICAgICAgICBsZXQgY29ubmVjdGlvbnMgPSBbXTtcblxuICAgICAgICAvLyBnbyB0aHJvdWdoIGFsbCBjb25uZWN0b3JzXG4gICAgICAgIGxldCBjb3VudGVyID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBjb25uIG9mIHRoaXMuY29ubmVjdG9ycykge1xuICAgICAgICAgICAgLy8gZ28gdGhyb3VnaCBlYWNoIGl0cyB3aXJlIGlkXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29ubi53aXJlSWRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRoaXNXaXJlSWQ7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmFwcEluc3RhbmNlLmV4cG9ydFdpcmVJZE1hcC5oYXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHdpcmUgaWQgaXMgbm90IGluIHRoZSBtYXAsIGFkZCBpdCBhbmQgYXNzaWduIG5ldyBhcmJpdHJhcnkgaWRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBJbnN0YW5jZS5leHBvcnRXaXJlSWRNYXAuc2V0KGl0ZW0sIHRoaXMuYXBwSW5zdGFuY2UuZXhwb3J0V2lyZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1dpcmVJZCA9IHRoaXMuYXBwSW5zdGFuY2UuZXhwb3J0V2lyZUlkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcEluc3RhbmNlLmV4cG9ydFdpcmVJZCsrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgZ2V0IGlkIGZyb20gdGhlIG1hcFxuICAgICAgICAgICAgICAgICAgICB0aGlzV2lyZUlkID0gdGhpcy5hcHBJbnN0YW5jZS5leHBvcnRXaXJlSWRNYXAuZ2V0KGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGFkZCB0aGlzIGNvbm5lY3Rpb24gdG8gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uc1tjb25uZWN0aW9ucy5sZW5ndGhdID0ge1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogY291bnRlcixcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogY29ubi50eXBlLFxuICAgICAgICAgICAgICAgICAgICB3aXJlSWQ6IHRoaXNXaXJlSWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnRlcisrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIGNhdGVnb3J5OiB0aGlzLmNhdGVnb3J5LFxuICAgICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLmdldFRyYW5zZm9ybSh0cnVlKSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25zOiBjb25uZWN0aW9uc1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCBzZXQgb2Ygbm9kZXMgdGhhdCBhcmUgbm90IHN1aXRhYmxlIGZvciB3aXJlIHJvdXRpbmdcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFttYXJnaW5Ub3A9MF0gICAgdG9wIG1hcmdpbiBvZiB0aGUgZWxlbWVudCAoZGlzdGFuY2UgZnJvbSB0aGUgZWxlbWVudCB0aGF0IHNob3VsZCBiZSBhbHNvIGJsb2NrZWQpXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbbWFyZ2luUmlnaHQ9MF0gIHJpZ2h0IG1hcmdpbiBvZiB0aGUgZWxlbWVudFxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW21hcmdpbkJvdHRvbT0wXSBib3R0b20gbWFyZ2luIG9mIHRoZSBlbGVtZW50XG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbbWFyZ2luTGVmdD0wXSAgIGxlZnQgbWFyZ2luIG9mIHRoZSBlbGVtZW50XG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBzcGVjaWFsTm9kZXMgICAgIGFkZGl0aW9uYWwgbm9kZXMgdGhhdCBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIHNldFxuICAgICAqIEByZXR1cm4ge1NldH0gICAgICAgICAgICAgICAgICAgICBzZXQgb2Ygbm90IHN1aXRhYmxlIG5vZGVzXG4gICAgICovXG4gICAgZ2VuZXJhdGVCbG9ja05vZGVzKFxuICAgICAgICBtYXJnaW5Ub3AgPSAwLFxuICAgICAgICBtYXJnaW5SaWdodCA9IDAsXG4gICAgICAgIG1hcmdpbkJvdHRvbSA9IDAsXG4gICAgICAgIG1hcmdpbkxlZnQgPSAwLFxuICAgICAgICAuLi5zcGVjaWFsTm9kZXNcbiAgICApIHtcbiAgICAgICAgdGhpcy5ibG9ja2VkTm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAobGV0IHggPSBtYXJnaW5MZWZ0OyB4IDw9IHRoaXMuZ3JpZFdpZHRoIC0gbWFyZ2luUmlnaHQ7IHgrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IG1hcmdpblRvcDsgeSA8PSB0aGlzLmdyaWRIZWlnaHQgLSBtYXJnaW5Cb3R0b207IHkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tlZE5vZGVzLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IG5vZGUgb2Ygc3BlY2lhbE5vZGVzKSB7XG4gICAgICAgICAgICB0aGlzLmJsb2NrZWROb2Rlcy5hZGQobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBlbXB0eSBmdW5jdGlvbiwgcmVkZWZpbmVkIGluIGluaGVyaXRlZCBlbGVtZW50c1xuICAgICAqIHJlZnJlc2hTdGF0ZSB0YWtlcyBpbnB1dCBjb25uZWN0b3IgdmFsdWVzIGFuZCBzZXRzIG91dHB1dCB2YWx1ZXMgYWNjb3JkaW5nbHlcbiAgICAgKi9cbiAgICByZWZyZXNoU3RhdGUoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQ2FsbGluZyB0aGUgdmlydHVhbCBmdW5jdGlvbiByZWZyZXNoU3RhdGUgaGFzIG5vIGVmZmVjdC4nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjaGFuZ2UgaW1hZ2UgdG8gYW5vdGhlciBvbmUgdGhhdCBlbmRzIHdpdGggYSBzcGVjaWZpZWQgc3VmZml4XG4gICAgICpcbiAgICAgKiAqdXNhZ2U6KiBgY2hhbmdlSW1hZ2UoXCJhYmNcIilgIGNoYW5nZXMgaW1hZ2UgdXJsIHRvIGBpbWFnZS1hYmMuc3ZnYCxcbiAgICAgKiBgY2hhbmdlSW1hZ2UoKWAgY2hhbmdlcyBpbWFnZSB1cmwgdG8gdGhlIGRlZmF1bHQgb25lIChgaW1hZ2Uuc3ZnYClcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IFtzdWZmaXhdIG5ldyBzdWZmaXggZm9yIHRoZSBpbWFnZVxuICAgICAqL1xuICAgIGNoYW5nZUltYWdlKHN1ZmZpeCkge1xuICAgICAgICBpZiAoc3VmZml4ID09PSB1bmRlZmluZWQgfHwgc3VmZml4ID09PSAnJykge1xuICAgICAgICAgICAgdGhpcy5pbWdTdWZmaXggPSAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW1nU3VmZml4ID0gJy0nICsgc3VmZml4O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbWFnZS5jaGFuZ2VVcmwodGhpcy51cmwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCBhIGpRdWVyeSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGlzIGJveFxuICAgICAqIEByZXR1cm4ge2pRdWVyeS5lbGVtZW50fVxuICAgICAqL1xuICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ZnT2JqLmdldCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJvdGF0ZSB0aGUgc2V0IG9mIGJsb2NrZWQgbm9kZXMgYnkgOTAgZGVncmVlcyB0byB0aGUgcmlnaHQgb3IgdG8gdGhlIGxlZnQsIGRlcGVuZGluZyBvbiB0aGUgcGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiB1c2VkIHRvIHJvdGF0ZSB0aGUgbm9kZXMgd2hlbiB0aGUgb2JqZWN0IGl0c2VsZiBpcyByb3RhdGVkXG4gICAgICogQHBhcmFtICB7Ym9vbGVhbn0gcmlnaHQgcm90YXRlIGNsb2Nrd2lzZSBpZiB0cnVlLCBjb3VudGVyY2xvY2t3aXNlIGlmIGZhbHNlXG4gICAgICovXG4gICAgcm90YXRlQmxvY2tlZE5vZGVzKGNlbnRlciwgcmlnaHQpIHtcbiAgICAgICAgaWYgKHRoaXMucm90YXRpb25QYXJpdHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGlvblBhcml0eSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yb3RhdGlvblBhcml0eSA9ICF0aGlzLnJvdGF0aW9uUGFyaXR5O1xuXG4gICAgICAgIGxldCBuZXdCbG9ja2VkTm9kZXMgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgLy8gcm90YXRlIHRoZSBub2RlXG4gICAgICAgIGNvbnNvbGUubG9nKCdjZW50ZXI6JywgY2VudGVyKTtcblxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5ibG9ja2VkTm9kZXMpIHtcbiAgICAgICAgICAgIGxldCBuZXdOb2RlO1xuXG4gICAgICAgICAgICBjb25zdCBwYXJpdHlGYWN0b3IgPSB0aGlzLnJvdGF0aW9uUGFyaXR5ID8gMSA6IC0xO1xuXG4gICAgICAgICAgICBpZiAocmlnaHQpIHtcbiAgICAgICAgICAgICAgICBuZXdOb2RlID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiAtbm9kZS55ICsgdGhpcy5ncmlkSGVpZ2h0ICsgKGNlbnRlci54IC0gY2VudGVyLnkpICogcGFyaXR5RmFjdG9yLFxuICAgICAgICAgICAgICAgICAgICB5OiBub2RlLnggKyAoY2VudGVyLnkgLSBjZW50ZXIueCkgKiBwYXJpdHlGYWN0b3JcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdOb2RlID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBub2RlLnkgKyAoY2VudGVyLnggLSBjZW50ZXIueSkgKiBwYXJpdHlGYWN0b3JcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucm90YXRpb25QYXJpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS55ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIC1ub2RlLnggK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmlkV2lkdGggK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuZ3JpZEhlaWdodCAtIGNlbnRlci55IC0gKHRoaXMuZ3JpZFdpZHRoIC0gY2VudGVyLngpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLnkgPSAtbm9kZS54ICsgdGhpcy5ncmlkSGVpZ2h0ICsgKGNlbnRlci55IC0gY2VudGVyLngpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmV3QmxvY2tlZE5vZGVzLmFkZChuZXdOb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYmxvY2tlZE5vZGVzID0gbmV3QmxvY2tlZE5vZGVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJvdGF0ZSB0aGUgc2V0IG9mIGJsb2NrZWQgbm9kZXMgdG8gdGhlIHJpZ2h0XG4gICAgICpcbiAgICAgKiB1c2VkIHRvIHJvdGF0ZSB0aGUgbm9kZXMgd2hlbiB0aGUgb2JqZWN0IGl0c2VsZiBpcyByb3RhdGVkXG4gICAgICovXG4gICAgcm90YXRlQmxvY2tlZE5vZGVzUmlnaHQoY2VudGVyKSB7XG4gICAgICAgIHRoaXMucm90YXRlQmxvY2tlZE5vZGVzKGNlbnRlciwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcm90YXRlIHRoZSBzZXQgb2YgYmxvY2tlZCBub2RlcyB0byB0aGUgcmlnaHRcbiAgICAgKlxuICAgICAqIHVzZWQgdG8gcm90YXRlIHRoZSBub2RlcyB3aGVuIHRoZSBvYmplY3QgaXRzZWxmIGlzIHJvdGF0ZWRcbiAgICAgKi9cbiAgICByb3RhdGVCbG9ja2VkTm9kZXNMZWZ0KGNlbnRlcikge1xuICAgICAgICB0aGlzLnJvdGF0ZUJsb2NrZWROb2RlcyhjZW50ZXIsIGZhbHNlKTtcbiAgICB9XG5cbiAgICByb3RhdGUoY2xvY2tXaXNlKSB7XG4gICAgICAgIC8vIGdldCB0aGUgdHJhbnNmb3JtIHZhbHVlIGZvciB0aGlzIGJveCBhbmQgY29udmVydCBpdCB0byBncmlkIHBpeGVsc1xuICAgICAgICAvLyAoc28gd2UgZG9uJ3QgaGF2ZSB0byBjb252ZXJ0IGJldHdlZW4gU1ZHIGFuZCBncmlkIHBpeGVscyBtYW51YWxseSlcbiAgICAgICAgbGV0IHRyYW5zZm9ybSA9IHRoaXMuZ2V0VHJhbnNmb3JtKCk7XG4gICAgICAgIHRyYW5zZm9ybS50b0dyaWRQaXhlbHModGhpcy5hcHBJbnN0YW5jZSk7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBjZW50ZXIgb2YgdGhlIGJveFxuICAgICAgICBjb25zdCByZWFsQ2VudGVyID0ge1xuICAgICAgICAgICAgeDogTWF0aC5yb3VuZCh0aGlzLmdyaWRXaWR0aCAvIDIpLFxuICAgICAgICAgICAgeTogTWF0aC5yb3VuZCh0aGlzLmdyaWRIZWlnaHQgLyAyKVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHN3YXAgdGhlIGNvb3JkaW5hdGVzIHdoZW4gdGhlIHJvdGF0aW9uIHBhcml0eSBpcyAxXG4gICAgICAgIGNvbnN0IGNlbnRlciA9IHRoaXMucm90YXRpb25QYXJpdHlcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgeDogcmVhbENlbnRlci55LFxuICAgICAgICAgICAgICAgICAgeTogcmVhbENlbnRlci54XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogcmVhbENlbnRlcjtcblxuICAgICAgICAvLyBhcHBseSB0aGUgcm90YXRpb24gdG8gdGhlIHRyYW5zZm9ybSBvYmplY3RcbiAgICAgICAgaWYgKGNsb2NrV2lzZSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtLnJvdGF0ZVJpZ2h0KGNlbnRlci54LCBjZW50ZXIueSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm0ucm90YXRlTGVmdChjZW50ZXIueCwgY2VudGVyLnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcm90YXRlIHRoZSBibG9ja2VkIG5vZGVzIGFzIHdlbGxcbiAgICAgICAgaWYgKGNsb2NrV2lzZSkge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGVCbG9ja2VkTm9kZXNSaWdodChjZW50ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGVCbG9ja2VkTm9kZXNMZWZ0KGNlbnRlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb252ZXJ0IHRoZSBtb2RpZmllZCB0cmFuc2Zvcm0gYmFjayB0byBTVkcgcGl4ZWxzXG4gICAgICAgIC8vIGFuZCBhcHBseSBpdCB0byB0aGUgc3ZnT2JqXG4gICAgICAgIHRyYW5zZm9ybS50b1NWR1BpeGVscyh0aGlzLmFwcEluc3RhbmNlKTtcbiAgICAgICAgdGhpcy5zdmdPYmouYWRkQXR0cih7IHRyYW5zZm9ybTogdHJhbnNmb3JtLmdldCgpIH0pO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgd2lyZXNcbiAgICAgICAgdGhpcy51cGRhdGVXaXJlcygpO1xuXG4gICAgICAgIC8vIGlmIHR1dG9yaWFsIGV4aXN0cywgY2FsbCB0aGUgdHV0b3JpYWwgY2FsbGJhY2tcbiAgICAgICAgaWYgKHRoaXMuYXBwSW5zdGFuY2UudHV0b3JpYWwpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwSW5zdGFuY2UudHV0b3JpYWwub25Cb3hSb3RhdGVkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhZGQgYSBjb25uZWN0b3IgdG8gdGhlIGVsZW1lbnQgb24gdGhlIHNwZWNpZmllZCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSAgbGVmdCAgICAgICAgICAgICBob3Jpem9udGFsIGRpc3RhbmNlIGZyb20gdGhlIGxlZnQgZWRnZSBvZiB0aGUgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSAgdG9wICAgICAgICAgICAgICB2ZXJ0aWNhbCBkaXN0YW5jZSBmcm9tIHRoZSB0b3AgZWRnZSBvZiB0aGUgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNJbnB1dENvbm5lY3RvciB3aGV0aGVyIG9yIG5vdCBzaG91bGQgdGhpcyBjb25uZWN0b3IgYW4gaW5wdXQgY29ubmVjdG9yIChgdHJ1ZWAgZm9yIGlucHV0IGNvbm5lY3RvciwgYGZhbHNlYCBmb3Igb3V0cHV0IGNvbm5lY3RvcilcbiAgICAgKi9cbiAgICBhZGRDb25uZWN0b3IobGVmdCwgdG9wLCBpc0lucHV0Q29ubmVjdG9yKSB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuY29ubmVjdG9ycy5sZW5ndGg7XG4gICAgICAgIGlmIChpc0lucHV0Q29ubmVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvcnNbaW5kZXhdID0gbmV3IElucHV0Q29ubmVjdG9yKHRoaXMuYXBwSW5zdGFuY2UsIGxlZnQsIHRvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvcnNbaW5kZXhdID0gbmV3IE91dHB1dENvbm5lY3Rvcih0aGlzLmFwcEluc3RhbmNlLCBsZWZ0LCB0b3ApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3ZnT2JqLmFkZENoaWxkKHRoaXMuY29ubmVjdG9yc1tpbmRleF0uZ2V0KCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFkZCBhbiBpbnB1dCBjb25uZWN0b3IgdG8gdGhlIGVsZW1lbnQgb24gdGhlIHNwZWNpZmllZCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IGhvcml6b250YWwgZGlzdGFuY2UgZnJvbSB0aGUgbGVmdCBlZGdlIG9mIHRoZSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvcCAgdmVydGljYWwgZGlzdGFuY2UgZnJvbSB0aGUgdG9wIGVkZ2Ugb2YgdGhlIGVsZW1lbnRcbiAgICAgKi9cbiAgICBhZGRJbnB1dENvbm5lY3RvcihsZWZ0LCB0b3ApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkQ29ubmVjdG9yKGxlZnQsIHRvcCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWRkIGFuIG91dHB1dCBjb25uZWN0b3IgdG8gdGhlIGVsZW1lbnQgb24gdGhlIHNwZWNpZmllZCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IGhvcml6b250YWwgZGlzdGFuY2UgZnJvbSB0aGUgbGVmdCBlZGdlIG9mIHRoZSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvcCAgdmVydGljYWwgZGlzdGFuY2UgZnJvbSB0aGUgdG9wIGVkZ2Ugb2YgdGhlIGVsZW1lbnRcbiAgICAgKi9cbiAgICBhZGRPdXRwdXRDb25uZWN0b3IobGVmdCwgdG9wKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZENvbm5lY3RvcihsZWZ0LCB0b3AsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIGNvbm5lY3RvciBvYmplY3QgYmFzZWQgb24gaXRzIGlkXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBjb25uZWN0b3JJZCBJRCBvZiB0aGUge0BsaW5rIENvbm5lY3Rvcn1cbiAgICAgKiBAcmV0dXJuIHtDb25uZWN0b3J9ICAgICAgICAgICAgIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgQ29ubmVjdG9yfSBvciBgdW5kZWZpbmVkYCBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgICBnZXRDb25uZWN0b3JCeUlkKGNvbm5lY3RvcklkKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb25uZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0b3JzW2ldLmlkID09PSBjb25uZWN0b3JJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RvcnNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgY29ubmVjdG9yIG5vdCBmb3VuZCwgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgaW5zdGFuY2Ugb2Yge0BsaW5rIFRyYW5zZm9ybX0gcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZiB0aGUgdHJhbnNmb3JtIGF0dHJpYnV0ZSBvZiB0aGlzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBbZ3JpZFBpeGVscz1mYWxzZV0gaWYgYHRydWVgLCBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgcmVzdWx0IGluIGdyaWQgcGl4ZWxzIGluc3RlYWQgb2YgU1ZHIHBpeGVsc1xuICAgICAqIEByZXR1cm4ge1RyYW5zZm9ybX0gICAgICAgICAgICAgICAgICB7QGxpbmsgVHJhbnNmb3JtfSBvZiB0aGUgZWxlbWVudFxuICAgICAqL1xuICAgIGdldFRyYW5zZm9ybShncmlkUGl4ZWxzID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybTtcbiAgICAgICAgaWYgKCF0aGlzLnN2Z09iai4kZWwuYXR0cigndHJhbnNmb3JtJykpIHtcbiAgICAgICAgICAgIC8vIHRoZSBlbGVtZW50IGRvZXMgbm90IGhhdmUgYSBcInRyYW5zZm9ybVwiIHByb3BlcnR5IC0tPiBjcmVhdGUgaXRcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybS5zZXRUcmFuc2xhdGUoMCwgMCk7XG4gICAgICAgICAgICB0aGlzLnN2Z09iai5hZGRBdHRyKHsgdHJhbnNmb3JtOiB0cmFuc2Zvcm0uZ2V0KCkgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGUgZWxlbWVudCBkb2VzIGhhdmUgYSBcInRyYW5zZm9ybVwiIHByb3BlcnR5IC0tPiBjaGFuZ2UgaXRcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0odGhpcy5zdmdPYmouJGVsLmF0dHIoJ3RyYW5zZm9ybScpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnZlcnQgdmFsdWVzIHRvIGdyaWQgcGl4ZWxzXG4gICAgICAgIGlmIChncmlkUGl4ZWxzKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm0udG9HcmlkUGl4ZWxzKHRoaXMuYXBwSW5zdGFuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIGluc3RhbmNlIG9mIHtAbGluayBUcmFuc2Zvcm19IHJlcHJlc2VudGluZyB0aGUgc3RhdGUgb2YgdGhlIHRyYW5zZm9ybSBhdHRyaWJ1dGUgb2YgdGhpcyBlbGVtZW50IF93aXRoIGxlbmdodCB1bml0cyBpbiBncmlkIHBpeGVsc19cbiAgICAgKiBAcmV0dXJuIHtUcmFuc2Zvcm19IHtAbGluayBUcmFuc2Zvcm19IG9mIHRoZSBlbGVtZW50XG4gICAgICovXG4gICAgZ2V0R3JpZFBpeGVsVHJhbnNmb3JtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUcmFuc2Zvcm0odHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0IHRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlIG9mIHRoaXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm0ge0BsaW5rIFRyYW5zZm9ybX0gb2YgdGhlIGVsZW1lbnQgKHdpdGggbGVuZ3RocyBzcGVjaWZpZWQgaW4gU1ZHIHBpeGVscylcbiAgICAgKi9cbiAgICBzZXRUcmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gICAgICAgIHRoaXMuc3ZnT2JqLmFkZEF0dHIoeyB0cmFuc2Zvcm06IHRyYW5zZm9ybS5nZXQoKSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBvbiBldmVyeSBtb3VzZSBkb3duIG9uIHRoaXMgZWxlbWVudFxuICAgICAqXG4gICAgICogbW92ZXMgdGhlIGVsZW1lbnQgdG8gdGhlIGZyb250IGFuZCBjYWxscyBvbk1vdXNlRG93bkxlZnQgaWYgYXBwbGljYWJsZVxuICAgICAqIEBwYXJhbSAge2pRdWVyeS5Nb3VzZUV2ZW50fSBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubW91c2VMZWZ0ID0gZmFsc2U7XG4gICAgICAgIGlmIChldmVudC53aGljaCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5tb3VzZUxlZnQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5vbk1vdXNlRG93bkxlZnQoZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBtb3ZlIHRoZSBET00gZWxlbWVudCB0byBmcm9udFxuICAgICAgICAgICAgdGhpcy5hcHBJbnN0YW5jZS5tb3ZlVG9Gcm9udEJ5SWQodGhpcy5zdmdPYmouaWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgb24gZXZlcnkgbGVmdCBtb3VzZSBkb3duIG9uIHRoaXMgZWxlbWVudFxuICAgICAqXG4gICAgICogcHJlcGFyZXMgZWxlbWVudCBmb3IgdGhlIFwiY2xpY2tcIiBhbmQgXCJkcmFnIGFuZCBkcm9wXCIgYWN0aW9uc1xuICAgICAqIEBwYXJhbSAge2pRdWVyeS5Nb3VzZUV2ZW50fSBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VEb3duTGVmdChldmVudCkge1xuICAgICAgICB0aGlzLm1vdXNlTW92ZWQgPSBmYWxzZTtcblxuICAgICAgICBsZXQgdHJhbnNmb3JtID0gdGhpcy5nZXRUcmFuc2Zvcm0oKTtcblxuICAgICAgICAvLyBzYXZlIHRoZSBjdXJyZW50IGl0ZW0gcG9zaXRpb24gaW50byBhIHZhcmlhYmxlXG4gICAgICAgIGxldCBjdXJyZW50UG9zaXRpb24gPSB0cmFuc2Zvcm0uZ2V0VHJhbnNsYXRlKCk7XG5cbiAgICAgICAgbGV0IHsgcGFnZVgsIHBhZ2VZIH0gPSB0aGlzLmFwcEluc3RhbmNlLnZpZXdib3gudHJhbnNmb3JtRXZlbnQoZXZlbnQpO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBtb3VzZSBvZmZzZXQgZnJvbSB0aGUgb2JqZWN0IG9yaWdpblxuICAgICAgICB0aGlzLm9mZnNldCA9IHtcbiAgICAgICAgICAgIHg6IHBhZ2VYIC0gY3VycmVudFBvc2l0aW9uLngsXG4gICAgICAgICAgICB5OiBwYWdlWSAtIGN1cnJlbnRQb3NpdGlvbi55XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgb24gZXZlcnkgbGVmdCBtb3VzZSBtb3ZlIHdpdGggdGhpcyBlbGVtZW50XG4gICAgICogYXBwbGllcyB0aGUgY29ycmVjdCB0cmFuc2Zvcm0gdmFsdWVzIHRvIHByb3ZpZGUgdGhlIFwiZHJhZyBhbmQgZHJvcFwiIGZ1bmN0aW9uYWxpdHlcbiAgICAgKiBAcGFyYW0gIHtqUXVlcnkuTW91c2VFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgICBpZiAodGhpcy5tb3VzZUxlZnQpIHtcbiAgICAgICAgICAgIHRoaXMuc3ZnT2JqLiRlbC5hZGRDbGFzcygnZ3JhYmJlZCcpO1xuXG4gICAgICAgICAgICB0aGlzLm1vdXNlTW92ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICBsZXQgeyBwYWdlWCwgcGFnZVkgfSA9IHRoaXMuYXBwSW5zdGFuY2Uudmlld2JveC50cmFuc2Zvcm1FdmVudChldmVudCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBwYWdlWCAtIHRoaXMub2Zmc2V0Lng7XG4gICAgICAgICAgICBjb25zdCB0b3AgPSBwYWdlWSAtIHRoaXMub2Zmc2V0Lnk7XG5cbiAgICAgICAgICAgIGxldCB0cmFuc2Zvcm0gPSB0aGlzLmdldFRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgdHJhbnNmb3JtLnNldFRyYW5zbGF0ZShsZWZ0LCB0b3ApO1xuXG4gICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVdpcmVzKHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgb24gZXZlcnkgbW91c2UgdXAgb24gdGhpcyBlbGVtZW50XG4gICAgICogcHJvdmlkZXMgdGhlIFwiY2xpY2tcIiBmdW5jdGlvbmFsaXR5IGFuZCBjYWxscyB0aGUgb25Ecm9wIGhhbmRsZXIgZm9yIHRoZSBcImRyYWcgYW5kIGRyb3BcIiBmdW5jdGlvbmFsaXR5XG4gICAgICogQHBhcmFtICB7alF1ZXJ5Lk1vdXNlRXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZVVwKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC53aGljaCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubW91c2VNb3ZlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25Ecm9wKGV2ZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsaWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQud2hpY2ggPT09IDIpIHtcbiAgICAgICAgICAgIHRoaXMub25DbGlja01pZGRsZShldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN2Z09iai4kZWwucmVtb3ZlQ2xhc3MoJ2dyYWJiZWQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjYWxsZWQgYnkgb25Nb3VzZVVwIHdoZW4gdGhlIG1vdXNlIGhhcyBiZWVuIG1vdmVkIGJldHdlZW4gb25Nb3VzZURvd24gYW5kIG9uTW91c2VVcFxuICAgICAqXG4gICAgICogYXBwbGllcyBncmlkIHNuYXBwaW5nIG9mIHRoZSBlbGVtZW50IG9uIHRoZSBlbmQgb2YgdGhlIFwiZHJhZyBhbmQgZHJvcFwiIGFjdGlvblxuICAgICAqIEBwYXJhbSAge2pRdWVyeS5Nb3VzZUV2ZW50fSBldmVudFxuICAgICAqL1xuICAgIG9uRHJvcChldmVudCkge1xuICAgICAgICBsZXQgeyBwYWdlWCwgcGFnZVkgfSA9IHRoaXMuYXBwSW5zdGFuY2Uudmlld2JveC50cmFuc2Zvcm1FdmVudChldmVudCk7XG5cbiAgICAgICAgbGV0IGxlZnQgPSBwYWdlWCAtIHRoaXMub2Zmc2V0Lng7XG4gICAgICAgIGxldCB0b3AgPSBwYWdlWSAtIHRoaXMub2Zmc2V0Lnk7XG5cbiAgICAgICAgbGVmdCA9IHRoaXMuYXBwSW5zdGFuY2Uuc25hcFRvR3JpZChsZWZ0KTtcbiAgICAgICAgdG9wID0gdGhpcy5hcHBJbnN0YW5jZS5zbmFwVG9HcmlkKHRvcCk7XG5cbiAgICAgICAgbGV0IHRyYW5zZm9ybSA9IHRoaXMuZ2V0VHJhbnNmb3JtKCk7XG4gICAgICAgIHRyYW5zZm9ybS5zZXRUcmFuc2xhdGUobGVmdCwgdG9wKTtcblxuICAgICAgICB0aGlzLnNldFRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuXG4gICAgICAgIHRoaXMudXBkYXRlV2lyZXMoKTtcblxuICAgICAgICAvLyBpZiB0dXRvcmlhbCBleGlzdHMsIGNhbGwgdHV0b3JpYWwgY2FsbGJhY2tcbiAgICAgICAgaWYgKHRoaXMuYXBwSW5zdGFuY2UudHV0b3JpYWwpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwSW5zdGFuY2UudHV0b3JpYWwub25Cb3hNb3ZlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZW1wdHkgZnVuY3Rpb24sIHdpbGwgYmUgcmVkZWZpbmVkIGluIElucHV0Qm94XG4gICAgICovXG4gICAgb25DbGljaygpIHt9XG5cbiAgICAvKipcbiAgICAgKiBjdXN0b20gY2FsbGJhY2sgZnVuY3Rpb24gZm9yIG1pZGRsZSBjbGljayB0aGF0IHJvdGF0ZXMgdGhlIGJveCBieSA5MCBkZWdyZWVzIHRvIHRoZSByaWdodFxuICAgICAqL1xuICAgIG9uQ2xpY2tNaWRkbGUoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmN0cmxLZXkpIHtcbiAgICAgICAgICAgIHRoaXMucm90YXRlKGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucm90YXRlKHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhbGwgd2lyZXMgY29ubmVjdGVkIHRvIHRoaXMgYm94LiBJdGVyYXRlcyBvdmVyIGFsbCB3aXJlcyB0aGF0IGFyZSBjb25uZWN0ZWQgdG8gdGhpcyBib3hcbiAgICAgKiBhbmQgY2FsbHMgcm91dGVXaXJlIChvciB0ZW1wb3JhcnlXaXJlIGlmIHRoZSBgdGVtcG9yYXJ5YCBwYXJhbWV0ZXIgaXMgc2V0IHRvIHRydWUpIHRvIHVwZGF0ZSB0aGUgd2lyZSByb3V0aW5nXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gW3RlbXBvcmFyeT1mYWxzZV0gW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgIHVwZGF0ZVdpcmVzKHRlbXBvcmFyeSA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdG9ycy5mb3JFYWNoKGNvbm4gPT4ge1xuICAgICAgICAgICAgY29ubi53aXJlSWRzLmZvckVhY2god2lyZUlkID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgd2lyZSA9IHRoaXMuYXBwSW5zdGFuY2UuZ2V0V2lyZUJ5SWQod2lyZUlkKTtcbiAgICAgICAgICAgICAgICBpZiAodGVtcG9yYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHdpcmUudGVtcG9yYXJ5V2lyZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdpcmUucm91dGVXaXJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsImltcG9ydCBOZXR3b3JrRWxlbWVudCBmcm9tICcuL05ldHdvcmtFbGVtZW50JztcbmltcG9ydCB7IFJlY3RhbmdsZSB9IGZyb20gJy4uL3N2Z09iamVjdHMnO1xuaW1wb3J0IExvZ2ljIGZyb20gJy4uL0xvZ2ljJztcblxuaW1wb3J0IHN0YXRlQ2xhc3NlcyBmcm9tICcuL3N0YXRlQ2xhc3Nlcyc7XG5cbi8qKiBAbW9kdWxlIGVkaXRvckVsZW1lbnRzLkNvbm5lY3RvciAqL1xuXG4vKipcbiAqIHBhcmVudCBjbGFzcyBmb3IgaW5wdXQgYW5kIG91dHB1dCBjb25uZWN0b3JzXG4gKiBAZXh0ZW5kcyBOZXR3b3JrRWxlbWVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb25uZWN0b3IgZXh0ZW5kcyBOZXR3b3JrRWxlbWVudCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcHB9IGFwcEluc3RhbmNlIGxpbmsgdG8gdGhlIFtBcHBdKC4vbW9kdWxlLUFwcC5odG1sKSBpbnN0YW5jZSB0aGF0IHRoaXMgY29ubmVjdG9yIHdpbGwgYmVsb25nIHRvXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdyaWRTaXplICBzaXplIG9mIHRoZSBncmlkIGluIFNWRyBwaXhlbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVmdCAgICAgIGhvcml6b250YWwgcG9zaXRpb24gZGVmaW5lZCBpbiBncmlkIHVuaXRzIChTVkcgcGl4ZWxzIGRpdmlkZWQgYnkgdGhlIGdyaWQgc2l6ZSlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9wICAgICAgIHZlcnRpY2FsIHBvc2l0aW9uIGRlZmluZWQgaW4gZ3JpZCB1bml0cyAoU1ZHIHBpeGVscyBkaXZpZGVkIGJ5IHRoZSBncmlkIHNpemUpXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYXBwSW5zdGFuY2UsIGxlZnQsIHRvcCkge1xuICAgICAgICBzdXBlcihhcHBJbnN0YW5jZSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNpemUgb2YgdGhlIGdyaWQgaW4gU1ZHIHBpeGVsc1xuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ncmlkU2l6ZSA9IGFwcEluc3RhbmNlLmdyaWRTaXplO1xuICAgICAgICAvKipcbiAgICAgICAgICogc2l6ZSBvZiB0aGUgY29ubmVjdG9yIGluIFNWRyBwaXhlbHNcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29ubmVjdG9yU2l6ZSA9IGFwcEluc3RhbmNlLmdyaWRTaXplO1xuICAgICAgICAvKipcbiAgICAgICAgICogb2Zmc2V0IG9mIHRoZSBjb25uZWN0b3IgZnJvbSB0aGUgZ3JpZCBpbiBTVkcgcGl4ZWxzXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbm5lY3Rvck9mZnNldCA9IHRoaXMuY29ubmVjdG9yU2l6ZSAvIDI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGluc3RhbmNlIG9mIHtAbGluayBzdmdPYmplY3RzLnN2Z09ian0gdGhhdCBob2xkcyBhbGwgU1ZHIGluZm9ybWF0aW9uIGFib3V0IHRoaXMgY29ubmVjdG9yXG4gICAgICAgICAqIEB0eXBlIHtzdmdPYmp9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN2Z09iaiA9IG5ldyBSZWN0YW5nbGUoXG4gICAgICAgICAgICBsZWZ0ICogdGhpcy5ncmlkU2l6ZSAtIHRoaXMuY29ubmVjdG9yT2Zmc2V0LFxuICAgICAgICAgICAgdG9wICogdGhpcy5ncmlkU2l6ZSAtIHRoaXMuY29ubmVjdG9yT2Zmc2V0LFxuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3JTaXplLFxuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3JTaXplLFxuICAgICAgICAgICAgJ25vbmUnLFxuICAgICAgICAgICAgJ2JsYWNrJ1xuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuc3ZnT2JqLiRlbC5hZGRDbGFzcygnY29ubmVjdG9yJyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRoaXMgZmxhZyBkZXNjcmliZXMgd2hldGhlciB0aGlzIGNvbm5lY3RvciBpcyBhbiBpbnB1dCBjb25uZWN0b3JcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzSW5wdXRDb25uZWN0b3IgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogY3VycmVudCBsb2dpY2FsIHN0YXRlIG9mIHRoaXMgY29ubmVjdG9yXG4gICAgICAgICAqIEB0eXBlIHtMb2dpYy5zdGF0ZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZWxlbWVudFN0YXRlID0gTG9naWMuc3RhdGUudW5rbm93bjtcbiAgICAgICAgdGhpcy5zdmdPYmouYWRkQ2xhc3Moc3RhdGVDbGFzc2VzW0xvZ2ljLnN0YXRlLnVua25vd25dKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IG9mIGlkcyBvZiBhbGwgd2lyZXMgY29ubmVjdGVkIHRvIHRoaXMgY29ubmVjdG9yXG4gICAgICAgICAqIEB0eXBlIHtTZXR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndpcmVJZHMgPSBuZXcgU2V0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogd2hldGhlciB0aGlzIGNvbm5lY3RvciBpcyBhbiBvdXRwdXQgY29ubmVjdG9yXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgaXNPdXRwdXRDb25uZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc0lucHV0Q29ubmVjdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHdoZXRoZXIgdGhpcyBjb25uZWN0b3IgaXMgYW4gb3V0cHV0IGNvbm5lY3RvclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2V0IGlzT3V0cHV0Q29ubmVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaXNJbnB1dENvbm5lY3RvciA9ICF2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhZGQgYSB3aXJlIGlkIHRvIHRoZSBsaXN0IG9mIHdpcmUgaWRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdpcmVJZFxuICAgICAqL1xuICAgIGFkZFdpcmVJZCh3aXJlSWQpIHtcbiAgICAgICAgdGhpcy53aXJlSWRzLmFkZCh3aXJlSWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBhIHdpcmUgaWQgZnJvbSB0aGUgbGlzdCBvZiB3aXJlIGlkc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3aXJlSWRcbiAgICAgKi9cbiAgICByZW1vdmVXaXJlSWQod2lyZUlkKSB7XG4gICAgICAgIHRoaXMud2lyZUlkcy5kZWxldGUod2lyZUlkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgYSB3aXJlIHNwZWNpZmllZCBieSBJRCBhbmQgdXBkYXRlIHRoZSBjb25uZWN0b3JcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHdpcmVJZCBJRCBvZiB0aGUgd2lyZSB0byBiZSByZW1vdmVkXG4gICAgICovXG4gICAgcmVtb3ZlV2lyZUlkQW5kVXBkYXRlKHdpcmVJZCkge1xuICAgICAgICB0aGlzLnJlbW92ZVdpcmVJZCh3aXJlSWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldCBsb2dpY2FsIHN0YXRlIG9mIHRoZSBjb25uZWN0b3JcbiAgICAgKiBAcGFyYW0ge0xvZ2ljLnN0YXRlfSBzdGF0ZSBuZXcgc3RhdGUgb2YgdGhlIGNvbm5lY3RvclxuICAgICAqL1xuICAgIHNldFN0YXRlKHN0YXRlKSB7XG4gICAgICAgIHRoaXMuc3ZnT2JqLnJlbW92ZUNsYXNzZXMoLi4uc3RhdGVDbGFzc2VzKTtcbiAgICAgICAgdGhpcy5zdmdPYmouYWRkQ2xhc3Moc3RhdGVDbGFzc2VzW3N0YXRlXSk7XG5cbiAgICAgICAgdGhpcy5lbGVtZW50U3RhdGUgPSBzdGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgc3RhdGUgb2YgdGhpcyBjb25uZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtMb2dpYy5zdGF0ZX1cbiAgICAgKi9cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRTdGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgc3ZnT2JqIGluc3RhbmNlIGNvbnRlbnQgb2YgdGhpcyBjb25uZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtzdmdPYmplY3RzLlJlY3RhbmdsZX1cbiAgICAgKi9cbiAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN2Z09iajtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjYWxsIFt3aXJlQ3JlYXRpb25IZWxwZXJdKC4vbW9kdWxlLUFwcC5odG1sI3dpcmVDcmVhdGlvbkhlbHBlcikgb24gbW91c2UgdXBcbiAgICAgKi9cbiAgICBvbk1vdXNlVXAoZXZlbnQpIHtcbiAgICAgICAgLy8gb25seSBsZWZ0IGNsaWNrIGNvdW50c1xuICAgICAgICBpZiAoZXZlbnQud2hpY2ggPT09IDEpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gdGhpcy5hcHBJbnN0YW5jZS52aWV3Ym94LnRyYW5zZm9ybUV2ZW50KGV2ZW50KTtcblxuICAgICAgICAgICAgY29uc3QgbW91c2VQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB4OiBldmVudC5wYWdlWCxcbiAgICAgICAgICAgICAgICB5OiBldmVudC5wYWdlWVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5hcHBJbnN0YW5jZS53aXJlQ3JlYXRpb25IZWxwZXIodGhpcy5zdmdPYmouaWQsIG1vdXNlUG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IExvZ2ljIGZyb20gJy4uL0xvZ2ljJztcblxuaW1wb3J0IEJveCBmcm9tICcuL0JveCc7XG5cbi8qKiBAbW9kdWxlIGVkaXRvckVsZW1lbnRzLkdhdGUgKi9cblxuLyoqXG4gKiBHYXRlIGlzIGEgYm94IHRoYXQgcHJvY2Vzc2VzIHRoZSBzdGF0ZXMgb2YgaXRzIGlucHV0IGNvbm5lY3RvcnMgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBpbiBpdHMgb3V0cHV0IGNvbm5lY3RvcnMuXG4gKiBAZXh0ZW5kcyBCb3hcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2F0ZSBleHRlbmRzIEJveCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcHB9IGFwcEluc3RhbmNlICBpbnN0YW5jZSBvZiBbQXBwXSguL21vZHVsZS1BcHAuaHRtbClcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAgICAgICBuYW1lIG9mIHRoZSBnYXRlIChhbmQsIG5vdCwgeG9yLi4uKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFwcEluc3RhbmNlLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gOTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gNDtcblxuICAgICAgICBzdXBlcihhcHBJbnN0YW5jZSwgbmFtZSwgJ2dhdGUnLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICAvLyBBREQgQ09OTkVDVE9SU1xuXG4gICAgICAgIGxldCBzcGVjaWFsTm9kZXMgPSBbXTtcblxuICAgICAgICAvLyBvdXRwdXRcbiAgICAgICAgdGhpcy5hZGRDb25uZWN0b3Iod2lkdGgsIGhlaWdodCAvIDIsIGZhbHNlKTtcblxuICAgICAgICAvLyBibG9jayB0aGUgb3V0cHV0IGNvbm5lY3RvclxuICAgICAgICBzcGVjaWFsTm9kZXMucHVzaCh7XG4gICAgICAgICAgICB4OiB3aWR0aCxcbiAgICAgICAgICAgIHk6IGhlaWdodCAvIDJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMubmFtZSA9PT0gJ25vdCcgfHwgdGhpcy5uYW1lID09PSAncmVwZWF0ZXInKSB7XG4gICAgICAgICAgICAvLyBpbnB1dFxuICAgICAgICAgICAgdGhpcy5hZGRDb25uZWN0b3IoMCwgaGVpZ2h0IC8gMiwgdHJ1ZSk7XG4gICAgICAgICAgICAvLyBibG9jayB0aGUgaW5wdXQgY29ubmVjdG9yXG4gICAgICAgICAgICBzcGVjaWFsTm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiBoZWlnaHQgLyAyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlucHV0XG4gICAgICAgICAgICB0aGlzLmFkZENvbm5lY3RvcigwLCBoZWlnaHQgLyA0LCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuYWRkQ29ubmVjdG9yKDAsIGhlaWdodCAvICg0IC8gMyksIHRydWUpO1xuXG4gICAgICAgICAgICAvLyBibG9jayB0aGUgaW5wdXQgY29ubmVjdG9yc1xuICAgICAgICAgICAgc3BlY2lhbE5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogaGVpZ2h0IC8gNFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzcGVjaWFsTm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiBoZWlnaHQgLyAoNCAvIDMpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gYWRkIG9uZSBibG9ja2VkIG5vZGUgYmV0d2VlbiB0aGUgaW5wdXRzIChmb3IgYmV0dGVyIGxvb2tpbmcgd2lyaW5nKVxuICAgICAgICAgICAgc3BlY2lhbE5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogaGVpZ2h0IC8gMlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdlbmVyYXRlQmxvY2tOb2RlcyguLi5zcGVjaWFsTm9kZXMpO1xuXG4gICAgICAgIHRoaXMucmVmcmVzaFN0YXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYXJyYXkgb2YgdmFsaWQgZ2F0ZSBuYW1lc1xuICAgICAqIEB0eXBlIHtTZXR9XG4gICAgICovXG4gICAgc3RhdGljIGdldCB2YWxpZEdhdGVzKCkge1xuICAgICAgICAvLyByZXR1cm4gbmV3IFNldChbXCJub3RcIiwgXCJhbmRcIiwgXCJvclwiLCBcIm5hbmRcIiwgXCJub3JcIiwgXCJ4b3JcIiwgXCJ4bm9yXCIsIFwicmVwZWF0ZXJcIl0pO1xuICAgICAgICByZXR1cm4gbmV3IFNldChbJ25vdCcsICdhbmQnLCAnb3InLCAnbmFuZCcsICdub3InLCAneG9yJywgJ3hub3InXSk7XG4gICAgfVxuXG4gICAgZ2VuZXJhdGVCbG9ja05vZGVzKC4uLnNwZWNpYWxOb2Rlcykge1xuICAgICAgICBpZiAoc3BlY2lhbE5vZGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN1cGVyLmdlbmVyYXRlQmxvY2tOb2RlcygwLCAxLCAwLCAxLCAuLi5zcGVjaWFsTm9kZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIuZ2VuZXJhdGVCbG9ja05vZGVzKDAsIDEsIDAsIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHJvY2Nlc3MgdGhlIGlucHV0IGNvbm5lY3RvciBzdGF0ZXMgYW5kIHJlZmxlY3QgdGhlbSBpbiB0aGUgb3V0cHV0IGNvbm5lY3RvciBzdGF0ZXMgYWNjb3JkaW5nXG4gICAgICogdG8gdGhlIGxvZ2ljIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBnYXRlJ3MgbmFtZVxuICAgICAqL1xuICAgIHJlZnJlc2hTdGF0ZSgpIHtcbiAgICAgICAgLy8gbWFwIGdhdGUgbmFtZXMgdG8gdGhlaXIgbG9naWMgZnVuY3Rpb25zXG4gICAgICAgIGNvbnN0IHN0YXRlTWFwID0ge1xuICAgICAgICAgICAgYW5kOiAoKSA9PiBMb2dpYy5hbmQodGhpcy5jb25uZWN0b3JzWzFdLnN0YXRlLCB0aGlzLmNvbm5lY3RvcnNbMl0uc3RhdGUpLFxuICAgICAgICAgICAgbmFuZDogKCkgPT4gTG9naWMubmFuZCh0aGlzLmNvbm5lY3RvcnNbMV0uc3RhdGUsIHRoaXMuY29ubmVjdG9yc1syXS5zdGF0ZSksXG4gICAgICAgICAgICBub3I6ICgpID0+IExvZ2ljLm5vcih0aGlzLmNvbm5lY3RvcnNbMV0uc3RhdGUsIHRoaXMuY29ubmVjdG9yc1syXS5zdGF0ZSksXG4gICAgICAgICAgICBub3Q6ICgpID0+IExvZ2ljLm5vdCh0aGlzLmNvbm5lY3RvcnNbMV0uc3RhdGUpLFxuICAgICAgICAgICAgb3I6ICgpID0+IExvZ2ljLm9yKHRoaXMuY29ubmVjdG9yc1sxXS5zdGF0ZSwgdGhpcy5jb25uZWN0b3JzWzJdLnN0YXRlKSxcbiAgICAgICAgICAgIHhub3I6ICgpID0+IExvZ2ljLnhub3IodGhpcy5jb25uZWN0b3JzWzFdLnN0YXRlLCB0aGlzLmNvbm5lY3RvcnNbMl0uc3RhdGUpLFxuICAgICAgICAgICAgeG9yOiAoKSA9PiBMb2dpYy54b3IodGhpcy5jb25uZWN0b3JzWzFdLnN0YXRlLCB0aGlzLmNvbm5lY3RvcnNbMl0uc3RhdGUpLFxuICAgICAgICAgICAgcmVwZWF0ZXI6ICgpID0+IHRoaXMuY29ubmVjdG9yc1sxXS5zdGF0ZVxuICAgICAgICB9O1xuXG4gICAgICAgIGxldCBzdGF0ZSA9IExvZ2ljLnN0YXRlLnVua25vd247XG5cbiAgICAgICAgaWYgKHN0YXRlTWFwW3RoaXMubmFtZV0pIHtcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGVNYXBbdGhpcy5uYW1lXSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm90aWZ5IHRoZSBzaW11bGF0b3IgYWJvdXQgdGhpcyBjaGFuZ2VcbiAgICAgICAgdGhpcy5hcHBJbnN0YW5jZS5zaW11bGF0aW9uLm5vdGlmeUNoYW5nZSh0aGlzLmNvbm5lY3RvcnNbMF0uaWQsIHN0YXRlKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBQb2x5TGluZSwgUG9seUxpbmVQb2ludHMsIFBvbHlMaW5lUG9pbnQgfSBmcm9tICcuLi9zdmdPYmplY3RzJztcblxuaW1wb3J0IE5ldHdvcmtFbGVtZW50IGZyb20gJy4vTmV0d29ya0VsZW1lbnQnO1xuXG4vKiogQG1vZHVsZSBlZGl0b3JFbGVtZW50cy5IZWxwZXJXaXJlICovXG5cbi8qKlxuICogQSB0ZW1wb3Jhcnkgd2lyZSB0aGF0IGlzIGNvbm5lY3RpbmcgYSB7QGxpbmsgQ29ubmVjdG9yfSB3aXRoIGEgbW91c2UgcG9pbnRlciB3aGVuIHVzZXIgY3JlYXRlcyBhIHdpcmUuXG4gKiBAZXh0ZW5kcyBOZXR3b3JrRWxlbWVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIZWxwZXJXaXJlIGV4dGVuZHMgTmV0d29ya0VsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKGFwcEluc3RhbmNlLCBmcm9tSWQsIG1vdXNlUG9zaXRpb24pIHtcbiAgICAgICAgc3VwZXIoYXBwSW5zdGFuY2UpO1xuXG4gICAgICAgIGNvbnN0IGNvbm5lY3RvciA9IHRoaXMuYXBwSW5zdGFuY2UuZ2V0Q29ubmVjdG9yQnlJZChmcm9tSWQpO1xuICAgICAgICB0aGlzLmNvbm5lY3RvclBvc2l0aW9uID0gdGhpcy5hcHBJbnN0YW5jZS5nZXRDb25uZWN0b3JQb3NpdGlvbihjb25uZWN0b3IsIHRydWUpO1xuXG4gICAgICAgIGNvbnN0IGZyb20gPSBuZXcgUG9seUxpbmVQb2ludCh0aGlzLmNvbm5lY3RvclBvc2l0aW9uLngsIHRoaXMuY29ubmVjdG9yUG9zaXRpb24ueSk7XG4gICAgICAgIGNvbnN0IHRvID0gbmV3IFBvbHlMaW5lUG9pbnQobW91c2VQb3NpdGlvbi54LCBtb3VzZVBvc2l0aW9uLnkpO1xuXG4gICAgICAgIGNvbnN0IHBvaW50cyA9IG5ldyBQb2x5TGluZVBvaW50cyhbZnJvbSwgdG9dKTtcblxuICAgICAgICB0aGlzLnN2Z09iaiA9IG5ldyBQb2x5TGluZShwb2ludHMsIDIsICcjOGI4YjhiJyk7XG4gICAgfVxuXG4gICAgdXBkYXRlTW91c2VQb3NpdGlvbihtb3VzZVBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IGZyb20gPSBuZXcgUG9seUxpbmVQb2ludCh0aGlzLmNvbm5lY3RvclBvc2l0aW9uLngsIHRoaXMuY29ubmVjdG9yUG9zaXRpb24ueSk7XG4gICAgICAgIGNvbnN0IHRvID0gbmV3IFBvbHlMaW5lUG9pbnQobW91c2VQb3NpdGlvbi54LCBtb3VzZVBvc2l0aW9uLnkpO1xuXG4gICAgICAgIGNvbnN0IHBvaW50cyA9IG5ldyBQb2x5TGluZVBvaW50cyhbZnJvbSwgdG9dKTtcblxuICAgICAgICB0aGlzLnN2Z09iai51cGRhdGVQb2ludHMocG9pbnRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIGpRdWVyeSBlbGVtZW50IGZvciB0aGlzIGhlbHBlciB3aXJlXG4gICAgICogQHJldHVybiB7alF1ZXJ5LmVsZW1lbnR9XG4gICAgICovXG4gICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdmdPYmouZ2V0KCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IExvZ2ljIGZyb20gJy4uL0xvZ2ljJztcblxuaW1wb3J0IEJveCBmcm9tICcuL0JveCc7XG5cbi8qKiBAbW9kdWxlIGVkaXRvckVsZW1lbnRzLklucHV0Qm94ICovXG5cbi8qKlxuICogSW5wdXRCb3ggaGFzIG9ubHkgb3V0cHV0IGNvbm5lY3RvcnMgYW5kIGlzIHVzZWQgdG8gc2V0IHRoZSBpbnB1dCBzdGF0ZXMgZm9yIHRoZSBsb2dpYyBuZXR3b3JrLlxuICogQGV4dGVuZHMgQm94XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElucHV0Qm94IGV4dGVuZHMgQm94IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FwcH0gYXBwSW5zdGFuY2UgIGluc3RhbmNlIG9mIFtBcHBdKC4vbW9kdWxlLUFwcC5odG1sKVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzT249ZmFsc2VdIHRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBpbnB1dGJveCAoYHRydWVgIGlzICpvbiosIGBmYWxzZWAgaXMgKm9mZiopXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYXBwSW5zdGFuY2UsIGlzT24gPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBncmlkV2lkdGggPSA3O1xuICAgICAgICBjb25zdCBncmlkSGVpZ2h0ID0gNDtcblxuICAgICAgICBzdXBlcihhcHBJbnN0YW5jZSwgJ2lucHV0JywgJ290aGVyJywgZ3JpZFdpZHRoLCBncmlkSGVpZ2h0KTtcblxuICAgICAgICB0aGlzLmFkZENvbm5lY3RvcihncmlkV2lkdGgsIGdyaWRIZWlnaHQgLyAyLCBmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5vbiA9IGlzT247XG5cbiAgICAgICAgdGhpcy5nZW5lcmF0ZUJsb2NrTm9kZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgZGF0YSBvZiB0aGlzIGlucHV0IGJveCBhcyBhIEpTT04tcmVhZHkgb2JqZWN0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGVzc2VudGlhbCBkYXRhIGZvciB0aGlzIGlucHV0IGJveFxuICAgICAqL1xuICAgIGdldCBleHBvcnREYXRhKCkge1xuICAgICAgICBsZXQgZGF0YSA9IHN1cGVyLmV4cG9ydERhdGE7XG4gICAgICAgIGRhdGEuaXNPbiA9IHRoaXMuaXNPbjtcblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBnZW5lcmF0ZUJsb2NrTm9kZXMoKSB7XG4gICAgICAgIC8vIGJsb2NrIHRoZSBpbnB1dCBjb25uZWN0b3Igbm9kZVxuICAgICAgICBjb25zdCBzcGVjaWFsTm9kZSA9IHtcbiAgICAgICAgICAgIHg6IHRoaXMuZ3JpZFdpZHRoLFxuICAgICAgICAgICAgeTogdGhpcy5ncmlkSGVpZ2h0IC8gMlxuICAgICAgICB9O1xuICAgICAgICBzdXBlci5nZW5lcmF0ZUJsb2NrTm9kZXMoMCwgMSwgMSwgMCwgc3BlY2lhbE5vZGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHN0YXJ0IGEgbmV3IHNpbXVsYXRpb24gZnJvbSB0aGUgb3V0cHV0IGNvbm5lY3RvclxuICAgICAqL1xuICAgIHJlZnJlc2hTdGF0ZSgpIHtcbiAgICAgICAgdGhpcy5hcHBJbnN0YW5jZS5zdGFydE5ld1NpbXVsYXRpb24odGhpcy5jb25uZWN0b3JzWzBdLCB0aGlzLmNvbm5lY3RvcnNbMF0uc3RhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldCB0aGUgc3RhdGUgb2YgdGhlIGlucHV0Ym94IHRvIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gaXNPbiBzZXQgdG8gKm9uKiBpZiBgdHJ1ZWAsIHNldCB0byAqb2ZmKiBpZiBgZmFsc2VgXG4gICAgICovXG4gICAgc2V0IG9uKGlzT24pIHtcbiAgICAgICAgaWYgKGlzT24pIHtcbiAgICAgICAgICAgIC8vIHR1cm4gb25cbiAgICAgICAgICAgIHRoaXMuY2hhbmdlSW1hZ2UoJ29uJyk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvcnNbMF0uc2V0U3RhdGUoTG9naWMuc3RhdGUub24pO1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoU3RhdGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHR1cm4gb2ZmXG4gICAgICAgICAgICB0aGlzLmNoYW5nZUltYWdlKCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvcnNbMF0uc2V0U3RhdGUoTG9naWMuc3RhdGUub2ZmKTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaFN0YXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzT24gPSBpc09uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgc3RhdGUgb2YgdGhlIGlucHV0Ym94IChgdHJ1ZWAgaWYgKm9uKiwgYGZhbHNlYCBpZiAqb2ZmKilcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBbZGVzY3JpcHRpb25dXG4gICAgICovXG4gICAgZ2V0IG9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc09uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRvZ2dsZSB0aGUgc3RhdGUgb2YgdGhlIGlucHV0Ym94XG4gICAgICovXG4gICAgb25DbGljaygpIHtcbiAgICAgICAgdGhpcy5vbiA9ICF0aGlzLm9uO1xuXG4gICAgICAgIGlmICh0aGlzLmFwcEluc3RhbmNlLnR1dG9yaWFsKSB7XG4gICAgICAgICAgICB0aGlzLmFwcEluc3RhbmNlLnR1dG9yaWFsLm9uQ2hhbmdlSW5wdXRCb3hTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IENvbm5lY3RvciBmcm9tICcuL0Nvbm5lY3Rvcic7XG5pbXBvcnQgTG9naWMgZnJvbSAnLi4vTG9naWMnO1xuXG4vKiogQG1vZHVsZSBlZGl0b3JFbGVtZW50cy5JbnB1dENvbm5lY3RvciAqL1xuXG4vKipcbiAqIENvbm5lY3RvciB0aGF0IGdldHMgaXRzIHN0YXRlIGZyb20gYSBjb25uZWN0ZWQgdmFsdWUgYW5kIHBhc3NlcyBpdCB0aHJvdWdoIHRvIHRoZSB7QGxpbmsgQm94fSB0aGlzIGNvbm5lY3RvciBiZWxvbmdzIHRvLlxuICogQGV4dGVuZHMgQ29ubmVjdG9yXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElucHV0Q29ubmVjdG9yIGV4dGVuZHMgQ29ubmVjdG9yIHtcbiAgICAvKipcbiAgICAgKiBDYWxsIHRoZSBjb25zdHJ1Y3RvciBmcm9tIHRoZSBwYXJlbnQge0BsaW5rIENvbm5lY3Rvcn0gY2xhc3MgYW5kIHNldCBpc0lucHV0Q29ubmVjdG9yIHRvIHRydWUuXG4gICAgICogQHBhcmFtIHtBcHB9IGFwcEluc3RhbmNlIGxpbmsgdG8gdGhlIFtBcHBdKC4vbW9kdWxlLUFwcC5odG1sKSBpbnN0YW5jZSB0aGF0IHRoaXMgY29ubmVjdG9yIHdpbGwgYmVsb25nIHRvXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgICAgICBob3Jpem9udGFsIHBvc2l0aW9uIGRlZmluZWQgaW4gZ3JpZCB1bml0cyAoU1ZHIHBpeGVscyBkaXZpZGVkIGJ5IHRoZSBncmlkIHNpemUpXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvcCAgICAgICB2ZXJ0aWNhbCBwb3NpdGlvbiBkZWZpbmVkIGluIGdyaWQgdW5pdHMgKFNWRyBwaXhlbHMgZGl2aWRlZCBieSB0aGUgZ3JpZCBzaXplKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFwcEluc3RhbmNlLCBsZWZ0LCB0b3ApIHtcbiAgICAgICAgc3VwZXIoYXBwSW5zdGFuY2UsIGxlZnQsIHRvcCk7XG5cbiAgICAgICAgdGhpcy5pc0lucHV0Q29ubmVjdG9yID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsIHRoZSBzZXRTdGF0ZSBtZXRob2Qgb2Yge0BsaW5rIENvbm5lY3Rvcn0gYW5kIHRoYW4gcmVmcmVzaCB0aGUgc3RhdGUgb2YgdGhlIGNvbm5lY3RlZCB7QGxpbmsgQm94fVxuICAgICAqIEBwYXJhbSB7TG9naWMuc3RhdGV9IHN0YXRlIG5ldyB7QGxpbmsgTG9naWMuc3RhdGV9IG9mIHRoZSBjb25uZWN0b3JcbiAgICAgKi9cbiAgICBzZXRTdGF0ZShzdGF0ZSkge1xuICAgICAgICBzdXBlci5zZXRTdGF0ZShzdGF0ZSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiU0VUIFNUQVRFIE9OIElDXCIsIHRoaXMuaWQsIFwiOlwiLCBzdGF0ZSlcblxuICAgICAgICBsZXQgYm94ID0gdGhpcy5hcHBJbnN0YW5jZS5nZXRCb3hCeUNvbm5lY3RvcklkKHRoaXMuc3ZnT2JqLmlkKTtcbiAgICAgICAgYm94LnJlZnJlc2hTdGF0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSB0aGUgd2lyZSAoYnkgY2FsbGluZyB0aGUgcmVtb3ZlV2lyZUlkQW5kVXBkYXRlIG9mIHtAbGluayBDb25uZWN0b3J9KVxuICAgICAqIGFuZCB1cGRhdGUgc3RhdGUgb2YgdGhpcyBjb25uZWN0b3IgYnkgc2V0dGluZyBpdCB0byB1bmRlZmluZWQgdXNpbmcgdGhlIHNldFN0YXRlIG1ldGhvZFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gd2lyZUlkIElEIG9mIHRoZSB7QGxpbmsgV2lyZX1cbiAgICAgKi9cbiAgICByZW1vdmVXaXJlSWRBbmRVcGRhdGUod2lyZUlkKSB7XG4gICAgICAgIHN1cGVyLnJlbW92ZVdpcmVJZEFuZFVwZGF0ZSh3aXJlSWQpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKExvZ2ljLnN0YXRlLnVua25vd24pO1xuICAgIH1cbn1cbiIsIi8qKiBAbW9kdWxlIGVkaXRvckVsZW1lbnRzLk5ldHdvcmtFbGVtZW50ICovXG5cbi8qKlxuICogcGFyZW50IGNsYXNzIGZvciBhbGwgbmV0d29yayBlbGVtZW50c1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOZXR3b3JrRWxlbWVudCB7XG4gICAgLyoqXG4gICAgICogQmFzaWMgY29uc3RydWN0b3IgZm9yIE5ldHdvcmtFbGVtZW50XG4gICAgICogQHBhcmFtIHtBcHB9IGFwcEluc3RhbmNlIHJlZmVyZW5jZSB0byB0aGUgaW5zdGFuY2Ugb2YgW0FwcF0oLi9tb2R1bGUtQXBwLmh0bWwpIHRoYXQgdGhpcyBlbGVtZW50IGJlbG9uZ3MgdG9cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhcHBJbnN0YW5jZSkge1xuICAgICAgICBpZiAoIWFwcEluc3RhbmNlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQYXJlbnQgU1ZHIGVsZW1lbnQgaGFzIHRvIGJlIGRlZmluZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcHBJbnN0YW5jZSA9IGFwcEluc3RhbmNlO1xuXG4gICAgICAgIC8vIHVzZWQgdG8gc3RvcmUgdGhlIHN2ak9iamVjdCdzIGluc3RhbmNlIG9mIHRoaXMgZWxlbWVudFxuICAgICAgICB0aGlzLnN2Z09iaiA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHVuaXF1ZSBJRCBvZiB0aGUgU1ZHIGVsZW1lbnQgdGllZCB0byB0aGlzIGxvZ2ljYWwgZWxlbWVudFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gSUQgb2YgdGhlIFNWRyBlbGVtZW50XG4gICAgICovXG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdmdPYmouaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZW1wdHkgY2FsbGJhY2sgZnVuY3Rpb24gdG8gcHJldmVudCBlcnJvciBtZXNzYWdlcywgZnVuY3Rpb24gaXMgaW1wbGVtZW50ZWQgbGF0ZXIgaW4gdGhlIHtAbGluayBCb3h9IGNsYXNzXG4gICAgICovXG4gICAgb25Nb3VzZURvd24oKSB7fVxuXG4gICAgLyoqXG4gICAgICogZW1wdHkgZnVuY3Rpb24gdG8gcHJldmVudCBlcnJvciBtZXNzYWdlcywgZnVuY3Rpb24gaXMgaW1wbGVtZW50ZWQgbGF0ZXIgaW4gdGhlIHtAbGluayBCb3h9IGFuZCB7QGxpbmsgQ29ubmVjdG9yfSBjbGFzc2VzXG4gICAgICovXG4gICAgb25Nb3VzZVVwKCkge31cblxuICAgIC8qKlxuICAgICAqIGVtcHR5IGZ1bmN0aW9uIHRvIHByZXZlbnQgZXJyb3IgbWVzc2FnZXMsIGZ1bmN0aW9uIGlzIGltcGxlbWVudGVkIGxhdGVyIGluIHRoZSB7QGxpbmsgQm94fSBjbGFzc1xuICAgICAqL1xuICAgIG9uTW91c2VNb3ZlKCkge31cblxuICAgIC8qKlxuICAgICAqIFwidmlydHVhbFwiIGdldHRlciBmb3IganNvbiBkYXRhLCBwcmludHMgYW4gZXJyb3IgdGhhdCBpdCBoYXMgdG8gYmUgcmVkZWZpbmVkIGluIHRoZSBkZXJpdmVkIGNsYXNzZXNcbiAgICAgKi9cbiAgICBnZXQgZXhwb3J0RGF0YSgpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIidqc29uJyBnZXR0ZXIgaGFzIG5vdCBiZWVuIGRlZmluZWQgZm9yIHRoaXMgZWxlbWVudFwiLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG4iLCJpbXBvcnQgTG9naWMgZnJvbSAnLi4vTG9naWMnO1xuXG5pbXBvcnQgQm94IGZyb20gJy4vQm94JztcblxuLyoqIEBtb2R1bGUgZWRpdG9yRWxlbWVudHMuT3V0cHV0Qm94ICovXG5cbi8qKlxuICogT3V0cHV0Qm94IGhhcyBvbmx5IGlucHV0IGNvbm5lY3RvcnMgYW5kIGlzIHVzZWQgdG8gdmlzdWFsaXplIHRoZSBvdXRwdXQgc3RhdGVzIG9mIHRoZSBsb2dpYyBuZXR3b3JrLlxuICogQGV4dGVuZHMgQm94XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE91dHB1dEJveCBleHRlbmRzIEJveCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcHB9IGFwcEluc3RhbmNlICBpbnN0YW5jZSBvZiBbQXBwXSguL21vZHVsZS1BcHAuaHRtbClcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhcHBJbnN0YW5jZSkge1xuICAgICAgICBjb25zdCBncmlkSGVpZ2h0ID0gNDtcbiAgICAgICAgY29uc3QgZ3JpZFdpZHRoID0gNTtcblxuICAgICAgICBzdXBlcihhcHBJbnN0YW5jZSwgJ291dHB1dCcsICdvdGhlcicsIGdyaWRXaWR0aCwgZ3JpZEhlaWdodCk7XG5cbiAgICAgICAgdGhpcy5hZGRDb25uZWN0b3IoMCwgZ3JpZEhlaWdodCAvIDIsIHRydWUpO1xuXG4gICAgICAgIHRoaXMuZ2VuZXJhdGVCbG9ja05vZGVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0IHN0YXRlIG9mIHRoaXMgb3V0cHV0IGJveCB0byBtYXRjaCB0aGUgc3RhdGUgb2YgaXRzIGlucHV0IGNvbm5lY3RvclxuICAgICAqL1xuICAgIHJlZnJlc2hTdGF0ZSgpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh0aGlzLmNvbm5lY3RvcnNbMF0uc3RhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZmxlY3QgdGhlIGlucHV0IGNvbm5lY3RvciBzdGF0ZSBpbiB0aGUgYXBwZWFyYW5jZSBvZiB0aGUgZWxlbWVudCAtIHNldFxuICAgICAqIHRoZSBlbGVtZW50IGltYWdlIHRvIHJlcHJlc2VudCB0aGUgY29ycmVzcG9uZGluZyBzdGF0ZVxuICAgICAqIEBwYXJhbSB7TG9naWMuc3RhdGV9IHN0YXRlIG5ldyBzdGF0ZSBvZiB0aGlzIG91dHB1dEJveFxuICAgICAqL1xuICAgIHNldFN0YXRlKHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gTG9naWMuc3RhdGUub24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFwcEluc3RhbmNlLnR1dG9yaWFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBJbnN0YW5jZS50dXRvcmlhbC5vbk91dHB1dEJveFRydWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzdGF0ZU1hcCA9IHt9O1xuICAgICAgICBzdGF0ZU1hcFtMb2dpYy5zdGF0ZS5vbl0gPSAnb24nO1xuICAgICAgICBzdGF0ZU1hcFtMb2dpYy5zdGF0ZS5vZmZdID0gJ29mZic7XG4gICAgICAgIHN0YXRlTWFwW0xvZ2ljLnN0YXRlLnVua25vd25dID0gJyc7XG4gICAgICAgIHN0YXRlTWFwW0xvZ2ljLnN0YXRlLm9zY2lsbGF0aW5nXSA9ICdvc2MnO1xuXG4gICAgICAgIHRoaXMuY2hhbmdlSW1hZ2Uoc3RhdGVNYXBbc3RhdGVdKTtcbiAgICB9XG5cbiAgICBnZW5lcmF0ZUJsb2NrTm9kZXMoKSB7XG4gICAgICAgIC8vIGJsb2NrIHRoZSBpbnB1dCBjb25uZWN0b3Igbm9kZVxuICAgICAgICBjb25zdCBzcGVjaWFsTm9kZSA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiB0aGlzLmdyaWRIZWlnaHQgLyAyXG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyLmdlbmVyYXRlQmxvY2tOb2RlcygwLCAwLCAwLCAxLCBzcGVjaWFsTm9kZSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IENvbm5lY3RvciBmcm9tICcuL0Nvbm5lY3Rvcic7XG5cbi8qKiBAbW9kdWxlIGVkaXRvckVsZW1lbnRzLk91dHB1dENvbm5lY3RvciAqL1xuXG4vKipcbiAqIENvbm5lY3RvciB0aGF0IHRha2VzIGEgc3RhdGUgZGVmaW5lZCBieSB0aGUge0BsaW5rIEJveH0gaXQgYmVsb25ncyB0byBhbmQgcGFzc2VzIGl0IHRvIGFsbCBjb25uZWN0ZWQgd2lyZVxuICogQGV4dGVuZHMgQ29ubmVjdG9yXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE91dHB1dENvbm5lY3RvciBleHRlbmRzIENvbm5lY3RvciB7XG4gICAgLyoqXG4gICAgICogQ2FsbCB0aGUgY29uc3RydWN0b3IgZnJvbSB0aGUgcGFyZW50IHtAbGluayBDb25uZWN0b3J9IGNsYXNzIGFuZCBzZXQgaXNPdXRwdXRDb25uZWN0b3IgdG8gdHJ1ZS5cbiAgICAgKiBAcGFyYW0ge0FwcH0gYXBwSW5zdGFuY2UgbGluayB0byB0aGUgW0FwcF0oLi9tb2R1bGUtQXBwLmh0bWwpIGluc3RhbmNlIHRoYXQgdGhpcyBjb25uZWN0b3Igd2lsbCBiZWxvbmcgdG9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVmdCAgICAgIGhvcml6b250YWwgcG9zaXRpb24gZGVmaW5lZCBpbiBncmlkIHVuaXRzIChTVkcgcGl4ZWxzIGRpdmlkZWQgYnkgdGhlIGdyaWQgc2l6ZSlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9wICAgICAgIHZlcnRpY2FsIHBvc2l0aW9uIGRlZmluZWQgaW4gZ3JpZCB1bml0cyAoU1ZHIHBpeGVscyBkaXZpZGVkIGJ5IHRoZSBncmlkIHNpemUpXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYXBwSW5zdGFuY2UsIGxlZnQsIHRvcCkge1xuICAgICAgICBzdXBlcihhcHBJbnN0YW5jZSwgbGVmdCwgdG9wKTtcblxuICAgICAgICB0aGlzLmlzT3V0cHV0Q29ubmVjdG9yID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsIHRoZSBzZXRTdGF0ZSBtZXRob2Qgb2Yge0BsaW5rIENvbm5lY3Rvcn0gYW5kIHRoYW4gc2V0IHRoZSBzdGF0ZSBvZiB0aGUgY29ubmVjdGVkIHtAbGluayBXaXJlfXNcbiAgICAgKiBAcGFyYW0ge0xvZ2ljLnN0YXRlfSBzdGF0ZSBuZXcge0BsaW5rIExvZ2ljLnN0YXRlfSBvZiB0aGUgY29ubmVjdG9yXG4gICAgICovXG4gICAgc2V0U3RhdGUoc3RhdGUpIHtcbiAgICAgICAgc3VwZXIuc2V0U3RhdGUoc3RhdGUpO1xuXG4gICAgICAgIGZvciAoY29uc3Qgd2lyZUlkIG9mIHRoaXMud2lyZUlkcykge1xuICAgICAgICAgICAgdGhpcy5hcHBJbnN0YW5jZS5nZXRXaXJlQnlJZCh3aXJlSWQpLnNldFN0YXRlKHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qKiBAbW9kdWxlIGVkaXRvckVsZW1lbnRzLlRyYW5zZm9ybSAqL1xuXG4vKipcbiAqIEhlbHBlciBjbGFzcyB1c2VkIGJ5IHtAbGluayBUcmFuc2Zvcm19LlxuICpcbiAqIFJlcHJlc2VudHMgb25lIHNpbmdsZSBwcm9wZXJ0eSBvZiB0aGUgdHJhbnNmb3JtIGFyZ3VtZW50LCBmb3IgZXhhbXBsZSBgdHJhbnNsYXRlKDM2MCAxNTApYFxuICogdGhhdCBtYXkgYmUgYSBwYXJ0IG9mIGxvbmdlciB0cmFuc2Zvcm0gYXJndW1lbnQgbGlrZSBgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDM2MCAxNTApIHJvdGF0ZSg5MCAzMCAyMClcImBcbiAqL1xuY2xhc3MgUHJvcGVydHkge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIFByb3BlcnR5IG9iamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nXSBzdHJpbmcgaW4gdGhlIHByb3BlcnR5IGZvcm1hdCBgcHJvcGVydHluYW1lKGxpc3Qgb2Ygc3BhY2Ugc2VwYXJhdGVkIHZhbHVlcylgXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc3RyaW5nKSB7XG4gICAgICAgIGlmIChzdHJpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gc3RyaW5nLnJlcGxhY2UoL15bIF0qKFteKF0rKS4qLywgJyQxJyk7XG4gICAgICAgICAgICB0aGlzLmFyZ3MgPSBzdHJpbmcucmVwbGFjZSgvXlteKF0rXFwoKC4qKVxcKS8sICckMScpLnNwbGl0KCcgJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgb3IgcmVwbGFjZSB0aGUgbmFtZSBvZiB0aGlzIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmV3IG5hbWUgZm9yIHRoaXMgcHJvcGVydHlcbiAgICAgKi9cbiAgICBzZXROYW1lKG5hbWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgYXJndW1lbnRzIG9mIHRoaXMgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBhcmdzIGFycmF5IG9mIGFyZ3VtZW50c1xuICAgICAqL1xuICAgIHNldEFyZ3VtZW50cyhhcmdzKSB7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHByb3BlcnR5IGluIHRoZSBwcm9wZXJ0eSBmb3JtYXQgYG5hbWUoYXJnMSBhcmcyKWBcbiAgICAgKi9cbiAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyAnKCcgKyB0aGlzLmFyZ3Muam9pbignICcpICsgJyknO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBUEkgZm9yIG1hbmlwdWxhdGluZyB0aGUgdHJhbnNmb3JtIGFyZ3VtZW50IHVzZWQgaW4gU1ZHXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYW5zZm9ybSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgVHJhbnNmb3JtIG9iamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nXSBzdHJpbmcgaW4gdGhlIGZvcm1hdCBvZiB0aGUgYHRyYW5zZm9ybWAgYXJndW1lbnQgaW4gU1ZHLCBmb3IgZXhhbXBsZSBgdHJhbnNsYXRlKDM2MCAxNTApIHJvdGF0ZSg5MCAzMCAyMClgXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc3RyaW5nKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhcnJheSBvZiB7QGxpbmsgUHJvcGVydHl9IGluc3RhbmNlc1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLml0ZW1zID0gW107XG5cbiAgICAgICAgaWYgKHN0cmluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygc3RyaW5nLnNwbGl0KCcpJykpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBub3QgZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKG5ldyBQcm9wZXJ0eShpdGVtICsgJyknKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29udmVydCBkaXN0YW5jZXMgZnJvbSBTVkcgcGl4ZWxzIHRvIGdyaWQgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtBcHB9IGFwcEluc3RhbmNlIGluc3RhbmNlIG9mIFtBcHBdKC4vbW9kdWxlLUFwcC5odG1sKVxuICAgICAqL1xuICAgIHRvR3JpZFBpeGVscyhhcHBJbnN0YW5jZSkge1xuICAgICAgICB0aGlzLnBpeGVsQ29udmVyc2lvbih2YWwgPT4gYXBwSW5zdGFuY2UuU1ZHVG9HcmlkKHZhbCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNvbnZlcnQgZGlzdGFuY2VzIGZyb20gZ3JpZCBwaXhlbHMgdG8gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7QXBwfSBhcHBJbnN0YW5jZSBpbnN0YW5jZSBvZiBbQXBwXSguL21vZHVsZS1BcHAuaHRtbClcbiAgICAgKi9cbiAgICB0b1NWR1BpeGVscyhhcHBJbnN0YW5jZSkge1xuICAgICAgICB0aGlzLnBpeGVsQ29udmVyc2lvbih2YWwgPT4gYXBwSW5zdGFuY2UuZ3JpZFRvU1ZHKHZhbCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgZGlzdGFuY2VzIHVzaW5nIGEgc3BlY2lmaWVkIGNvbnZlcnRvci4gVXNlZCBieSB0b0dyaWRQaXhlbHMgYW5kIHRvU1ZHUGl4ZWxzXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNvbnZlcnRvciBmdW5jdGlvbiB0aGF0IGNvbnZlcnRzIGludCB0byBpbnRcbiAgICAgKi9cbiAgICBwaXhlbENvbnZlcnNpb24oY29udmVydG9yKSB7XG4gICAgICAgIGNvbnN0IHByb3BlcnR5TWFwID0ge1xuICAgICAgICAgICAgdHJhbnNsYXRlOiBpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBpdGVtLmFyZ3MgPSBpdGVtLmFyZ3MubWFwKGFyZyA9PiBjb252ZXJ0b3IoYXJnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcm90YXRlOiBpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBpdGVtLmFyZ3MgPSBbaXRlbS5hcmdzWzBdLCBjb252ZXJ0b3IoaXRlbS5hcmdzWzFdKSwgY29udmVydG9yKGl0ZW0uYXJnc1syXSldO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuaXRlbXMgPSB0aGlzLml0ZW1zLm1hcChpdGVtID0+IHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eU1hcFtpdGVtLm5hbWVdID8gcHJvcGVydHlNYXBbaXRlbS5uYW1lXShpdGVtKSA6IGl0ZW07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGZpbmQgYSB0cmFuc2Zvcm0gcHJvcGVydHkgYnkgbmFtZSBhbmQgZ2V0IGl0cyBpbmRleCBpbiB0aGUgW2l0ZW1zXSgjaXRlbXMpIGFycmF5XG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICogQHJldHVybiB7bnVtYmVyfSAgICAgIGluZGV4IG9mIHRoZSBwcm9wZXJ0eSBpbiB0aGUgYXJyYXkgb2YgcHJvcGVydGllcyBvciBgLTFgIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICAgIGdldEluZGV4KG5hbWUpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gdGhpcy5pdGVtc1tpXS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSB0cmFuc2xhdGUgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcnMgb2YgdGhlIHRyYW5zbGF0ZSBhdHRyaWJ1dGVcbiAgICAgKi9cbiAgICBnZXRUcmFuc2xhdGUoKSB7XG4gICAgICAgIGxldCBhcmdzID0gdGhpcy5nZXRBcmd1bWVudHModGhpcy5nZXRJbmRleCgndHJhbnNsYXRlJykpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBOdW1iZXIoYXJnc1swXSksXG4gICAgICAgICAgICB5OiBOdW1iZXIoYXJnc1sxXSlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIHJvdGF0ZSBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVycyBvZiB0aGUgcm90YXRlIGF0dHJpYnV0ZVxuICAgICAqL1xuICAgIGdldFJvdGF0ZSgpIHtcbiAgICAgICAgbGV0IGFyZ3MgPSB0aGlzLmdldEFyZ3VtZW50cyh0aGlzLmdldEluZGV4KCdyb3RhdGUnKSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlZzogTnVtYmVyKGFyZ3NbMF0pLFxuICAgICAgICAgICAgY2VudGVyWDogTnVtYmVyKGFyZ3NbMV0pLFxuICAgICAgICAgICAgY2VudGVyWTogTnVtYmVyKGFyZ3NbMl0pXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0IHRyYW5zbGF0ZSB0byB0aGUgc3BlY2lmaWVkIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IGhvcml6b250YWwgdHJhbnNsYXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSB2ZXJ0aWNhbCB0cmFuc2xhdGlvblxuICAgICAqL1xuICAgIHNldFRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgICAgIHRoaXMuc2V0UGFyYW1ldGVyKCd0cmFuc2xhdGUnLCBbeCwgeV0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldCByb3RhdGUgdG8gdGhlIHNwZWNpZmllZCB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVnICAgICBhbmdsZSBvZiB0aGUgcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjZW50ZXJYIGhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvZiB0aGUgcm90YXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2VudGVyWSB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9mIHRoZSByb3RhdGlvblxuICAgICAqL1xuICAgIHNldFJvdGF0ZShkZWcsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXIoJ3JvdGF0ZScsIFtkZWcsIGNlbnRlclgsIGNlbnRlclldKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByb3RhdGUgYnkgOTAgZGVncmVlcyB0byB0aGUgcmlnaHQgb3IgbGVmdCwgZGVwZW5kaW5nIG9uIHRoZSBwYXJhbWV0ZXIgYHJpZ2h0YFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjZW50ZXJYIGhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvZiB0aGUgcm90YXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2VudGVyWSB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9mIHRoZSByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmlnaHQgcm90YXRlIHRvIHRoZSByaWdodCBpZiBgdHJ1ZWAsIHRvIHRoZSBsZWZ0IGlmIGBmYWxzZWBcbiAgICAgKi9cbiAgICByb3RhdGVSaWdodEFuZ2xlKGNlbnRlclgsIGNlbnRlclksIHJpZ2h0KSB7XG4gICAgICAgIGNvbnN0IGFtb3VudCA9IHJpZ2h0ID8gOTAgOiAyNzA7XG5cbiAgICAgICAgaWYgKHRoaXMuZ2V0SW5kZXgoJ3JvdGF0ZScpID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5zZXRSb3RhdGUoYW1vdW50LCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuZXdSb3RhdGlvbiA9IChwYXJzZUludCh0aGlzLmdldFJvdGF0ZSgpLmRlZykgKyBhbW91bnQpICUgMzYwO1xuXG4gICAgICAgICAgICBpZiAobmV3Um90YXRpb24gPT09IDE4MCkge1xuICAgICAgICAgICAgICAgIC8vIHN3YXAgY2VudGVyIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSByb3RhdGUoYywgeCwgeSkgaXMgZGVmaW5lZCBsaWtlIHRyYW5zZm9ybSgteCwgLXkpIHJvdGF0ZShjKSB0cmFuc2Zvcm0oeCwgeSlcbiAgICAgICAgICAgICAgICBsZXQgYSA9IGNlbnRlclg7XG4gICAgICAgICAgICAgICAgY2VudGVyWCA9IGNlbnRlclk7XG4gICAgICAgICAgICAgICAgY2VudGVyWSA9IGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2V0Um90YXRlKG5ld1JvdGF0aW9uLCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJvdGF0ZSBieSA5MCBkZWdyZWVzIHRvIHRoZSByaWdodFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gY2VudGVyWCBob3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHJvdGF0aW9uXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBjZW50ZXJZIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHJvdGF0aW9uXG4gICAgICovXG4gICAgcm90YXRlUmlnaHQoY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgICB0aGlzLnJvdGF0ZVJpZ2h0QW5nbGUoY2VudGVyWCwgY2VudGVyWSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcm90YXRlIGJ5IDkwIGRlZ3JlZXMgdG8gdGhlIGxlZnRcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNlbnRlclggaG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9mIHRoZSByb3RhdGlvblxuICAgICAqIEBwYXJhbSAge251bWJlcn0gY2VudGVyWSB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9mIHRoZSByb3RhdGlvblxuICAgICAqL1xuICAgIHJvdGF0ZUxlZnQoY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgICB0aGlzLnJvdGF0ZVJpZ2h0QW5nbGUoY2VudGVyWCwgY2VudGVyWSwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgdHJhbnNmb3JtIHZhbHVlcyBpbiBhIHN0cmluZ1xuICAgICAqIEByZXR1cm4ge3N0cmluZ30gc3RyaW5nIHRoYXQgY2FuIGJlIHVzZWQgYXMgYSB2YWx1ZSBmb3IgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0eSBvZiBhIFNWRyBlbGVtZW50XG4gICAgICovXG4gICAgZ2V0KCkge1xuICAgICAgICBsZXQgcmV0VmFsO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5pdGVtcykge1xuICAgICAgICAgICAgaWYgKHJldFZhbCkge1xuICAgICAgICAgICAgICAgIHJldFZhbCArPSAnICcgKyBpdGVtLmdldCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXRWYWwgPSBpdGVtLmdldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXRWYWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IGFyZ3VtZW50cyBvZiBhIHByb3BlcnR5IHNwZWNpZmllZCBieSBpbmRleFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gaW5kZXggaW5kZXggb2YgdGhlIHByb3BlcnR5XG4gICAgICogQHJldHVybiB7YXJyYXl9ICAgICAgIGFycmF5IG9mIGFyZ3VtZW50cyBvZiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5XG4gICAgICovXG4gICAgZ2V0QXJndW1lbnRzKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zW2luZGV4XS5hcmdzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldCBhcmd1bWV0cyBvZiBhIHByb3BlcnR5IHNwZWNpZmllZCBieSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBhcmdzIGFycmF5IG9mIGFyZ3VtZW50cyBvZiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5XG4gICAgICovXG4gICAgc2V0UGFyYW1ldGVyKG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgLy8gZGV0ZXJtaW5lIGluZGV4IG9mIHRoZSBwYXJhbWV0ZXIgKGlmIHNldCksIGVsc2UgaW5kZXggPT0gLTFcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5nZXRJbmRleChuYW1lKTtcblxuICAgICAgICAvLyBpZiB0aGUgcHJvcGVydHkgaGFzIGJlZW4gYWxyZWFkeSBzZXQsIGNoYW5nZSBpdCAocmV3cml0ZSB0aGUgYXJyYXkgaW4gdGhlIHJpZ2h0IGluZGV4KVxuICAgICAgICAvLyBlbHNlIGNyZWF0ZSBhIG5ldyBvbmUgKHNldCBpbmRleCB0byB0aGUgbGVuZ3RoIG9mIGFuIGFycmF5IC0tPiBhZCBhbiBpdGVtIHRvIHRoZSBlbmQpXG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLml0ZW1zW2luZGV4XSA9IG5ldyBQcm9wZXJ0eSgpO1xuICAgICAgICAgICAgdGhpcy5pdGVtc1tpbmRleF0uc2V0TmFtZShuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNhdmUgYXJncyB1bmRlciB0aGUgcmlnaHQgaW5kZXhcbiAgICAgICAgdGhpcy5pdGVtc1tpbmRleF0uc2V0QXJndW1lbnRzKGFyZ3MpO1xuICAgIH1cbn1cbiIsIi8qKiBAbW9kdWxlIGVkaXRvckVsZW1lbnRzLldpcmUgKi9cblxuaW1wb3J0IHsgUG9seUxpbmUsIFBvbHlMaW5lUG9pbnRzLCBQb2x5TGluZVBvaW50LCBHcm91cCB9IGZyb20gJy4uL3N2Z09iamVjdHMnO1xuaW1wb3J0IExvZ2ljIGZyb20gJy4uL0xvZ2ljJztcbmltcG9ydCBzdGF0ZUNsYXNzZXMgZnJvbSAnLi9zdGF0ZUNsYXNzZXMnO1xuaW1wb3J0IGZpbmRQYXRoIGZyb20gJy4uL2ZpbmRQYXRoJztcblxuaW1wb3J0IE5ldHdvcmtFbGVtZW50IGZyb20gJy4vTmV0d29ya0VsZW1lbnQnO1xuXG4vKipcbiAqIFdpcmUgcmVwcmVzZW50cyBjb25uZWN0aW9uIG9mIHR3byB7QGxpbmsgQ29ubmVjdG9yfXMuXG4gKiBAZXh0ZW5kcyBOZXR3b3JrRWxlbWVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXaXJlIGV4dGVuZHMgTmV0d29ya0VsZW1lbnQge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXBwfSBhcHBJbnN0YW5jZSAgaW5zdGFuY2Ugb2YgW0FwcF0oLi9tb2R1bGUtQXBwLmh0bWwpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICBmcm9tSWQgICAgaWQgb2YgdGhlIGZpcnN0IGNvbm5lY3RvciB0aGlzIHdpcmUgd2lsbCBiZSBjb25uZWN0ZWQgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gIHRvSWQgICAgICBpZCBvZiB0aGUgc2Vjb25kIGNvbm5lY3RvciB0aGlzIHdpcmUgd2lsbCBiZSBjb25uZWN0ZWQgdG9cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZWZyZXNoPXRydWVdIGlmIGB0cnVlYCwgdGhlIFtBcHBdKC4vbW9kdWxlLUFwcC5odG1sKSB3aWxsIHJlZnJlc2ggYWZ0ZXIgY3JlYXRpbmcgdGhpcyB3aXJlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYXBwSW5zdGFuY2UsIGZyb21JZCwgdG9JZCwgcmVmcmVzaCA9IHRydWUsIHJvdXRlID0gdHJ1ZSkge1xuICAgICAgICBzdXBlcihhcHBJbnN0YW5jZSk7XG5cbiAgICAgICAgdGhpcy5ncmlkU2l6ZSA9IGFwcEluc3RhbmNlLmdyaWRTaXplO1xuXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IHtcbiAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgICBpZDogZnJvbUlkLFxuICAgICAgICAgICAgICAgIGJveDogdGhpcy5hcHBJbnN0YW5jZS5nZXRCb3hCeUNvbm5lY3RvcklkKGZyb21JZCksXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yOiB0aGlzLmFwcEluc3RhbmNlLmdldENvbm5lY3RvckJ5SWQoZnJvbUlkKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHRvSWQsXG4gICAgICAgICAgICAgICAgYm94OiB0aGlzLmFwcEluc3RhbmNlLmdldEJveEJ5Q29ubmVjdG9ySWQodG9JZCksXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yOiB0aGlzLmFwcEluc3RhbmNlLmdldENvbm5lY3RvckJ5SWQodG9JZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uLmZyb20uY29ubmVjdG9yLmlzT3V0cHV0Q29ubmVjdG9yKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uLnRvLmNvbm5lY3Rvci5pc0lucHV0Q29ubmVjdG9yKSB7XG4gICAgICAgICAgICAgICAgLy8gZGVzaXJlZCBzdGF0ZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjb25uZWN0aW5nIHR3byBvdXRwdXQgY29ubmVjdG9yc1xuICAgICAgICAgICAgICAgIHRocm93ICdDYW4gbm90IHBsYWNlIHdpcmUgYmV0d2VlbiB0d28gb3V0cHV0IGNvbm5lY3RvcnMnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbi50by5jb25uZWN0b3IuaXNJbnB1dENvbm5lY3Rvcikge1xuICAgICAgICAgICAgICAgIC8vIGNvbm5lY3RpbmcgdHdvIGlucHV0IGNvbm5lY3RvcnNcbiAgICAgICAgICAgICAgICB0aHJvdyAnQ2FuIG5vdCBwbGFjZSB3aXJlIGJldHdlZW4gdHdvIGlucHV0IGNvbm5lY3RvcnMnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzd2FwIHRoZW0gYW5kIHdlIGFyZSByZWFkeSB0byBnb1xuICAgICAgICAgICAgICAgIFt0aGlzLmNvbm5lY3Rpb24uZnJvbSwgdGhpcy5jb25uZWN0aW9uLnRvXSA9IFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLnRvLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24uZnJvbVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm91dGUpIHtcbiAgICAgICAgICAgIHRoaXMucm91dGVXaXJlKHRydWUsIHJlZnJlc2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50ZW1wb3JhcnlXaXJlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVsZW1lbnRTdGF0ZSA9IExvZ2ljLnN0YXRlLnVua25vd247XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh0aGlzLmNvbm5lY3Rpb24uZnJvbS5jb25uZWN0b3Iuc3RhdGUpO1xuXG4gICAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGNvbm5lY3RvciB9ID0gdGhpcy5jb25uZWN0aW9uLnRvO1xuICAgICAgICAgICAgdGhpcy5hcHBJbnN0YW5jZS5zdGFydE5ld1NpbXVsYXRpb24oY29ubmVjdG9yLCBjb25uZWN0b3Iuc3RhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdmdPYmouJGVsLmFkZENsYXNzKCd3aXJlJyk7XG4gICAgfVxuXG4gICAgZ2V0IGJveGVzKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuY29ubmVjdGlvbi5mcm9tLmJveCwgdGhpcy5jb25uZWN0aW9uLnRvLmJveF07XG4gICAgfVxuXG4gICAgZ2V0IGNvbm5lY3RvcnMoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5jb25uZWN0aW9uLmZyb20uY29ubmVjdG9yLCB0aGlzLmNvbm5lY3Rpb24udG8uY29ubmVjdG9yXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgZGF0YSBvZiB0aGlzIHdpcmUgYXMgYSBKU09OLXJlYWR5IG9iamVjdFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gamF2YXNjcmlwdCBvYmplY3QgY29udGFpbmluZyBlc3NlbnRpYWwgZGF0YSBmb3IgdGhpcyB3aXJlXG4gICAgICovXG4gICAgZ2V0IGV4cG9ydERhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmcm9tSWQ6IHRoaXMuY29ubmVjdGlvbi5mcm9tLmlkLFxuICAgICAgICAgICAgdG9JZDogdGhpcy5jb25uZWN0aW9uLnRvLmlkXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0IHRoZSBzdGF0ZSBvZiB0aGlzIHdpcmUgdG8gbWF0Y2ggdGhlIHN0YXRlIG9mIHRoZSBpbnB1dCBjb25uZWN0b3IgaXQgaXMgY29ubmVjdGVkIHRvXG4gICAgICogQHBhcmFtIHtMb2dpYy5zdGF0ZX0gc3RhdGUgW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgIHNldFN0YXRlKHN0YXRlKSB7XG4gICAgICAgIHRoaXMuc3ZnT2JqLnJlbW92ZUNsYXNzZXMoLi4uc3RhdGVDbGFzc2VzKTtcbiAgICAgICAgdGhpcy5zdmdPYmouYWRkQ2xhc3Moc3RhdGVDbGFzc2VzW3N0YXRlXSk7XG5cbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLnRvLmNvbm5lY3Rvci5zZXRTdGF0ZShzdGF0ZSk7XG5cbiAgICAgICAgdGhpcy5lbGVtZW50U3RhdGUgPSBzdGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIGN1cnJlbnQgW0xvZ2ljLnN0YXRlXSguL21vZHVsZXMtTG9naWMuaHRtbCMuc3RhdGUpIG9mIHRoaXMgd2lyZVxuICAgICAqIEByZXR1cm4ge0xvZ2ljLnN0YXRlfVxuICAgICAqL1xuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudFN0YXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSB0aGUgc3RhdGUgb2YgdGhpcyB3aXJlXG4gICAgICovXG4gICAgdXBkYXRlV2lyZVN0YXRlKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGJveCBvZiB0aGlzLmJveGVzKSB7XG4gICAgICAgICAgICBib3gucmVmcmVzaFN0YXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIGpRdWVyeSBlbGVtZW50IGZvciB0aGlzIHdpcmVcbiAgICAgKiBAcmV0dXJuIHtqUXVlcnkuZWxlbWVudH1cbiAgICAgKi9cbiAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN2Z09iai5nZXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIFBvbHlMaW5lIHBvaW50cyBmb3IgYSB0ZW1wb3Jhcnkgd2lyZSBwbGFjZW1lbnQgY29ubmVjdGluZyB0aGUgdHdvIGNvbm5lY3RvcnNcbiAgICAgKiBAcmV0dXJuIHtQb2x5TGluZVBvaW50c30gbmV3IGluc3RhbmNlIG9mIHtAbGluayBQb2x5TGluZVBvaW50c31cbiAgICAgKi9cbiAgICBnZXRUZW1wb3JhcnlXaXJlUG9pbnRzKCkge1xuICAgICAgICBsZXQgcG9pbnRzID0gbmV3IFBvbHlMaW5lUG9pbnRzKCk7XG4gICAgICAgIHBvaW50cy5hcHBlbmQobmV3IFBvbHlMaW5lUG9pbnQodGhpcy53aXJlU3RhcnQueCwgdGhpcy53aXJlU3RhcnQueSkpO1xuICAgICAgICBwb2ludHMuYXBwZW5kKG5ldyBQb2x5TGluZVBvaW50KHRoaXMud2lyZUVuZC54LCB0aGlzLndpcmVFbmQueSkpO1xuICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJvdXRlIHRoZSB3aXJlIHVzaW5nIHRoZSB0ZW1wb3Jhcnkgd2lyZSBwb2ludHNcbiAgICAgKi9cbiAgICB0ZW1wb3JhcnlXaXJlKCkge1xuICAgICAgICB0aGlzLndpcmVTdGFydCA9IHRoaXMuYXBwSW5zdGFuY2UuZ2V0Q29ubmVjdG9yUG9zaXRpb24oXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24uZnJvbS5jb25uZWN0b3IsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgICB0aGlzLndpcmVFbmQgPSB0aGlzLmFwcEluc3RhbmNlLmdldENvbm5lY3RvclBvc2l0aW9uKHRoaXMuY29ubmVjdGlvbi50by5jb25uZWN0b3IsIGZhbHNlKTtcblxuICAgICAgICB0aGlzLnNldFdpcmVQYXRoKHRoaXMuZ2V0VGVtcG9yYXJ5V2lyZVBvaW50cygpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByb3V0ZSB0aGUgd2lyZSB1c2luZyB0aGUgbW9kaWZpZWQgQSogd2lyZSByb3V0aW5nIGFsZ29yaXRobVxuICAgICAqL1xuICAgIHJvdXRlV2lyZShzbmFwVG9HcmlkID0gdHJ1ZSwgcmVmcmVzaCA9IHRydWUpIHtcbiAgICAgICAgdGhpcy53aXJlU3RhcnQgPSB0aGlzLmFwcEluc3RhbmNlLmdldENvbm5lY3RvclBvc2l0aW9uKFxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLmZyb20uY29ubmVjdG9yLFxuICAgICAgICAgICAgc25hcFRvR3JpZFxuICAgICAgICApO1xuICAgICAgICB0aGlzLndpcmVFbmQgPSB0aGlzLmFwcEluc3RhbmNlLmdldENvbm5lY3RvclBvc2l0aW9uKFxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLnRvLmNvbm5lY3RvcixcbiAgICAgICAgICAgIHNuYXBUb0dyaWRcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnBvaW50cyA9IHRoaXMuZmluZFJvdXRlKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHg6IHRoaXMud2lyZVN0YXJ0LnggLyB0aGlzLmdyaWRTaXplLFxuICAgICAgICAgICAgICAgIHk6IHRoaXMud2lyZVN0YXJ0LnkgLyB0aGlzLmdyaWRTaXplXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHg6IHRoaXMud2lyZUVuZC54IC8gdGhpcy5ncmlkU2l6ZSxcbiAgICAgICAgICAgICAgICB5OiB0aGlzLndpcmVFbmQueSAvIHRoaXMuZ3JpZFNpemVcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnNldFdpcmVQYXRoKHRoaXMucG9pbnRzKTtcblxuICAgICAgICBpZiAocmVmcmVzaCkgdGhpcy51cGRhdGVXaXJlU3RhdGUoKTtcblxuICAgICAgICAvLyByZWdlbmVyYXRlIGluY29udmVuaWVudCBub2Rlc1xuICAgICAgICB0aGlzLmdlbmVyYXRlSW5jb252ZW5pZW50Tm9kZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdGhlIHdpcmUgdG8gZm9sbG93IHRoZSBzcGVjaWZpZWQgcG9pbnRzXG4gICAgICogQHBhcmFtIHtQb2x5TGluZVBvaW50c30gcG9pbnRzIGluc3RhbmNlIG9mIHtAbGluayBQb2x5TGluZVBvaW50c31cbiAgICAgKi9cbiAgICBzZXRXaXJlUGF0aChwb2ludHMpIHtcbiAgICAgICAgLy8gc2V0IHRoZSBsaW5lXG4gICAgICAgIGlmICh0aGlzLnN2Z09iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyB0aGlzLnN2Z09iai51cGRhdGVQb2ludHMocG9pbnRzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuc3ZnT2JqLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQudXBkYXRlUG9pbnRzKHBvaW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN2Z09iaiA9IG5ldyBHcm91cCgpO1xuXG4gICAgICAgICAgICBsZXQgaGl0Ym94ID0gbmV3IFBvbHlMaW5lKHBvaW50cywgMTAsICd3aGl0ZScpO1xuICAgICAgICAgICAgaGl0Ym94LmFkZENsYXNzKCdoaXRib3gnKTtcbiAgICAgICAgICAgIGhpdGJveC5hZGRBdHRyKHsgb3BhY2l0eTogMCB9KTtcbiAgICAgICAgICAgIHRoaXMuc3ZnT2JqLmFkZENoaWxkKGhpdGJveCk7XG5cbiAgICAgICAgICAgIGxldCBtYWluTGluZSA9IG5ldyBQb2x5TGluZShwb2ludHMsIDIpO1xuICAgICAgICAgICAgbWFpbkxpbmUuYWRkQ2xhc3MoJ21haW4nLCAnc3RhdGVVbmtub3duJyk7XG4gICAgICAgICAgICB0aGlzLnN2Z09iai5hZGRDaGlsZChtYWluTGluZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYXRoVG9Qb2x5TGluZShwYXRoKSB7XG4gICAgICAgIGxldCB0b3RhbFBhdGggPSBuZXcgUG9seUxpbmVQb2ludHMoKTtcbiAgICAgICAgZm9yIChjb25zdCBwb2ludCBvZiBwYXRoKSB7XG4gICAgICAgICAgICB0b3RhbFBhdGguYXBwZW5kKG5ldyBQb2x5TGluZVBvaW50KHBvaW50LnggKiB0aGlzLmdyaWRTaXplLCBwb2ludC55ICogdGhpcy5ncmlkU2l6ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbFBhdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZmluZCBhIG5pY2Ugcm91dGUgZm9yIHRoZSB3aXJlXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBzdGFydCBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWAgdGhhdCByZXByZXNlbnQgdGhlIGZpcnN0IGVuZHBvaW50IG9mIHRoZSB3aXJlIGluIGdyaWQgcGl4ZWxcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGVuZCAgIG9iamVjdCBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YCB0aGF0IHJlcHJlc2VudCB0aGUgc2Vjb25kIGVuZHBvaW50IG9mIHRoZSB3aXJlIGluIGdyaWQgcGl4ZWxzXG4gICAgICogQHJldHVybiB7UG9seUxpbmVQb2ludHN9ICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICBmaW5kUm91dGUoc3RhcnQsIGVuZCkge1xuICAgICAgICBsZXQgbm9uUm91dGFibGUgPSB0aGlzLmFwcEluc3RhbmNlLmdldE5vblJvdXRhYmxlTm9kZXMoKTtcblxuICAgICAgICBsZXQgcHVuaXNoZWRCdXRSb3V0YWJsZTtcbiAgICAgICAgaWYgKHRoaXMuc3ZnT2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHB1bmlzaGVkQnV0Um91dGFibGUgPSB0aGlzLmFwcEluc3RhbmNlLmdldEluY29udmVuaWVudE5vZGVzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwdW5pc2hlZEJ1dFJvdXRhYmxlID0gdGhpcy5hcHBJbnN0YW5jZS5nZXRJbmNvbnZlbmllbnROb2Rlcyh0aGlzLnN2Z09iai5pZCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcGF0aCA9IGZpbmRQYXRoKHN0YXJ0LCBlbmQsIG5vblJvdXRhYmxlLCBwdW5pc2hlZEJ1dFJvdXRhYmxlLCB0aGlzLmdyaWRTaXplKTtcblxuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGF0aFRvUG9seUxpbmUocGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBhIHBhdGggd2FzIG5vdCBmb3VuZCwgdHJ5IGFnYWluIGJ1dCBkb24ndCB0YWtlIGludG8gYWNjb3VudCB0aGUgcHVuaXNoZWQgYW5kIG5vbiByb3V0YWJsZSBub2RlXG4gICAgICAgIHBhdGggPSBmaW5kUGF0aChzdGFydCwgZW5kLCBuZXcgU2V0KCksIG5ldyBTZXQoKSwgdGhpcy5ncmlkU2l6ZSk7XG5cbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhdGhUb1BvbHlMaW5lKHBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIHBhdGggd2FzIHN0aWxsIG5vdCBmb3VuZCwgZ2l2ZSB1cCBhbmQgcmV0dXJuIHRlbXBvcmFyeSBwb2ludHNcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGVtcG9yYXJ5V2lyZVBvaW50cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdlbmVyYXRlIGEgc2V0IG9mIG5vZGVzLCB0aGF0IGFyZSBpbmNvbnZlbmllbnQgZm9yIHdpcmluZywgYnV0IGNhbiBiZSB1c2VkLCBqdXN0IGFyZSBub3QgcHJlZmVycmVkXG4gICAgICogQHJldHVybiB7U2V0fSBzZXQgb2Ygbm9kZXMgKG9iamVjdHMgY29udGFpbmluZyB4IGFuZCB5IGNvb3JkaW5hdGVzKSB0aGF0IGFyZSBub3QgcHJlZmVycmVkIGZvciB3aXJpbmdcbiAgICAgKi9cbiAgICBnZW5lcmF0ZUluY29udmVuaWVudE5vZGVzKCkge1xuICAgICAgICB0aGlzLmluY29udmVuaWVudE5vZGVzID0gbmV3IFNldCgpO1xuXG4gICAgICAgIGxldCBwcmV2UG9pbnQ7XG5cbiAgICAgICAgdGhpcy5wb2ludHMuZm9yRWFjaChwb2ludCA9PiB7XG4gICAgICAgICAgICBjb25zdCB4ID0gdGhpcy5hcHBJbnN0YW5jZS5TVkdUb0dyaWQocG9pbnQueCksXG4gICAgICAgICAgICAgICAgeSA9IHRoaXMuYXBwSW5zdGFuY2UuU1ZHVG9HcmlkKHBvaW50LnkpO1xuXG4gICAgICAgICAgICBpZiAocHJldlBvaW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcHJldlBvaW50IGlzIHVuZGVmaW5lZCwgYWRkIHRoZSBmaXJzdCBwb2ludFxuICAgICAgICAgICAgICAgIHRoaXMuaW5jb252ZW5pZW50Tm9kZXMuYWRkKHsgeCwgeSB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZWxzZSBhZGQgYWxsIHRoZSBwb2ludCBiZXR3ZWVuIHRoZSBwcmV2UG9pbnQgKGV4Y2x1ZGVkKSBhbmQgcG9pbnQgKGluY2x1ZGVkKVxuXG4gICAgICAgICAgICAgICAgaWYgKHByZXZQb2ludC54ID09PSB4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBsaW5lIGlzIGhvcml6b250YWxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1pbihwcmV2UG9pbnQueSwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0byA9IE1hdGgubWF4KHByZXZQb2ludC55LCB5KTtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZnJvbSA8PSB0bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmNvbnZlbmllbnROb2Rlcy5hZGQoeyB4OiB4LCB5OiBmcm9tIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2UG9pbnQueSA9PT0geSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbGluZSBpcyB2ZXJ0aWNhbFxuICAgICAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWluKHByZXZQb2ludC54LCB4KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvID0gTWF0aC5tYXgocHJldlBvaW50LngsIHgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChmcm9tIDw9IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluY29udmVuaWVudE5vZGVzLmFkZCh7IHg6IGZyb20sIHk6IHkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBsaW5lIGlzIG5laXRoZXIgaG9yaXpvbnRhbCBub3IgdmVydGljYWwsIHRocm93IGFuIGVycm9yIGZvciBiZXR0ZXIgZnV0dXJlIGRlYnVnZ2luZ1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKFwiZ2V0SW5jb252ZW5pZW50Tm9kZXM6IGxpbmUgYmV0d2VlbiB0d28gcG9pbnRzIGlzIG5laXRoZXIgaG9yaXpvbnRhbCBub3IgdmVydGljYWxcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZXQgbmV3IHByZXZQb2ludFxuICAgICAgICAgICAgcHJldlBvaW50ID0geyB4LCB5IH07XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsImltcG9ydCBMb2dpYyBmcm9tICcuLi9Mb2dpYyc7XG5cbi8qKlxuICogbWFwcGluZyBvZiBsb2dpY2FsIHN0YXRlcyB0byBjc3MgY2xhc3Nlc1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuXG5sZXQgbWFwID0gW107IC8vIGFycmF5IHNvIHdlIGNhbiB1c2UgdGhlIC4uLnNwcmVhZCBvcGVyYXRvclxuXG5tYXBbTG9naWMuc3RhdGUub25dID0gJ3N0YXRlT24nO1xubWFwW0xvZ2ljLnN0YXRlLm9mZl0gPSAnc3RhdGVPZmYnO1xubWFwW0xvZ2ljLnN0YXRlLnVua25vd25dID0gJ3N0YXRlVW5rbm93bic7XG5tYXBbTG9naWMuc3RhdGUub3NjaWxsYXRpbmddID0gJ3N0YXRlT3NjaWxsYXRpbmcnO1xuXG5leHBvcnQgZGVmYXVsdCBtYXA7XG4iLCJpbXBvcnQgeyBtYW5oYXR0YW5EaXN0YW5jZSB9IGZyb20gJy4vb3RoZXIvaGVscGVyRnVuY3Rpb25zJztcbmltcG9ydCBNYXBXaXRoRGVmYXVsdFZhbHVlIGZyb20gJy4vb3RoZXIvbWFwV2l0aERlZmF1bHRWYWx1ZSc7XG5cbmltcG9ydCB7IFByaW9yaXR5UXVldWUgfSBmcm9tICdsaWJzdGwnOyAvLyBub3RlOiBpbXBvcnRlZCBmcm9tIGEgbm9kZSBtb2R1bGVcblxuLyoqIEBtb2R1bGUgZmluZFBhdGggKi9cblxuLyoqXG4gKiBIZWF2aWx5IG1vZGlmaWVkIGltcGxlbWVudGF0aW9uIG9mIHRoZSBBKiBhbGdvcml0aG1cbiAqIEBwYXJhbSAge09iamVjdH0gc3RhcnQgb2JqZWN0IGNvbnRhaW5pbmcgbnVtZXJpYyBhdHRyaWJ1dGVzIGB4YCBhbmQgYHlgIHRoYXQgcmVwcmVzZW50IHRoZSBmaXJzdCBlbmRwb2ludCBvZiB0aGUgd2lyZSBpbiBncmlkIHBpeGVsc1xuICogQHBhcmFtICB7T2JqZWN0fSBlbmQgICBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWAgdGhhdCByZXByZXNlbnQgdGhlIHNlY29uZCBlbmRwb2ludCBvZiB0aGUgd2lyZSBpbiBncmlkIHBpeGVsc1xuICogQHBhcmFtICB7U2V0fSBub25Sb3V0YWJsZSBzZXQgb2Ygbm9uIHJvdXRhYmxlIG5vZGVzXG4gKiBAcGFyYW0gIHtTZXR9IHB1bmlzaGVkQnV0Um91dGFibGUgc2V0IG9mIG5vZGVzIHRoYXQgYXJlIG5vdCBvcHRpbWFsIGZvciByb3V0aW5nXG4gKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmaW5kUGF0aChzdGFydCwgZW5kLCBub25Sb3V0YWJsZSwgcHVuaXNoZWRCdXRSb3V0YWJsZSkge1xuICAgIGNvbnN0IGRpc3RhbmNlRnVuY3Rpb24gPSBtYW5oYXR0YW5EaXN0YW5jZTtcblxuICAgIGNvbnN0IHdpcmVDcm9zc1B1bmlzaG1lbnQgPSAxO1xuICAgIGNvbnN0IHdpcmVCZW5kUHVuaXNobWVudCA9IDE7XG5cbiAgICAvLyBudW1iZXIgb2Ygbm9kZXMsIHRoYXQgY2FuIGJlIG9wZW5lZCBhdCBvbmNlXG4gICAgLy8gb25jZSBpcyB0aGlzIGxpbWl0IGV4Y2VlZGVkLCBhU3RhciB3aWxsIGZhaWwgYW5kIHJldHVybiB1bmRlZmluZWRcbiAgICBjb25zdCBtYXhOb2RlTGltaXQgPSAxMDAwMDA7XG5cbiAgICBsZXQgY2xvc2VkTm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgbGV0IG9wZW5Ob2RlcyA9IG5ldyBTZXQoKTtcbiAgICBsZXQgb3Blbk5vZGVRdWV1ZSA9IG5ldyBQcmlvcml0eVF1ZXVlKCk7XG5cbiAgICAvLyBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBvcGVuIG5vZGVzOlxuXG4gICAgLyoqXG4gICAgICogYWRkIGEgbmV3IG9wZW4gbm9kZSB0byB0aGUgc3RydWN0dXJlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgICBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWAgdGhhdCByZXByZXNlbnQgdGhlIGZpcnN0IGVuZHBvaW50IG9mIHRoZSB3aXJlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZzY29yZSBmU2NvcmUgb2YgdGhpcyBub2RlXG4gICAgICovXG4gICAgY29uc3QgYWRkT3Blbk5vZGUgPSAobm9kZSwgZnNjb3JlKSA9PiB7XG4gICAgICAgIG9wZW5Ob2Rlcy5hZGQobm9kZSk7XG4gICAgICAgIC8vIGZsaXAgdGhlIGZzY29yZSwgYmVjYXVzZSBQcmlvcml0eVF1ZXVlIHVzZXMgbWF4IGhlYXBcbiAgICAgICAgb3Blbk5vZGVRdWV1ZS5lbnF1ZXVlKG5vZGUsIDEgLyBmc2NvcmUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIG9wZW4gbm9kZSB3aXRoIHRoZSBsb3dlc3QgZlNjb3JlIGFuZCByZW1vdmUgaXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YCB0aGF0IHJlcHJlc2VudCB0aGUgZmlyc3QgZW5kcG9pbnQgb2YgdGhlIHdpcmVcbiAgICAgKi9cbiAgICBjb25zdCBnZXRPcGVuTm9kZSA9ICgpID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG9wZW5Ob2RlUXVldWUuZGVxdWV1ZSgpO1xuICAgICAgICBvcGVuTm9kZXMuZGVsZXRlKG5vZGUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuXG4gICAgbGV0IGNhbWVGcm9tID0gbmV3IE1hcCgpO1xuXG4gICAgLy8gZGVmYXVsdCB2YWx1ZTogaW5maW5pdHlcbiAgICBsZXQgZ1Njb3JlID0gbmV3IE1hcFdpdGhEZWZhdWx0VmFsdWUoSW5maW5pdHkpO1xuICAgIGdTY29yZS5zZXQoc3RhcnQsIDApO1xuXG4gICAgbGV0IHN0YXJ0RlNjb3JlID0gZGlzdGFuY2VGdW5jdGlvbihzdGFydCwgZW5kKTtcblxuICAgIGFkZE9wZW5Ob2RlKHN0YXJ0LCBzdGFydEZTY29yZSk7XG5cbiAgICBvcGVuTm9kZXMuYWRkKHN0YXJ0KTtcbiAgICBvcGVuTm9kZVF1ZXVlLmVucXVldWUoc3RhcnQsIDEgLyBzdGFydEZTY29yZSk7XG5cbiAgICB3aGlsZSAob3Blbk5vZGVzLnNpemUgPiAwKSB7XG4gICAgICAgIC8vIGdldCB0aGUgdmFsdWUgZnJvbSBvcGVuTm9kZXMgdGhhdCBoYXMgdGhlIGxvd2VzdCBmU2NvcmVcbiAgICAgICAgY29uc3QgY3VycmVudE5vZGUgPSBnZXRPcGVuTm9kZSgpO1xuXG4gICAgICAgIC8vIGlmIHdlIHJlYWNoZWQgdGhlIGVuZCBwb2ludCwgcmVjb25zdHJ1Y3QgdGhlIHBhdGggYW5kIHJldHVybiBpdFxuICAgICAgICBpZiAoY3VycmVudE5vZGUueCA9PSBlbmQueCAmJiBjdXJyZW50Tm9kZS55ID09IGVuZC55KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjb25zdHJ1Y3RQYXRoKGNhbWVGcm9tLCBjdXJyZW50Tm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgdGhpcyBub2RlIHRvIHRoZSBjbG9zZWQgbm9kZXNcbiAgICAgICAgY2xvc2VkTm9kZXMuYWRkKGN1cnJlbnROb2RlKTtcblxuICAgICAgICAvLyB0aGUgZmFydGhlc3QgcG9pbnRzIGFjY2Vzc2libGUgd2l0aG91dCBhdm9pZGluZyBvYnN0YWNsZXMgaW4gZXZlcnkgZGlyZWN0aW9uXG4gICAgICAgIC8vIChidXQgbWF4IDUwIGluIGVhY2ggZGlyZWN0aW9uKVxuICAgICAgICBmb3IgKGxldCBkaXJlY3Rpb24gPSAwOyBkaXJlY3Rpb24gPCA0OyBkaXJlY3Rpb24rKykge1xuICAgICAgICAgICAgbGV0IG5ld1BvaW50ID0gbW92ZVBvaW50KGN1cnJlbnROb2RlLCBkaXJlY3Rpb24pO1xuXG4gICAgICAgICAgICBsZXQgd2lyZXNDcm9zc2VkID0gMDtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1MDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgbmV3UG9pbnQgaXMgaW4gdGhlIHNldCBvZiBub24gcm91dGFibGUgcG9pbnRzLFxuICAgICAgICAgICAgICAgIC8vIGRvbid0IGFkZCBpdCBhbmQgc3RvcCBwcm9jZWVkaW5nIGluIHRoaXMgZGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHNldEhhc1RoaXNQb2ludChub25Sb3V0YWJsZSwgbmV3UG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgbm90IHRoZSBlbmQgb3Igc3RhcnQgcG9pbnQsIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICEobmV3UG9pbnQueCA9PT0gZW5kLnggJiYgbmV3UG9pbnQueSA9PT0gZW5kLnkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhKG5ld1BvaW50LnggPT09IHN0YXJ0LnggJiYgbmV3UG9pbnQueSA9PT0gc3RhcnQueSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHNraXAgdGhpcyBub2RlLCBpZiBpdCBoYXMgYmVlbiBhbHJlYWR5IGNsb3NlZFxuICAgICAgICAgICAgICAgIC8vIG9yIGlmIGl0IGlzIG9uIHRoZSBsaXN0IG9mIG5vbiByb3V0YWJsZSBub2Rlc1xuICAgICAgICAgICAgICAgIGlmIChjbG9zZWROb2Rlcy5oYXMobmV3UG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBwb3NzaWJsZSBHU2NvcmUgYnkgYXBwbHlpbmcgYSBwdW5pc2htZW50IGZvciBlYWNoIG5vZGUgKFwiYmVuZFwiKSBpbiB0aGUgcGF0aFxuICAgICAgICAgICAgICAgIGxldCBuZXdHU2NvcmUgPSB3aXJlQmVuZFB1bmlzaG1lbnQgKyBnU2NvcmUuZ2V0V2l0aERlZmF1bHQoY3VycmVudE5vZGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNldEhhc1RoaXNQb2ludChwdW5pc2hlZEJ1dFJvdXRhYmxlLCBuZXdQb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIG5vZGUgaXMgaW4gdGhlIHNldCBvZiBwdW5pc2hlZCBub2RlcywgYXBwbHkgdGhlIHB1bmlzaG1lbnRcbiAgICAgICAgICAgICAgICAgICAgd2lyZXNDcm9zc2VkKys7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYXBwbHkgdGhlIHB1bmlzaG1lbnQgZm9yIGVhY2ggd2lyZSBjcm9zc2VkIGluIHRoaXMgZGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgLy8gbm90ZTogd2UgYXJlIGNvdW50aW5nIHRoZSB3aXJlcyBjcm9zc2VkIHdoZW4gZXhwb3J0aW5nIHRoaXMgZGlyZWN0aW9uLCBub3QgdGhlIHdpcmVzXG4gICAgICAgICAgICAgICAgLy8gY3Jvc3NlZCBpbiB0aGUgZmluYWwgcGF0aCwgdGhlcmUgd2lsbCBiZSBwcm9iYWJseSBvbmx5IGF0IG1vc3Qgb2YgdGhlc2Ugbm9kZXMgaW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gZmluYWwgcGF0aCwgbm90IG11bHRpcGxlXG4gICAgICAgICAgICAgICAgbmV3R1Njb3JlICs9IHdpcmVzQ3Jvc3NlZCAqIHdpcmVDcm9zc1B1bmlzaG1lbnQ7XG5cbiAgICAgICAgICAgICAgICAvLyBza2lwIHRoaXMgbm9kZSBpZiBpdCBoYXMgd29yc3QgZXN0aW1hZ2UgZ3Njb3JlIHRoYW4gaW4gdGhlIGdzY29yZSB0YWJsZVxuICAgICAgICAgICAgICAgIGlmIChuZXdHU2NvcmUgPj0gZ1Njb3JlLmdldFdpdGhEZWZhdWx0KG5ld1BvaW50KSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjYW1lRnJvbS5zZXQobmV3UG9pbnQsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgICAgICBnU2NvcmUuc2V0KG5ld1BvaW50LCBuZXdHU2NvcmUpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RlNjb3JlID0gbmV3R1Njb3JlICsgZGlzdGFuY2VGdW5jdGlvbihuZXdQb2ludCwgZW5kKTtcblxuICAgICAgICAgICAgICAgIGlmICghb3Blbk5vZGVzLmhhcyhuZXdQb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBwb2ludCB0byB0aGUgbGlzdCBvZiBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgYWRkT3Blbk5vZGUobmV3UG9pbnQsIG5ld0ZTY29yZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0byB0aGUgbmV4dCBwb2ludCBpbiB0aGUgZGlyZWNpdG9uXG4gICAgICAgICAgICAgICAgbmV3UG9pbnQgPSBtb3ZlUG9pbnQobmV3UG9pbnQsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3Blbk5vZGVzLnNpemUgPiBtYXhOb2RlTGltaXQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIGBhU3RhcjogTnVtYmVyIG9mIG9wZW4gbm9kZXMgKCR7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5Ob2Rlcy5zaXplXG4gICAgICAgICAgICAgICAgfSkgZXhjZWVkZWQgdGhlIGxpbWl0IGZvciBvcGVuIG5vZGVzICgke21heE5vZGVMaW1pdH0pLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiB3ZSBnb3QgaGVyZSwgdGhlIHBhdGggd2FzIG5vdCBmb3VuZFxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiByZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3BlY2lmaWVkIHNldCBvZiBwb2ludHMgY29udGFpbnMgdGhlIHNwZWNpZmllZCBwb2ludCAoYW5kIHJldHVybnMgYGZhbHNlYCBvdGhlcndpc2UpXG4gKiBAcGFyYW0ge1NldH0gc2V0IHNldCBvZiBwb2ludHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludCBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWBcbiAqL1xuZnVuY3Rpb24gc2V0SGFzVGhpc1BvaW50KHNldCwgcG9pbnQpIHtcbiAgICBmb3IgKGxldCBpdGVtIG9mIHNldCkge1xuICAgICAgICBpZiAoaXRlbS54ID09PSBwb2ludC54ICYmIGl0ZW0ueSA9PT0gcG9pbnQueSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IG1vdmVzIHRoZSBwYXNzZWQgcG9pbnQgaW4gdGhlIHNwZWNpZmllZCBkaXJlY3Rpb24uIEl0IHNpbXBseSBhZGRzIG9yIHN1YnRyYWN0cyAxIGZyb20gb25lIG9mIHRoZSBjb29yZGluYXRlcyBkZXBlbmRpbmcgb24gdGhlIGRpcmVjdGlvbiBhdHRyaWJ1dGUuXG4gKiBAcGFyYW0gIHtPYmplY3R9IHBvaW50ICAgICBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWBcbiAqIEBwYXJhbSAge251bWJlcn0gZGlyZWN0aW9uIGRpcmVjdGlvbnM6XG4gKiAgICAgLSAwOiB1cFxuICogICAgIC0gMTogcmlnaHRcbiAqICAgICAtIDI6IGRvd25cbiAqICAgICAtIDM6IGxlZnRcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgIG9iamVjdCBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YFxuICovXG5mdW5jdGlvbiBtb3ZlUG9pbnQoeyB4LCB5IH0sIGRpcmVjdGlvbikge1xuICAgIC8vIG1hcCBkaXJlY3Rpb24gZG8gcG9pbnQgY29vcmRpbmF0ZSBtb2RpZmljYXRpb25cbiAgICBjb25zdCBkaXJNYXAgPSB7XG4gICAgICAgIDA6ICgpID0+IHtcbiAgICAgICAgICAgIHkgLT0gMTtcbiAgICAgICAgfSxcbiAgICAgICAgMTogKCkgPT4ge1xuICAgICAgICAgICAgeCArPSAxO1xuICAgICAgICB9LFxuICAgICAgICAyOiAoKSA9PiB7XG4gICAgICAgICAgICB5ICs9IDE7XG4gICAgICAgIH0sXG4gICAgICAgIDM6ICgpID0+IHtcbiAgICAgICAgICAgIHggLT0gMTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBkaXJNYXBbZGlyZWN0aW9uXSgpO1xuXG4gICAgcmV0dXJuIHsgeCwgeSB9O1xufVxuXG4vKipcbiAqIGhlbHBlciBiYWNrdHJhY2tpbmcgZnVuY3Rpb24gdXNlZCBieSB0aGUgYVN0YXIgYWxnb3JpdGhtIHRvIGNvbnN0cnVjdCB0aGUgZmluYWwgcGF0aFxuICogQHBhcmFtICB7T2JqZWN0fSBjYW1lRnJvbSAgICBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWBcbiAqIEBwYXJhbSAge09iamVjdH0gY3VycmVudE5vZGUgb2JqZWN0IGNvbnRhaW5pbmcgbnVtZXJpYyBhdHRyaWJ1dGVzIGB4YCBhbmQgYHlgXG4gKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YFxuICovXG5mdW5jdGlvbiByZWNvbnN0cnVjdFBhdGgoY2FtZUZyb20sIGN1cnJlbnROb2RlKSB7XG4gICAgbGV0IHBhdGggPSBbXTtcblxuICAgIHBhdGgucHVzaCh7XG4gICAgICAgIHg6IGN1cnJlbnROb2RlLngsXG4gICAgICAgIHk6IGN1cnJlbnROb2RlLnlcbiAgICB9KTtcblxuICAgIHdoaWxlIChjYW1lRnJvbS5oYXMoY3VycmVudE5vZGUpKSB7XG4gICAgICAgIGN1cnJlbnROb2RlID0gY2FtZUZyb20uZ2V0KGN1cnJlbnROb2RlKTtcbiAgICAgICAgcGF0aC5wdXNoKHtcbiAgICAgICAgICAgIHg6IGN1cnJlbnROb2RlLngsXG4gICAgICAgICAgICB5OiBjdXJyZW50Tm9kZS55XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIEhlbHBlckZ1bmN0aW9uc1xuICovXG5cbmltcG9ydCBzdHJpbmdpZnkgZnJvbSAnanNvbi1zdHJpbmdpZnktcHJldHR5LWNvbXBhY3QnOyAvLyBub3RlOiBpbXBvcnRlZCBmcm9tIGEgbW9kdWxlXG5cbi8qKlxuICogYWRkIGEgY3Jvc3MgYnJvd3NlciBldmVudCBsaXN0ZW5lciBvbiBhIG1vdXNlIHNjcm9sbFxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IERPTSBxdWVyeSBvZiB0aGUgZWxlbWVudCB0aGF0IHRoZSBsaXN0ZW5lciB3aWxsIGJlIGFkZGVkIHRvXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jICBGdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IG9jY3Vycy4gVGhlIGZ1bmN0aW9uIHRha2VzIGFzIGEgcGFyYW1ldGVyIGFuIGV2ZW50IG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZE1vdXNlU2Nyb2xsRXZlbnRMaXN0ZW5lcihxdWVyeSwgZnVuYykge1xuICAgIGxldCBNb3VzZVdoZWVsSGFuZGxlciA9IGV2ZW50ID0+IHtcbiAgICAgICAgLy8gcmVkZWNsYXJlIGZvciBvbGQgSUUgc3VwcG9ydFxuICAgICAgICB2YXIgZXZlbnQgPSB3aW5kb3cuZXZlbnQgfHwgZXZlbnQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVkZWNsYXJlXG5cbiAgICAgICAgZXZlbnQuZGVsdGEgPSBNYXRoLm1heCgtMSwgTWF0aC5taW4oMSwgZXZlbnQud2hlZWxEZWx0YSB8fCAtZXZlbnQuZGV0YWlsKSk7XG5cbiAgICAgICAgZnVuYyhldmVudCk7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBsZXQgc3ZnZWxlbWVudDtcblxuICAgIC8vIGlmIHRoZSBxdWVyeSBpcyBhIHNpbXBsZSBET00gaWQgc2VsZWN0b3IsIHdlIGNhbiB1c2UgZ2V0RWxlbWVudEJ5SWQgd2hpY2ggaGFzIGJldHRlciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgIGlmIChxdWVyeS5tYXRjaCgvXiNcXHcrJC8pKSB7XG4gICAgICAgIHN2Z2VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChxdWVyeS5zdWJzdHIoMSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN2Z2VsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHF1ZXJ5KTtcbiAgICB9XG5cbiAgICBpZiAoc3ZnZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIC8vIElFOSwgQ2hyb21lLCBTYWZhcmksIE9wZXJhXG4gICAgICAgIHN2Z2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIE1vdXNlV2hlZWxIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIC8vIEZpcmVmb3hcbiAgICAgICAgc3ZnZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIE1vdXNlV2hlZWxIYW5kbGVyLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSUUgNi83LzhcbiAgICAgICAgc3ZnZWxlbWVudC5hdHRhY2hFdmVudCgnb25tb3VzZXdoZWVsJywgTW91c2VXaGVlbEhhbmRsZXIpO1xuICAgIH1cbiAgICBzdmdlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICdtb3VzZXdoZWVsJyxcbiAgICAgICAgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2V2ZW50JywgZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZhbHNlXG4gICAgKTtcbn1cblxuLyoqXG4gKiBjb252ZXJ0IGEgZGF0YSBvYmplY3QgdG8gSlNPTiBzdHJpbmcgb3IgdG8gYSBkYXRhIFVSSSBjb250YWluaW5nIGEgSlNPTiBzdHJpbmdcbiAqIEBwYXJhbSAge09iamVjdH0gIGRhdGEgICAgICAgICAgICBvYmplY3QgdGhhdCB3aWxsIGJlIHNlcmlhbGl6ZWQgaW50byBhIEpTT04gc3RyaW5nXG4gKiBAcGFyYW0gIHtCb29sZWFufSBbcHJldHR5PWZhbHNlXSAgaWYgYHRydWVgLCB0aGUgY29kZSB3aWxsIGJlIHByb3ByZXJseSBpbmRlbnRlZCwgZWxzZSBhIG1vcmUgY29tcGFjdCBzeW50YXggd2lsbCBiZSB1c2VkXG4gKiBAcGFyYW0gIHtCb29sZWFufSBbZGF0YVVyaT1mYWxzZV0gcmV0dXJuIGRhdGFVcmkgY29udGFpbmluZyB0aGUgSlNPTiBzdHJpbmcgaW5zdGVhZCBvZiB0aGUgcHVyZSBKU09OIHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SlNPTlN0cmluZyhkYXRhLCBwcmV0dHkgPSBmYWxzZSwgZGF0YVVyaSA9IGZhbHNlKSB7XG4gICAgaWYgKGRhdGFVcmkpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICdkYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCwnICsgZW5jb2RlVVJJQ29tcG9uZW50KGdldEpTT05TdHJpbmcoZGF0YSwgcHJldHR5KSlcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJldHR5KSByZXR1cm4gc3RyaW5naWZ5KGRhdGEsIHsgbWF4TGVuZ3RoOiA1MCB9KTtcblxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgfVxufVxuXG4vKipcbiAqIHJldHVybnMgdGhlIE1hbmhhdHRhbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBwb2ludHMgX2FfIGFuZCBfYl9cbiAqIEBwYXJhbSAge09iamVjdH0gYSBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWBcbiAqIEBwYXJhbSAge09iamVjdH0gYiBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWBcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hbmhhdHRhbkRpc3RhbmNlKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoYS54IC0gYi54KSArIE1hdGguYWJzKGEueSAtIGIueSk7XG59XG4iLCIvKiogQG1vZHVsZSBJZCAqL1xuXG4vKipcbiAqIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIElkXG4gKiBAdHlwZSB7SWR9XG4gKi9cbmxldCBleGlzdGluZ0lkSW5zdGFuY2U7XG5cbi8qKlxuICogc2luZ2xldG9uIHRvIGdlbmVyYXRlIHVuaXF1ZSBpZCdzXG4gKlxuICogdXNhZ2U6IGBsZXQgaWQgPSBuZXcgSWQoKS51bmlxdWVgXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElkIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgaWYgKCFleGlzdGluZ0lkSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGV4aXN0aW5nSWRJbnN0YW5jZSA9IHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogcHJlZml4IGZvciB0aGUgaWQsIHRoYXQgaXMgY29tbW9uIGluIGFsbCB0aGUgSWRzXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZWZpeCA9ICdpZCc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG51bWVyaWMgcGFydCBvZiB0aGUgbmV4dCBpZCAodGhlIG5leHQgaWQgd2l0aG91dCB0aGUgcHJlZml4KVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZXh0SWQgPSAwO1xuXG4gICAgICAgIHJldHVybiBleGlzdGluZ0lkSW5zdGFuY2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHVuaXF1ZSBJRFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gbmV3IHVuaXF1ZSBJRFxuICAgICAqL1xuICAgIGdldCB1bmlxdWUoKSB7XG4gICAgICAgIGxldCByZXRWYWwgPSB0aGlzLnByZWZpeCArIHRoaXMubmV4dElkO1xuXG4gICAgICAgIC8vIGZpbmQgbmV4dCB1bnVzZWQgaWRYWFhYIHRvIHByZXZlbnQgaWQgY29sbGlzaW9uIHRoYXQgbWlnaHQgYmUgY2F1c2VkIGJ5IHNvbWUgb3RoZXIgY29tcG9uZW50XG4gICAgICAgIC8vIChpdCByZWFsbHkgc2hvdWxkIG5vdCBoYXBwZW4sIGJ1dCB0aGlzIGlzIGEgc2ltcGxlIHdheSB0byBlbnN1cmUgaXQpXG4gICAgICAgIHdoaWxlICgkKCcjJyArIHJldFZhbCkubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRJZCsrO1xuICAgICAgICAgICAgcmV0VmFsID0gdGhpcy5nZW5lcmF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJldHVybiB0aGlzIGlkXG4gICAgICAgIHRoaXMubmV4dElkKys7XG5cbiAgICAgICAgcmV0dXJuIHJldFZhbDtcbiAgICB9XG59XG4iLCIvKiogQG1vZHVsZSBNYXBXaXRoRGVmYXVsdFZhbHVlICovXG4vKipcbiAqIE1hcCB0aGF0IGhhcyBhIGRlZmF1bHQgdmFsdWUgc3BlY2lmaWVkIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBGb3IgdGhlIGNvbXBsZXRlIGRvY3VtZW50YXRpb24gb2YgdGhlIE1hcCBzZWUgW01hcCBpbiB0aGUgTUROIHdlYiBkb2NzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXApXG4gKlxuICogVXNhZ2U6XG4gKiBgYGBKYXZhU2NyaXB0XG4gbGV0IG15TWFwID0gbmV3IE1hcFdpdGhEZWZhdWx0VmFsdWUoSW5maW5pdHkpO1xuIGNvbnN0IHZhbHVlID0gbXlNYXAuZ2V0V2l0aERlZmF1bHQoa2V5KVxuIGBgYFxuICpcbiAqIF9Ob3RlOiBUaGlzIHZlcnNpb24gaXMgd3JpdHRlbiBzcGVjaWFsbHkgZm9yIEVTNiBjb21waWxlZCBpbnRvIEVTNS4gSW4gbm9uLWNvbXBpbGVkIEVTNiBpcyB0aGUgaW1wbGVtZW50YXRpb24gZmFyIG1vcmUgZWxlZ2FudDpfXG4gKlxuICogYGBgSmF2YVNjcmlwdFxuIGV4cG9ydCBjbGFzcyBNYXBXaXRoRGVmYXVsdFZhbHVlIGV4dGVuZHMgTWFwIHtcbiAgICAgY29uc3RydWN0b3IoZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgICB0aGlzLmRlZmF1bHQgPSBkZWZhdWx0VmFsdWU7XG4gICAgIH1cblxuICAgICBnZXQoa2V5KSB7XG4gICAgICAgICBpZih0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmdldChrZXkpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0O1xuICAgICAgICAgfVxuICAgICB9XG4gfWBgYFxuICogQGNsYXNzIE1hcFdpdGhEZWZhdWx0VmFsdWVcbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUge2FueX0gZGVmYXVsdCB2YWx1ZSB0aGF0IHdpbGwgYmUgcmV0dXJuZWQgd2hlbiB0aGUgcmVxdWVzdGVkIGtleSBpcyBub3QgZm91bmQgaW4gdGhlIG1hcFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkZWZhdWx0VmFsdWUpIHtcbiAgICBsZXQgbWFwID0gbmV3IE1hcCgpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge2FueX0ga2V5IGtleSBvZiBhIHJlcXVlc3RlZCBpdGVtXG4gICAgICogQHJldHVybiB7YW55fSB2YWx1ZSBvZiB0aGUgaXRlbSB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGtleSwgb3IgZGVmYXVsdFZhbHVlIGlmIHRoZSBrZXkgaXMgbm90IGZvdW5kIGluIHRoZSBtYXBcbiAgICAgKi9cbiAgICBtYXAuZ2V0V2l0aERlZmF1bHQgPSBrZXkgPT4ge1xuICAgICAgICByZXR1cm4gbWFwLmhhcyhrZXkpID8gbWFwLmdldChrZXkpIDogZGVmYXVsdFZhbHVlO1xuICAgIH07XG4gICAgcmV0dXJuIG1hcDtcbn1cbiIsIi8qKiBAbW9kdWxlIHN2Z09iamVjdHMgKi9cblxuLy8gbm9uLXN2ZyBjbGFzc2VzIHVzZWQgYXMgaGVscGVyc1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQb2x5TGluZVBvaW50IH0gZnJvbSAnLi9zdmdPYmplY3RzL1BvbHlMaW5lUG9pbnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQb2x5TGluZVBvaW50cyB9IGZyb20gJy4vc3ZnT2JqZWN0cy9Qb2x5TGluZVBvaW50cyc7XG5cbi8vIHZpcnR1YWwgc3ZnIGVsZW1lbnRzXG5leHBvcnQgeyBkZWZhdWx0IGFzIFBhdHRlcm4gfSBmcm9tICcuL3N2Z09iamVjdHMvUGF0dGVybic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEdyb3VwIH0gZnJvbSAnLi9zdmdPYmplY3RzL0dyb3VwJztcblxuLy8gXCJwaHlzaWNhbC90b3VjaGFibGVcIiBzdmcgZWxlbWVudHNcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUmVjdGFuZ2xlIH0gZnJvbSAnLi9zdmdPYmplY3RzL1JlY3RhbmdsZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFN2Z0ltYWdlIH0gZnJvbSAnLi9zdmdPYmplY3RzL1N2Z0ltYWdlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUG9seUxpbmUgfSBmcm9tICcuL3N2Z09iamVjdHMvUG9seUxpbmUnO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIFRleHQgfSBmcm9tICcuL3N2Z09iamVjdHMvVGV4dCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE11bHRpTGluZVRleHQgfSBmcm9tICcuL3N2Z09iamVjdHMvTXVsdGlMaW5lVGV4dCc7XG4iLCJpbXBvcnQgVGFnIGZyb20gJy4vVGFnJztcblxuLyoqIEBtb2R1bGUgc3ZnT2JqZWN0cy5Hcm91cCAqL1xuXG4vKipcbiAqIFNWRyBncm91cCwgdXNlZCBmb3IgZ3JvdXBpbmcgZWxlbWVudHMsIGZvciBleGFtcGxlIGEgZ2F0ZSBpcyByZXByZXNlbnRlZCBieSBtYW55IGVsZW1lbnRzIChyZWN0YW5nbGUsIGltYWdlLCBpbml2aXNpYmxlIGhpdGJveCByZWN0YW5nbGUuLi4pLFxuICogYnV0IGFsbCBvZiB0aGUgZWxlbWVudHMgbmVlZCB0byBiZSB0cmFuc2Zvcm1lZCB0b2dldGhlci4gVXNpbmcgZ3JvdXBzIHRoZSB0cmFuc2Zvcm0gcHJvcGVydHkgY2FuIGJlIHNldCBvbiB0aGUgZ3JvdXAgd2hpY2ggY29udGFpbnMgYWxsIHRoZSBlbGVtZW50cy5cbiAqIEBleHRlbmRzIFRhZ1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcm91cCBleHRlbmRzIFRhZyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdnJyk7XG5cbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFkZCBhbiBlbGVtZW50IHRvIHRoZSBncm91cFxuICAgICAqIEBwYXJhbSB7U3ZnRWxlbWVudH0gZWwgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFN2Z0VsZW1lbnR9XG4gICAgICovXG4gICAgYWRkQ2hpbGQoZWwpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGVsKTtcblxuICAgICAgICB0aGlzLiRlbC5hcHBlbmQoZWwuJGVsKTtcbiAgICAgICAgcmV0dXJuIGVsOyAvLyBwcm8gamVkbm9kdXNzaSBcImxldCByZWN0ID0gZy5hZGRDaGlsZChuZXcgUmVjdGFuZ2xlKC4uLlwiXG4gICAgfVxufVxuIiwiaW1wb3J0IFRhZyBmcm9tICcuL1RhZyc7XG5pbXBvcnQgVGV4dCBmcm9tICcuL1RleHQnO1xuXG4vKiogQG1vZHVsZSBzdmdPYmplY3RzLk11bHRpTGluZVRleHQgKi9cblxuLyoqXG4gKiBNdWx0aSBsaW5lIHRleHQgZWxlbWVudCBpbiBTVkdcbiAqXG4gKiBNdWx0aSBsaW5lIHRleHQgaXMgbm90IG5hdGl2ZWx5IHN1cHBvcnRlbmQgaW4gU1ZHIDEuMSxcbiAqIHRoZSB3b3JrYXJvdW5kIGlzIHRvIHVzZSB0aGUgPGZvcmVpZ25PYmplY3Q+IGVsZW1lbnQgYW5kIGRpc3BsYXlcbiAqIGEgSFRNTCBwYXJhZ3JhcGggaW5zaWRlIG9mIHRoZSBTVkcgZG9jdW1lbnQuXG4gKlxuICogQmVjYXVzZSB0aGlzIHRlY2huaXF1ZSBpcyBub3Qgc3VwcG9ydGVkIGJ5IGFsbCBvZiB0aGUgYnJvd3NlcnMsXG4gKiB0aGUgZm9yZWlnbk9iamVjdCBlbGVtZW50IGlzIHdyYXBwZWQgaW4gPHN3aXRjaD4sIHdoaWNoXG4gKiBwcm92aWRlcyBmYWxsYmFjayBmb3IgdGhvc2UgY2FzZXMuXG4gKlxuICogcmVhZCBtb3JlOiBbZm9yZWlnbk9iamVjdCBvbiBNRE4gd2ViIGRvY3NdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9FbGVtZW50L2ZvcmVpZ25PYmplY3QpXG4gKlxuICogQGV4dGVuZHMgVGFnXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE11bHRpTGluZVRleHQgZXh0ZW5kcyBUYWcge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4ICAgICAgIGhvcml6b250YWwgcG9zaXRpb24gaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5ICAgICAgIHZlcnRpY2FsIHBvc2l0aW9uIGluIFNWRyBwaXhlbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdyAgICAgICB3aWR0aCBvZiB0aGUgdGV4dCBib3ggaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoICAgICAgIGhlaWdodCBvZiB0aGUgdGV4dCBib3ggaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0ZXh0ICAgIHRleHQgY29udGVudCBvZiB0aGUgdGV4dCBib3hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2l6ZSAgICBDU1MgZm9udCBzaXplIG9mIHRoZSB0ZXh0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb2xvcj1cImJsYWNrXCJdIGNvbG9yIG9mIHRoZSB0ZXh0XG4gICAgICpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih4LCB5LCB3LCBoLCB0ZXh0LCBzaXplLCBjb2xvciA9ICdibGFjaycpIHtcbiAgICAgICAgc3VwZXIoJ3N3aXRjaCcpO1xuXG4gICAgICAgIGxldCBmb3JlaWduT2JqZWN0ID0gbmV3IFRhZygnZm9yZWlnbk9iamVjdCcpO1xuICAgICAgICBsZXQgYWx0ZXJuYXRpdmVUZXh0ID0gbmV3IFRleHQoeCwgeSwgdywgaCwgdGV4dCwgc2l6ZSwgY29sb3IpO1xuXG4gICAgICAgIGZvcmVpZ25PYmplY3QuYWRkQXR0cih7XG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeSxcbiAgICAgICAgICAgIHdpZHRoOiB3LFxuICAgICAgICAgICAgaGVpZ2h0OiBoXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxldCAkd3JhcHBlciA9ICQoJzxkaXY+JylcbiAgICAgICAgICAgIC5hdHRyKCd4bWxucycsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJylcbiAgICAgICAgICAgIC5hZGRDbGFzcygnbXVsdGlsaW5ldGV4dCcpXG4gICAgICAgICAgICAuY3NzKCdoZWlnaHQnLCBoKTtcblxuICAgICAgICBsZXQgJHBhcmFncmFwaCA9ICQoJzxwPicpXG4gICAgICAgICAgICAuYXR0cigneG1sbnMnLCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcpXG4gICAgICAgICAgICAuY3NzKCdmb250LXNpemUnLCBzaXplKVxuICAgICAgICAgICAgLmFwcGVuZCh0ZXh0KTtcblxuICAgICAgICAkd3JhcHBlci5hcHBlbmQoJHBhcmFncmFwaCk7XG4gICAgICAgIGZvcmVpZ25PYmplY3QuJGVsLmFwcGVuZCgkd3JhcHBlcik7XG5cbiAgICAgICAgdGhpcy4kZWwuYXBwZW5kKGZvcmVpZ25PYmplY3QuJGVsKS5hcHBlbmQoYWx0ZXJuYXRpdmVUZXh0LiRlbCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IFRhZyBmcm9tICcuL1RhZyc7XG5cbi8qKiBAbW9kdWxlIHN2Z09iamVjdHMuUGF0dGVybiAqL1xuXG4vKipcbiAqIHBhdHRlcm4gb2JqZWN0IGluIFNWR1xuICogQGV4dGVuZHMgVGFnXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhdHRlcm4gZXh0ZW5kcyBUYWcge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAgICAgdW5pcXVlIGlkIG9mIHRoaXMgcGF0dGVyblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAgd2lkdGggb2Ygb25lIHBhdHRlcm4gdGlsZSBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBoZWlnaHQgb2Ygb25lIHBhdHRlcm4gdGlsZSBpbiBTVkcgcGl4ZWxzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaWQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoJ3BhdHRlcm4nKTtcblxuICAgICAgICB0aGlzLmFkZEF0dHIoe1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIHBhdHRlcm5Vbml0czogJ3VzZXJTcGFjZU9uVXNlJyxcbiAgICAgICAgICAgIHZpZXdCb3g6ICcwIDAgJyArIHdpZHRoICsgJyAnICsgaGVpZ2h0XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFkZCBhIGNoaWxkIHRvIHRoaXMgcGF0dGVyblxuICAgICAqXG4gICAgICogcGF0dGVybiBiZWhhdmVzIGEgbGl0dGxlIGxpa2Uge0BsaW5rIEdyb3VwfSAtIGl0IGNvbnRhaW5zIGNoaWxkIGVsZW1lbnRzLCB3aGljaCByZXByZXNlbnQgdGhlIGNvbnRlbnQgb2Ygb25lIHRpbGUgb2YgdGhlIHBhdHRlcm5cbiAgICAgKiBhbmQgdGhlIHdob2xlIHBhY2thZ2Ugb2YgdGhlIGNoaWxkIGVsZW1lbnRzIGlzIHJlcGVhdGVkIG9uIGVhY2ggdGlsZSBvZiB0aGUgcGF0dGVyblxuICAgICAqIEBwYXJhbSB7U3ZnRWxlbWVudH0gZWwgZWxlbWVudCB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHBhdHRlcm5cbiAgICAgKi9cbiAgICBhZGRDaGlsZChlbCkge1xuICAgICAgICB0aGlzLiRlbC5hcHBlbmQoZWwuJGVsKTtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH1cbn1cbiIsImltcG9ydCBUYWcgZnJvbSAnLi9UYWcnO1xuXG4vKiogQG1vZHVsZSBzdmdPYmplY3RzLlBvbHlMaW5lICovXG5cbi8qKlxuICogU1ZHIFBvbHlMaW5lIChhIHBhdGggZGVmaW5lZCBieSBzZXF1ZW5jZSBvZiBwb2ludHMgb24gcGxhbmUpXG4gKiBAZXh0ZW5kcyBUYWdcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9seUxpbmUgZXh0ZW5kcyBUYWcge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UG9seUxpbmVQb2ludHN9IHBvaW50cyBwb2ludHMgZGVzY3JpYmluZyB0aGlzIFBvbHlMaW5lXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdHJva2VXaWR0aF0gd2lkdGggb2YgdGhlIHN0cm9rZSBmb3IgdGhpcyBQb2x5TGluZSBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb2xvcl0gQ1NTIGNvbG9yIG9mIHRoaXMgUG9seUxpbmVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwb2ludHMsIHN0cm9rZVdpZHRoLCBjb2xvcikge1xuICAgICAgICBzdXBlcignUG9seUxpbmUnKTtcblxuICAgICAgICBsZXQgYXR0cmlidXRlcyA9IHtcbiAgICAgICAgICAgIHBvaW50czogcG9pbnRzLnN0cmluZyxcbiAgICAgICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiBzdHJva2VXaWR0aFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChjb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnN0cm9rZSA9IGNvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hZGRBdHRyKGF0dHJpYnV0ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSBwb2ludHMgb2YgdGhpcyBQb2x5TGluZVxuICAgICAqIEBwYXJhbSB7UG9seUxpbmVQb2ludHN9IHBvaW50cyBuZXcgc2V0IG9mIHBvaW50cyBkZXNjcmliaW5nIHRoaXMgUG9seUxpbmVcbiAgICAgKi9cbiAgICB1cGRhdGVQb2ludHMocG9pbnRzKSB7XG4gICAgICAgIHRoaXMuYWRkQXR0cih7XG4gICAgICAgICAgICBwb2ludHM6IHBvaW50cy5zdHJpbmdcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiLyoqIEBtb2R1bGUgc3ZnT2JqZWN0cy5Qb2x5TGluZVBvaW50ICovXG5cbi8qKlxuICogb25lIHBvaW50IG9mIHtAbGluayBQb2x5TGluZVBvaW50c30sIHVzZWQgaW4gdGhlIHtAbGluayBQb2x5TGluZX0gb2JqZWN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvbHlMaW5lUG9pbnQge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IGhvcml6b250YWwgY29vcmRpbmF0ZSBvZiB0aGUgUG9seUxpbmUgcG9pbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSB2ZXJ0aWNhbCBjb29yZGluYXRlIG9mIHRoZSBQb2x5TGluZSBwb2ludFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHgsIHkpIHtcbiAgICAgICAgdGhpcy54ID0gMDtcbiAgICAgICAgdGhpcy55ID0gMDtcbiAgICAgICAgaWYgKHggIT09IHVuZGVmaW5lZCAmJiB5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2hhbmdlIHRoZSBjb29yZGluYXRlcyBvZiB0aGlzIHBvaW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggaG9yaXpvbnRhbCBjb29yZGluYXRlIG9mIHRoZSBQb2x5TGluZSBwb2ludFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IHZlcnRpY2FsIGNvb3JkaW5hdGUgb2YgdGhlIFBvbHlMaW5lIHBvaW50XG4gICAgICovXG4gICAgc2V0KHgsIHkpIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgUG9seUxpbmUgZnJvbSBhIGNvbW1hIHNlcGFyYXRlZCBzdHJpbmcgKGUuZy4gZnJvbSBhIHN0cmluZyBmb3JtYXR0ZWQgbGlrZSB0aGlzOiBcIngseVwiLCBmb3IgZXhhbXBsZSBcIjE1LDhcIilcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHN0cmluZyBzdHJpbmcgaW4gdGhlIGZvcm1hdCBcIngseVwiIHJlcHJlc2VudGluZyBhIHBvaW50IGluIHRoZSBTVkcgUG9seUxpbmVcbiAgICAgKiBAcmV0dXJuIHtQb2x5TGluZVBvaW50fSBuZXdseSBjcmVhdGVkIGluc3RhbmNlIG9mIHtAbGluayBQb2x5TGluZVBvaW50fVxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZUZyb21TdHJpbmcoc3RyaW5nKSB7XG4gICAgICAgIGxldCBhcnIgPSBzdHJpbmcuc3BsaXQoJywnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5TGluZVBvaW50KGFyclswXSwgYXJyWzFdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBQb2x5TGluZSBwb2ludFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gc3RyaW5nIGluIHRoZSBmb3JtYXQgXCJ4LHlcIlxuICAgICAqL1xuICAgIGdldCBzdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggKyAnLCcgKyB0aGlzLnk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29tcGFyZSBQb2x5TGluZSBwb2ludHMsIHJldHVybiBgdHJ1ZWAgaWYgdGhleSBhcmUgZXF1YWwsIGVsc2UgcmV0dXJuIGBmYWxzZWBcbiAgICAgKiBAcGFyYW0gIHtQb2x5TGluZVBvaW50fSBhXG4gICAgICogQHBhcmFtICB7UG9seUxpbmVQb2ludH0gYlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnggPT09IGIueCAmJiBhLnkgPT09IGIueTtcbiAgICB9XG59XG4iLCJpbXBvcnQgUG9seUxpbmVQb2ludCBmcm9tICcuL1BvbHlMaW5lUG9pbnQnO1xuXG4vKiogQG1vZHVsZSBzdmdPYmplY3RzLlBvbHlMaW5lUG9pbnRzICovXG5cbi8qKlxuICogYXJyYXktbGlrZSBzdHJ1Y3R1cmUgdXNlZCBpbiB7QGxpbmsgUG9seUxpbmVQb2ludHN9XG4gKi9cbmNsYXNzIFNtYXJ0QXJyYXkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcnJdIGlmIHNldCwgaW5pdGlhbGl6ZWQgU21hcnRBcnJheSB3aWxsIGNvbnRhaW4gdGhlc2UgdmFsdWVzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYXJyKSB7XG4gICAgICAgIGlmIChhcnIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5hcnIgPSBhcnI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFyciA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IGEgZGVlcCBjb3B5IG9mIHRoaXMgYXJyYXlcbiAgICAgKiBAcmV0dXJuIHtTbWFydEFycmF5fVxuICAgICAqL1xuICAgIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiBTbWFydEFycmF5KCQuZXh0ZW5kKHRydWUsIFtdLCB0aGlzLmFycikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFwcGVuZCBhbiBpdGVtIHRvIHRoZSBhcnJheVxuICAgICAqIEBwYXJhbSBpdGVtIG5ldyBpdGVtIHRoYXQgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgYXJyYXlcbiAgICAgKi9cbiAgICBhcHBlbmQoaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRXaXRoSW5kZXgoaXRlbSwgdGhpcy5hcnIubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwcmVwZW5kIGFuIGl0ZW0gdG8gdGhlIGFycmF5XG4gICAgICogQHBhcmFtIGl0ZW0gbmV3IGl0ZW0gdGhhdCB3aWxsIGJlIHByZXBlbmRlZCB0byB0aGUgYXJyYXlcbiAgICAgKi9cbiAgICBwcmVwZW5kKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkV2l0aEluZGV4KGl0ZW0sIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFkZCBhIG5ldyBpdGVtIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXgsIG1vdmUgYWxsIGZvbGxvd2luZyBpdGVtc1xuICAgICAqIEBwYXJhbSBpdGVtIG5ldyBpdGVtIHRoYXQgd2lsbCBiZSBhZGRlZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4IG9mIHRoaXMgaXRlbVxuICAgICAqL1xuICAgIGFkZFdpdGhJbmRleChpdGVtLCBpbmRleCkge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5hcnIubGVuZ3RoOyBpID4gaW5kZXg7IC0taSkge1xuICAgICAgICAgICAgdGhpcy5hcnJbaV0gPSB0aGlzLmFycltpIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcnJbaW5kZXhdID0gaXRlbTtcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vIHRvIGVuYWJsZSBjaGFpbmluZyBvZiBhcHBlbmQgLyBwcmVwcGVuZCAvIGFkZFdpdGhJbmRleCBjb21tYW5kc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCBsZW5ndGggb2YgdGhlIGFycmF5XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFyci5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IGl0ZW0gYnkgaW5kZXhcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGluZGV4IGluZGV4IG9mIHRoZSBpdGVtXG4gICAgICogQHJldHVybiBjb250ZW50cyBvZiB0aGUgYXJyYXkgb24gdGhlIHNwZWNpZmllZCBpbmRleFxuICAgICAqL1xuICAgIGdldEl0ZW0oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyW2luZGV4XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIGxhc3QgZWxlbWVudCBvZiB0aGUgYXJyYXlcbiAgICAgKi9cbiAgICBnZXQgbGFzdCgpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcnJbdGhpcy5sZW5ndGggLSAxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gZmlyc3QgZWxlbWVudCBvZiB0aGUgYXJyYXlcbiAgICAgKi9cbiAgICBnZXQgZmlyc3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXJyWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIGFuIGl0ZW0gZnJvbSB0aGUgYXJyYXkgYnkgaW5kZXhcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGluZGV4IGluZGV4IG9mIHRoZSBpdGVtIHRoYXQgd2lsbCBiZSByZW1vdmVkXG4gICAgICovXG4gICAgcmVtb3ZlKGluZGV4KSB7XG4gICAgICAgIGxldCBsZW5ndGggPSB0aGlzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGxldCBpID0gaW5kZXg7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5hcnJbaV0gPSB0aGlzLmFycltpICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcnIucG9wKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIHBvaW50cyBvZiB0aGUge0BsaW5rIFBvbHlMaW5lfVxuICogQGV4dGVuZHMgU21hcnRBcnJheVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2x5TGluZVBvaW50cyBleHRlbmRzIFNtYXJ0QXJyYXkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcnJdIGFycmF5IGNvbnRhaW5pbmcgaW5zdGFuY2VzIG9mIHtAbGluayBQb2x5TGluZVBvaW50fVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFycikge1xuICAgICAgICBzdXBlcihhcnIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCBhIGRlZXAgY29weSBvZiB0aGlzIG9iamVjdFxuICAgICAqIEByZXR1cm4ge1BvbHlMaW5lUG9pbnRzfVxuICAgICAqL1xuICAgIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9seUxpbmVQb2ludHMoJC5leHRlbmQodHJ1ZSwgW10sIHRoaXMuYXJyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYXBwZW5kIGEgcG9pbnRcbiAgICAgKiBAcGFyYW0gIHtQb2x5TGluZVBvaW50fSBwb2ludCBhIG5ldyBwb2ludFxuICAgICAqL1xuICAgIGFwcGVuZChwb2ludCkge1xuICAgICAgICAvLyBjYWxsIGluaGVyaXRlZCBmdW5jdGlvbiB0byBoYW5kbGUgdGhlIGFwcGVuZGluZ1xuICAgICAgICBzdXBlci5hcHBlbmQocG9pbnQpO1xuXG4gICAgICAgIC8vIGlmIHRoZSBzZWNvbmQgdG8gbGFzdCBwb2ludCBpcyB1bm5lY2Vzc2FyeSwgcmVtb3ZlIGl0XG4gICAgICAgIGxldCBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgbGVuZ3RoID49IDMgJiZcbiAgICAgICAgICAgICgodGhpcy5nZXRJdGVtKGxlbmd0aCAtIDMpLnggPT09IHRoaXMuZ2V0SXRlbShsZW5ndGggLSAyKS54ICYmXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRJdGVtKGxlbmd0aCAtIDIpLnggPT09IHRoaXMuZ2V0SXRlbShsZW5ndGggLSAxKS54KSB8fFxuICAgICAgICAgICAgICAgICh0aGlzLmdldEl0ZW0obGVuZ3RoIC0gMykueSA9PT0gdGhpcy5nZXRJdGVtKGxlbmd0aCAtIDIpLnkgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRJdGVtKGxlbmd0aCAtIDIpLnkgPT09IHRoaXMuZ2V0SXRlbShsZW5ndGggLSAxKS55KSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShsZW5ndGggLSAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldHVybiB0aGlzIGVsZW1lbnQgKHRvIGFsbG93IGNoYWluaW5nKVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwYXJzZSBQb2x5TGluZSBmcm9tIHN0cmluZ1xuICAgICAqIEBwYXJhbSAge3N0cmluZ30gc3RyaW5nIHN0cmluZyBpbiB0aGUgUG9seUxpbmUgZm9ybWF0IChgeDEseTEgeDIseTIsIHgzLHkzYClcbiAgICAgKiBAcmV0dXJuIHtQb2x5TGluZVBvaW50c30gYSBuZXcgaW5zdGFuY2Ugb2Yge0BsaW5rIFBvbHlMaW5lUG9pbnRzfSBjcmVhdGVkIGJ5IHBhcnNpbmcgdGhlIHN0cmluZ1xuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZUZyb21TdHJpbmcoc3RyaW5nKSB7XG4gICAgICAgIGxldCBwb2ludFN0cmluZ3MgPSBzdHJpbmcuc3BsaXQoJyAnKTtcbiAgICAgICAgbGV0IHBvaW50cyA9IG5ldyBQb2x5TGluZVBvaW50cygpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRTdHJpbmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBwb2ludHMuYXBwZW5kKFBvbHlMaW5lUG9pbnQucGFyc2VGcm9tU3RyaW5nKHBvaW50U3RyaW5nc1tpXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBQb2x5TGluZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gc3RyaW5nIGluIHRoZSBQb2x5TGluZSBmb3JtYXQgKGB4MSx5MSB4Mix5MiwgeDMseTNgKVxuICAgICAqL1xuICAgIGdldCBzdHJpbmcoKSB7XG4gICAgICAgIGxldCBzdHJpbmcgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJpbmcgKz0gdGhpcy5hcnJbaV0uc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogd3JhcHBlciBmb3IgZm9yZWFjaCBvbiB0aGUgUG9seUxpbmUgcG9pbnRzXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGZ1bmMgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIGVsZW1lbnRcbiAgICAgKi9cbiAgICBmb3JFYWNoKGZ1bmMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFyci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgZnVuYyh0aGlzLmFycltpXSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgU3ZnRWxlbWVudCBmcm9tICcuL1N2Z0VsZW1lbnQnO1xuXG4vKiogQG1vZHVsZSBzdmdPYmplY3RzLlJlY3RhbmdsZSAqL1xuXG4vKipcbiAqIGEgcmVjdGFuZ2xlIGluIFNWR1xuICogQGV4dGVuZHMgU3ZnRWxlbWVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWN0YW5nbGUgZXh0ZW5kcyBTdmdFbGVtZW50IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAgICAgICBob3Jpem9udGFsIHBvc2l0aW9uIGluIFNWRyBwaXhlbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAgICAgICB2ZXJ0aWNhbCBwb3NpdGlvbiBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHcgICAgICAgd2lkdGggaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoICAgICAgIGhlaWdodCBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGwgICAgZmlsbGluZyBjb2xvciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cm9rZSAgc3Ryb2tlIGNvbG9yIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih4LCB5LCB3LCBoLCBmaWxsLCBzdHJva2UpIHtcbiAgICAgICAgc3VwZXIoeCwgeSwgdywgaCwgJ3JlY3QnKTtcbiAgICAgICAgdGhpcy5hZGRBdHRyKHtcbiAgICAgICAgICAgIGZpbGw6IGZpbGwsXG4gICAgICAgICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiAwLjUsXG4gICAgICAgICAgICAncG9pbnRlci1ldmVudHMnOiAnYWxsJyAvLyB0byB0cmlnZ2VyIGhvdmVyIGV2ZW4gd2l0aCB0cmFuc3BhcmVudCBiYWNrZ3JvdW5kXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsImltcG9ydCBUYWcgZnJvbSAnLi9UYWcnO1xuXG4vKiogQG1vZHVsZSBzdmdPYmplY3RzLlN2Z0VsZW1lbnQgKi9cblxuLyoqXG4gKiByZXByZXNlbnRzIHZpc2libGUgZWxlbWVudCBpbiBTVkcgdGhhdCBoYXMgcG9zaXRpb24gYW5kIGRpbWVuc2lvbnMgKGZvciBleGFtcGxlIGByZWN0YW5nbGVgIGlzIGEgU3ZnRWxlbWVudCwgYnV0IGBwYXR0ZXJuYCBpcyBub3QsIGV2ZW4gdGhvdWdoIGJvdGggYXJlIHRhZ3MpXG4gKiBAZXh0ZW5kcyBUYWdcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3ZnRWxlbWVudCBleHRlbmRzIFRhZyB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggICAgICAgaG9yaXpvbnRhbCBwb3NpdGlvbiBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgICAgICAgdmVydGljYWwgcG9zaXRpb24gaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3ICAgICAgIHdpZHRoIGluIFNWRyBwaXhlbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaCAgICAgICBoZWlnaHQgaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lIHRhZyBuYW1lIG9mIHRoZSBlbGVtZW50XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeCwgeSwgdywgaCwgdGFnTmFtZSkge1xuICAgICAgICBzdXBlcih0YWdOYW1lKTtcblxuICAgICAgICB0aGlzLmFkZEF0dHIoe1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgICAgIGhlaWdodDogaFxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgU3ZnRWxlbWVudCBmcm9tICcuL1N2Z0VsZW1lbnQnO1xuXG4vKiogQG1vZHVsZSBzdmdPYmplY3RzLlN2Z0ltYWdlICovXG5cbi8qKlxuICogYW4gaW1hZ2UgaW4gU1ZHXG4gKiBAZXh0ZW5kcyBTdmdFbGVtZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN2Z0ltYWdlIGV4dGVuZHMgU3ZnRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoeCwgeSwgdywgaCwgdXJsKSB7XG4gICAgICAgIHN1cGVyKHgsIHksIHcsIGgsICdpbWFnZScpO1xuICAgICAgICB0aGlzLmFkZEF0dHIoe1xuICAgICAgICAgICAgJ3hsaW5rOmhyZWYnOiB1cmxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2hhbmdlIHVybCBvZiB0aGUgaW1hZ2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIHRoZSBuZXcgdXJsIG9mIHRoZSBpbWFnZVxuICAgICAqL1xuICAgIGNoYW5nZVVybCh1cmwpIHtcbiAgICAgICAgdGhpcy5hZGRBdHRyKHtcbiAgICAgICAgICAgICd4bGluazpocmVmJzogdXJsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsImltcG9ydCBJZCBmcm9tICcuLi9vdGhlci9pZCc7XG5cbi8qKiBAbW9kdWxlIHN2Z09iamVjdHMuVGFnICovXG5cbi8qKlxuICogUGFyZW50IGNsYXNzIGZvciBhbGwgc3ZnT2JqZWN0c1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUYWcge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lIFNWRyB0YWcgaWRlbnRpZmllciAoYHJlY3RgLCBgaW1hZ2VgLCBgUG9seUxpbmVgKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRhZ05hbWUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNWRyB0YWcgaWRlbnRpZmllciAoYHJlY3RgLCBgaW1hZ2VgLCBgUG9seUxpbmVgKVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YWdOYW1lID0gdGFnTmFtZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogalF1ZXJ5IGVsZW1lbnQgZm9yIHRoaXMgdGFnXG4gICAgICAgICAqIEB0eXBlIHtqUXVlcnkuZWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuJGVsID0gJCgnPCcgKyB0aGlzLnRhZ05hbWUgKyAnPicpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB1bmlxdWUgSUQgb2YgdGhpcyBTVkcgb2JqZWN0XG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkID0gbmV3IElkKCkudW5pcXVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFkZCBhIGNsYXNzIHRvIHRoaXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGNsYXNzIG5hbWUgdG8gYmUgYWRkZWRcbiAgICAgKi9cbiAgICBhZGRDbGFzcyhuYW1lKSB7XG4gICAgICAgIHRoaXMuJGVsLmFkZENsYXNzKG5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBjbGFzcyBuYW1lcyBmcm9tIHRoaXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gY2xhc3NlcyBjbGFzcyBuYW1lcyB0byBiZSByZW1vdmVkXG4gICAgICovXG4gICAgcmVtb3ZlQ2xhc3NlcyguLi5jbGFzc2VzKSB7XG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2YgY2xhc3Nlcykge1xuICAgICAgICAgICAgdGhpcy4kZWwucmVtb3ZlQ2xhc3MoaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgYXR0cmlidXRlcyBvZiB0aGlzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXNzb2MgamF2YXNjcmlwdCBvYmplY3QgdGhhdCB3aWxsIGJlIG1hcHBlZCBpbnRvIGF0dHJpYnV0ZXMgKGB7a2V5OiB2YWx1ZX1gIC0+IGBrZXk9XCJ2YWx1ZVwiYClcbiAgICAgKi9cbiAgICBhZGRBdHRyKGFzc29jKSB7XG4gICAgICAgIHRoaXMuY2hlY2tJZkVsZW1lbnRFeGlzdHNJbkRPTSgpO1xuXG4gICAgICAgIC8vIGFkZCBhdHRyaWJ1dGVzIHRvIHRoZSBlbGVtZW50XG4gICAgICAgIHRoaXMuJGVsLmF0dHIoYXNzb2MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCBhdHRyaWJ1dGUgdmFsdWUgYnkgbmFtZVxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAqL1xuICAgIGdldEF0dHIobmFtZSkge1xuICAgICAgICB0aGlzLmNoZWNrSWZFbGVtZW50RXhpc3RzSW5ET00oKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kZWwuYXR0cihuYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgYXR0cmlidXRlIGJ5IHZhbHVlXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBiZSByZW1vdmVkXG4gICAgICovXG4gICAgcmVtb3ZlQXR0cihuYW1lKSB7XG4gICAgICAgIHRoaXMuY2hlY2tJZkVsZW1lbnRFeGlzdHNJbkRPTSgpO1xuXG4gICAgICAgIHRoaXMuJGVsLnJlbW92ZUF0dHIobmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0IGlkIG9mIHRoaXMgU1ZHIG9iamVjdFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gaWQgbmV3IGlkIGZvciB0aGlzIG9iamVjdFxuICAgICAqL1xuICAgIHNldCBpZChpZCkge1xuICAgICAgICB0aGlzLmFkZEF0dHIoeyBpZDogaWQgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IGlkIG9mIHRoaXMgU1ZHIG9iamVjdFxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEF0dHIoJ2lkJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IGpRdWVyeSBlbGVtZW50IGZvciB0aGlzIFNWRyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtqUXVlcnkuZWxlbWVudH1cbiAgICAgKi9cbiAgICBnZXQoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tJZkVsZW1lbnRFeGlzdHNJbkRPTSgpO1xuICAgICAgICByZXR1cm4gdGhpcy4kZWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2hlY2sgaWYgdGhlIGVsZW1lbnQgZXhpc3RzIGluIGRvbSwgaWYgc28sIHJlZmV0Y2ggaXQgZnJvbSBET00gdXNpbmcgalF1ZXJ5XG4gICAgICovXG4gICAgY2hlY2tJZkVsZW1lbnRFeGlzdHNJbkRPTSgpIHtcbiAgICAgICAgbGV0ICRqcUVsZW1lbnQgPSAkKCcjJyArIHRoaXMuJGVsLmF0dHIoJ2lkJykpO1xuICAgICAgICBpZiAoJGpxRWxlbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsID0gJGpxRWxlbWVudDtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCBUYWcgZnJvbSAnLi9UYWcnO1xuXG4vKiogQG1vZHVsZSBzdmdPYmplY3RzLlRleHQgKi9cblxuLyoqXG4gKiBUZXh0IGVsZW1lbnQgaW4gU1ZHXG4gKiBAZXh0ZW5kcyBUYWdcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dCBleHRlbmRzIFRhZyB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggICAgICAgaG9yaXpvbnRhbCBwb3NpdGlvbiBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgICAgICAgdmVydGljYWwgcG9zaXRpb24gaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3ICAgICAgIHdpZHRoIG9mIHRoZSB0ZXh0IGJveCBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGggICAgICAgaGVpZ2h0IG9mIHRoZSB0ZXh0IGJveCBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRleHQgICAgdGV4dCBjb250ZW50IG9mIHRoZSB0ZXh0IGJveFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzaXplICAgIENTUyBmb250IHNpemUgb2YgdGhlIHRleHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbG9yPVwiYmxhY2tcIl0gY29sb3Igb2YgdGhlIHRleHRcbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHgsIHksIHcsIGgsIHRleHQsIHNpemUsIGNvbG9yID0gJ2JsYWNrJykge1xuICAgICAgICBzdXBlcigndGV4dCcpO1xuICAgICAgICB0aGlzLmFkZEF0dHIoe1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgICAgIGhlaWdodDogaCxcbiAgICAgICAgICAgIGZpbGw6IGNvbG9yXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzaXplKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEF0dHIoe1xuICAgICAgICAgICAgICAgICdmb250LXNpemUnOiBzaXplXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJGVsLmFwcGVuZCh0ZXh0KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBnZXRMaWJyYXJ5LCBnZXROZXR3b3JrRnJvbUxpYnJhcnkgfSBmcm9tICcuL25ldHdvcmtMaWJyYXJ5JztcblxuaW1wb3J0IHsgR2F0ZSB9IGZyb20gJy4uL2VkaXRvckVsZW1lbnRzJztcblxuLyoqXG4gKiBJdGVtIGluIHRoZSBbQ29udGV4dE1lbnVdKC4vbW9kdWxlLUNvbnRleHRNZW51Lmh0bWwpLiBDb250ZXh0TWVudUl0ZW1zIGNhbiBiZSBuZXN0ZWQgdXNpbmcgdGhlIGFwcGVuZEl0ZW0gZnVuY3Rpb24uXG4gKi9cbmNsYXNzIENvbnRleHRNZW51SXRlbSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgICAgICAgICAgdGV4dCBvbiB0aGUgYnV0dG9uXG4gICAgICogQHBhcmFtIHtDb250ZXh0TWVudX0gY29udGV4dE1lbnUgaW5zdGFuY2Ugb2YgdGhlIFtDb250ZXh0TWVudV0oLi9tb2R1bGUtQ29udGV4dE1lbnUuaHRtbCkgdGhpcyBpdGVtIGJlbG9uZ3MgdG9cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbGlja0Z1bmN0aW9uIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB1c2VyIGNsaWNrcyB0aGlzIGl0ZW1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBjb250ZXh0TWVudSwgY2xpY2tGdW5jdGlvbikge1xuICAgICAgICAvKipcbiAgICAgICAgICogdGV4dCBvbiB0aGUgYnV0dG9uXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpbnN0YW5jZSBvZiB0aGUgW0NvbnRleHRNZW51XSguL21vZHVsZS1Db250ZXh0TWVudS5odG1sKSB0aGlzIGl0ZW0gYmVsb25ncyB0b1xuICAgICAgICAgKiBAdHlwZSB7Q29udGV4dE1lbnV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnRleHRNZW51ID0gY29udGV4dE1lbnU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGpRdWVyeSBlbGVtZW50IHJlcHJlc2VudGluZyBET00gY29udGVudCBvZiB0aGlzIG1lbnUgaXRlbVxuICAgICAgICAgKiBAdHlwZSB7alF1ZXJ5LmVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiRlbCA9ICQoJzxsaT4nKS50ZXh0KHRleHQpO1xuXG4gICAgICAgIC8vIHNldCB1cCBjbGljayBjYWxsYmFjayBpZiBjbGlja0Z1bmN0aW9uIGlzIGRlZmluZWRcbiAgICAgICAgaWYgKGNsaWNrRnVuY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgJCh0aGlzLiRlbCkuY2xpY2soZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIGNsaWNrRnVuY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0TWVudS5oaWRlKCk7XG5cbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGpRdWVyeSBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIHN1Ym1lbnUgKG9yIHVuZGVmaW5lZCwgaWYgaXRlbSBoYXMgbm8gc3ViaXRlbXMpXG4gICAgICAgICAqIEB0eXBlIHtqUXVlcnkuZWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuJHN1Ym1lbnUgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHN1Ym1lbnUgaXRlbSBjb3VudGVyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLml0ZW1Db3VudCA9IDA7XG5cbiAgICAgICAgLy8gc2V0IGhvdmVyIGNhbGxiYWNrXG4gICAgICAgICQodGhpcy4kZWwpLmhvdmVyKFxuICAgICAgICAgICAgZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIG1vdXNlIG9uXG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHN1Ym1lbnUuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHRoaXMuJGVsLm9mZnNldCgpLnRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMuJGVsLnBhcmVudCgpLm9mZnNldCgpLmxlZnQgKyB0aGlzLiRlbC5wYXJlbnQoKS53aWR0aCgpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dE1lbnUuJGVsLmFmdGVyKHRoaXMuJHN1Ym1lbnUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gbW91c2Ugb3V0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJHN1Ym1lbnUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kc3VibWVudS5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBzdG9wIGV2ZW50IHByb3BhZ2F0aW9uLCBoZXJlIGl0IGlzIHdhbnRlZFxuICAgICAgICAgICAgICAgIC8vIChiZWNhdXNlIHN1Ym1lbnUgb3ZlcnJpZGVzIGRpc3BsYXk6IG5vbmUgd2hlbiB1c2VyIG1vdmVzIGZyb20gdGhpcyBtZW51IGl0ZW0gdG8gdGhlIHN1Ym1lbnUpXG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW5zdGFuY2Ugb2YgW0FwcF0oLi9tb2R1bGUtQXBwLmh0bWwpIHRoaXMgbWVudSBiZWxvbmdzIHRvXG4gICAgICogQHR5cGUge0FwcH1cbiAgICAgKi9cbiAgICBnZXQgYXBwSW5zdGFuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHRNZW51LmFwcEluc3RhbmNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgc3VibWVudVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtQ291bnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWRkIGEgQ1NTIGNsYXNzIHRvIHRoaXMgaXRlbVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbHMgW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgIGFkZENsYXNzKGNscykge1xuICAgICAgICB0aGlzLiRlbC5hZGRDbGFzcyhjbHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhcHBlbmQgYSBuZXN0ZWQge0BsaW5rIENvbnRleHRNZW51SXRlbX0gdG8gdGhpcyBpdGVtXG4gICAgICogQHBhcmFtICB7Q29udGV4dE1lbnVJdGVtfSBpdGVtIGl0ZW0gdGhhdCB3aWxsIGJlIGFwcGVuZGVkXG4gICAgICovXG4gICAgYXBwZW5kSXRlbShpdGVtKSB7XG4gICAgICAgIGlmICghdGhpcy4kc3VibWVudSkge1xuICAgICAgICAgICAgdGhpcy4kc3VibWVudSA9ICQoJzx1bD4nKS5hZGRDbGFzcygnc3ViTGlzdCcpO1xuICAgICAgICAgICAgdGhpcy4kc3VibWVudS5ob3ZlcihcbiAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHN1Ym1lbnUuY3NzKCdkaXNwbGF5JywgJ2Jsb2NrJyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHN1Ym1lbnUuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJHN1Ym1lbnUuYXBwZW5kKGl0ZW0uJGVsKTtcblxuICAgICAgICB0aGlzLml0ZW1Db3VudCsrO1xuXG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCBqUXVlcnkgZWxlbWVudCBvZiB0aGlzIG1lbnUgaXRlbVxuICAgICAqIEByZXR1cm4ge2pRdWVyeS5lbGVtZW50fSBqUXVlcnkgZWxlbWVudCBjb250YWluaW5nIGFsbCBET00gY29udGVudCBmb3IgdGhpcyBtZW51IGl0ZW1cbiAgICAgKi9cbiAgICBnZXQgalF1ZXJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kZWw7XG4gICAgfVxuXG4gICAgZ2V0IGpRdWVyeVN1Ym1lbnUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRzdWJtZW51O1xuICAgIH1cbn1cblxuLyoqXG4gKiBNZW51IGl0ZW0gdGhhdCBoYXMgYSBjdXN0b20gY2xpY2sgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBhZGRzIGEge0BsaW5rIEdhdGV9IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSB0byB0aGUgW0FwcF0oLi9tb2R1bGUtQXBwLmh0bWwpXG4gKiBAZXh0ZW5kcyBDb250ZXh0TWVudUl0ZW1cbiAqL1xuY2xhc3MgR2F0ZU1lbnVJdGVtIGV4dGVuZHMgQ29udGV4dE1lbnVJdGVtIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAgICAgICAgdHlwZSBvZiB0aGUgZ2F0ZSB7QGxpbmsgR2F0ZX0gKGFuZCwgb3IsIC4uLilcbiAgICAgKiBAcGFyYW0ge0NvbnRleHRNZW51fSBjb250ZXh0TWVudSBpbnN0YW5jZSBvZiB0aGUgW0NvbnRleHRNZW51XSguL21vZHVsZS1Db250ZXh0TWVudS5odG1sKSB0aGF0IHRoaXMgaXRlbSBiZWxvbmdzIHRvXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodHlwZSwgY29udGV4dE1lbnUpIHtcbiAgICAgICAgc3VwZXIoYCR7dHlwZS50b1VwcGVyQ2FzZSgpfSBnYXRlYCwgY29udGV4dE1lbnUsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYXBwSW5zdGFuY2UubmV3R2F0ZShcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIHRoaXMuYXBwSW5zdGFuY2Uuc25hcFRvR3JpZChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBJbnN0YW5jZS52aWV3Ym94LnRyYW5zZm9ybVgoY29udGV4dE1lbnUucG9zaXRpb24ueClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHRoaXMuYXBwSW5zdGFuY2Uuc25hcFRvR3JpZChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBJbnN0YW5jZS52aWV3Ym94LnRyYW5zZm9ybVkoY29udGV4dE1lbnUucG9zaXRpb24ueSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogTWVudSBpdGVtIHRoYXQgaGFzIGEgY3VzdG9tIGNsaWNrIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgYWRkcyBhIHNwZWNpZmllZCB7QGxpbmsgQmxhY2tib3h9IHRvIHRoZSBbQXBwXSguL21vZHVsZS1BcHAuaHRtbClcbiAqIEBleHRlbmRzIENvbnRleHRNZW51SXRlbVxuICovXG5jbGFzcyBCbGFja2JveE1lbnVJdGVtIGV4dGVuZHMgQ29udGV4dE1lbnVJdGVtIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBmaWxlLCBjb250ZXh0TWVudSkge1xuICAgICAgICBzdXBlcihuYW1lLCBjb250ZXh0TWVudSwgKCkgPT4ge1xuICAgICAgICAgICAgZ2V0TmV0d29ya0Zyb21MaWJyYXJ5KGZpbGUpXG4gICAgICAgICAgICAgICAgLnRoZW4oKHsgYmxhY2tib3gsIG5hbWUgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGlucHV0cywgb3V0cHV0cywgdGFibGUgfSA9IGJsYWNrYm94O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgbmFtZSBzcGVjaWZpZWQgaW4gdGhlIGJsYWNrYm94IGl0ZW0sIGlmIGl0IGRvZXMgbm90IGV4aXN0LCB1c2UgdGhlIG5hbWUgZm9yIHRoZSBuZXR3b3JrXG4gICAgICAgICAgICAgICAgICAgIGxldCB1c2VkTmFtZSA9IGJsYWNrYm94Lm5hbWUgfHwgbmFtZTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcEluc3RhbmNlLm5ld0JsYWNrYm94KFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlZE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcEluc3RhbmNlLnNuYXBUb0dyaWQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBJbnN0YW5jZS52aWV3Ym94LnRyYW5zZm9ybVgoY29udGV4dE1lbnUucG9zaXRpb24ueClcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcEluc3RhbmNlLnNuYXBUb0dyaWQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBJbnN0YW5jZS52aWV3Ym94LnRyYW5zZm9ybVkoY29udGV4dE1lbnUucG9zaXRpb24ueSlcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogTWVudSBpdGVtIHRoYXQgaGFzIGEgY3VzdG9tIGNsaWNrIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgYWRkcyBhIHNwZWNpZmllZCBOZXR3b3JrIHRvIHRoZSBbQXBwXSguL21vZHVsZS1BcHAuaHRtbClcbiAqIEBleHRlbmRzIENvbnRleHRNZW51SXRlbVxuICovXG5jbGFzcyBOZXR3b3JrTWVudUl0ZW0gZXh0ZW5kcyBDb250ZXh0TWVudUl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGZpbGUsIGNvbnRleHRNZW51KSB7XG4gICAgICAgIHN1cGVyKG5hbWUsIGNvbnRleHRNZW51LCAoKSA9PiB7XG4gICAgICAgICAgICBnZXROZXR3b3JrRnJvbUxpYnJhcnkoZmlsZSlcbiAgICAgICAgICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBJbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgLmltcG9ydERhdGEoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcEluc3RhbmNlLnZpZXdib3gudHJhbnNmb3JtWChjb250ZXh0TWVudS5wb3NpdGlvbi54KSAvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcEluc3RhbmNlLmdyaWRTaXplXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcEluc3RhbmNlLnZpZXdib3gudHJhbnNmb3JtWShjb250ZXh0TWVudS5wb3NpdGlvbi55KSAvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcEluc3RhbmNlLmdyaWRTaXplXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4od2FybmluZ3MgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgd2FybmluZyBvZiB3YXJuaW5ncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcEluc3RhbmNlLm1lc3NhZ2VzLm5ld1dhcm5pbmdNZXNzYWdlKHdhcm5pbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBJbnN0YW5jZS5tZXNzYWdlcy5uZXdFcnJvck1lc3NhZ2UoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKiBAbW9kdWxlIENvbnRleHRNZW51ICovXG4vKipcbiAqIENvbnRleHRNZW51IHJlcHJlc2VudHMgdGhlIG1lbnUgdGhhdCBpcyBkaXNwbGF5ZWQgdG8gdGhlIHVzZXIgd2hlbiB0aGV5IHJpZ2h0IGNsaWNrIG9uIGEgY2FudmFzLlxuICogVGhpcyBtZW51IGFsbG93cyB1c2VyIHRvIGFkZCBlbGVtZW50cyB0byB0aGUgY2FudmFzIGFuZCBpbiB0aGUgY2FzZSB0aGF0IHVzZXIgcmlnaHRjbGlja2VkXG4gKiBvbiBhIHNwZWNpZmljIGVsZW1lbnQsIHRoaXMgbWVudSBhbGxvd3MgdGhlbSB0byByZW1vdmUgdGhpcyBlbGVtZW50LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb250ZXh0TWVudSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcHB9IGFwcEluc3RhbmNlIGluc3RhbmNlIG9mIFtBcHBdKC4vbW9kdWxlLUFwcC5odG1sKSB0aGlzIG1lbnUgYmVsb25ncyB0b1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFwcEluc3RhbmNlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpbnN0YW5jZSBvZiBbQXBwXSguL21vZHVsZS1BcHAuaHRtbCkgdGhpcyBtZW51IGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHR5cGUge0FwcH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXBwSW5zdGFuY2UgPSBhcHBJbnN0YW5jZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUG9zaXRpb24gb2YgdGhlIGNvbnRleHQgbWVudS4gSXQgaXMgdXNlZCB0byBhZGQgdGhlIG5ldyBlbGVtZW50cyB0byB0aGUgY29ycmVjdCBwb3NpdGlvbiBvbiB0aGUgY2FudmFzLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGpRdWVyeSBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIGNvbnRleHQgbWVudVxuICAgICAgICAgKiBAdHlwZSB7alF1ZXJ5LmVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiRlbCA9ICQoJzx1bD4nKTtcbiAgICAgICAgdGhpcy4kZWwuYXR0cignaWQnLCAnY29udGV4dE1lbnUnKTtcblxuICAgICAgICBsZXQgc3BlY2lhbCA9IG5ldyBDb250ZXh0TWVudUl0ZW0oJ1NwZWNpYWwgZWxlbWVudHMnLCB0aGlzKTtcblxuICAgICAgICAvLyBhZGQgaW5wdXQgYm94XG4gICAgICAgIHNwZWNpYWwuYXBwZW5kSXRlbShcbiAgICAgICAgICAgIG5ldyBDb250ZXh0TWVudUl0ZW0oJ0lucHV0IGJveCcsIHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMuYXBwSW5zdGFuY2Uuc25hcFRvR3JpZChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcEluc3RhbmNlLnZpZXdib3gudHJhbnNmb3JtWCh0aGlzLnBvc2l0aW9uLngpXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIHRvcDogdGhpcy5hcHBJbnN0YW5jZS5zbmFwVG9HcmlkKFxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwSW5zdGFuY2Uudmlld2JveC50cmFuc2Zvcm1ZKHRoaXMucG9zaXRpb24ueSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBhcHBJbnN0YW5jZS5uZXdJbnB1dChwb3NpdGlvbi5sZWZ0LCBwb3NpdGlvbi50b3ApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBhZGQgb3V0cHV0IGJveFxuICAgICAgICBzcGVjaWFsLmFwcGVuZEl0ZW0oXG4gICAgICAgICAgICBuZXcgQ29udGV4dE1lbnVJdGVtKCdPdXRwdXQgYm94JywgdGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBwb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogdGhpcy5hcHBJbnN0YW5jZS5zbmFwVG9HcmlkKFxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwSW5zdGFuY2Uudmlld2JveC50cmFuc2Zvcm1YKHRoaXMucG9zaXRpb24ueClcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiB0aGlzLmFwcEluc3RhbmNlLnNuYXBUb0dyaWQoXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBJbnN0YW5jZS52aWV3Ym94LnRyYW5zZm9ybVkodGhpcy5wb3NpdGlvbi55KVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGFwcEluc3RhbmNlLm5ld091dHB1dChwb3NpdGlvbi5sZWZ0LCBwb3NpdGlvbi50b3ApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLmFwcGVuZEl0ZW0oc3BlY2lhbCk7XG5cbiAgICAgICAgLy8gbGlzdCBvZiBnYXRlcyB0aGF0IGNhbiBiZSBhZGRlZFxuICAgICAgICBjb25zdCBnYXRlcyA9IEdhdGUudmFsaWRHYXRlcztcbiAgICAgICAgbGV0IGdhdGVMaXN0ID0gbmV3IENvbnRleHRNZW51SXRlbSgnTmV3IGdhdGUnLCB0aGlzLCBhcHBJbnN0YW5jZSk7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBnYXRlcykge1xuICAgICAgICAgICAgZ2F0ZUxpc3QuYXBwZW5kSXRlbShuZXcgR2F0ZU1lbnVJdGVtKG5hbWUsIHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwcGVuZEl0ZW0oZ2F0ZUxpc3QpO1xuXG4gICAgICAgIC8vIG1vcmUgb3B0aW9ucyB3aWxsIGJlIGFkZGVkIGluIHRoZSBnZXRMaWJyYXJ5KCkgY2FsbGJhY2sgYmVsb3dcbiAgICAgICAgbGV0IG5ldHdvcmtMaXN0ID0gbmV3IENvbnRleHRNZW51SXRlbSgnQWRkIGEgbmV0d29yaycsIHRoaXMpO1xuICAgICAgICBuZXR3b3JrTGlzdC5hcHBlbmRJdGVtKFxuICAgICAgICAgICAgbmV3IENvbnRleHRNZW51SXRlbSgnUGFzdGUgYSBuZXR3b3JrJywgdGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheUltcG9ydERpYWxvZygpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5hcHBlbmRJdGVtKG5ldHdvcmtMaXN0KTsgLy8gYWx3YXlzIGFwcGVuZFxuXG4gICAgICAgIGxldCBibGFja2JveExpc3QgPSBuZXcgQ29udGV4dE1lbnVJdGVtKCdBZGQgYSBibGFja2JveCcsIHRoaXMpOyAvLyBhcHBlbmRzIG9ubHkgaWYgY29udGFpbnMgaXRlbXMgKHNlZSB0aGUgY2FsbGJhY2spXG5cbiAgICAgICAgLy8gbmV0d29yayBpbXBvcnQgKGJsYWNrYm94LCBuZXR3b3JrKVxuICAgICAgICBnZXRMaWJyYXJ5KClcbiAgICAgICAgICAgIC50aGVuKG5ldHdvcmtzID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgbmFtZSwgZmlsZSwgaGFzVGFibGUsIGhhc05ldHdvcmsgfSBvZiBuZXR3b3Jrcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgYSBuZXR3b3JrIGFzIGEgYmxhY2tib3hcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1RhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBibGFja2JveExpc3QuYXBwZW5kSXRlbShuZXcgQmxhY2tib3hNZW51SXRlbShuYW1lLCBmaWxlLCB0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBsb2FkIGEgbmV0d29yayBhcyBhIG5ldHdvcmsgb2YgY29tcG9uZW50cyBjb25uZWN0ZWQgd2l0aCB3aXJlc1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzTmV0d29yaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29ya0xpc3QuYXBwZW5kSXRlbShuZXcgTmV0d29ya01lbnVJdGVtKG5hbWUsIGZpbGUsIHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChibGFja2JveExpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZEl0ZW0oYmxhY2tib3hMaXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGFkZCBjb25kaXRpb25hbCBpdGVtcyBmb3IgYm94IGFuZCB3aXJlIHJlbW92YWxcbiAgICAgICAgdGhpcy5hcHBlbmRDb25kaXRpb25hbEl0ZW0oJ2JveCcsICdSZW1vdmUgdGhpcyBpdGVtJywgaWQgPT4ge1xuICAgICAgICAgICAgdGhpcy5hcHBJbnN0YW5jZS5yZW1vdmVCb3goaWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hcHBlbmRDb25kaXRpb25hbEl0ZW0oJ3dpcmUnLCAnUmVtb3ZlIHRoaXMgd2lyZScsIGlkID0+IHtcbiAgICAgICAgICAgIHRoaXMuYXBwSW5zdGFuY2UucmVtb3ZlV2lyZUJ5SWQoaWQpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBhZGQgdGhlIGNvbnRleHQgbWVudSB0byB0aGUgRE9NXG4gICAgICAgIGFwcEluc3RhbmNlLiRzdmcuYmVmb3JlKHRoaXMuJGVsKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTnVtYmVyIG9mIGl0ZW1zIGluIHRoaXMgbWVudSAodXNlZCBpbiB0aGUgLmxlbmdodCBnZXR0ZXIpLiBDb25kaXRpb25hbCBpdGVtcyBkbyBub3QgY291bnQuXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLml0ZW1Db3VudCA9IDA7XG4gICAgfVxuXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbUNvdW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFwcGVuZCBhIGNvbnRleHQgbWVudSBpdGVtIHRvIHRoZSBjb250ZXh0IG1lbnVcbiAgICAgKiBAcGFyYW0gIHtDb250ZXh0TWVudUl0ZW19IGl0ZW0gaW5zdGFuY2Ugb2Yge0BsaW5rIENvbnRleHRNZW51SXRlbX0gdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoaXMgbWVudVxuICAgICAqL1xuICAgIGFwcGVuZEl0ZW0oaXRlbSkge1xuICAgICAgICB0aGlzLiRlbC5hcHBlbmQoaXRlbS5qUXVlcnkpO1xuXG4gICAgICAgIHRoaXMuaXRlbUNvdW50Kys7XG5cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYXBwZW5kcyBhbiBjb25uZGl0aW9uYWwgaXRlbSAodGhhdCBpcyBzaG93biBvbmx5IGlmIHRoZSB0YXJnZXQgaGFzIHRoZSBjbGFzcyBpdGVtQ2xhc3MpXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBpdGVtQ2xhc3MgICAgIHNob3cgdGhlIGl0ZW0gb25seSBpZiB0aGUgdGFyZ2V0IGhhcyB0aGlzIGNsYXNzXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0ICAgICAgICAgIHRleHQgb2YgdGhpcyBtZW51IGl0ZW1cbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2xpY2tGdW5jdGlvbiBmdW5jdGlvbiB3aXRoIG9uZSBhcmd1bWVudCAoSUQgb2YgdGhlIHRhcmdldCkgdGhhdCB3aWxsIGJlIGNhbGxlZCBvbiBjbGlja1xuICAgICAqL1xuICAgIGFwcGVuZENvbmRpdGlvbmFsSXRlbShpdGVtQ2xhc3MsIHRleHQsIGNsaWNrRnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbmRpdGlvbmFsSXRlbXMpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uYWxJdGVtcyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb25kaXRpb25hbEl0ZW1zW3RoaXMuY29uZGl0aW9uYWxJdGVtcy5sZW5ndGhdID0ge1xuICAgICAgICAgICAgaXRlbUNsYXNzOiBpdGVtQ2xhc3MsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgY2xpY2tGdW5jdGlvbjogY2xpY2tGdW5jdGlvblxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGRpc3BsYXkgdGhlIGRpYWxvZyBmb3IgaW1wb3J0aW5nIGEgbmV0d29yayBmcm9tIGEgY2xpcGJvYXJkXG4gICAgICovXG4gICAgZGlzcGxheUltcG9ydERpYWxvZygpIHtcbiAgICAgICAgbGV0ICRwb3B1cCA9ICQoJzxkaXY+JylcbiAgICAgICAgICAgIC5hZGRDbGFzcygnaW1wb3J0RXhwb3J0JylcbiAgICAgICAgICAgIC5hZGRDbGFzcygnaW1wb3J0Jyk7XG5cbiAgICAgICAgbGV0IHRleHRhcmVhSWQgPSAnaW1wb3J0SlNPTic7XG4gICAgICAgIGxldCAkdGV4dGJsb2NrID0gJCgnPHRleHRhcmVhPicpLmF0dHIoJ2lkJywgdGV4dGFyZWFJZCk7XG5cbiAgICAgICAgbGV0IGxpdHlJbnN0YW5jZTtcblxuICAgICAgICAkcG9wdXAuYXBwZW5kKCR0ZXh0YmxvY2spLmFwcGVuZChcbiAgICAgICAgICAgICQoJzxhPicpXG4gICAgICAgICAgICAgICAgLmF0dHIoe1xuICAgICAgICAgICAgICAgICAgICBocmVmOiAnIycsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiAndXBsb2FkJ1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgkKCc8aW1nPicpLmF0dHIoJ3NyYycsICdpbWcvZ3VpL2ltcG9ydC5zdmcnKSlcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCcgaW1wb3J0IGZyb20gSlNPTicpXG4gICAgICAgICAgICAgICAgLm9uKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGE7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKCQoJyMnICsgdGV4dGFyZWFJZCkudmFsKCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcEluc3RhbmNlLm1lc3NhZ2VzLm5ld0Vycm9yTWVzc2FnZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIGltcG9ydGVkIGZpbGUgaXMgbm90IGEgdmFsaWQgSlNPTiBmaWxlLidcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXR5SW5zdGFuY2UuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9jY2VzcyB0aGUgaW1wb3J0ZWQgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBJbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pbXBvcnREYXRhKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBJbnN0YW5jZS52aWV3Ym94LnRyYW5zZm9ybVgodGhpcy5wb3NpdGlvbi54KSAvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBJbnN0YW5jZS5ncmlkU2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBJbnN0YW5jZS52aWV3Ym94LnRyYW5zZm9ybVkodGhpcy5wb3NpdGlvbi55KSAvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBJbnN0YW5jZS5ncmlkU2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHdhcm5pbmdzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB3YXJuaW5nIG9mIHdhcm5pbmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcEluc3RhbmNlLm1lc3NhZ2VzLm5ld1dhcm5pbmdNZXNzYWdlKHdhcm5pbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpdHlJbnN0YW5jZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICBsaXR5SW5zdGFuY2UgPSBsaXR5KCRwb3B1cCk7XG5cbiAgICAgICAgLy8gZm9jdXMgb24gdGhlIHRleHRibG9ja1xuICAgICAgICAkdGV4dGJsb2NrLmZvY3VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZGVjaWRlIHdoZXRoZXIgb3Igbm90IHRvIGRpc3BsYXkgc3BlY2lmaWMgY29uZGl0aW9uYWwgaXRlbXNcbiAgICAgKiBAcGFyYW0gIHtqUXVlcnkuZWxlbWVudH0gJHRhcmdldCBqUXVlcnkgdGFyZ2V0IG9mIGEgTW91c2VFdmVudCAoZWxlbWVudCB0aGF0IHVzZXIgY2xpY2tlZCBvbilcbiAgICAgKi9cbiAgICByZXNvbHZlQ29uZGl0aW9uYWxJdGVtcygkdGFyZ2V0KSB7XG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2YgdGhpcy5jb25kaXRpb25hbEl0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoJHRhcmdldC5oYXNDbGFzcyhpdGVtLml0ZW1DbGFzcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZEl0ZW0oXG4gICAgICAgICAgICAgICAgICAgIG5ldyBDb250ZXh0TWVudUl0ZW0oaXRlbS50ZXh0LCB0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmNsaWNrRnVuY3Rpb24oJHRhcmdldC5hdHRyKCdpZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApLmFkZENsYXNzKCdjb25kaXRpb25hbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGlkZSBhbGwgY29uZGl0aW9uYWwgaXRlbXNcbiAgICAgKi9cbiAgICBoaWRlQWxsQ29uZGl0aW9uYWxJdGVtcygpIHtcbiAgICAgICAgdGhpcy4kZWwuY2hpbGRyZW4oJy5jb25kaXRpb25hbCcpLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGRpc3BsYXlzIHRoZSBjb250ZXh0IG1lbnUgd2l0aCB0aGUgcmlnaHQgc2V0IG9mIGNvbmRpdGlvbmFsIGl0ZW1zXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB4ICAgICAgIGhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGNvbnRleHQgbWVudSBpbiBDU1MgcGl4ZWxzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB5ICAgICAgIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBjb250ZXh0IG1lbnUgaW4gQ1NTIHBpeGVsc1xuICAgICAqIEBwYXJhbSAge2pRdWVyeS5lbGVtZW50fSAkdGFyZ2V0IGpRdWVyeSB0YXJnZXQgb2YgYSBNb3VzZUV2ZW50IChlbGVtZW50IHRoYXQgdXNlciBjbGlja2VkIG9uKVxuICAgICAqL1xuICAgIGRpc3BsYXkoeCwgeSwgJHRhcmdldCkge1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHlcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnJlc29sdmVDb25kaXRpb25hbEl0ZW1zKCR0YXJnZXQpO1xuXG4gICAgICAgIHRoaXMuJGVsXG4gICAgICAgICAgICAuY3NzKHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICAgICAgICAgIHRvcDogeSxcbiAgICAgICAgICAgICAgICBsZWZ0OiB4XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLy8gc2V0IHRoZSB3aWR0aCBleHBpY2l0bHksIG9yIGVsc2UgdGhlIG1lbnUgd2lsbCB3aWRlbiB3aGVuIGRpc3BsYXlpbmcgYSBzdWJtZW51XG4gICAgICAgICAgICAvLyAyIGlzIHRvIHByZXZlbnQgYSB3ZWlyZCB0ZXh0IHdyYXAgYnVnXG4gICAgICAgICAgICAuY3NzKCd3aWR0aCcsICdhdXRvJylcbiAgICAgICAgICAgIC5jc3MoJ3dpZHRoJywgdGhpcy4kZWwuaW5uZXJXaWR0aCgpICsgMik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGlkZSB0aGUgY29udGV4dCBtZW51XG4gICAgICovXG4gICAgaGlkZSgpIHtcbiAgICAgICAgdGhpcy4kZWwuY3NzKHsgZGlzcGxheTogJ25vbmUnIH0pO1xuICAgICAgICAkKCcuc3ViTGlzdCcpLmNzcyh7IGRpc3BsYXk6ICdub25lJyB9KTtcbiAgICAgICAgdGhpcy5oaWRlQWxsQ29uZGl0aW9uYWxJdGVtcygpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGdldEpTT05TdHJpbmcgfSBmcm9tICcuLi9vdGhlci9oZWxwZXJGdW5jdGlvbnMnO1xuXG4vKipcbiAqIEZsb2F0aW5nQnV0dG9uIHJlcHJlc2VudHMgYSBidXR0b24gdGhhdCBpcyB1c2VkIGluIHRoZSBmbG9hdGluZyBtZW51IGluIHRoZSByaWdodCBib3R0b20gY29ybmVyXG4gKiBvZiB0aGUgYXBwbGljYXRpb24uIEl0IG1heSBoYXZlIGEgY3VzdG9tIHRvb2x0aXAgYW5kIGNhbGxiYWNrIG9uIHRoZSBjbGljayBldmVudFxuICovXG5jbGFzcyBGbG9hdGluZ0J1dHRvbiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJ1dHRvbkNsYXNzIEN1c3RvbSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoZSBTVkcgaWNvbiB1c2VkIG9uIHRoaXMgYnV0dG9uLiBUaGlzIHN0cmluZyBpcyBhbHNvIGFkZGVkIGFzIGEgQ1NTIGNsYXNzIHRvIHRoZSBidXR0b24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRvb2x0aXAgICAgIHRvb2x0aXAgZm9yIHRoZSBidXR0b24sIHRoYXQgd2lsbCBiZSBkaXNwbGF5ZWQgb24gaG92ZXIgYW5kIGFsc28gdXNlZCBhcyBhbHRlcm5hdGl2ZSB0aXRsZSBmb3IgdGhlIGltYWdlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2xpY2tFdmVudCAgY3VzdG9tIGNhbGxiYWNrIHdoZW4gdXNlciBjbGlja3MgdGhlIGJ1dHRvblxuICAgICAqIEBwYXJhbSB7QXBwfSBhcHBJbnN0YW5jZSAgIHJlZmVyZW5jZSB0byB0aGUgcGFyZW50IFNWRyBlbGVtZW50XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYnV0dG9uQ2xhc3MsIHRvb2x0aXAsIGNsaWNrRXZlbnQsIGFwcEluc3RhbmNlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBqUXVlcnkgZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGJ1dHRvblxuICAgICAgICAgKiBAdHlwZSB7alF1ZXJ5LmVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiRlbCA9ICQoJzxhPicpO1xuXG4gICAgICAgIC8vIGFkZCBjbGFzc2VzIHRvIHRoZSBlbGVtZW50XG4gICAgICAgIHRoaXMuJGVsLmFkZENsYXNzKCdidXR0b24nKTtcbiAgICAgICAgdGhpcy4kZWwuYWRkQ2xhc3MoYnV0dG9uQ2xhc3MpO1xuXG4gICAgICAgIC8vIGFkZCB0aGUgaWNvblxuICAgICAgICB0aGlzLiRlbC5hcHBlbmQoXG4gICAgICAgICAgICAkKCc8aW1nPicpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3NyYycsIGBpbWcvZ3VpLyR7YnV0dG9uQ2xhc3N9LnN2Z2ApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2FsdCcsIHRvb2x0aXApXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gYWRkIHRoZSB0b29sdGlwIGVsZW1lbnQgYW5kIGFuIGV2ZW50IGxpc3RlbmVyIGlmIHRvb2x0aXAgaXMgZGVmaW5lZFxuICAgICAgICBpZiAodG9vbHRpcCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBqUXVlcnkgZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIHRvb2x0aXBcbiAgICAgICAgICAgICAqIEB0eXBlIHtqUXVlcnkuZWxlbWVudH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy4kdG9vbHRpcCA9ICQoJzxkaXY+Jyk7XG4gICAgICAgICAgICB0aGlzLiR0b29sdGlwLmFkZENsYXNzKCd0b29sdGlwJykuaHRtbCh0b29sdGlwKTtcblxuICAgICAgICAgICAgYXBwSW5zdGFuY2UuJHN2Zy5hZnRlcih0aGlzLiR0b29sdGlwKTtcblxuICAgICAgICAgICAgdGhpcy4kZWwuaG92ZXIoXG4gICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiR0b29sdGlwLmZhZGVJbigyMDApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiR0b29sdGlwLmZhZGVPdXQoMjAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGFuIGV2ZW50IGxpc3RlbmVyIG9uIGNsaWNrLCBpZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgZGVmaW5lZFxuICAgICAgICBpZiAoY2xpY2tFdmVudCkge1xuICAgICAgICAgICAgdGhpcy4kZWwub24oJ2NsaWNrJywgY2xpY2tFdmVudCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKiBAbW9kdWxlIEZsb2F0aW5nTWVudSAqL1xuLyoqXG4gKiBDbGFzcyB0byByZXByZXNlbnQgdGhlIGZsb2F0aW5nIG1lbnUgaW4gdGhlIHJpZ2h0IGJvdHRvbSBjb3JuZXIgb2YgdGhlIHBhZ2UuXG4gKiBJdCBpbnN0YW50aWF0ZXMgYWxsIHRoZSBidXR0b25zIGFuZCB0aGVpciBjYWxsYmFja3MuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZsb2F0aW5nTWVudSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcHB9IGFwcEluc3RhbmNlIHJlZmVyZW5jZSB0byB0aGUgQXBwIGVsZW1lbnQgdGhpcyBtZW51IGlzIGFzc29jaWF0ZWQgd2l0aFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFwcEluc3RhbmNlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aGUgalF1ZXJ5IGVsZW1lbnQgY29udGFpbmluZyBhbGwgYnV0dG9uc1xuICAgICAgICAgKiBAdHlwZSB7alF1ZXJ5LmVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiRlbCA9ICQoJzxkaXY+Jyk7XG5cbiAgICAgICAgY29uc3QgaWQgPSAnZmxvYXRpbmdNZW51JztcblxuICAgICAgICB0aGlzLiRlbC5hdHRyKCdpZCcsIGlkKTtcblxuICAgICAgICAvLyBjb25zdCAkbG9hZGVyID0gJChcIjxkaXY+XCIpLmFkZENsYXNzKFwibG9hZGVyXCIpLmFkZENsYXNzKFwiaGlkZGVuXCIpO1xuXG4gICAgICAgIC8qIEVYUE9SVCAqL1xuICAgICAgICB0aGlzLmFwcGVuZChcbiAgICAgICAgICAgIG5ldyBGbG9hdGluZ0J1dHRvbihcbiAgICAgICAgICAgICAgICAnZXhwb3J0JyxcbiAgICAgICAgICAgICAgICAnR2V0IGNvZGUgZm9yIHRoaXMgbmV0d29yaycsXG4gICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgdGhlIHBvcHVwIGNvbnRhaW5lciBob2xkaW5nIGFsbCBwb3B1cCBjb250ZW50ICh0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIGxpdHkpXG4gICAgICAgICAgICAgICAgICAgIGxldCAkcG9wdXAgPSAkKCc8ZGl2PicpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2ltcG9ydEV4cG9ydCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2V4cG9ydCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGdlbmVyYXRlIHRoZSBibG9jayB3aXRoIGNvZGUgdG8gYmUgZGlzcGxheWVkIGFuZCBhcHBlbmQgaXQgdG8gdGhlIHBvcHVwIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgJHRleHRibG9jayA9ICQoJzx0ZXh0YXJlYT4nKS50ZXh0KFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0SlNPTlN0cmluZyhhcHBJbnN0YW5jZS5leHBvcnREYXRhLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICRwb3B1cC5hcHBlbmQoJHRleHRibG9jayk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZ2VuZXJhdGUgdGhlIGxpbmtzXG4gICAgICAgICAgICAgICAgICAgICRwb3B1cC5hcHBlbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAkKCc8YT4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogZ2V0SlNPTlN0cmluZyhhcHBJbnN0YW5jZS5leHBvcnREYXRhLCB0cnVlLCB0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6ICdkb3dubG9hZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvd25sb2FkOiAnbmV0d29yay5qc29uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKCc8aW1nPicpLmF0dHIoJ3NyYycsICdpbWcvZ3VpL2V4cG9ydC5zdmcnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCcgZXhwYW5kZWQgSlNPTicpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICRwb3B1cC5hcHBlbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAkKCc8YT4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogZ2V0SlNPTlN0cmluZyhhcHBJbnN0YW5jZS5leHBvcnREYXRhLCBmYWxzZSwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnZG93bmxvYWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3dubG9hZDogJ25ldHdvcmsubWluLmpzb24nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCQoJzxpbWc+JykuYXR0cignc3JjJywgJ2ltZy9ndWkvZXhwb3J0LnN2ZycpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJyBjb21wYWN0IEpTT04nKVxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIGxpdHkoJHBvcHVwKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBoaWdobGlnaHQgdGhlIHRleHQgaW4gdGhlIHRleHRibG9ja1xuICAgICAgICAgICAgICAgICAgICAkdGV4dGJsb2NrLnNlbGVjdCgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYXBwSW5zdGFuY2VcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICAvKiBUdXRvcmlhbCAqL1xuICAgICAgICB0aGlzLmFwcGVuZChcbiAgICAgICAgICAgIG5ldyBGbG9hdGluZ0J1dHRvbihcbiAgICAgICAgICAgICAgICAndHV0b3JpYWwnLFxuICAgICAgICAgICAgICAgICdTdGFydCB0aGUgdHV0b3JpYWwnLFxuICAgICAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYXBwSW5zdGFuY2Uuc3RhcnRUdXRvcmlhbCgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYXBwSW5zdGFuY2VcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICBhcHBJbnN0YW5jZS4kc3ZnLmFmdGVyKHRoaXMuJGVsKTtcblxuICAgICAgICAvKiBIRUxQICovXG5cbiAgICAgICAgbGV0IGhlbHAgPSBuZXcgRmxvYXRpbmdCdXR0b24oJ2hlbHAnLCAnRGlzcGxheSBhIGhlbHAgcGFnZScsIGZhbHNlLCBhcHBJbnN0YW5jZSk7XG4gICAgICAgIGhlbHAuJGVsLmF0dHIoe1xuICAgICAgICAgICAgaHJlZjogJy4vZG9jcy91c2VyLmh0bWwnLFxuICAgICAgICAgICAgJ2RhdGEtbGl0eSc6ICcnXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFwcGVuZChoZWxwKTtcblxuICAgICAgICBjb25zdCBnaXRodWIgPSBuZXcgRmxvYXRpbmdCdXR0b24oJ2dpdGh1YicsICdPcGVuIHRoZSBwcm9qZWN0IHJlcG9zaXRvcnknLCBmYWxzZSwgYXBwSW5zdGFuY2UpO1xuICAgICAgICBnaXRodWIuJGVsLmF0dHIoe1xuICAgICAgICAgICAgaHJlZjogJ2h0dHBzOi8vZ2l0aHViLmNvbS9qYW5qYXJvbWlyaG9yYWsvaHJhZGxhJyxcbiAgICAgICAgICAgIHRhcmdldDogJ19ibGFuaydcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXBwZW5kKGdpdGh1Yik7XG5cbiAgICAgICAgYXBwSW5zdGFuY2UuJHN2Zy5hZnRlcih0aGlzLiRlbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYXBwZW5kIGEgRmxvYXRpbmdCdXR0b24gdG8gdGhpcyBtZW51XG4gICAgICogQHBhcmFtICB7RmxvYXRpbmdCdXR0b259IG1lbnVJdGVtIGFwcGVuZCBhbiBpbnN0YW5jZSBvZiAge0BsaW5rIEZsb2F0aW5nQnV0dG9ufSB0byB0aGlzIG1lbnVcbiAgICAgKi9cbiAgICBhcHBlbmQobWVudUl0ZW0pIHtcbiAgICAgICAgdGhpcy4kZWwuYXBwZW5kKG1lbnVJdGVtLiRlbCk7XG4gICAgfVxufVxuIiwiLyoqIEBtb2R1bGUgTWVzc2FnZXMgKi9cblxuLyoqXG4gKiBhIGdlbmVyaWMgbWVzc2FnZSB0aGF0IGNhbiBiZSBkaXNwbGF5ZWQgaW4gdGhlIHtAbGluayBNZXNzYWdlc30gYm94XG4gKi9cbmNsYXNzIE1lc3NhZ2Uge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0ICAgICAgICAgICAgICAgdGV4dCBvZiB0aGUgbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkhpZGVdIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBgaGlkZSgpYCBtZXRob2QgaXMgY2FsbGVkXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGV4dCwgb25IaWRlKSB7XG4gICAgICAgIHRoaXMuJGVsID0gJCgnPGRpdj4nKVxuICAgICAgICAgICAgLmFkZENsYXNzKCdtZXNzYWdlJylcbiAgICAgICAgICAgIC50ZXh0KHRleHQpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGBoaWRlKClgIG1ldGhvZCBpcyBjYWxsZWRcbiAgICAgICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkhpZGUgPSBvbkhpZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGlkZSB0aGUgbWVzc2FnZSAoYW5kIGNhbGwgdGhlIG9uSGlkZSBjYWxsYmFjayBpZiB0aGVyZSBpcyBhbnkpXG4gICAgICovXG4gICAgaGlkZSgpIHtcbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMub25IaWRlKSB7XG4gICAgICAgICAgICB0aGlzLm9uSGlkZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIGEgbG9hZGluZyBtZXNzYWdlIHRoYXQgY2FuIGJlIGRpc3BsYXllZCBpbiB0aGUge0BsaW5rIE1lc3NhZ2VzfSBib3hcbiAqIEBleHRlbmRzIE1lc3NhZ2VcbiAqL1xuY2xhc3MgTG9hZGluZ01lc3NhZ2UgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBvbkhpZGUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3VwZXIodGV4dCwgb25IaWRlKTtcblxuICAgICAgICB0aGlzLiRlbC5hZGRDbGFzcygnbG9hZGluZycpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBhIG1lc3NhZ2UgdGhhdCBoYXMgYSBjbG9zZSBidXR0b24gYW5kIHRoYXQgY2FuIGJlIGRpc3BsYXllZCBpbiB0aGUge0BsaW5rIE1lc3NhZ2VzfSBib3hcbiAqIEBleHRlbmRzIE1lc3NhZ2VcbiAqL1xuY2xhc3MgQ2xvc2FibGVNZXNzYWdlIGV4dGVuZHMgTWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3IodGV4dCwgb25IaWRlID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN1cGVyKHRleHQsIG9uSGlkZSk7XG5cbiAgICAgICAgdGhpcy4kZWwuYXBwZW5kKFxuICAgICAgICAgICAgJCgnPHNwYW4+JylcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2Nsb3NlJylcbiAgICAgICAgICAgICAgICAuY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBhbiBlcnJvciBtZXNzYWdlIHRoYXQgY2FuIGJlIGRpc3BsYXllZCBpbiB0aGUge0BsaW5rIE1lc3NhZ2VzfSBib3hcbiAqIEBleHRlbmRzIENsb3NhYmxlTWVzc2FnZVxuICovXG5jbGFzcyBFcnJvck1lc3NhZ2UgZXh0ZW5kcyBDbG9zYWJsZU1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIG9uSGlkZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBzdXBlcih0ZXh0LCBvbkhpZGUpO1xuXG4gICAgICAgIHRoaXMuJGVsLmFkZENsYXNzKCdlcnJvcicpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBhIHdhcm5pbmcgbWVzc2FnZSB0aGF0IGNhbiBiZSBkaXNwbGF5ZWQgaW4gdGhlIHtAbGluayBNZXNzYWdlc30gYm94XG4gKiBAZXh0ZW5kcyBDbG9zYWJsZU1lc3NhZ2VcbiAqL1xuY2xhc3MgV2FybmluZ01lc3NhZ2UgZXh0ZW5kcyBDbG9zYWJsZU1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIG9uSGlkZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBzdXBlcih0ZXh0LCBvbkhpZGUpO1xuXG4gICAgICAgIHRoaXMuJGVsLmFkZENsYXNzKCd3YXJuaW5nJyk7XG4gICAgfVxufVxuXG4vKipcbiAqIGRpc3BsYXkgbWVzc2FnZXMgdG8gdGhlIHVzZXIgaW4gYSBuaWNlIFVJXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lc3NhZ2VzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGpRdWVyeSBlbGVtZW50IHRoYXQgcmVwcmVzZW50cyB0aGUgbWVzc2FnZSBpbnRlcmZhY2UuIFRoaXMgZWxlbWVudCBjb250YWlucyBhbGwgdGhlIGN1cnJlbnRseSBkaXNwbGF5ZWQgbWVzc2FnZXMuXG4gICAgICAgICAqIEB0eXBlIHtqUXVlcnkuZWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuJGVsID0gJCgnPGRpdj4nKS5hZGRDbGFzcygnbWVzc2FnZXMnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogbnVtYmVyIG9mIGN1cnJlbnRseSBkaXNwbGF5ZWQgbWVzc2FnZXMsIGhhcyBhIHNwZWNpZmllZCBzZXR0ZXIgYW5kIGdldHRlclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG5cbiAgICAgICAgLy8gcGxhY2UgdGhlIHByb2dyZXNzIGluZm8gZWxlbWVudFxuICAgICAgICAkKCdib2R5JykuYXBwZW5kKHRoaXMuJGVsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIG51bWJlciBvZiBjdXJyZW50bHkgZGlzcGxheWVkIG1lc3NhZ2VzXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBbZGVzY3JpcHRpb25dXG4gICAgICovXG4gICAgZ2V0IGNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlQ291bnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBudW1iZXIgb2YgY3VycmVudGx5IGRpc3BsYXllZCBtZXNzYWdlcy4gU2hvdWxkIGJlIGNhbGxlZCBvbmx5IHRocm91Z2ggZnVuY3Rpb25zIHRoYXQgYWRkIG1lc3NhZ2VzLlxuICAgICAqXG4gICAgICogSWYgdGhlIG1lc3NhZ2UgY291bnQgaXMgPj0gMSwgdGhlIGpRdWVyeSBlbGVtZW50IGZvciB0aGUgVUkgaXMgZGlzcGxheWVkLCBpZiB0aGUgbWVzc2FnZSBjb3VudCBpcyA8MSwgdGhlIFVJIGlzIGhpZGRlbi5cbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICBzZXQgY291bnQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlQ291bnQgPSB2YWx1ZTtcblxuICAgICAgICBpZiAodGhpcy5tZXNzYWdlQ291bnQgPCAxKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGlkZSB0aGUgbWVzc2FnZSBib3ggYnkgYWRkaW5nIGEgYGhpZGRlbmAgY2xhc3MgdG8gdGhlIGVsZW1lbnRcbiAgICAgKi9cbiAgICBoaWRlKCkge1xuICAgICAgICB0aGlzLiRlbC5hZGRDbGFzcygnaGlkZGVuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZGlzcGxheSB0aGUgbWVzc2FnZSBib3ggYnkgcmVtb3ZpbmcgdGhlIGBoaWRkZW5gIGNsYXNzIHRvIHRoZSBlbGVtZW50XG4gICAgICovXG4gICAgZGlzcGxheSgpIHtcbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlQ2xhc3MoJ2hpZGRlbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFkZCBhIG5ldyBtZXNzYWdlIHRvIHRoZSBtZXNzYWdlIGJveFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gdGV4dCAgICAgICAgICAgICB0ZXh0IG9mIHRoZSBtZXNzYWdlXG4gICAgICogQHBhcmFtICB7TWVzc2FnZX0gW2NvbnN0cj1NZXNzYWdlXSBjb25zdHJ1Y3RvciBvZiB0aGUgbWVzc2FnZSwgbXVzdCBiZSBhIGRlcml2YXRlIG9mIHRoZSB7QGxpbmsgTWVzc2FnZX0gY2xhc3NcbiAgICAgKiBAcmV0dXJuIHtNZXNzYWdlfSAgICAgICAgICAgICAgICAgIHRoZSBuZXdseSBjb25zdHJ1Y3RlZCBtZXNzYWdlIChpbnN0YW5jZSBtYWRlIGJ5IHRoZSBzcGVjaWZpZWQgY29uc3RydWN0b3IpXG4gICAgICovXG4gICAgbmV3TWVzc2FnZSh0ZXh0LCBjb25zdHIgPSBNZXNzYWdlKSB7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgbWVzc2FnZSBieSBjYWxsaW5nIHRoZSBjb25zdHJ1Y3RvcixcbiAgICAgICAgLy8gcHJvdmlkZSBpdCB3aXRoIHRleHQgYW5kIGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIGhpZGluZyB0aGUgbWVzc2FnZS5cbiAgICAgICAgLy8gVGhpcyBjYWxsYmFjayBzdWJ0cmFjdHMgMSBmcm9tIHRoZVxuICAgICAgICBsZXQgbWVzc2FnZSA9IG5ldyBjb25zdHIodGV4dCwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb3VudC0tO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLiRlbC5hcHBlbmQobWVzc2FnZS4kZWwpO1xuICAgICAgICB0aGlzLmNvdW50Kys7XG5cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIGEgbmV3IGxvYWRpbmcgbWVzc2FnZSBhbmQgYWRkIGl0IHRvIHRoZSBtZXNzYWdlIGJveFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gdGV4dCB0ZXh0IG9mIHRoZSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7TG9hZGluZ01lc3NhZ2V9IHRoZSBuZXdseSBjb25zdHJ1Y3RlZCB7QGxpbmsgTG9hZGluZ01lc3NhZ2V9XG4gICAgICovXG4gICAgbmV3TG9hZGluZ01lc3NhZ2UodGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdNZXNzYWdlKHRleHQsIExvYWRpbmdNZXNzYWdlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgYSBuZXcgZXJyb3IgbWVzc2FnZSBhbmQgYWRkIGl0IHRvIHRoZSBtZXNzYWdlIGJveFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gdGV4dCB0ZXh0IG9mIHRoZSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7RXJyb3JNZXNzYWdlfSB0aGUgbmV3bHkgY29uc3RydWN0ZWQge0BsaW5rIEVycm9yTWVzc2FnZX1cbiAgICAgKi9cbiAgICBuZXdFcnJvck1lc3NhZ2UodGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdNZXNzYWdlKHRleHQsIEVycm9yTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIGEgbmV3IHdhcm5pbmcgbWVzc2FnZSBhbmQgYWRkIGl0IHRvIHRoZSBtZXNzYWdlIGJveFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gdGV4dCB0ZXh0IG9mIHRoZSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7V2FybmluZ01lc3NhZ2V9IHRoZSBuZXdseSBjb25zdHJ1Y3RlZCB7QGxpbmsgV2FybmluZ01lc3NhZ2V9XG4gICAgICovXG4gICAgbmV3V2FybmluZ01lc3NhZ2UodGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdNZXNzYWdlKHRleHQsIFdhcm5pbmdNZXNzYWdlKTtcbiAgICB9XG59XG4iLCIvKiogQG1vZHVsZSBUdXRvcmlhbCAqL1xuLyoqXG4gKiBEaXNwbGF5IGFuZCBtYW5hZ2UgdGhlIHR1dG9yaWFsXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR1dG9yaWFsIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FwcH0gYXBwSW5zdGFuY2UgaW5zdGFuY2Ugb2YgW0FwcF0oLi9tb2R1bGUtQXBwLmh0bWwpIGZvciB0aGlzIHR1dG9yaWFsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uVHV0b3JpYWxDbG9zZWRdIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdXNlciBjbG9zZXMgb3IgZmluaXNoZXMgdGhlIHR1dG9yaWFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYXBwSW5zdGFuY2UsIG9uVHV0b3JpYWxDbG9zZWQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGluc3RhbmNlIG9mIFtBcHBdKC4vbW9kdWxlLUFwcC5odG1sKSBmb3IgdGhpcyB0dXRvcmlhbFxuICAgICAgICAgKiBAdHlwZSB7QXBwfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hcHBJbnN0YW5jZSA9IGFwcEluc3RhbmNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBoZWxwZXIgdmFyaWFibGUgZm9yIHRoZSBgc3RlcGAgcHJvcGVydHksIHN0b3JlcyBjdXJyZW50IHN0YXRlIG9mIHRoZSB0dXRvcmlhbCAoc3RlcCBgMGAgbWVhbnMgdGhhdCB0dXRvcmlhbCBpcyBjbG9zZWQpXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGVwID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogalF1ZXJ5IGVsZW1lbnQgY29udGFpbmluZyB0aGUgdHV0b3JpYWwgcG9wdXBcbiAgICAgICAgICogQHR5cGUge2pRdWVyeS5lbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy4kdHV0b3JpYWxXaW5kb3c7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBqUXVlcnkgZWxlbWVudCBmb3IgdGhlIGR5bmFtaWMgcGFydCBvZiB0aGUgdHV0b3JpYWwgcG9wdXBcbiAgICAgICAgICogKHRleHQgYW5kIGJ1dHRvbnMgdGhhdCBhcmUgZGVwZW5kZW50IG9uIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSB0dXRvcmlhbClcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy4kdHV0b3JpYWxDb250ZW50O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhcnJheSBvZiBmdW5jdGlvbnMgdGhhdCByZXByZXNlbnQgaW50aXZpZHVhbCBzdGVwcyBpbiB0aGUgdHV0b3JpYWxcbiAgICAgICAgICogYnkgZGVmYXVsdCBwb3B1bGF0ZWQgd2l0aCBzdGVwIGAwYCB0aGF0IGNsb3NlcyB0aGUgdHV0b3JpYWxcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGVwcyA9IFtcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlV2luZG93KG9uVHV0b3JpYWxDbG9zZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuXG4gICAgICAgIC8vIHNldCB1cCB0aGUgdHV0b3JpYWxcbiAgICAgICAgdGhpcy5zZXRVcFR1dG9yaWFsKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBjdXJyZW50IHN0ZXAgb2YgdGhlIHR1dG9yaWFsLCB0aGlzIG51bWJlciBjb3JyZXNwb25kcyB0byB0aGUgaW5kZXggaW4gdGhlIGB0aGlzLnN0ZXBzYCBhcnJheVxuICAgICAqIHRoYXQgY29udGFpbnMgdGhlIGZ1bmN0aW9uIGZvciB0aGUgbGFzdCBkaXNwbGF5ZWQgc3RlcFxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgc3RlcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFN0ZXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2hhbmdlIHRoZSBjdXJyZW50IHN0ZXAgb2YgdGhlIHR1dG9yaWFsLCBgMGAgbWVhbnMgXCJzdG9wIHRoZSB0dXRvcmlhbFwiXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB2YWx1ZSB0aGUgc3RlcCBvZiB0aGUgdHV0b3JpYWwgdG8gYmUgZGlzcGxheWVkXG4gICAgICovXG4gICAgc2V0IHN0ZXAodmFsdWUpIHtcbiAgICAgICAgLy8gcmVzZXQgYWxsIGhvb2tzXG4gICAgICAgIHRoaXMucmVzZXRIb29rcygpO1xuXG4gICAgICAgIHRoaXMuY3VycmVudFN0ZXAgPSB2YWx1ZTtcblxuICAgICAgICBpZiAodGhpcy5zdGVwIDwgdGhpcy5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RlcHNbdGhpcy5zdGVwXSgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zdGVwID09PSAxKSB0aGlzLmRpc3BsYXlXaW5kb3coKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RlcCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXNldCBhbGwgdHV0b3JpYWwgaG9va3NcbiAgICAgKi9cbiAgICByZXNldEhvb2tzKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogX3R1dG9yaWFsIGhvb2tfLCBjYWxsZWQgd2hlbiB0aGUgY29udGV4dCBtZW51IGlzIG9wZW5lZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkNvbnRleHRNZW51T3BlbmVkID0gKCkgPT4ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIF90dXRvcmlhbCBob29rXywgY2FsbGVkIHdoZW4gYSBuZXcgZWxlbWVudCBpcyBhZGRlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkVsZW1lbnRBZGRlZCA9ICgpID0+IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBfdHV0b3JpYWwgaG9va18sIGNhbGxlZCB3aGVuIGEgYm94IGlzIG1vdmVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQm94TW92ZWQgPSAoKSA9PiB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogX3R1dG9yaWFsIGhvb2tfLCBjYWxsZWQgd2hlbiBhIGJveCBpcyByb3RhdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQm94Um90YXRlZCA9ICgpID0+IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBfdHV0b3JpYWwgaG9va18sIGNhbGxlZCB3aGVuIGFuIG91dHB1dCBib3ggdmFsdWUgaXMgc2V0IHRvIGBvbmBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25PdXRwdXRCb3hUcnVlID0gKCkgPT4ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIF90dXRvcmlhbCBob29rXywgY2FsbGVkIHdoZW4gdGhlIGNhbnZhcyBpcyBtb3ZlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkNhbnZhc01vdmVkID0gKCkgPT4ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIF90dXRvcmlhbCBob29rXywgY2FsbGVkIHdoZW4gdGhlIGNhbnZhcyBpcyB6b29tZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25DYW52YXNab29tZWQgPSAoKSA9PiB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogX3R1dG9yaWFsIGhvb2tfLCBjYWxsZWQgd2hlbiBhIGJveCBpcyByZW1vdmVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uRWxlbWVudFJlbW92ZWQgPSAoKSA9PiB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogX3R1dG9yaWFsIGhvb2tfLCBjYWxsZWQgd2hlbiB1c2VyIGNoYW5nZXMgdGhlIHN0YXRlIG9mIGFuIGlucHV0IGJveFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkNoYW5nZUlucHV0Qm94U3RhdGUgPSAoKSA9PiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdXAgdGhlIHR1dG9yaWFsOiByZXNldCBhbGwgdHV0b3JpYWwgaG9va3MgYW5kIGRlZmluZSB0aGUgb3JkZXIgb2YgdHV0b3JpYWwgc3RlcHNcbiAgICAgKi9cbiAgICBzZXRVcFR1dG9yaWFsKCkge1xuICAgICAgICB0aGlzLnJlc2V0SG9va3MoKTtcblxuICAgICAgICB0aGlzLnN0ZXBzLnB1c2goXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGVwV2VsY29tZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0ZXBBZGRCb3hlcygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0ZXBNb3ZlQ2FudmFzKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RlcFpvb21DYW52YXMoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGVwTW92ZUJveGVzKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RlcFdpcmluZygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN3aXRjaElucHV0Qm94KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RlcFJlbW92ZUJveCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0ZXBGaW5pc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBfdHV0b3JpYWwgc3RlcF86IGRpc3BsYXkgY29udGV4dCBtZW51XG4gICAgICovXG4gICAgc3RlcFdlbGNvbWUoKSB7XG4gICAgICAgIHRoaXMud2luZG93Q29udGVudChcbiAgICAgICAgICAgIGBXZWxjb21lIHRvIEhyYWRsYSEgVG8gZ2V0IHN0YXJ0ZWQsIGNsaWNrIGFueXdoZXJlIG9uIHRoZSBlZGl0aW5nIGFyZWEgd2l0aCB5b3VyIHJpZ2h0IG1vdXNlIGJ1dHRvbi5gXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5vbkNvbnRleHRNZW51T3BlbmVkID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogX3R1dG9yaWFsIHN0ZXBfOiBhZGQgaW5wdXQgYm94LCBvdXRwdXQgYm94IGFuZCBhIE5PVCBnYXRlXG4gICAgICovXG4gICAgc3RlcEFkZEJveGVzKCkge1xuICAgICAgICB0aGlzLndpbmRvd0NvbnRlbnQoXG4gICAgICAgICAgICBgR3JlYXQgam9iISBOb3cgeW91IGtub3csIGhvdyB0byBvcGVuIHRoZSBlZGl0b3IgbWVudS5cbiAgICAgICAgICAgIE5vdyB0cnkgdG8gYWRkIGFuIDxlbT5JbnB1dCBib3g8L2VtPiwgPGVtPk91dHB1dCBib3g8L2VtPiBhbmQgYSA8ZW0+Tk9UIGdhdGU8L2VtPlxuICAgICAgICAgICAgdG8gdGhlIGVkaXRpbmcgYXJlYS5gXG4gICAgICAgICk7XG5cbiAgICAgICAgbGV0IGVsZW1lbnRzQWRkZWQgPSB7XG4gICAgICAgICAgICBpbnB1dEJveDogZmFsc2UsXG4gICAgICAgICAgICBvdXRwdXRCb3g6IGZhbHNlLFxuICAgICAgICAgICAgbm90R2F0ZTogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLm9uRWxlbWVudEFkZGVkID0gbmFtZSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzQWRkZWQuaW5wdXRCb3ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdvdXRwdXQnOlxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50c0FkZGVkLm91dHB1dEJveCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ25vdCc6XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzQWRkZWQubm90R2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIGFjdGlvbiBvbiBkZWZhdWx0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWxlbWVudHNBZGRlZC5pbnB1dEJveCAmJiBlbGVtZW50c0FkZGVkLm91dHB1dEJveCAmJiBlbGVtZW50c0FkZGVkLm5vdEdhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBwcm9jZWVkIHRvIHRoZSBuZXh0IHN0ZXAgb2YgdGhlIHR1dG9yaWFsXG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogX3R1dG9yaWFsIHN0ZXBfOiBtb3ZlIHRoZSBjYW52YXNcbiAgICAgKi9cbiAgICBzdGVwTW92ZUNhbnZhcygpIHtcbiAgICAgICAgdGhpcy53aW5kb3dDb250ZW50KFxuICAgICAgICAgICAgYFlvdSBjYW4gbW92ZSB0aGUgZWRpdGluZyBhcmVhIChzb21ldGltZXMgY2FsbGVkIGNhbnZhcykgYnkgZHJhZ2dpbmdcbiAgICAgICAgICAgIHdpdGggdGhlIG1pZGRsZSBtb3VzZSBidXR0b24gb3IgYnkgaG9sZGluZyB0aGUgPGNvZGU+Q3RybDwvY29kZT4ga2V5XG4gICAgICAgICAgICBhbmQgZHJhZ2dpbmcgd2l0aCB0aGUgbGVmdCBtb3VzZSBidXR0b24uIENoZWNrIGl0IG91dC5gXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5vbkNhbnZhc01vdmVkID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogX3R1dG9yaWFsIHN0ZXBfOiB6b29tIHRoZSBjYW52YXNcbiAgICAgKi9cbiAgICBzdGVwWm9vbUNhbnZhcygpIHtcbiAgICAgICAgdGhpcy53aW5kb3dDb250ZW50KFxuICAgICAgICAgICAgYFlvdSBjYW4gYWxzbyB6b29tIGluIGFuZCBvdXQgdXNpbmcgdGhlIG1vdXNlIHdoZWVsXG4gICAgICAgICAgICBvciB3aXRoIHRoZSA8Y29kZT4rPC9jb2RlPiZuYnNwO2FuZCA8Y29kZT7iiJI8L2NvZGU+Jm5ic3A7a2V5cy5gXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5vbkNhbnZhc1pvb21lZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIF90dXRvcmlhbCBzdGVwXzogbW92ZSB0aGUgYm94ZXNcbiAgICAgKi9cbiAgICBzdGVwTW92ZUJveGVzKCkge1xuICAgICAgICB0aGlzLndpbmRvd0NvbnRlbnQoYFlvdSBjYW4gbW92ZSB0aGUgZWxlbWVudHMgb24gdGhlIGVkaXRpbmcgY2FudmFzIGJ5IGRyYWdnaW5nIHRoZW1cbiAgICAgICAgICAgIHVzaW5nIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbi4gWW91IGNhbiBhbHNvIHJvdGF0ZSB0aGVtIHVzaW5nIG1pZGRsZSBjbGljay4gVHJ5IGl0IG91dC5gKTtcblxuICAgICAgICBsZXQgYm94TW92ZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGJveFJvdGF0ZWQgPSBmYWxzZTtcblxuICAgICAgICBsZXQgbW92ZVJvdGF0ZUNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGJveE1vdmVkICYmIGJveFJvdGF0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLm9uQm94TW92ZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBib3hNb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICBtb3ZlUm90YXRlQ2FsbGJhY2soKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLm9uQm94Um90YXRlZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGJveFJvdGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgbW92ZVJvdGF0ZUNhbGxiYWNrKCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogX3R1dG9yaWFsIHN0ZXBfOiBjcmVhdGUgYW4gaW52ZXJ0b3JcbiAgICAgKi9cbiAgICBzdGVwV2lyaW5nKCkge1xuICAgICAgICB0aGlzLndpbmRvd0NvbnRlbnQoXG4gICAgICAgICAgICBgRXNzZW50aWFsIHBhcnQgb2YgbG9naWMgbmV0d29ya3MgaXMgdGhlIHdpcmluZy4gQ3JlYXRlIGEgdmVyeSBzaW1wbGVcbiAgICAgICAgICAgIGludmVydGVyIGJ5IGNvbm5lY3RpbmcgdGhlIDxlbT5JbnB1dCBib3g8L2VtPiB0byB0aGUgaW5wdXQgb2YgdGhlIDxlbT5OT1QgZ2F0ZTwvZW0+XG4gICAgICAgICAgICBhbmQgdGhlIG91dHB1dCBvZiB0aGUgPGVtPk5PVCBnYXRlPC9lbT4gdG8gdGhlIGlucHV0IG9mIHRoZSA8ZW0+T3V0cHV0IGJveDwvZW0+LmAsXG4gICAgICAgICAgICBgVG8gY29ubmVjdCB0d28gZWxlbW50cywgc2ltcGx5IGNsaWNrIG9uIGEgY29ubmVjdG9yIG9mIHRoZSBmaXJzdCBlbGVtZW50LFxuICAgICAgICAgICAgdGhhbiBjbGljayBvbiBhIGNvbmVjdG9yIG9mIHRoZSBzZWNvbmQgZWxlbWVudC5gXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5vbk91dHB1dEJveFRydWUgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBfdHV0b3JpYWwgc3RlcF86IGNoYW5nZSB0aGUgc3RhdGUgb2YgYW4gaW5wdXQgYm94XG4gICAgICovXG4gICAgc3dpdGNoSW5wdXRCb3goKSB7XG4gICAgICAgIHRoaXMud2luZG93Q29udGVudChgXG4gICAgICAgICAgICBUaGUgaW5wdXQgYm94ZXMgY2FuIGJlIGluIHR3byBzdGF0ZXM6IDxlbT5PTjwvZW0+IGFuZCA8ZW0+T0ZGPC9lbT4sIHNpZ25hbGxlZFxuICAgICAgICAgICAgYnkgdGhlIGdyZWVuIGFuZCByZWQgY29sb3JzIHJlc3BlY3RpdmVseS4gWW91IGNhbiBsZWZ0IGNsaWNrIG9uIGFuIElucHV0IGJveCB0b1xuICAgICAgICAgICAgc3dpdGNoIGl0cyBzdGF0ZS4gVHJ5IGl0IG91dCFcbiAgICAgICAgYCk7XG5cbiAgICAgICAgdGhpcy5vbkNoYW5nZUlucHV0Qm94U3RhdGUgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBfdHV0b3JpYWwgc3RlcF86IHJlbW92ZSBhIGJveFxuICAgICAqL1xuICAgIHN0ZXBSZW1vdmVCb3goKSB7XG4gICAgICAgIHRoaXMud2luZG93Q29udGVudChcbiAgICAgICAgICAgIGBXaGVuIHlvdSByaWdodCBjbGljayBvbiBhbiBlbGVtZW50LCB5b3UgY2FuIGZpbmQgYSBuZXcgaXRlbSBpbiB0aGUgbWVudSxcbiAgICAgICAgICAgIHRoYXQgYWxsb3dzIHlvdSB0byByZW1vdmUgdGhlIGVsZW1lbnQuIFRoaXMgd29ya3MgZm9yIHdpcmVzIGFzIHdlbGwgYXMgZm9yIGdhdGVzIGFuZCBvdGhlciB0eXBlcyBvZiBib3hlcy5cbiAgICAgICAgICAgIFRyeSB0byByZW1vdmUgYW4gZWxlbWVudCFgXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5vbkVsZW1lbnRSZW1vdmVkID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogX3R1dG9yaWFsIHN0ZXBfOiBhc2sgdGhlIHVzZXIgaWYgdGhleSB3YW50IHRvIGNsZWFuIHRoZSBjYW52YXMgYmVmb3JlIGNsb3NpbmcgdGhlIHR1dG9yaWFsXG4gICAgICovXG4gICAgc3RlcEZpbmlzaCgpIHtcbiAgICAgICAgdGhpcy53aW5kb3dDb250ZW50KFxuICAgICAgICAgICAgYFlvdSdyZSBhbGwgc2V0LCBlbmpveSB5b3VyIHN0YXkhYCxcbiAgICAgICAgICAgIGBEbyB5b3Ugd2lzaCB0byBzdGFydCB3aXRoIGVtcHR5IGNhbnZhcz9gXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMud2luZG93Q2hvaWNlKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRleHQ6ICd5ZXMsIGNsZWFuIHRoZSBjYW52YXMnLFxuICAgICAgICAgICAgICAgIGZ1bmM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBJbnN0YW5jZS5jbGVhbkNhbnZhcygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRleHQ6ICdubywga2VlcCB0aGUgY2FudmFzIGFzIGl0IGlzJyxcbiAgICAgICAgICAgICAgICBmdW5jOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBkaXNwbGF5IHRoZSB0dXRvcmlhbCB3aW5kb3dcbiAgICAgKi9cbiAgICBkaXNwbGF5V2luZG93KCkge1xuICAgICAgICB0aGlzLmFwcEluc3RhbmNlLiRzdmcuYWZ0ZXIodGhpcy4kdHV0b3JpYWxXaW5kb3cpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNsb3NlIHRoZSB0dXRvcmlhbCB3aW5kb3dcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW29uVHV0b3JpYWxDbG9zZWRdIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHR1dG9yaWFsIGlzIGNsb3NlZFxuICAgICAqL1xuICAgIGNsb3NlV2luZG93KG9uVHV0b3JpYWxDbG9zZWQpIHtcbiAgICAgICAgdGhpcy4kdHV0b3JpYWxXaW5kb3cucmVtb3ZlKCk7XG5cbiAgICAgICAgaWYgKG9uVHV0b3JpYWxDbG9zZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb25UdXRvcmlhbENsb3NlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0IHRoZSB0dXRvcmlhbCB3aW5kb3cgdGV4dCBjb250ZW50XG4gICAgICogQHBhcmFtICB7Li4uc3RyaW5nfSB0ZXh0IGVhY2ggc3RyaW5nIGlzIGEgc2VwYXJhdGUgcGFyYWdyYXBoXG4gICAgICovXG4gICAgd2luZG93Q29udGVudCguLi50ZXh0KSB7XG4gICAgICAgIGlmICghdGhpcy4kdHV0b3JpYWxXaW5kb3cpIHtcbiAgICAgICAgICAgIHRoaXMuJHR1dG9yaWFsV2luZG93ID0gJCgnPGRpdj4nKS5hdHRyKCdpZCcsICd0dXRvcmlhbCcpO1xuXG4gICAgICAgICAgICB0aGlzLiR0b3BCdXR0b25zTGVmdCA9ICQoJzxkaXY+JykuYWRkQ2xhc3MoJ2xlZnQnKTtcblxuICAgICAgICAgICAgdGhpcy4kdHV0b3JpYWxXaW5kb3cuYXBwZW5kKFxuICAgICAgICAgICAgICAgICQoJzxkaXY+JylcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCd0b3BCdXR0b25zJylcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCh0aGlzLiR0b3BCdXR0b25zTGVmdClcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSAucmlnaHQgZGl2IGNhbiBiZSBhZGRlZCBoZXJlIGJlY2F1c2UgaXQgaXMgbm90IG1vZGlmaWVkIGR1cmluZyB0aGUgdHV0b3JpYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJzxkaXY+JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3JpZ2h0JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCc8YT4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6ICcjJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ2Nsb3NlIHR1dG9yaWFsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnYnV0dG9uIGNsb3NlJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdGhpcy4kdHV0b3JpYWxXaW5kb3cuYXBwZW5kKHRoaXMuJHRvcEJ1dHRvbnMpO1xuXG4gICAgICAgICAgICB0aGlzLiR0dXRvcmlhbENvbnRlbnQgPSAkKCc8ZGl2PicpLmFkZENsYXNzKCdjb250ZW50Jyk7XG4gICAgICAgICAgICB0aGlzLiR0dXRvcmlhbFdpbmRvdy5hcHBlbmQodGhpcy4kdHV0b3JpYWxDb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJHRvcEJ1dHRvbnNMZWZ0Lmh0bWwoJycpO1xuXG4gICAgICAgIGxldCAkcHJldiA9ICQoJzxhPicpXG4gICAgICAgICAgICAuYXR0cih7XG4gICAgICAgICAgICAgICAgaHJlZjogJyMnLFxuICAgICAgICAgICAgICAgIHRpdGxlOiAnZ28gYmFjaydcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYWRkQ2xhc3MoJ2J1dHRvbiBwcmV2Jyk7XG5cbiAgICAgICAgaWYgKHRoaXMuc3RlcCA+IDEpIHtcbiAgICAgICAgICAgICRwcmV2LmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXYoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHByZXYuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgJG5leHQgPSAkKCc8YT4nKVxuICAgICAgICAgICAgLmF0dHIoe1xuICAgICAgICAgICAgICAgIGhyZWY6ICcjJyxcbiAgICAgICAgICAgICAgICB0aXRsZTogJ2dvIGZvcndhcmQnXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmFkZENsYXNzKCdidXR0b24gbmV4dCcpO1xuXG4gICAgICAgIGlmICh0aGlzLnN0ZXAgPCB0aGlzLnN0ZXBzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICRuZXh0LmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJG5leHQuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiR0b3BCdXR0b25zTGVmdC5hcHBlbmQoJHByZXYpLmFwcGVuZCgkbmV4dCk7XG5cbiAgICAgICAgLy8gc2V0IHRoZSB0ZXh0IGNvbnRlbnRcblxuICAgICAgICB0aGlzLiR0dXRvcmlhbENvbnRlbnQuaHRtbCgnJyk7XG4gICAgICAgIGZvciAoY29uc3QgcGFyYWdyYXBoIG9mIHRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuJHR1dG9yaWFsQ29udGVudC5hcHBlbmQoJCgnPHA+JykuaHRtbChwYXJhZ3JhcGgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC8vIHJlbmRlciB0aGUgYnV0dG9ucyBpbiBlYWNoIHN0ZXAgKHRvIHJlbW92ZSBmb2N1cyBhbmQgdG9cbiAgICAgICAgLy8gLy8gZW5zdXJlIHRoZXJlIGlzIG5vIFwiYmFja1wiIGJ1dHRvbiBvbiB0aGUgZmlyc3Qgc3RlcCBvciBcIm5leHRcIiBidXR0b24gb24gdGhlIGxhc3Qgc3RlcClcbiAgICAgICAgLy8gaWYodGhpcy4kcHJldk5leHQpIHtcbiAgICAgICAgLy8gICAgIHRoaXMuJHByZXZOZXh0LnJlbW92ZSgpO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vXG4gICAgICAgIC8vIHRoaXMuJHByZXZOZXh0ID0gJChcIjxkaXY+XCIpLmFkZENsYXNzKFwiYm90dG9tQnV0dG9uc1wiKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gaWYodGhpcy5zdGVwPjEpIHtcbiAgICAgICAgLy8gICAgIHRoaXMuJHByZXZOZXh0LmFwcGVuZChcbiAgICAgICAgLy8gICAgICAgICAkKFwiPGE+XCIpLmF0dHIoXCJocmVmXCIsIFwiI1wiKS5hZGRDbGFzcyhcImJ1dHRvbiBwcmV2XCIpXG4gICAgICAgIC8vICAgICAgICAgLy8gLnRleHQoXCJiYWNrXCIpXG4gICAgICAgIC8vICAgICAgICAgLmNsaWNrKCgpID0+IHtcbiAgICAgICAgLy8gICAgICAgICAgICAgdGhpcy5zdGVwLS07XG4gICAgICAgIC8vICAgICAgICAgfSlcbiAgICAgICAgLy8gICAgIClcbiAgICAgICAgLy8gfVxuICAgICAgICAvL1xuICAgICAgICAvLyBpZih0aGlzLnN0ZXAgPCB0aGlzLnN0ZXBzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgLy8gICAgIHRoaXMuJHByZXZOZXh0LmFwcGVuZChcbiAgICAgICAgLy8gICAgICAgICAkKFwiPGE+XCIpLmF0dHIoXCJocmVmXCIsIFwiI1wiKS5hZGRDbGFzcyhcImJ1dHRvbiBuZXh0XCIpXG4gICAgICAgIC8vICAgICAgICAgLy8gLnRleHQoXCJuZXh0XCIpXG4gICAgICAgIC8vICAgICAgICAgLmNsaWNrKCgpID0+IHtcbiAgICAgICAgLy8gICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIC8vICAgICAgICAgfSlcbiAgICAgICAgLy8gICAgIClcbiAgICAgICAgLy8gfVxuICAgICAgICAvL1xuICAgICAgICAvLyB0aGlzLiR0dXRvcmlhbFdpbmRvdy5hcHBlbmQodGhpcy4kcHJldk5leHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFkZCBidXR0b25zIHdpdGggY2hvaWNlcyB0byB0aGUgdHV0b3JpYWwgd2luZG93XG4gICAgICogQHBhcmFtICB7Li4ub2JqZWN0fSBjaG9pY2VzIGVhY2ggY2hvaWNlIGlzIGFuIG9iamVjdCBpbiB3aXRoIGEgYHN0cmluZ2AgcHJvcGVydHkgX3RleHRfIGFuZCBhIGBmdW5jdGlvbmAgcHJvcGVydHkgX2Z1bmNfXG4gICAgICovXG4gICAgd2luZG93Q2hvaWNlKC4uLmNob2ljZXMpIHtcbiAgICAgICAgbGV0ICRjaG9pY2VzID0gJCgnPG9sPicpLmFkZENsYXNzKCdjaG9pY2VzJyk7XG4gICAgICAgIGZvciAoY29uc3QgY2hvaWNlIG9mIGNob2ljZXMpIHtcbiAgICAgICAgICAgICRjaG9pY2VzLmFwcGVuZChcbiAgICAgICAgICAgICAgICAkKCc8bGk+JykuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICAkKCc8YT4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hyZWYnLCAnIycpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNob2ljZS5mdW5jKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmh0bWwoY2hvaWNlLnRleHQpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiR0dXRvcmlhbENvbnRlbnQuYXBwZW5kKCRjaG9pY2VzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzdGFydCB0aGUgdHV0b3JpYWxcbiAgICAgKi9cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5zdGVwID0gMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnbyB0byB0aGUgbmV4dCBzdGVwIG9mIHRoZSB0dXRvcmlhbFxuICAgICAqL1xuICAgIG5leHQoKSB7XG4gICAgICAgIHRoaXMuc3RlcCsrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdvIHRvIHRoZSBwcmV2aW91cyBzdGVwIG9mIHRoZSB0dXRvcmlhbFxuICAgICAqL1xuICAgIHByZXYoKSB7XG4gICAgICAgIHRoaXMuc3RlcC0tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHN0b3AgdGhlIHR1dG9yaWFsXG4gICAgICovXG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5zdGVwID0gMDtcbiAgICB9XG59XG4iLCIvKiogQG1vZHVsZSBWaWV3Qm94ICovXG4vKipcbiAqIFZpZXdCb3ggcHJvdmlkZXMgYW4gYXBpIGZvciBvcHJlcmF0aW5nIHdpdGggdGhlIHZpZXdCb3ggYXJndW1lbnQgb2YgdGhlIDxzdmc+IERPTSBlbGVtZW50LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaWV3Qm94IHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHZpZXdCb3hcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVmdCAgIGRpc3RhbmNlIG9mIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIHZpZXdib3ggZnJvbSBkb2N1bWVudCdzIHkgYXhpcyBpbiBTVkcgcGl4ZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvcCAgICBkaXN0YW5jZSBvZiB0aGUgdG9wIGVkZ2Ugb2YgdGhlIHZpZXdib3ggZnJvbSB0aGUgZG9jdW1lbnQncyB4IGF4aXMgaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAgd2lkdGggb2YgdGhlIHZpZXdib3ggaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgaGVpZ2h0IG9mIHRoZSB2aWV3Ym94IGluIFNWRyBwaXhlbHNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZpZXdCb3ggYXR0cmlidXRlcyBiZWZvcmUgYXBwbHlpbmcgem9vbSBhbmQgc2hpZnRcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVhbCA9IHsgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXhpbXVtIGFtb3VudCBvZiB6b29tIG9uIHRoZSB2aWV3Ym94XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1heFpvb20gPSA4O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1pbmltdW0gYW1vdW50IG9mIHpvb20gb24gdGhlIHZpZXdib3hcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWluWm9vbSA9IDAuMTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW1vdW50IG9mIHpvb20gb24gdGhlIHZpZXdib3gsIGFsd2F5cyBiZXR3ZWVuIHRoaXMubWluWm9vbSBhbmQgdGhpcy5tYXhab29tXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlYWxab29tID0gMTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogYW1vdW50IG9mIGhvcml6b250YWwgc2hpZnQgb2YgdGhlIGRvY3VtZW50XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxlZnRTaGlmdCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhbW91bnQgb2YgdmVydGljYWwgc2hpZnQgb2YgdGhlIGRvY3VtZW50XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRvcFNoaWZ0ID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB1cGRhdGUgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHZpZXdib3ggKHVzZWQgb24gd2luZG93IHJlc2l6ZSlcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHdpZHRoICBuZXcgd2lkdGggb2YgdGhlIHZpZXdib3ggaW4gU1ZHIHBpeGVsc1xuICAgICAqIEBwYXJhbSAge051bWJlcn0gaGVpZ2h0IG5ldyBoZWlnaHQgb2YgdGhlIHZpZXdib3ggaW4gU1ZHIHBpeGVsc1xuICAgICAqL1xuICAgIG5ld0RpbWVuc2lvbnMod2lkdGgsIGhlaWdodCkge1xuICAgICAgICAvLyBrZWVwIHRoZSB2aWV3Ym94IGNlbnRlcmVkXG4gICAgICAgIHRoaXMucmVhbC5sZWZ0ICs9ICh0aGlzLnJlYWwud2lkdGggLSB3aWR0aCkgLyAyO1xuICAgICAgICB0aGlzLnJlYWwudG9wICs9ICh0aGlzLnJlYWwuaGVpZ2h0IC0gaGVpZ2h0KSAvIDI7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBkaW1lbnNpb25zXG4gICAgICAgIHRoaXMucmVhbC53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLnJlYWwuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFwcGx5IHZpZXdib3ggbW92ZW1lbnQgYW5kIHRha2UgdGhlIHpvb20gaW50byBhY2NvdW50XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBsZWZ0IGhvcml6b250YWwgbW92ZW1lbnRcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRvcCAgdmVydGljYWwgbW92ZW1lbnRcbiAgICAgKi9cbiAgICBtb3ZlKGxlZnQsIHRvcCkge1xuICAgICAgICB0aGlzLmxlZnRTaGlmdCArPSBsZWZ0IC8gdGhpcy56b29tO1xuICAgICAgICB0aGlzLnRvcFNoaWZ0ICs9IHRvcCAvIHRoaXMuem9vbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIGFtb3VudCBvZiB6b29tIG9uIHRoZSB2aWV3Ym94XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCB6b29tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFsWm9vbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdGhlIGFtb3VudCBvZiB6b29tIG9uIHRoZSB2aWV3Ym94XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIHRoZSBuZXcgYW1vdW50IG9mIHpvb21cbiAgICAgKi9cbiAgICBzZXQgem9vbSh2YWx1ZSkge1xuICAgICAgICAvLyBmaXQgdGhpcy5yZWFsWm9vbSB0byBmaXQgYmV0d2VlbiB0aGlzLm1pblpvb20gYW5kIHRoaXMubWF4Wm9vbVxuICAgICAgICB0aGlzLnJlYWxab29tID0gTWF0aC5tYXgoTWF0aC5taW4odmFsdWUsIHRoaXMubWF4Wm9vbSksIHRoaXMubWluWm9vbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSB3aWR0aCBvZiB0aGUgdmlld2JveCB3aXRoIHRoZSBjdXJyZW50IHpvb20gYXBwbGllZFxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIGZpbmFsIHdpZHRoIG9mIHRoZSB2aWV3Ym94XG4gICAgICovXG4gICAgZ2V0IHdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFsLndpZHRoIC8gdGhpcy56b29tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgaGVpZ2h0IG9mIHRoZSB2aWV3Ym94IHdpdGggdGhlIGN1cnJlbnQgem9vbSBhcHBsaWVkXG4gICAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgZmluYWwgaGVpZ2h0IG9mIHRoZSB2aWV3Ym94XG4gICAgICovXG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhbC5oZWlnaHQgLyB0aGlzLnpvb207XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBob3Jpem9udGFsIGRpc3RhbmNlIGZyb20gdGhlIHkgYXhpcyBvZiB0aGUgZG9jdW1lbnQgd2l0aCB6b29tIGFuZCBzaGlmdCB2YWx1ZSBhcHBsaWVkXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBsZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFsLmxlZnQgLSB0aGlzLmxlZnRTaGlmdCArICh0aGlzLnJlYWwud2lkdGggLSB0aGlzLndpZHRoKSAvIDI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSB2ZXJ0aWNhbCBkaXN0YW5jZSBmcm9tIHRoZSB4IGF4aXMgb2YgdGhlIGRvY3VtZW50IHdpdGggem9vbSBhbmQgc2hpZnQgdmFsdWUgYXBwbGllZFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgdG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFsLnRvcCAtIHRoaXMudG9wU2hpZnQgKyAodGhpcy5yZWFsLmhlaWdodCAtIHRoaXMuaGVpZ2h0KSAvIDI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBjb21wdXRlZCB2aWV3Ym94IHZhbHVlcyBhcyBhIHN0cmluZyBpbiB0aGUgY29ycmVjdCBmb3JtYXQgdGhhdCBjYW4gYmUgdXNlZCBpbiB0aGUgdmlld0JveCBhdHRyaWJ1dGUgb2YgdGhlIFNWRyBlbGVtZW50XG4gICAgICogQHJldHVybiB7c3RyaW5nfSBzdHJpbmcgaW4gZm9ybWF0IFwibGVmdCB0b3Agd2lkdGggaGVpZ2h0XCJcbiAgICAgKi9cbiAgICBnZXQgc3RyKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5sZWZ0fSAke3RoaXMudG9wfSAke3RoaXMud2lkdGh9ICR7dGhpcy5oZWlnaHR9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0cmFuc2Zvcm0gaG9yaXpvbnRhbCB1bml0cyB0byB0aGUgc2NhbGUgYW5kIHNoaWZ0IG9mIHRoZSBlZGl0b3JcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggb3JpZ2luYWwgaG9yaXpvbnRhbCB2YWx1ZVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gICB0cmFuc2Zvcm1lZCBob3Jpem9udGFsIHZhbHVlXG4gICAgICovXG4gICAgdHJhbnNmb3JtWCh4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlZnQgKyB4IC8gdGhpcy56b29tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRyYW5zZm9ybSB2ZXJ0aWNhbCB1bml0cyB0byB0aGUgc2NhbGUgYW5kIHNoaWZ0IG9mIHRoZSBlZGl0b3JcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgb3JpZ2luYWwgdmVydGljYWwgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgdHJhbnNmb3JtZWQgdmVydGljYWwgdmFsdWVcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1ZKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9wICsgeSAvIHRoaXMuem9vbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0cmFuc2Zvcm0gcGFnZVggYW5kIHBhZ2VZIHBhcmFtZXRlcnMgb2YgdGhlIGpxdWVyeSBldmVudCB0byBtYXRjaCB0aGUgem9vbSBhbmQgc2hpZnQgb2YgdGhlIHZpZXdib3hcbiAgICAgKiBAcGFyYW0gIHtqcXVlcnkuTW91c2VFdmVudH0gZXZlbnQgb3JpZ2luYWwgZXZlbnRcbiAgICAgKiBAcmV0dXJuIHtqcXVlcnkuTW91c2VFdmVudH0gICAgICAgdGhlIHNhbWUgZXZlbnQgYnV0IHdpdGggdHJhbnNmb3JtZWQgcGFnZVggYW5kIHBhZ2VZIG1lbWJlcnNcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1FdmVudChldmVudCkge1xuICAgICAgICBldmVudC5wYWdlWCA9IHRoaXMudHJhbnNmb3JtWChldmVudC5wYWdlWCk7XG4gICAgICAgIGV2ZW50LnBhZ2VZID0gdGhpcy50cmFuc2Zvcm1ZKGV2ZW50LnBhZ2VZKTtcblxuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfVxufVxuIiwiLyoqXG4gKiBAbW9kdWxlIExpYnJhcnlcbiAqL1xuXG5jb25zdCBsaWJyYXJ5RGlyID0gJy4vbGlicmFyeS8nO1xuXG4vKipcbiAqIGdldCBsaXN0IG9mIG5ldHdvcmtzIGZyb20gdGhlIGxpYnJhcnlcbiAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UsIHRoZSByZXNvbHV0aW9uIGlzIGFuIG9iamVjdCBjb250YWluaW5nIGEgbGlzdCBvZiBsaWJyYXJpZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExpYnJhcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgbGlicmFyeUZpbGUgPSBsaWJyYXJ5RGlyICsgJ25ldHdvcmtMaXN0Lmpzb24nO1xuXG4gICAgICAgIGxldCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5yZXNwb25zZS5uZXR3b3Jrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihbJ2Vycm9yJywgJ2Fib3J0J10sICgpID0+IHtcbiAgICAgICAgICAgIHJlamVjdCgnRmFpbGVkIGxvYWRpbmcgbGlicmFyaWVzLicpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIGxpYnJhcnlGaWxlLCB0cnVlKTtcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnanNvbic7XG4gICAgICAgIHJlcXVlc3Quc2VuZCgpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIGdldCBhIG5ldHdvcmsgZnJvbSB0aGUgbGlicmFyeSwgc3BlY2lmaWVkIGJ5IGZpbGVuYW1lXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG5ldHdvcmtOYW1lIGxpYnJhcnkgZmlsZSBuYW1lIHdpdGhvdXQgdGhlIGV4dGVuc2lvblxuICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSwgdGhlIHJlc29sdXRpb24gaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGxpYnJhcnkgaW1wb3J0IGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE5ldHdvcmtGcm9tTGlicmFyeShuZXR3b3JrTmFtZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGxldCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihbJ2Vycm9yJywgJ2Fib3J0J10sICgpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChgRmFpbGVkIGxvYWRpbmcgbGlicmFyeSAke25ldHdvcmtOYW1lfS5gKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVxdWVzdC5vcGVuKCdHRVQnLCBsaWJyYXJ5RGlyICsgbmV0d29ya05hbWUgKyAnLmpzb24nLCB0cnVlKTtcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnanNvbic7XG4gICAgICAgIHJlcXVlc3Quc2VuZCgpO1xuICAgIH0pO1xufVxuIl19"}