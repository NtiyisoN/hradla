{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/json-stringify-pretty-compact/index.js","node_modules/libstl/Datastructures/DoublyLinkedList.js","node_modules/libstl/Datastructures/Heap.js","node_modules/libstl/Datastructures/MaxHeap.js","node_modules/libstl/Datastructures/MinHeap.js","node_modules/libstl/Datastructures/PriorityQueue.js","node_modules/libstl/Datastructures/Queue.js","node_modules/libstl/Datastructures/Stack.js","node_modules/libstl/node-module.js","src/es6/modules/findPath.js","src/es6/modules/other/helperFunctions.js","src/es6/modules/other/mapWithDefaultValue.js","src/es6/routeWorker.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;kBCGwB,Q;;AAfxB;;AACA;;;;AAEA;;;;AAAwC;;AAExC;;AAEA;;;;;;;;AAQe,SAAS,QAAT,CAAkB,KAAlB,EAAyB,GAAzB,EAA8B,WAA9B,EAA2C,mBAA3C,EAAgE;AAC3E,QAAM,qDAAN;;AAEA,QAAM,sBAAsB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","file":"routeWorker.js","sourcesContent":["(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()","function stringify (obj, options) {\n  options = options || {}\n  var indent = JSON.stringify([1], null, get(options, 'indent', 2)).slice(2, -3)\n  var addMargin = get(options, 'margins', false)\n  var maxLength = (indent === '' ? Infinity : get(options, 'maxLength', 80))\n\n  return (function _stringify (obj, currentIndent, reserved) {\n    if (obj && typeof obj.toJSON === 'function') {\n      obj = obj.toJSON()\n    }\n\n    var string = JSON.stringify(obj)\n\n    if (string === undefined) {\n      return string\n    }\n\n    var length = maxLength - currentIndent.length - reserved\n\n    if (string.length <= length) {\n      var prettified = prettify(string, addMargin)\n      if (prettified.length <= length) {\n        return prettified\n      }\n    }\n\n    if (typeof obj === 'object' && obj !== null) {\n      var nextIndent = currentIndent + indent\n      var items = []\n      var delimiters\n      var comma = function (array, index) {\n        return (index === array.length - 1 ? 0 : 1)\n      }\n\n      if (Array.isArray(obj)) {\n        for (var index = 0; index < obj.length; index++) {\n          items.push(\n            _stringify(obj[index], nextIndent, comma(obj, index)) || 'null'\n          )\n        }\n        delimiters = '[]'\n      } else {\n        Object.keys(obj).forEach(function (key, index, array) {\n          var keyPart = JSON.stringify(key) + ': '\n          var value = _stringify(obj[key], nextIndent,\n                                 keyPart.length + comma(array, index))\n          if (value !== undefined) {\n            items.push(keyPart + value)\n          }\n        })\n        delimiters = '{}'\n      }\n\n      if (items.length > 0) {\n        return [\n          delimiters[0],\n          indent + items.join(',\\n' + nextIndent),\n          delimiters[1]\n        ].join('\\n' + currentIndent)\n      }\n    }\n\n    return string\n  }(obj, '', 0))\n}\n\n// Note: This regex matches even invalid JSON strings, but since we’re\n// working on the output of `JSON.stringify` we know that only valid strings\n// are present (unless the user supplied a weird `options.indent` but in\n// that case we don’t care since the output would be invalid anyway).\nvar stringOrChar = /(\"(?:[^\\\\\"]|\\\\.)*\")|[:,\\][}{]/g\n\nfunction prettify (string, addMargin) {\n  var m = addMargin ? ' ' : ''\n  var tokens = {\n    '{': '{' + m,\n    '[': '[' + m,\n    '}': m + '}',\n    ']': m + ']',\n    ',': ', ',\n    ':': ': '\n  }\n  return string.replace(stringOrChar, function (match, string) {\n    return string ? match : tokens[match]\n  })\n}\n\nfunction get (options, name, defaultValue) {\n  return (name in options ? options[name] : defaultValue)\n}\n\nmodule.exports = stringify\n","/**\n * The DoublyLinkedList class provides the main functionality of a doubly linked list.\n *\n * @class DoublyLinkedList\n */\nvar DoublyLinkedList = (function () {\n    function DoublyLinkedList() {\n        /**\n         * Count of elements in list\n         *\n         * @property _length\n         * @type number\n         * @private\n         */\n        this._length = 0;\n        /**\n         * Iteration pointer\n         *\n         * @property _key\n         * @type number\n         * @private\n         */\n        this._key = 0;\n        /**\n         * Reference to head(first) element in list\n         *\n         * @property _head\n         * @type DoublyLinkedListNode\n         * @private\n         */\n        this._head = null;\n        /**\n         * Reference to tail(last) element in list\n         *\n         * @property _tail\n         * @type DoublyLinkedListNode\n         * @private\n         */\n        this._tail = null;\n        /**\n         * Reference to iterated element in list\n         *\n         * @property _current\n         * @type DoublyLinkedListNode\n         * @private\n         */\n        this._current = null;\n    }\n    /**\n     * Insert a new value at the specified index\n     *\n     * @method add\n     * @param index The index where the new value is to be inserted.\n     * @param value The new value for the index.\n     * @return void\n     */\n    DoublyLinkedList.prototype.add = function (index, value) {\n        if (index < 0 || index >= this._length) {\n            throw new Error(\"Out of bounds\");\n        }\n        var i = 0;\n        var current = this._head;\n        while (i < index) {\n            current = current.next;\n            i++;\n        }\n        current.value = value;\n    };\n    /**\n     * Pops a node from the end of the doubly linked list\n     *\n     * @method pop\n     * @return any  The value of the popped node.\n     */\n    DoublyLinkedList.prototype.pop = function () {\n        if (this._length === 0) {\n            throw new Error(\"Can't pop from an empty data structure\");\n        }\n        var value = this._tail.value;\n        this._tail = this._tail.prev;\n        if (this._tail) {\n            delete this._tail.next;\n            this._tail.next = null;\n        }\n        this._length--;\n        if (this._length === 0) {\n            delete this._head;\n            this._head = null;\n        }\n        return value;\n    };\n    /**\n     * Shifts a node from the beginning of the doubly linked list\n     *\n     * @method shift\n     * @return any  The value of the shifted node.\n     */\n    DoublyLinkedList.prototype.shift = function () {\n        if (this._length === 0) {\n            throw new Error(\"Can't shift from an empty data structure\");\n        }\n        var value = this._head.value;\n        this._head = this._head.next;\n        if (this._head) {\n            delete this._head.prev;\n            this._head.prev = null;\n        }\n        this._length--;\n        return value;\n    };\n    /**\n     * Pushes an element at the end of the doubly linked list\n     *\n     * @method push\n     * @param value The value to push.\n     * @return void\n     */\n    DoublyLinkedList.prototype.push = function (value) {\n        // allocate new node\n        var node = {\n            value: value,\n            prev: this._tail,\n            next: null\n        };\n        if (this._length === 0) {\n            this._head = this._tail = node;\n        }\n        else {\n            this._tail.next = node;\n            this._tail = this._tail.next;\n        }\n        this._length++;\n    };\n    /**\n     * Prepends the doubly linked list with an element\n     *\n     * @method unshift\n     * @param value The value to unshift.\n     * @return void\n     */\n    DoublyLinkedList.prototype.unshift = function (value) {\n        // allocate new node\n        var node = {\n            value: value,\n            prev: null,\n            next: this._head\n        };\n        if (this._length === 0) {\n            this._head = this._tail = node;\n        }\n        else {\n            this._head.prev = node;\n            this._head = this._head.prev;\n        }\n        this._length++;\n    };\n    /**\n     * Peeks at the node from the end of the doubly linked list\n     *\n     * @method top\n     * @return any  The value of the last node.\n     */\n    DoublyLinkedList.prototype.top = function () {\n        if (this._tail)\n            return this._tail.value;\n    };\n    /**\n     * Peeks at the node from the beginning of the doubly linked list\n     *\n     * @method bottom\n     * @return any  The value of the first node.\n     */\n    DoublyLinkedList.prototype.bottom = function () {\n        if (this._head)\n            return this._head.value;\n    };\n    /**\n     * Counts the number of elements in the doubly linked list\n     *\n     * @method count\n     * @return number the number of elements in the doubly linked list.\n     */\n    DoublyLinkedList.prototype.count = function () {\n        return this._length;\n    };\n    /**\n     * Checks whether the doubly linked list is empty\n     *\n     * @method isEmpty\n     * @return boolean whether the doubly linked list is empty.\n     */\n    DoublyLinkedList.prototype.isEmpty = function () {\n        return (this._length === 0);\n    };\n    /**\n     * Rewind iterator back to the start\n     *\n     * @method rewind\n     * @return void\n     */\n    DoublyLinkedList.prototype.rewind = function () {\n        this._key = 0;\n        this._current = this._head;\n    };\n    /**\n     * Return current list entry\n     *\n     * @method current\n     * @return any  The current node value.\n     */\n    DoublyLinkedList.prototype.current = function () {\n        if (this._current) {\n            return this._current.value;\n        }\n        return null;\n    };\n    /**\n     * Return current node index\n     *\n     * @method key\n     * @return any  The current node index.\n     */\n    DoublyLinkedList.prototype.key = function () {\n        return this._key;\n    };\n    /**\n     * Move to next entry\n     *\n     * @method next\n     * @return void\n     */\n    DoublyLinkedList.prototype.next = function () {\n        this._current = this._current.next;\n        this._key++;\n    };\n    /**\n     * Move to previous entry\n     *\n     * @method prev\n     * @return void\n     */\n    DoublyLinkedList.prototype.prev = function () {\n        this._current = this._current.prev;\n        this._key--;\n    };\n    /**\n     * Check whether the doubly linked list contains more nodes\n     *\n     * @method valid\n     * @return boolean true if the doubly linked list contains any more nodes, false otherwise.\n     */\n    DoublyLinkedList.prototype.valid = function () {\n        return (this._key >= 0 && this._key < this._length);\n    };\n    /**\n     * Export the list to array\n     *\n     * @method toArray\n     * @return Array   The exported array\n     */\n    DoublyLinkedList.prototype.toArray = function () {\n        var list = [];\n        var current = this._head;\n        while (current) {\n            list.push(current.value);\n            current = current.next;\n        }\n        return list;\n    };\n    /**\n     * Serializes the list to string\n     *\n     * @method toString\n     * @return string   The serialized string.\n     */\n    DoublyLinkedList.prototype.toString = function () {\n        return \"{\" + this.toArray().join(\"->\") + \"}\";\n    };\n    return DoublyLinkedList;\n})();\nmodule.exports = DoublyLinkedList;\n//# sourceMappingURL=DoublyLinkedList.js.map","/**\n * The Heap class provides the main functionality of a Heap.\n *\n * @class Heap\n */\nvar Heap = (function () {\n    function Heap() {\n        /**\n         * Binary tree storage array\n         *\n         * @property _tree\n         * @type Array\n         * @private\n         */\n        this._tree = [];\n        /**\n         * Heap type\n         *\n         * @property _type\n         * @type number\n         * @private\n         */\n        this._type = Heap.MAX;\n        /**\n         * Iteration pointer\n         *\n         * @property _key\n         * @type number\n         * @private\n         */\n        this._key = 0;\n    }\n    /**\n     * Get index of left child element in binary tree stored in array\n     *\n     * @method _child\n     * @param n\n     * @return number\n     * @private\n     */\n    Heap.prototype._child = function (n) {\n        return 2 * n + 1;\n    };\n    /**\n     * Get index of parent element in binary tree stored in array\n     *\n     * @method _parent\n     * @param n\n     * @return number\n     * @private\n     */\n    Heap.prototype._parent = function (n) {\n        //console.log('n=', n, Math.floor(n / 2));\n        return Math.floor(n / 2);\n    };\n    /**\n     * Swap 2 elements in binary tree\n     *\n     * @method _swap\n     * @param first\n     * @param second\n     * @private\n     */\n    Heap.prototype._swap = function (first, second) {\n        var swap = this._tree[first];\n        this._tree[first] = this._tree[second];\n        this._tree[second] = swap;\n    };\n    /**\n     * Sift elements in binary tree\n     *\n     * @method _siftUp\n     * @param i\n     * @private\n     */\n    Heap.prototype._siftUp = function (i) {\n        while (i > 0) {\n            var parent = this._parent(i);\n            if (this.compare(this._tree[i], this._tree[parent]) * this._type > 0) {\n                this._swap(i, parent);\n                i = parent;\n            }\n            else {\n                break;\n            }\n        }\n    };\n    /**\n     * Sift down elements in binary tree\n     *\n     * @method _siftDown\n     * @param i\n     * @private\n     */\n    Heap.prototype._siftDown = function (i) {\n        while (i < this._tree.length) {\n            var left = this._child(i);\n            var right = left + 1;\n            if ((left < this._tree.length) && (right < this._tree.length) &&\n                (this.compare(this._tree[i], this._tree[left]) * this._type < 0 ||\n                    this.compare(this._tree[i], this._tree[right]) * this._type < 0)) {\n                // there is 2 children and one of them must be swapped\n                // get correct element to sift down\n                var sift = left;\n                if (this.compare(this._tree[left], this._tree[right]) * this._type < 0) {\n                    sift = right;\n                }\n                this._swap(i, sift);\n                i = sift;\n            }\n            else if (left < this._tree.length &&\n                this.compare(this._tree[i], this._tree[left]) * this._type < 0) {\n                // only one child exists\n                this._swap(i, left);\n                i = left;\n            }\n            else {\n                break;\n            }\n        }\n    };\n    /**\n     * Extracts a node from top of the heap and sift up\n     *\n     * @method extract\n     * @return any The value of the extracted node.\n     */\n    Heap.prototype.extract = function () {\n        if (this._tree.length === 0) {\n            throw new Error(\"Can't extract from an empty data structure\");\n        }\n        var extracted = this._tree[0];\n        if (this._tree.length === 1) {\n            this._tree = [];\n        }\n        else {\n            this._tree[0] = this._tree.pop();\n            this._siftDown(0);\n        }\n        return extracted;\n    };\n    /**\n     * Inserts an element in the heap by sifting it up\n     *\n     * @method insert\n     * @param value The value to insert.\n     * @return void\n     */\n    Heap.prototype.insert = function (value) {\n        this._tree.push(value);\n        this._siftUp(this._tree.length - 1);\n    };\n    /**\n     * Peeks at the node from the top of the heap\n     *\n     * @method top\n     * @return any The value of the node on the top.\n     */\n    Heap.prototype.top = function () {\n        if (this._tree.length === 0) {\n            throw new Error(\"Can't peek at an empty heap\");\n        }\n        return this._tree[0];\n    };\n    /**\n     * Counts the number of elements in the heap\n     *\n     * @method count\n     * @return number the number of elements in the heap.\n     */\n    Heap.prototype.count = function () {\n        return this._tree.length;\n    };\n    /**\n     * Checks whether the heap is empty\n     *\n     * @method isEmpty\n     * @return boolean whether the heap is empty.\n     */\n    Heap.prototype.isEmpty = function () {\n        return (this._tree.length === 0);\n    };\n    /**\n     * Rewind iterator back to the start (no-op)\n     *\n     * @method rewind\n     * @return void\n     */\n    Heap.prototype.rewind = function () {\n        this._key = 0;\n    };\n    /**\n     * Return current node pointed by the iterator\n     *\n     * @method current\n     * @return any The current node value.\n     */\n    Heap.prototype.current = function () {\n        return this._tree[this._key];\n    };\n    /**\n     * Return current node index\n     *\n     * @method key\n     * @return any The current node index.\n     */\n    Heap.prototype.key = function () {\n        return this._key;\n    };\n    /**\n     * Move to the next node\n     *\n     * @method next\n     * @return void\n     */\n    Heap.prototype.next = function () {\n        this._key++;\n    };\n    /**\n     * Move to previous entry\n     *\n     * @method prev\n     * @return void\n     */\n    Heap.prototype.prev = function () {\n        this._key--;\n    };\n    /**\n     * Check whether the heap contains more nodes\n     *\n     * @method valid\n     * @return boolean true if the heap contains any more nodes, false otherwise.\n     */\n    Heap.prototype.valid = function () {\n        return (this._key >= 0 && this._key < this._tree.length);\n    };\n    /**\n     * Compare elements in order to place them correctly in the heap while sifting up.\n     *\n     * @method compare\n     * @param first The value of the first node being compared.\n     * @param second The value of the second node being compared.\n     * @return number Result of the comparison, positive integer if first is greater than second, 0 if they are equal, negative integer otherwise.\n     * Having multiple elements with the same value in a Heap is not recommended. They will end up in an arbitrary relative position.\n     */\n    Heap.prototype.compare = function (first, second) {\n        if (first > second) {\n            return 1;\n        }\n        else if (first == second) {\n            return 0;\n        }\n        else {\n            return -1;\n        }\n    };\n    /**\n     * Visually display heap tree\n     *\n     * @method _displayNode\n     * @param node\n     * @param prefix\n     * @param last\n     * @return String\n     * @private\n     */\n    Heap.prototype._displayNode = function (node, prefix, last) {\n        if (prefix === void 0) { prefix = ''; }\n        if (last === void 0) { last = true; }\n        var line = prefix;\n        // get child indexes\n        var left = this._child(node);\n        var right = left + 1;\n        if (last) {\n            line += (prefix ? '└─' : '  ');\n        }\n        else {\n            line += '├─';\n        }\n        line += this._tree[node];\n        prefix += (last ? '  ' : '│ ');\n        if (left < this._tree.length) {\n            line += '\\n' + this._displayNode(left, prefix, (this._tree[right] == undefined ? true : false));\n        }\n        if (right < this._tree.length) {\n            line += '\\n' + this._displayNode(right, prefix, true);\n        }\n        return line;\n    };\n    /**\n     * Serializes the heap to string\n     *\n     * @method toString\n     * @return string   The serialized string.\n     */\n    Heap.prototype.toString = function () {\n        // start with root and recursively goes to each node\n        return this._displayNode(0);\n    };\n    /**\n     * Serializes the heap to array\n     *\n     * @method toArray\n     * @return Array   The serialized array.\n     */\n    Heap.prototype.toArray = function () {\n        return this._tree;\n    };\n    /**\n     * Max heap flag\n     *\n     * @property MAX\n     * @type number\n     * @static\n     */\n    Heap.MAX = 1;\n    /**\n     * Min heap flag\n     *\n     * @property MIN\n     * @type number\n     * @static\n     */\n    Heap.MIN = -1;\n    return Heap;\n})();\nmodule.exports = Heap;\n//# sourceMappingURL=Heap.js.map","var __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\nvar Heap = require('./Heap');\n/**\n * The MaxHeap class provides the main functionality of a heap, keeping the maximum on the top.\n *\n * @class MaxHeap\n * @extends Heap\n */\nvar MaxHeap = (function (_super) {\n    __extends(MaxHeap, _super);\n    function MaxHeap() {\n        _super.apply(this, arguments);\n        this._type = Heap.MAX;\n    }\n    return MaxHeap;\n})(Heap);\nmodule.exports = MaxHeap;\n//# sourceMappingURL=MaxHeap.js.map","var __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\nvar Heap = require('./Heap');\n/**\n * The MinHeap class provides the main functionality of a heap, keeping the minimum on the top.\n *\n * @class MinHeap\n * @extends Heap\n */\nvar MinHeap = (function (_super) {\n    __extends(MinHeap, _super);\n    function MinHeap() {\n        _super.apply(this, arguments);\n        this._type = Heap.MIN;\n    }\n    return MinHeap;\n})(Heap);\nmodule.exports = MinHeap;\n//# sourceMappingURL=MinHeap.js.map","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Heap = require('./Heap');\n/**\n * The PriorityQueue class provides the main functionality of an prioritized queue, implemented using a max heap.\n *\n * @class PriorityQueue\n * @extends Heap\n */\nvar PriorityQueue = (function (_super) {\n    __extends(PriorityQueue, _super);\n    function PriorityQueue() {\n        _super.apply(this, arguments);\n        this._type = Heap.MAX;\n    }\n    /**\n     * Adds an element to the queue\n     *\n     * @method enqueue\n     * @param value The value to enqueue.\n     * @param priority The priority of value.\n     * @return void\n     */\n    PriorityQueue.prototype.enqueue = function (value, priority) {\n        return this.insert(new PriorityQueueNode(value, priority));\n    };\n    /**\n     * Dequeues a node from the queue\n     *\n     * @method dequeue\n     * @return any  The value of the dequeued node.\n     */\n    PriorityQueue.prototype.dequeue = function () {\n        return this.extract().value;\n    };\n    /**\n     * Peeks at the node from the top of the heap\n     *\n     * @method top\n     * @return any The value of the node on the top.\n     */\n    PriorityQueue.prototype.top = function () {\n        return _super.prototype.top.call(this).value;\n    };\n    /**\n     * Compare elements in order to place them correctly in the heap while sifting up.\n     *\n     * @method compare\n     * @param first The value of the first node being compared.\n     * @param second The value of the second node being compared.\n     * @return number Result of the comparison, positive integer if first is greater than second, 0 if they are equal, negative integer otherwise.\n     * Having multiple elements with the same value in a Heap is not recommended. They will end up in an arbitrary relative position.\n     */\n    PriorityQueue.prototype.compare = function (first, second) {\n        if (first.priority > second.priority) {\n            return 1;\n        }\n        else if (first.priority == second.priority) {\n            return 0;\n        }\n        else {\n            return -1;\n        }\n    };\n    return PriorityQueue;\n})(Heap);\n/**\n * PriorityQueue Node\n *\n * @class PriorityQueueNode\n */\nvar PriorityQueueNode = (function () {\n    /**\n     * Constructor\n     *\n     * @method constructor\n     * @param value\n     * @param priority\n     */\n    function PriorityQueueNode(value, priority) {\n        this.value = value;\n        this.priority = priority;\n    }\n    /**\n     * Serializes the node to string\n     *\n     * @method toString\n     * @return string   The serialized string.\n     */\n    PriorityQueueNode.prototype.toString = function () {\n        return this.value + \" [\" + this.priority + \"]\";\n    };\n    return PriorityQueueNode;\n})();\nmodule.exports = PriorityQueue;\n//# sourceMappingURL=PriorityQueue.js.map","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DoublyLinkedList = require('./DoublyLinkedList');\n/**\n * The Queue class provides the main functionality of a queue implemented using a doubly linked list.\n *\n * @class Queue\n * @extends DoublyLinkedList\n */\nvar Queue = (function (_super) {\n    __extends(Queue, _super);\n    function Queue() {\n        _super.apply(this, arguments);\n    }\n    /**\n     * Adds an element to the queue\n     *\n     * @method enqueue\n     * @param value The value to enqueue.\n     * @return void\n     */\n    Queue.prototype.enqueue = function (value) {\n        return this.push(value);\n    };\n    /**\n     * Dequeues a node from the queue\n     *\n     * @method dequeue\n     * @return any  The value of the dequeued node.\n     */\n    Queue.prototype.dequeue = function () {\n        return this.shift();\n    };\n    return Queue;\n})(DoublyLinkedList);\nmodule.exports = Queue;\n//# sourceMappingURL=Queue.js.map","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DoublyLinkedList = require('./DoublyLinkedList');\n/**\n * The Stack class provides the main functionality of a stack implemented using a doubly linked list.\n *\n * @class Stack\n * @extends DoublyLinkedList\n */\nvar Stack = (function (_super) {\n    __extends(Stack, _super);\n    function Stack() {\n        _super.apply(this, arguments);\n    }\n    return Stack;\n})(DoublyLinkedList);\nmodule.exports = Stack;\n//# sourceMappingURL=Stack.js.map","/**\n * STL\n * @type {{DoublyLinkedList: exports, Stack: exports, Queue: exports, Heap: exports, MaxHeap: exports, MinHeap: exports, PriorityQueue: exports}}\n */\nmodule.exports = {\n\tDoublyLinkedList: require('./Datastructures/DoublyLinkedList'),\n\tStack: require('./Datastructures/Stack'),\n\tQueue: require('./Datastructures/Queue'),\n\tHeap: require('./Datastructures/Heap'),\n\tMaxHeap: require('./Datastructures/MaxHeap'),\n\tMinHeap: require('./Datastructures/MinHeap'),\n\tPriorityQueue: require('./Datastructures/PriorityQueue')\n};","import { manhattanDistance } from './other/helperFunctions'\nimport MapWithDefaultValue from './other/mapWithDefaultValue'\n\nimport { PriorityQueue } from 'libstl'; // note: imported from a node module\n\n/** @module findPath */\n\n/**\n * Heavily modified implementation of the A* algorithm\n * @param  {Object} start object containing numeric attributes `x` and `y` that represent the first endpoint of the wire in grid pixels\n * @param  {Object} end   object containing numeric attributes `x` and `y` that represent the second endpoint of the wire in grid pixels\n * @param  {Set} nonRoutable set of non routable nodes\n * @param  {Set} punishedButRoutable set of nodes that are not optimal for routing\n * @return {Array} array of objects containing numeric attributes `x` and `y`\n */\nexport default function findPath(start, end, nonRoutable, punishedButRoutable) {\n    const distanceFunction = manhattanDistance;\n\n    const wireCrossPunishment = 1;\n    const wireBendPunishment = 1;\n\n    // number of nodes, that can be opened at once\n    // once is this limit exceeded, aStar will fail and return undefined\n    const maxNodeLimit = 100000;\n\n    let closedNodes = new Set();\n    let openNodes = new Set();\n    let openNodeQueue = new PriorityQueue();\n\n    // functions for working with open nodes:\n\n    /**\n     * add a new open node to the structure\n     * @param {Object} node   object containing numeric attributes `x` and `y` that represent the first endpoint of the wire\n     * @param {number} fscore fScore of this node\n     */\n    const addOpenNode = (node, fscore) => {\n        openNodes.add(node);\n        // flip the fscore, because PriorityQueue uses max heap\n        openNodeQueue.enqueue(node, 1 / fscore);\n    }\n\n    /**\n     * get the open node with the lowest fScore and remove it\n     * @return {Object} object containing numeric attributes `x` and `y` that represent the first endpoint of the wire\n     */\n    const getOpenNode = () => {\n        const node = openNodeQueue.dequeue();\n        openNodes.delete(node);\n        return node;\n    }\n\n    let cameFrom = new Map();\n\n    // default value: infinity\n    let gScore = new MapWithDefaultValue(Infinity);\n    gScore.set(start, 0);\n\n    let startFScore = distanceFunction(start, end);\n\n    addOpenNode(start, startFScore);\n\n    openNodes.add(start);\n    openNodeQueue.enqueue(start, 1 / startFScore);\n\n    while (openNodes.size > 0) {\n        // get the value from openNodes that has the lowest fScore\n        const currentNode = getOpenNode();\n\n        // if we reached the end point, reconstruct the path and return it\n        if (currentNode.x == end.x && currentNode.y == end.y) {\n            return reconstructPath(cameFrom, currentNode);\n        }\n\n        // add this node to the closed nodes\n        closedNodes.add(currentNode);\n\n        // the farthest points accessible without avoiding obstacles in every direction\n        // (but max 50 in each direction)\n        for (let direction = 0; direction < 4; direction++) {\n            let newPoint = movePoint(currentNode, direction);\n\n            let wiresCrossed = 0;\n\n            for (let i = 0; i < 50; i++) {\n                // if newPoint is in the set of non routable points,\n                // don't add it and stop proceeding in this direction\n                if (setHasThisPoint(nonRoutable, newPoint)) {\n                    // if this not the end or start point, break\n                    if (!(newPoint.x === end.x && newPoint.y === end.y) &&\n                        !(newPoint.x === start.x && newPoint.y === start.y)) {\n                            break;\n                    }\n                }\n\n                // skip this node, if it has been already closed\n                // or if it is on the list of non routable nodes\n                if (closedNodes.has(newPoint)) {\n                    continue;\n                }\n\n                // calculate possible GScore by applying a punishment for each node (\"bend\") in the path\n                let newGScore = wireBendPunishment + gScore.getWithDefault(currentNode);\n\n                if (setHasThisPoint(punishedButRoutable, newPoint)) {\n                    // if the node is in the set of punished nodes, apply the punishment\n                    wiresCrossed++;\n                }\n\n                // apply the punishment for each wire crossed in this direction\n                // note: we are counting the wires crossed when exporting this direction, not the wires\n                // crossed in the final path, there will be probably only at most of these nodes in the\n                // final path, not multiple\n                newGScore += wiresCrossed * wireCrossPunishment;\n\n                // skip this node if it has worst estimage gscore than in the gscore table\n                if (newGScore >= gScore.getWithDefault(newPoint)) {\n                    continue;\n                }\n\n                cameFrom.set(newPoint, currentNode);\n                gScore.set(newPoint, newGScore);\n\n                const newFScore = newGScore + distanceFunction(newPoint, end);\n\n                if (!openNodes.has(newPoint)) {\n                    // add the point to the list of points\n                    addOpenNode(newPoint, newFScore);\n                }\n\n                // move to the next point in the direciton\n                newPoint = movePoint(newPoint, direction);\n            }\n        }\n\n        if (openNodes.size > maxNodeLimit) {\n            console.log(`aStar: Number of open nodes (${openNodes.size}) exceeded the limit for open nodes (${maxNodeLimit}).`)\n            break;\n        }\n    }\n    // if we got here, the path was not found\n\n    return undefined;\n}\n\n/**\n * returns `true` if the specified set of points contains the specified point (and returns `false` otherwise)\n * @param {Set} set set of points\n * @param {Object} point object containing numeric attributes `x` and `y`\n */\nfunction setHasThisPoint(set, point) {\n    for (let item of set) {\n        if (item.x === point.x && item.y === point.y) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Helper that moves the passed point in the specified direction. It simply adds or subtracts 1 from one of the coordinates depending on the direction attribute.\n * @param  {Object} point     object containing numeric attributes `x` and `y`\n * @param  {number} direction directions:\n *     - 0: up\n *     - 1: right\n *     - 2: down\n *     - 3: left\n * @return {Object}           object containing numeric attributes `x` and `y`\n */\nfunction movePoint({x, y}, direction) {\n    // map direction do point coordinate modification\n    const dirMap = {\n        0: () => {\n            y -= 1\n        },\n        1: () => {\n            x += 1\n        },\n        2: () => {\n            y += 1\n        },\n        3: () => {\n            x -= 1\n        }\n    }\n\n    dirMap[direction]();\n\n    return {x, y}\n}\n\n/**\n * helper backtracking function used by the aStar algorithm to construct the final path\n * @param  {Object} cameFrom    object containing numeric attributes `x` and `y`\n * @param  {Object} currentNode object containing numeric attributes `x` and `y`\n * @return {Array} array of objects containing numeric attributes `x` and `y`\n */\nfunction reconstructPath(cameFrom, currentNode) {\n    let path = [];\n\n    path.push({\n        x: currentNode.x,\n        y: currentNode.y\n    })\n\n    while (cameFrom.has(currentNode)) {\n        currentNode = cameFrom.get(currentNode);\n        // push the point on the beginning of the array instead of the end\n        path.splice(0, 0, {\n            x: currentNode.x,\n            y: currentNode.y\n        })\n    }\n\n    return path;\n}\n","/**\n * @module HelperFunctions\n */\n\nimport stringify from \"json-stringify-pretty-compact\"; // note: imported from a module\n\n/**\n * add a cross browser event listener on a mouse scroll\n * @param {string} query DOM query of the element that the listener will be added to\n * @param {Function} func  Function that will be called when the event occurs. The function takes as a parameter an event object.\n */\nexport function addMouseScrollEventListener(query, func) {\n    let MouseWheelHandler = event => {\n        // redeclare for old IE support\n        var event = window.event || event; // eslint-disable-line no-redeclare\n\n        event.delta = Math.max(-1, Math.min(1, (event.wheelDelta || -event.detail)));\n\n        func(event)\n\n        return false;\n    }\n\n    let svgelement;\n\n    // if the query is a simple DOM id selector, we can use getElementById which has better backwards compatibility\n    if(query.match(/^#\\w+$/)) {\n        svgelement = document.getElementById(query.substr(1))\n    } else {\n        svgelement = document.querySelector(query)\n    }\n\n    if (svgelement.addEventListener) {\n        // IE9, Chrome, Safari, Opera\n        svgelement.addEventListener(\"mousewheel\", MouseWheelHandler, false);\n        // Firefox\n        svgelement.addEventListener(\"DOMMouseScroll\", MouseWheelHandler, false);\n    } else  {\n        // IE 6/7/8\n        svgelement.attachEvent(\"onmousewheel\", MouseWheelHandler);\n    }\n    svgelement.addEventListener('mousewheel', function(e) {\n        console.log('event', e)\n    }, false)\n}\n\n/**\n * convert a data object to JSON string or to a data URI containing a JSON string\n * @param  {Object}  data            object that will be serialized into a JSON string\n * @param  {Boolean} [pretty=false]  if `true`, the code will be proprerly indented, else a more compact syntax will be used\n * @param  {Boolean} [dataUri=false] return dataUri containing the JSON string instead of the pure JSON string\n * @return {string}\n */\nexport function getJSONString(data, pretty = false, dataUri = false) {\n    if(dataUri) {\n        return 'data:application/json;charset=utf-8,'\n            + encodeURIComponent(getJSONString(data, pretty));\n    } else {\n        if (pretty)\n            return stringify(data, {maxLength: 50});\n\n        return JSON.stringify(data);\n    }\n}\n\n/**\n * returns the Manhattan distance between the points _a_ and _b_\n * @param  {Object} a object containing numeric attributes `x` and `y`\n * @param  {Object} b object containing numeric attributes `x` and `y`\n * @return {number}\n */\nexport function manhattanDistance(a, b) {\n    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\n}\n","/** @module MapWithDefaultValue */\n/**\n * Map that has a default value specified in the constructor.\n *\n * For the complete documentation of the Map see [Map in the MDN web docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\n *\n * Usage:\n * ```JavaScript\n let myMap = new MapWithDefaultValue(Infinity);\n const value = myMap.getWithDefault(key)\n ```\n *\n * _Note: This version is written specially for ES6 compiled into ES5. In non-compiled ES6 is the implementation far more elegant:_\n *\n * ```JavaScript\n export class MapWithDefaultValue extends Map {\n     constructor(defaultValue) {\n         super();\n\n         this.default = defaultValue;\n     }\n\n     get(key) {\n         if(this.has(key)) {\n             return super.get(key);\n         } else {\n             return this.default;\n         }\n     }\n }```\n * @class MapWithDefaultValue\n * @param defaultValue {any} default value that will be returned when the requested key is not found in the map\n */\nexport default function(defaultValue) {\n    let map = new Map();\n    /**\n     * @param  {any} key key of a requested item\n     * @return {any} value of the item with the corresponding key, or defaultValue if the key is not found in the map\n     */\n    map.getWithDefault = (key) => {\n        return map.has(key)\n            ? map.get(key)\n            : defaultValue;\n    }\n    return map;\n}\n","\"use strict\";\n\n/** @module routeWorker */\n\nimport findPath from './modules/findPath'\n\n/**\n * callback when a message is sent to the web worker\n *\n * @param {Object} event web worker event object (the `data` item of the event object is expected to contain\n *                       these items: `wires` (array), `nonRoutableNodes` (iterable) and `inconvenientNodes` (iterable))\n */\nonmessage = (event) => {\n    const {wires, nonRoutableNodes, inconvenientNodes} = event.data;\n\n    const paths = findPaths(wires, nonRoutableNodes, inconvenientNodes);\n\n    postMessage({paths});\n    close();\n}\n\n/**\n * find paths for all the specified wires\n * @param  {Array} wires              array of objects with attributes `from` and `to`, both of them which are objects\n *                                    with values `x` and `y` containing coordinates of the wire endpoints\n * @param  {Iterable} nonRoutableNodes  Set or array of non routable nodes\n * @param  {Iterable} inconvenientNodes Set or array of inconvenient nodes\n * @return {Array}                    array of paths, each item is an array of points of the path\n *                                    the returned array contains paths for the wires with corresponding indexes from the `wires` parameter\n */\nfunction findPaths(wires, nonRoutableNodes, inconvenientNodes) {\n    let paths = [];\n\n    for (const [from, to] of wires) {\n        const path = findPath(from, to, nonRoutableNodes, inconvenientNodes)\n\n        if(!path) {\n            console.log(\"path not found\")\n            console.log(from, to);\n        } else {\n            console.log(\"path found\")\n        }\n\n        paths.push(path);\n\n        // add new inconvenient nodes created by this new path\n        let prevPoint;\n        for(const point of path) {\n            if(prevPoint) {\n                if(point.x === prevPoint.x) {\n                    // horizontal section of the path\n                    for(let y = Math.min(point.y, prevPoint.y); y <= Math.max(point.y, prevPoint.y) ; ++y) {\n                        inconvenientNodes.add({\n                            x: point.x,\n                            y: y\n                        })\n                    }\n                } else if(point.y === prevPoint.y) {\n                    // vertical section of the path\n                    for(let x = Math.min(point.x, prevPoint.x); x <= Math.max(point.x, prevPoint.x) ; ++x) {\n                        inconvenientNodes.add({\n                            x: x,\n                            y: point.y\n                        })\n                    }\n                }\n            }\n\n            prevPoint = point;\n        }\n    }\n\n    return paths;\n}\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvanNvbi1zdHJpbmdpZnktcHJldHR5LWNvbXBhY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL0RvdWJseUxpbmtlZExpc3QuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL0hlYXAuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL01heEhlYXAuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL01pbkhlYXAuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL1ByaW9yaXR5UXVldWUuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL1F1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL2xpYnN0bC9EYXRhc3RydWN0dXJlcy9TdGFjay5qcyIsIm5vZGVfbW9kdWxlcy9saWJzdGwvbm9kZS1tb2R1bGUuanMiLCJzcmMvZXM2L21vZHVsZXMvZmluZFBhdGguanMiLCJzcmMvZXM2L21vZHVsZXMvb3RoZXIvaGVscGVyRnVuY3Rpb25zLmpzIiwic3JjL2VzNi9tb2R1bGVzL290aGVyL21hcFdpdGhEZWZhdWx0VmFsdWUuanMiLCJzcmMvZXM2L3JvdXRlV29ya2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O2tCQ0d3QixROztBQWZ4Qjs7QUFDQTs7OztBQUVBOzs7O0FBQXdDOztBQUV4Qzs7QUFFQTs7Ozs7Ozs7QUFRZSxTQUFTLFFBQVQsQ0FBa0IsS0FBbEIsRUFBeUIsR0FB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dCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfXJldHVybiBlfSkoKSIsImZ1bmN0aW9uIHN0cmluZ2lmeSAob2JqLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHZhciBpbmRlbnQgPSBKU09OLnN0cmluZ2lmeShbMV0sIG51bGwsIGdldChvcHRpb25zLCAnaW5kZW50JywgMikpLnNsaWNlKDIsIC0zKVxuICB2YXIgYWRkTWFyZ2luID0gZ2V0KG9wdGlvbnMsICdtYXJnaW5zJywgZmFsc2UpXG4gIHZhciBtYXhMZW5ndGggPSAoaW5kZW50ID09PSAnJyA/IEluZmluaXR5IDogZ2V0KG9wdGlvbnMsICdtYXhMZW5ndGgnLCA4MCkpXG5cbiAgcmV0dXJuIChmdW5jdGlvbiBfc3RyaW5naWZ5IChvYmosIGN1cnJlbnRJbmRlbnQsIHJlc2VydmVkKSB7XG4gICAgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb2JqID0gb2JqLnRvSlNPTigpXG4gICAgfVxuXG4gICAgdmFyIHN0cmluZyA9IEpTT04uc3RyaW5naWZ5KG9iailcblxuICAgIGlmIChzdHJpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHN0cmluZ1xuICAgIH1cblxuICAgIHZhciBsZW5ndGggPSBtYXhMZW5ndGggLSBjdXJyZW50SW5kZW50Lmxlbmd0aCAtIHJlc2VydmVkXG5cbiAgICBpZiAoc3RyaW5nLmxlbmd0aCA8PSBsZW5ndGgpIHtcbiAgICAgIHZhciBwcmV0dGlmaWVkID0gcHJldHRpZnkoc3RyaW5nLCBhZGRNYXJnaW4pXG4gICAgICBpZiAocHJldHRpZmllZC5sZW5ndGggPD0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBwcmV0dGlmaWVkXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkge1xuICAgICAgdmFyIG5leHRJbmRlbnQgPSBjdXJyZW50SW5kZW50ICsgaW5kZW50XG4gICAgICB2YXIgaXRlbXMgPSBbXVxuICAgICAgdmFyIGRlbGltaXRlcnNcbiAgICAgIHZhciBjb21tYSA9IGZ1bmN0aW9uIChhcnJheSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIChpbmRleCA9PT0gYXJyYXkubGVuZ3RoIC0gMSA/IDAgOiAxKVxuICAgICAgfVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBvYmoubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgaXRlbXMucHVzaChcbiAgICAgICAgICAgIF9zdHJpbmdpZnkob2JqW2luZGV4XSwgbmV4dEluZGVudCwgY29tbWEob2JqLCBpbmRleCkpIHx8ICdudWxsJ1xuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICBkZWxpbWl0ZXJzID0gJ1tdJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIGluZGV4LCBhcnJheSkge1xuICAgICAgICAgIHZhciBrZXlQYXJ0ID0gSlNPTi5zdHJpbmdpZnkoa2V5KSArICc6ICdcbiAgICAgICAgICB2YXIgdmFsdWUgPSBfc3RyaW5naWZ5KG9ialtrZXldLCBuZXh0SW5kZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5UGFydC5sZW5ndGggKyBjb21tYShhcnJheSwgaW5kZXgpKVxuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKGtleVBhcnQgKyB2YWx1ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIGRlbGltaXRlcnMgPSAne30nXG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgZGVsaW1pdGVyc1swXSxcbiAgICAgICAgICBpbmRlbnQgKyBpdGVtcy5qb2luKCcsXFxuJyArIG5leHRJbmRlbnQpLFxuICAgICAgICAgIGRlbGltaXRlcnNbMV1cbiAgICAgICAgXS5qb2luKCdcXG4nICsgY3VycmVudEluZGVudClcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5nXG4gIH0ob2JqLCAnJywgMCkpXG59XG5cbi8vIE5vdGU6IFRoaXMgcmVnZXggbWF0Y2hlcyBldmVuIGludmFsaWQgSlNPTiBzdHJpbmdzLCBidXQgc2luY2Ugd2XigJlyZVxuLy8gd29ya2luZyBvbiB0aGUgb3V0cHV0IG9mIGBKU09OLnN0cmluZ2lmeWAgd2Uga25vdyB0aGF0IG9ubHkgdmFsaWQgc3RyaW5nc1xuLy8gYXJlIHByZXNlbnQgKHVubGVzcyB0aGUgdXNlciBzdXBwbGllZCBhIHdlaXJkIGBvcHRpb25zLmluZGVudGAgYnV0IGluXG4vLyB0aGF0IGNhc2Ugd2UgZG9u4oCZdCBjYXJlIHNpbmNlIHRoZSBvdXRwdXQgd291bGQgYmUgaW52YWxpZCBhbnl3YXkpLlxudmFyIHN0cmluZ09yQ2hhciA9IC8oXCIoPzpbXlxcXFxcIl18XFxcXC4pKlwiKXxbOixcXF1bfXtdL2dcblxuZnVuY3Rpb24gcHJldHRpZnkgKHN0cmluZywgYWRkTWFyZ2luKSB7XG4gIHZhciBtID0gYWRkTWFyZ2luID8gJyAnIDogJydcbiAgdmFyIHRva2VucyA9IHtcbiAgICAneyc6ICd7JyArIG0sXG4gICAgJ1snOiAnWycgKyBtLFxuICAgICd9JzogbSArICd9JyxcbiAgICAnXSc6IG0gKyAnXScsXG4gICAgJywnOiAnLCAnLFxuICAgICc6JzogJzogJ1xuICB9XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShzdHJpbmdPckNoYXIsIGZ1bmN0aW9uIChtYXRjaCwgc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZyA/IG1hdGNoIDogdG9rZW5zW21hdGNoXVxuICB9KVxufVxuXG5mdW5jdGlvbiBnZXQgKG9wdGlvbnMsIG5hbWUsIGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4gKG5hbWUgaW4gb3B0aW9ucyA/IG9wdGlvbnNbbmFtZV0gOiBkZWZhdWx0VmFsdWUpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5naWZ5XG4iLCIvKipcbiAqIFRoZSBEb3VibHlMaW5rZWRMaXN0IGNsYXNzIHByb3ZpZGVzIHRoZSBtYWluIGZ1bmN0aW9uYWxpdHkgb2YgYSBkb3VibHkgbGlua2VkIGxpc3QuXG4gKlxuICogQGNsYXNzIERvdWJseUxpbmtlZExpc3RcbiAqL1xudmFyIERvdWJseUxpbmtlZExpc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERvdWJseUxpbmtlZExpc3QoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb3VudCBvZiBlbGVtZW50cyBpbiBsaXN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfbGVuZ3RoXG4gICAgICAgICAqIEB0eXBlIG51bWJlclxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0ZXJhdGlvbiBwb2ludGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfa2V5XG4gICAgICAgICAqIEB0eXBlIG51bWJlclxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fa2V5ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byBoZWFkKGZpcnN0KSBlbGVtZW50IGluIGxpc3RcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IF9oZWFkXG4gICAgICAgICAqIEB0eXBlIERvdWJseUxpbmtlZExpc3ROb2RlXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9oZWFkID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byB0YWlsKGxhc3QpIGVsZW1lbnQgaW4gbGlzdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgX3RhaWxcbiAgICAgICAgICogQHR5cGUgRG91Ymx5TGlua2VkTGlzdE5vZGVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RhaWwgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIGl0ZXJhdGVkIGVsZW1lbnQgaW4gbGlzdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgX2N1cnJlbnRcbiAgICAgICAgICogQHR5cGUgRG91Ymx5TGlua2VkTGlzdE5vZGVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2N1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgYSBuZXcgdmFsdWUgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxuICAgICAqXG4gICAgICogQG1ldGhvZCBhZGRcbiAgICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IHdoZXJlIHRoZSBuZXcgdmFsdWUgaXMgdG8gYmUgaW5zZXJ0ZWQuXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBuZXcgdmFsdWUgZm9yIHRoZSBpbmRleC5cbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPdXQgb2YgYm91bmRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgICAgICB3aGlsZSAoaSA8IGluZGV4KSB7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQudmFsdWUgPSB2YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBvcHMgYSBub2RlIGZyb20gdGhlIGVuZCBvZiB0aGUgZG91Ymx5IGxpbmtlZCBsaXN0XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHBvcFxuICAgICAqIEByZXR1cm4gYW55ICBUaGUgdmFsdWUgb2YgdGhlIHBvcHBlZCBub2RlLlxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcG9wIGZyb20gYW4gZW1wdHkgZGF0YSBzdHJ1Y3R1cmVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fdGFpbC52YWx1ZTtcbiAgICAgICAgdGhpcy5fdGFpbCA9IHRoaXMuX3RhaWwucHJldjtcbiAgICAgICAgaWYgKHRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl90YWlsLm5leHQ7XG4gICAgICAgICAgICB0aGlzLl90YWlsLm5leHQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xlbmd0aC0tO1xuICAgICAgICBpZiAodGhpcy5fbGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5faGVhZDtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNoaWZ0cyBhIG5vZGUgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkb3VibHkgbGlua2VkIGxpc3RcbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2hpZnRcbiAgICAgKiBAcmV0dXJuIGFueSAgVGhlIHZhbHVlIG9mIHRoZSBzaGlmdGVkIG5vZGUuXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHNoaWZ0IGZyb20gYW4gZW1wdHkgZGF0YSBzdHJ1Y3R1cmVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5faGVhZC52YWx1ZTtcbiAgICAgICAgdGhpcy5faGVhZCA9IHRoaXMuX2hlYWQubmV4dDtcbiAgICAgICAgaWYgKHRoaXMuX2hlYWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9oZWFkLnByZXY7XG4gICAgICAgICAgICB0aGlzLl9oZWFkLnByZXYgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xlbmd0aC0tO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYW4gZWxlbWVudCBhdCB0aGUgZW5kIG9mIHRoZSBkb3VibHkgbGlua2VkIGxpc3RcbiAgICAgKlxuICAgICAqIEBtZXRob2QgcHVzaFxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHVzaC5cbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIGFsbG9jYXRlIG5ldyBub2RlXG4gICAgICAgIHZhciBub2RlID0ge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgcHJldjogdGhpcy5fdGFpbCxcbiAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuX2xlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IHRoaXMuX3RhaWwgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdGFpbC5uZXh0ID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwgPSB0aGlzLl90YWlsLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGVuZ3RoKys7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcmVwZW5kcyB0aGUgZG91Ymx5IGxpbmtlZCBsaXN0IHdpdGggYW4gZWxlbWVudFxuICAgICAqXG4gICAgICogQG1ldGhvZCB1bnNoaWZ0XG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byB1bnNoaWZ0LlxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gYWxsb2NhdGUgbmV3IG5vZGVcbiAgICAgICAgdmFyIG5vZGUgPSB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBwcmV2OiBudWxsLFxuICAgICAgICAgICAgbmV4dDogdGhpcy5faGVhZFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5fbGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gdGhpcy5fdGFpbCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkLnByZXYgPSBub2RlO1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IHRoaXMuX2hlYWQucHJldjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sZW5ndGgrKztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBlZWtzIGF0IHRoZSBub2RlIGZyb20gdGhlIGVuZCBvZiB0aGUgZG91Ymx5IGxpbmtlZCBsaXN0XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHRvcFxuICAgICAqIEByZXR1cm4gYW55ICBUaGUgdmFsdWUgb2YgdGhlIGxhc3Qgbm9kZS5cbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS50b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl90YWlsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RhaWwudmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQZWVrcyBhdCB0aGUgbm9kZSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRvdWJseSBsaW5rZWQgbGlzdFxuICAgICAqXG4gICAgICogQG1ldGhvZCBib3R0b21cbiAgICAgKiBAcmV0dXJuIGFueSAgVGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBub2RlLlxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLmJvdHRvbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hlYWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGVhZC52YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvdW50cyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBkb3VibHkgbGlua2VkIGxpc3RcbiAgICAgKlxuICAgICAqIEBtZXRob2QgY291bnRcbiAgICAgKiBAcmV0dXJuIG51bWJlciB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBkb3VibHkgbGlua2VkIGxpc3QuXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZG91Ymx5IGxpbmtlZCBsaXN0IGlzIGVtcHR5XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGlzRW1wdHlcbiAgICAgKiBAcmV0dXJuIGJvb2xlYW4gd2hldGhlciB0aGUgZG91Ymx5IGxpbmtlZCBsaXN0IGlzIGVtcHR5LlxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fbGVuZ3RoID09PSAwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJld2luZCBpdGVyYXRvciBiYWNrIHRvIHRoZSBzdGFydFxuICAgICAqXG4gICAgICogQG1ldGhvZCByZXdpbmRcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5yZXdpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2tleSA9IDA7XG4gICAgICAgIHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGN1cnJlbnQgbGlzdCBlbnRyeVxuICAgICAqXG4gICAgICogQG1ldGhvZCBjdXJyZW50XG4gICAgICogQHJldHVybiBhbnkgIFRoZSBjdXJyZW50IG5vZGUgdmFsdWUuXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGN1cnJlbnQgbm9kZSBpbmRleFxuICAgICAqXG4gICAgICogQG1ldGhvZCBrZXlcbiAgICAgKiBAcmV0dXJuIGFueSAgVGhlIGN1cnJlbnQgbm9kZSBpbmRleC5cbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5rZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNb3ZlIHRvIG5leHQgZW50cnlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgbmV4dFxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9jdXJyZW50Lm5leHQ7XG4gICAgICAgIHRoaXMuX2tleSsrO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTW92ZSB0byBwcmV2aW91cyBlbnRyeVxuICAgICAqXG4gICAgICogQG1ldGhvZCBwcmV2XG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudCA9IHRoaXMuX2N1cnJlbnQucHJldjtcbiAgICAgICAgdGhpcy5fa2V5LS07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBkb3VibHkgbGlua2VkIGxpc3QgY29udGFpbnMgbW9yZSBub2Rlc1xuICAgICAqXG4gICAgICogQG1ldGhvZCB2YWxpZFxuICAgICAqIEByZXR1cm4gYm9vbGVhbiB0cnVlIGlmIHRoZSBkb3VibHkgbGlua2VkIGxpc3QgY29udGFpbnMgYW55IG1vcmUgbm9kZXMsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS52YWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9rZXkgPj0gMCAmJiB0aGlzLl9rZXkgPCB0aGlzLl9sZW5ndGgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRXhwb3J0IHRoZSBsaXN0IHRvIGFycmF5XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHRvQXJyYXlcbiAgICAgKiBAcmV0dXJuIEFycmF5ICAgVGhlIGV4cG9ydGVkIGFycmF5XG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBbXTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgbGlzdC5wdXNoKGN1cnJlbnQudmFsdWUpO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGxpc3QgdG8gc3RyaW5nXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHRvU3RyaW5nXG4gICAgICogQHJldHVybiBzdHJpbmcgICBUaGUgc2VyaWFsaXplZCBzdHJpbmcuXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIntcIiArIHRoaXMudG9BcnJheSgpLmpvaW4oXCItPlwiKSArIFwifVwiO1xuICAgIH07XG4gICAgcmV0dXJuIERvdWJseUxpbmtlZExpc3Q7XG59KSgpO1xubW9kdWxlLmV4cG9ydHMgPSBEb3VibHlMaW5rZWRMaXN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RG91Ymx5TGlua2VkTGlzdC5qcy5tYXAiLCIvKipcbiAqIFRoZSBIZWFwIGNsYXNzIHByb3ZpZGVzIHRoZSBtYWluIGZ1bmN0aW9uYWxpdHkgb2YgYSBIZWFwLlxuICpcbiAqIEBjbGFzcyBIZWFwXG4gKi9cbnZhciBIZWFwID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIZWFwKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQmluYXJ5IHRyZWUgc3RvcmFnZSBhcnJheVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgX3RyZWVcbiAgICAgICAgICogQHR5cGUgQXJyYXlcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RyZWUgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhlYXAgdHlwZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgX3R5cGVcbiAgICAgICAgICogQHR5cGUgbnVtYmVyXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90eXBlID0gSGVhcC5NQVg7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdGVyYXRpb24gcG9pbnRlclxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgX2tleVxuICAgICAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2tleSA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBpbmRleCBvZiBsZWZ0IGNoaWxkIGVsZW1lbnQgaW4gYmluYXJ5IHRyZWUgc3RvcmVkIGluIGFycmF5XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9jaGlsZFxuICAgICAqIEBwYXJhbSBuXG4gICAgICogQHJldHVybiBudW1iZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLl9jaGlsZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiAyICogbiArIDE7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgaW5kZXggb2YgcGFyZW50IGVsZW1lbnQgaW4gYmluYXJ5IHRyZWUgc3RvcmVkIGluIGFycmF5XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9wYXJlbnRcbiAgICAgKiBAcGFyYW0gblxuICAgICAqIEByZXR1cm4gbnVtYmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5fcGFyZW50ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnbj0nLCBuLCBNYXRoLmZsb29yKG4gLyAyKSk7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKG4gLyAyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN3YXAgMiBlbGVtZW50cyBpbiBiaW5hcnkgdHJlZVxuICAgICAqXG4gICAgICogQG1ldGhvZCBfc3dhcFxuICAgICAqIEBwYXJhbSBmaXJzdFxuICAgICAqIEBwYXJhbSBzZWNvbmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLl9zd2FwID0gZnVuY3Rpb24gKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgdmFyIHN3YXAgPSB0aGlzLl90cmVlW2ZpcnN0XTtcbiAgICAgICAgdGhpcy5fdHJlZVtmaXJzdF0gPSB0aGlzLl90cmVlW3NlY29uZF07XG4gICAgICAgIHRoaXMuX3RyZWVbc2Vjb25kXSA9IHN3YXA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTaWZ0IGVsZW1lbnRzIGluIGJpbmFyeSB0cmVlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9zaWZ0VXBcbiAgICAgKiBAcGFyYW0gaVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUuX3NpZnRVcCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHdoaWxlIChpID4gMCkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudChpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhcmUodGhpcy5fdHJlZVtpXSwgdGhpcy5fdHJlZVtwYXJlbnRdKSAqIHRoaXMuX3R5cGUgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3dhcChpLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgIGkgPSBwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2lmdCBkb3duIGVsZW1lbnRzIGluIGJpbmFyeSB0cmVlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9zaWZ0RG93blxuICAgICAqIEBwYXJhbSBpXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5fc2lmdERvd24gPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICB3aGlsZSAoaSA8IHRoaXMuX3RyZWUubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IHRoaXMuX2NoaWxkKGkpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gbGVmdCArIDE7XG4gICAgICAgICAgICBpZiAoKGxlZnQgPCB0aGlzLl90cmVlLmxlbmd0aCkgJiYgKHJpZ2h0IDwgdGhpcy5fdHJlZS5sZW5ndGgpICYmXG4gICAgICAgICAgICAgICAgKHRoaXMuY29tcGFyZSh0aGlzLl90cmVlW2ldLCB0aGlzLl90cmVlW2xlZnRdKSAqIHRoaXMuX3R5cGUgPCAwIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGFyZSh0aGlzLl90cmVlW2ldLCB0aGlzLl90cmVlW3JpZ2h0XSkgKiB0aGlzLl90eXBlIDwgMCkpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyAyIGNoaWxkcmVuIGFuZCBvbmUgb2YgdGhlbSBtdXN0IGJlIHN3YXBwZWRcbiAgICAgICAgICAgICAgICAvLyBnZXQgY29ycmVjdCBlbGVtZW50IHRvIHNpZnQgZG93blxuICAgICAgICAgICAgICAgIHZhciBzaWZ0ID0gbGVmdDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb21wYXJlKHRoaXMuX3RyZWVbbGVmdF0sIHRoaXMuX3RyZWVbcmlnaHRdKSAqIHRoaXMuX3R5cGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZnQgPSByaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fc3dhcChpLCBzaWZ0KTtcbiAgICAgICAgICAgICAgICBpID0gc2lmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxlZnQgPCB0aGlzLl90cmVlLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuY29tcGFyZSh0aGlzLl90cmVlW2ldLCB0aGlzLl90cmVlW2xlZnRdKSAqIHRoaXMuX3R5cGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBvbmUgY2hpbGQgZXhpc3RzXG4gICAgICAgICAgICAgICAgdGhpcy5fc3dhcChpLCBsZWZ0KTtcbiAgICAgICAgICAgICAgICBpID0gbGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyBhIG5vZGUgZnJvbSB0b3Agb2YgdGhlIGhlYXAgYW5kIHNpZnQgdXBcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZXh0cmFjdFxuICAgICAqIEByZXR1cm4gYW55IFRoZSB2YWx1ZSBvZiB0aGUgZXh0cmFjdGVkIG5vZGUuXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUuZXh0cmFjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyZWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBleHRyYWN0IGZyb20gYW4gZW1wdHkgZGF0YSBzdHJ1Y3R1cmVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV4dHJhY3RlZCA9IHRoaXMuX3RyZWVbMF07XG4gICAgICAgIGlmICh0aGlzLl90cmVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5fdHJlZSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdHJlZVswXSA9IHRoaXMuX3RyZWUucG9wKCk7XG4gICAgICAgICAgICB0aGlzLl9zaWZ0RG93bigwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXh0cmFjdGVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiBlbGVtZW50IGluIHRoZSBoZWFwIGJ5IHNpZnRpbmcgaXQgdXBcbiAgICAgKlxuICAgICAqIEBtZXRob2QgaW5zZXJ0XG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3RyZWUucHVzaCh2YWx1ZSk7XG4gICAgICAgIHRoaXMuX3NpZnRVcCh0aGlzLl90cmVlLmxlbmd0aCAtIDEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGVla3MgYXQgdGhlIG5vZGUgZnJvbSB0aGUgdG9wIG9mIHRoZSBoZWFwXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHRvcFxuICAgICAqIEByZXR1cm4gYW55IFRoZSB2YWx1ZSBvZiB0aGUgbm9kZSBvbiB0aGUgdG9wLlxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLnRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyZWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwZWVrIGF0IGFuIGVtcHR5IGhlYXBcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWVbMF07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb3VudHMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaGVhcFxuICAgICAqXG4gICAgICogQG1ldGhvZCBjb3VudFxuICAgICAqIEByZXR1cm4gbnVtYmVyIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGhlYXAuXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmVlLmxlbmd0aDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBoZWFwIGlzIGVtcHR5XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGlzRW1wdHlcbiAgICAgKiBAcmV0dXJuIGJvb2xlYW4gd2hldGhlciB0aGUgaGVhcCBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX3RyZWUubGVuZ3RoID09PSAwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJld2luZCBpdGVyYXRvciBiYWNrIHRvIHRoZSBzdGFydCAobm8tb3ApXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHJld2luZFxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLnJld2luZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fa2V5ID0gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBjdXJyZW50IG5vZGUgcG9pbnRlZCBieSB0aGUgaXRlcmF0b3JcbiAgICAgKlxuICAgICAqIEBtZXRob2QgY3VycmVudFxuICAgICAqIEByZXR1cm4gYW55IFRoZSBjdXJyZW50IG5vZGUgdmFsdWUuXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWVbdGhpcy5fa2V5XTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBjdXJyZW50IG5vZGUgaW5kZXhcbiAgICAgKlxuICAgICAqIEBtZXRob2Qga2V5XG4gICAgICogQHJldHVybiBhbnkgVGhlIGN1cnJlbnQgbm9kZSBpbmRleC5cbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5rZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNb3ZlIHRvIHRoZSBuZXh0IG5vZGVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgbmV4dFxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2tleSsrO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTW92ZSB0byBwcmV2aW91cyBlbnRyeVxuICAgICAqXG4gICAgICogQG1ldGhvZCBwcmV2XG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fa2V5LS07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBoZWFwIGNvbnRhaW5zIG1vcmUgbm9kZXNcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdmFsaWRcbiAgICAgKiBAcmV0dXJuIGJvb2xlYW4gdHJ1ZSBpZiB0aGUgaGVhcCBjb250YWlucyBhbnkgbW9yZSBub2RlcywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLnZhbGlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2tleSA+PSAwICYmIHRoaXMuX2tleSA8IHRoaXMuX3RyZWUubGVuZ3RoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXBhcmUgZWxlbWVudHMgaW4gb3JkZXIgdG8gcGxhY2UgdGhlbSBjb3JyZWN0bHkgaW4gdGhlIGhlYXAgd2hpbGUgc2lmdGluZyB1cC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgY29tcGFyZVxuICAgICAqIEBwYXJhbSBmaXJzdCBUaGUgdmFsdWUgb2YgdGhlIGZpcnN0IG5vZGUgYmVpbmcgY29tcGFyZWQuXG4gICAgICogQHBhcmFtIHNlY29uZCBUaGUgdmFsdWUgb2YgdGhlIHNlY29uZCBub2RlIGJlaW5nIGNvbXBhcmVkLlxuICAgICAqIEByZXR1cm4gbnVtYmVyIFJlc3VsdCBvZiB0aGUgY29tcGFyaXNvbiwgcG9zaXRpdmUgaW50ZWdlciBpZiBmaXJzdCBpcyBncmVhdGVyIHRoYW4gc2Vjb25kLCAwIGlmIHRoZXkgYXJlIGVxdWFsLCBuZWdhdGl2ZSBpbnRlZ2VyIG90aGVyd2lzZS5cbiAgICAgKiBIYXZpbmcgbXVsdGlwbGUgZWxlbWVudHMgd2l0aCB0aGUgc2FtZSB2YWx1ZSBpbiBhIEhlYXAgaXMgbm90IHJlY29tbWVuZGVkLiBUaGV5IHdpbGwgZW5kIHVwIGluIGFuIGFyYml0cmFyeSByZWxhdGl2ZSBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgaWYgKGZpcnN0ID4gc2Vjb25kKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaXJzdCA9PSBzZWNvbmQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBWaXN1YWxseSBkaXNwbGF5IGhlYXAgdHJlZVxuICAgICAqXG4gICAgICogQG1ldGhvZCBfZGlzcGxheU5vZGVcbiAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAqIEBwYXJhbSBwcmVmaXhcbiAgICAgKiBAcGFyYW0gbGFzdFxuICAgICAqIEByZXR1cm4gU3RyaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5fZGlzcGxheU5vZGUgPSBmdW5jdGlvbiAobm9kZSwgcHJlZml4LCBsYXN0KSB7XG4gICAgICAgIGlmIChwcmVmaXggPT09IHZvaWQgMCkgeyBwcmVmaXggPSAnJzsgfVxuICAgICAgICBpZiAobGFzdCA9PT0gdm9pZCAwKSB7IGxhc3QgPSB0cnVlOyB9XG4gICAgICAgIHZhciBsaW5lID0gcHJlZml4O1xuICAgICAgICAvLyBnZXQgY2hpbGQgaW5kZXhlc1xuICAgICAgICB2YXIgbGVmdCA9IHRoaXMuX2NoaWxkKG5vZGUpO1xuICAgICAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgMTtcbiAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgIGxpbmUgKz0gKHByZWZpeCA/ICfilJTilIAnIDogJyAgJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsaW5lICs9ICfilJzilIAnO1xuICAgICAgICB9XG4gICAgICAgIGxpbmUgKz0gdGhpcy5fdHJlZVtub2RlXTtcbiAgICAgICAgcHJlZml4ICs9IChsYXN0ID8gJyAgJyA6ICfilIIgJyk7XG4gICAgICAgIGlmIChsZWZ0IDwgdGhpcy5fdHJlZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxpbmUgKz0gJ1xcbicgKyB0aGlzLl9kaXNwbGF5Tm9kZShsZWZ0LCBwcmVmaXgsICh0aGlzLl90cmVlW3JpZ2h0XSA9PSB1bmRlZmluZWQgPyB0cnVlIDogZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmlnaHQgPCB0aGlzLl90cmVlLmxlbmd0aCkge1xuICAgICAgICAgICAgbGluZSArPSAnXFxuJyArIHRoaXMuX2Rpc3BsYXlOb2RlKHJpZ2h0LCBwcmVmaXgsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgaGVhcCB0byBzdHJpbmdcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9TdHJpbmdcbiAgICAgKiBAcmV0dXJuIHN0cmluZyAgIFRoZSBzZXJpYWxpemVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gc3RhcnQgd2l0aCByb290IGFuZCByZWN1cnNpdmVseSBnb2VzIHRvIGVhY2ggbm9kZVxuICAgICAgICByZXR1cm4gdGhpcy5fZGlzcGxheU5vZGUoMCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBoZWFwIHRvIGFycmF5XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHRvQXJyYXlcbiAgICAgKiBAcmV0dXJuIEFycmF5ICAgVGhlIHNlcmlhbGl6ZWQgYXJyYXkuXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNYXggaGVhcCBmbGFnXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgTUFYXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIEhlYXAuTUFYID0gMTtcbiAgICAvKipcbiAgICAgKiBNaW4gaGVhcCBmbGFnXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgTUlOXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIEhlYXAuTUlOID0gLTE7XG4gICAgcmV0dXJuIEhlYXA7XG59KSgpO1xubW9kdWxlLmV4cG9ydHMgPSBIZWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SGVhcC5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gdGhpcy5fX2V4dGVuZHMgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZTtcbiAgICBkLnByb3RvdHlwZSA9IG5ldyBfXygpO1xufTtcbnZhciBIZWFwID0gcmVxdWlyZSgnLi9IZWFwJyk7XG4vKipcbiAqIFRoZSBNYXhIZWFwIGNsYXNzIHByb3ZpZGVzIHRoZSBtYWluIGZ1bmN0aW9uYWxpdHkgb2YgYSBoZWFwLCBrZWVwaW5nIHRoZSBtYXhpbXVtIG9uIHRoZSB0b3AuXG4gKlxuICogQGNsYXNzIE1heEhlYXBcbiAqIEBleHRlbmRzIEhlYXBcbiAqL1xudmFyIE1heEhlYXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXhIZWFwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1heEhlYXAoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl90eXBlID0gSGVhcC5NQVg7XG4gICAgfVxuICAgIHJldHVybiBNYXhIZWFwO1xufSkoSGVhcCk7XG5tb2R1bGUuZXhwb3J0cyA9IE1heEhlYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXhIZWFwLmpzLm1hcCIsInZhciBfX2V4dGVuZHMgPSB0aGlzLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlO1xuICAgIGQucHJvdG90eXBlID0gbmV3IF9fKCk7XG59O1xudmFyIEhlYXAgPSByZXF1aXJlKCcuL0hlYXAnKTtcbi8qKlxuICogVGhlIE1pbkhlYXAgY2xhc3MgcHJvdmlkZXMgdGhlIG1haW4gZnVuY3Rpb25hbGl0eSBvZiBhIGhlYXAsIGtlZXBpbmcgdGhlIG1pbmltdW0gb24gdGhlIHRvcC5cbiAqXG4gKiBAY2xhc3MgTWluSGVhcFxuICogQGV4dGVuZHMgSGVhcFxuICovXG52YXIgTWluSGVhcCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1pbkhlYXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWluSGVhcCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX3R5cGUgPSBIZWFwLk1JTjtcbiAgICB9XG4gICAgcmV0dXJuIE1pbkhlYXA7XG59KShIZWFwKTtcbm1vZHVsZS5leHBvcnRzID0gTWluSGVhcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1pbkhlYXAuanMubWFwIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgSGVhcCA9IHJlcXVpcmUoJy4vSGVhcCcpO1xuLyoqXG4gKiBUaGUgUHJpb3JpdHlRdWV1ZSBjbGFzcyBwcm92aWRlcyB0aGUgbWFpbiBmdW5jdGlvbmFsaXR5IG9mIGFuIHByaW9yaXRpemVkIHF1ZXVlLCBpbXBsZW1lbnRlZCB1c2luZyBhIG1heCBoZWFwLlxuICpcbiAqIEBjbGFzcyBQcmlvcml0eVF1ZXVlXG4gKiBAZXh0ZW5kcyBIZWFwXG4gKi9cbnZhciBQcmlvcml0eVF1ZXVlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUHJpb3JpdHlRdWV1ZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQcmlvcml0eVF1ZXVlKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fdHlwZSA9IEhlYXAuTUFYO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGVsZW1lbnQgdG8gdGhlIHF1ZXVlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGVucXVldWVcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGVucXVldWUuXG4gICAgICogQHBhcmFtIHByaW9yaXR5IFRoZSBwcmlvcml0eSBvZiB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24gKHZhbHVlLCBwcmlvcml0eSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnNlcnQobmV3IFByaW9yaXR5UXVldWVOb2RlKHZhbHVlLCBwcmlvcml0eSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVxdWV1ZXMgYSBub2RlIGZyb20gdGhlIHF1ZXVlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRlcXVldWVcbiAgICAgKiBAcmV0dXJuIGFueSAgVGhlIHZhbHVlIG9mIHRoZSBkZXF1ZXVlZCBub2RlLlxuICAgICAqL1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLmRlcXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dHJhY3QoKS52YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBlZWtzIGF0IHRoZSBub2RlIGZyb20gdGhlIHRvcCBvZiB0aGUgaGVhcFxuICAgICAqXG4gICAgICogQG1ldGhvZCB0b3BcbiAgICAgKiBAcmV0dXJuIGFueSBUaGUgdmFsdWUgb2YgdGhlIG5vZGUgb24gdGhlIHRvcC5cbiAgICAgKi9cbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS50b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnRvcC5jYWxsKHRoaXMpLnZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcGFyZSBlbGVtZW50cyBpbiBvcmRlciB0byBwbGFjZSB0aGVtIGNvcnJlY3RseSBpbiB0aGUgaGVhcCB3aGlsZSBzaWZ0aW5nIHVwLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBjb21wYXJlXG4gICAgICogQHBhcmFtIGZpcnN0IFRoZSB2YWx1ZSBvZiB0aGUgZmlyc3Qgbm9kZSBiZWluZyBjb21wYXJlZC5cbiAgICAgKiBAcGFyYW0gc2Vjb25kIFRoZSB2YWx1ZSBvZiB0aGUgc2Vjb25kIG5vZGUgYmVpbmcgY29tcGFyZWQuXG4gICAgICogQHJldHVybiBudW1iZXIgUmVzdWx0IG9mIHRoZSBjb21wYXJpc29uLCBwb3NpdGl2ZSBpbnRlZ2VyIGlmIGZpcnN0IGlzIGdyZWF0ZXIgdGhhbiBzZWNvbmQsIDAgaWYgdGhleSBhcmUgZXF1YWwsIG5lZ2F0aXZlIGludGVnZXIgb3RoZXJ3aXNlLlxuICAgICAqIEhhdmluZyBtdWx0aXBsZSBlbGVtZW50cyB3aXRoIHRoZSBzYW1lIHZhbHVlIGluIGEgSGVhcCBpcyBub3QgcmVjb21tZW5kZWQuIFRoZXkgd2lsbCBlbmQgdXAgaW4gYW4gYXJiaXRyYXJ5IHJlbGF0aXZlIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICBpZiAoZmlyc3QucHJpb3JpdHkgPiBzZWNvbmQucHJpb3JpdHkpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpcnN0LnByaW9yaXR5ID09IHNlY29uZC5wcmlvcml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBQcmlvcml0eVF1ZXVlO1xufSkoSGVhcCk7XG4vKipcbiAqIFByaW9yaXR5UXVldWUgTm9kZVxuICpcbiAqIEBjbGFzcyBQcmlvcml0eVF1ZXVlTm9kZVxuICovXG52YXIgUHJpb3JpdHlRdWV1ZU5vZGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHBhcmFtIHByaW9yaXR5XG4gICAgICovXG4gICAgZnVuY3Rpb24gUHJpb3JpdHlRdWV1ZU5vZGUodmFsdWUsIHByaW9yaXR5KSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IHByaW9yaXR5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBub2RlIHRvIHN0cmluZ1xuICAgICAqXG4gICAgICogQG1ldGhvZCB0b1N0cmluZ1xuICAgICAqIEByZXR1cm4gc3RyaW5nICAgVGhlIHNlcmlhbGl6ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIFByaW9yaXR5UXVldWVOb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgKyBcIiBbXCIgKyB0aGlzLnByaW9yaXR5ICsgXCJdXCI7XG4gICAgfTtcbiAgICByZXR1cm4gUHJpb3JpdHlRdWV1ZU5vZGU7XG59KSgpO1xubW9kdWxlLmV4cG9ydHMgPSBQcmlvcml0eVF1ZXVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJpb3JpdHlRdWV1ZS5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBEb3VibHlMaW5rZWRMaXN0ID0gcmVxdWlyZSgnLi9Eb3VibHlMaW5rZWRMaXN0Jyk7XG4vKipcbiAqIFRoZSBRdWV1ZSBjbGFzcyBwcm92aWRlcyB0aGUgbWFpbiBmdW5jdGlvbmFsaXR5IG9mIGEgcXVldWUgaW1wbGVtZW50ZWQgdXNpbmcgYSBkb3VibHkgbGlua2VkIGxpc3QuXG4gKlxuICogQGNsYXNzIFF1ZXVlXG4gKiBAZXh0ZW5kcyBEb3VibHlMaW5rZWRMaXN0XG4gKi9cbnZhciBRdWV1ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFF1ZXVlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFF1ZXVlKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBlbGVtZW50IHRvIHRoZSBxdWV1ZVxuICAgICAqXG4gICAgICogQG1ldGhvZCBlbnF1ZXVlXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBlbnF1ZXVlLlxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIFF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1c2godmFsdWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVxdWV1ZXMgYSBub2RlIGZyb20gdGhlIHF1ZXVlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRlcXVldWVcbiAgICAgKiBAcmV0dXJuIGFueSAgVGhlIHZhbHVlIG9mIHRoZSBkZXF1ZXVlZCBub2RlLlxuICAgICAqL1xuICAgIFF1ZXVlLnByb3RvdHlwZS5kZXF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGlmdCgpO1xuICAgIH07XG4gICAgcmV0dXJuIFF1ZXVlO1xufSkoRG91Ymx5TGlua2VkTGlzdCk7XG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UXVldWUuanMubWFwIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgRG91Ymx5TGlua2VkTGlzdCA9IHJlcXVpcmUoJy4vRG91Ymx5TGlua2VkTGlzdCcpO1xuLyoqXG4gKiBUaGUgU3RhY2sgY2xhc3MgcHJvdmlkZXMgdGhlIG1haW4gZnVuY3Rpb25hbGl0eSBvZiBhIHN0YWNrIGltcGxlbWVudGVkIHVzaW5nIGEgZG91Ymx5IGxpbmtlZCBsaXN0LlxuICpcbiAqIEBjbGFzcyBTdGFja1xuICogQGV4dGVuZHMgRG91Ymx5TGlua2VkTGlzdFxuICovXG52YXIgU3RhY2sgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdGFjaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdGFjaygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBTdGFjaztcbn0pKERvdWJseUxpbmtlZExpc3QpO1xubW9kdWxlLmV4cG9ydHMgPSBTdGFjaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0YWNrLmpzLm1hcCIsIi8qKlxuICogU1RMXG4gKiBAdHlwZSB7e0RvdWJseUxpbmtlZExpc3Q6IGV4cG9ydHMsIFN0YWNrOiBleHBvcnRzLCBRdWV1ZTogZXhwb3J0cywgSGVhcDogZXhwb3J0cywgTWF4SGVhcDogZXhwb3J0cywgTWluSGVhcDogZXhwb3J0cywgUHJpb3JpdHlRdWV1ZTogZXhwb3J0c319XG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuXHREb3VibHlMaW5rZWRMaXN0OiByZXF1aXJlKCcuL0RhdGFzdHJ1Y3R1cmVzL0RvdWJseUxpbmtlZExpc3QnKSxcblx0U3RhY2s6IHJlcXVpcmUoJy4vRGF0YXN0cnVjdHVyZXMvU3RhY2snKSxcblx0UXVldWU6IHJlcXVpcmUoJy4vRGF0YXN0cnVjdHVyZXMvUXVldWUnKSxcblx0SGVhcDogcmVxdWlyZSgnLi9EYXRhc3RydWN0dXJlcy9IZWFwJyksXG5cdE1heEhlYXA6IHJlcXVpcmUoJy4vRGF0YXN0cnVjdHVyZXMvTWF4SGVhcCcpLFxuXHRNaW5IZWFwOiByZXF1aXJlKCcuL0RhdGFzdHJ1Y3R1cmVzL01pbkhlYXAnKSxcblx0UHJpb3JpdHlRdWV1ZTogcmVxdWlyZSgnLi9EYXRhc3RydWN0dXJlcy9Qcmlvcml0eVF1ZXVlJylcbn07IiwiaW1wb3J0IHsgbWFuaGF0dGFuRGlzdGFuY2UgfSBmcm9tICcuL290aGVyL2hlbHBlckZ1bmN0aW9ucydcbmltcG9ydCBNYXBXaXRoRGVmYXVsdFZhbHVlIGZyb20gJy4vb3RoZXIvbWFwV2l0aERlZmF1bHRWYWx1ZSdcblxuaW1wb3J0IHsgUHJpb3JpdHlRdWV1ZSB9IGZyb20gJ2xpYnN0bCc7IC8vIG5vdGU6IGltcG9ydGVkIGZyb20gYSBub2RlIG1vZHVsZVxuXG4vKiogQG1vZHVsZSBmaW5kUGF0aCAqL1xuXG4vKipcbiAqIEhlYXZpbHkgbW9kaWZpZWQgaW1wbGVtZW50YXRpb24gb2YgdGhlIEEqIGFsZ29yaXRobVxuICogQHBhcmFtICB7T2JqZWN0fSBzdGFydCBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWAgdGhhdCByZXByZXNlbnQgdGhlIGZpcnN0IGVuZHBvaW50IG9mIHRoZSB3aXJlIGluIGdyaWQgcGl4ZWxzXG4gKiBAcGFyYW0gIHtPYmplY3R9IGVuZCAgIG9iamVjdCBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YCB0aGF0IHJlcHJlc2VudCB0aGUgc2Vjb25kIGVuZHBvaW50IG9mIHRoZSB3aXJlIGluIGdyaWQgcGl4ZWxzXG4gKiBAcGFyYW0gIHtTZXR9IG5vblJvdXRhYmxlIHNldCBvZiBub24gcm91dGFibGUgbm9kZXNcbiAqIEBwYXJhbSAge1NldH0gcHVuaXNoZWRCdXRSb3V0YWJsZSBzZXQgb2Ygbm9kZXMgdGhhdCBhcmUgbm90IG9wdGltYWwgZm9yIHJvdXRpbmdcbiAqIEByZXR1cm4ge0FycmF5fSBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgbnVtZXJpYyBhdHRyaWJ1dGVzIGB4YCBhbmQgYHlgXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpbmRQYXRoKHN0YXJ0LCBlbmQsIG5vblJvdXRhYmxlLCBwdW5pc2hlZEJ1dFJvdXRhYmxlKSB7XG4gICAgY29uc3QgZGlzdGFuY2VGdW5jdGlvbiA9IG1hbmhhdHRhbkRpc3RhbmNlO1xuXG4gICAgY29uc3Qgd2lyZUNyb3NzUHVuaXNobWVudCA9IDE7XG4gICAgY29uc3Qgd2lyZUJlbmRQdW5pc2htZW50ID0gMTtcblxuICAgIC8vIG51bWJlciBvZiBub2RlcywgdGhhdCBjYW4gYmUgb3BlbmVkIGF0IG9uY2VcbiAgICAvLyBvbmNlIGlzIHRoaXMgbGltaXQgZXhjZWVkZWQsIGFTdGFyIHdpbGwgZmFpbCBhbmQgcmV0dXJuIHVuZGVmaW5lZFxuICAgIGNvbnN0IG1heE5vZGVMaW1pdCA9IDEwMDAwMDtcblxuICAgIGxldCBjbG9zZWROb2RlcyA9IG5ldyBTZXQoKTtcbiAgICBsZXQgb3Blbk5vZGVzID0gbmV3IFNldCgpO1xuICAgIGxldCBvcGVuTm9kZVF1ZXVlID0gbmV3IFByaW9yaXR5UXVldWUoKTtcblxuICAgIC8vIGZ1bmN0aW9ucyBmb3Igd29ya2luZyB3aXRoIG9wZW4gbm9kZXM6XG5cbiAgICAvKipcbiAgICAgKiBhZGQgYSBuZXcgb3BlbiBub2RlIHRvIHRoZSBzdHJ1Y3R1cmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSAgIG9iamVjdCBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YCB0aGF0IHJlcHJlc2VudCB0aGUgZmlyc3QgZW5kcG9pbnQgb2YgdGhlIHdpcmVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZnNjb3JlIGZTY29yZSBvZiB0aGlzIG5vZGVcbiAgICAgKi9cbiAgICBjb25zdCBhZGRPcGVuTm9kZSA9IChub2RlLCBmc2NvcmUpID0+IHtcbiAgICAgICAgb3Blbk5vZGVzLmFkZChub2RlKTtcbiAgICAgICAgLy8gZmxpcCB0aGUgZnNjb3JlLCBiZWNhdXNlIFByaW9yaXR5UXVldWUgdXNlcyBtYXggaGVhcFxuICAgICAgICBvcGVuTm9kZVF1ZXVlLmVucXVldWUobm9kZSwgMSAvIGZzY29yZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBvcGVuIG5vZGUgd2l0aCB0aGUgbG93ZXN0IGZTY29yZSBhbmQgcmVtb3ZlIGl0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWAgdGhhdCByZXByZXNlbnQgdGhlIGZpcnN0IGVuZHBvaW50IG9mIHRoZSB3aXJlXG4gICAgICovXG4gICAgY29uc3QgZ2V0T3Blbk5vZGUgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBvcGVuTm9kZVF1ZXVlLmRlcXVldWUoKTtcbiAgICAgICAgb3Blbk5vZGVzLmRlbGV0ZShub2RlKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgbGV0IGNhbWVGcm9tID0gbmV3IE1hcCgpO1xuXG4gICAgLy8gZGVmYXVsdCB2YWx1ZTogaW5maW5pdHlcbiAgICBsZXQgZ1Njb3JlID0gbmV3IE1hcFdpdGhEZWZhdWx0VmFsdWUoSW5maW5pdHkpO1xuICAgIGdTY29yZS5zZXQoc3RhcnQsIDApO1xuXG4gICAgbGV0IHN0YXJ0RlNjb3JlID0gZGlzdGFuY2VGdW5jdGlvbihzdGFydCwgZW5kKTtcblxuICAgIGFkZE9wZW5Ob2RlKHN0YXJ0LCBzdGFydEZTY29yZSk7XG5cbiAgICBvcGVuTm9kZXMuYWRkKHN0YXJ0KTtcbiAgICBvcGVuTm9kZVF1ZXVlLmVucXVldWUoc3RhcnQsIDEgLyBzdGFydEZTY29yZSk7XG5cbiAgICB3aGlsZSAob3Blbk5vZGVzLnNpemUgPiAwKSB7XG4gICAgICAgIC8vIGdldCB0aGUgdmFsdWUgZnJvbSBvcGVuTm9kZXMgdGhhdCBoYXMgdGhlIGxvd2VzdCBmU2NvcmVcbiAgICAgICAgY29uc3QgY3VycmVudE5vZGUgPSBnZXRPcGVuTm9kZSgpO1xuXG4gICAgICAgIC8vIGlmIHdlIHJlYWNoZWQgdGhlIGVuZCBwb2ludCwgcmVjb25zdHJ1Y3QgdGhlIHBhdGggYW5kIHJldHVybiBpdFxuICAgICAgICBpZiAoY3VycmVudE5vZGUueCA9PSBlbmQueCAmJiBjdXJyZW50Tm9kZS55ID09IGVuZC55KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjb25zdHJ1Y3RQYXRoKGNhbWVGcm9tLCBjdXJyZW50Tm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgdGhpcyBub2RlIHRvIHRoZSBjbG9zZWQgbm9kZXNcbiAgICAgICAgY2xvc2VkTm9kZXMuYWRkKGN1cnJlbnROb2RlKTtcblxuICAgICAgICAvLyB0aGUgZmFydGhlc3QgcG9pbnRzIGFjY2Vzc2libGUgd2l0aG91dCBhdm9pZGluZyBvYnN0YWNsZXMgaW4gZXZlcnkgZGlyZWN0aW9uXG4gICAgICAgIC8vIChidXQgbWF4IDUwIGluIGVhY2ggZGlyZWN0aW9uKVxuICAgICAgICBmb3IgKGxldCBkaXJlY3Rpb24gPSAwOyBkaXJlY3Rpb24gPCA0OyBkaXJlY3Rpb24rKykge1xuICAgICAgICAgICAgbGV0IG5ld1BvaW50ID0gbW92ZVBvaW50KGN1cnJlbnROb2RlLCBkaXJlY3Rpb24pO1xuXG4gICAgICAgICAgICBsZXQgd2lyZXNDcm9zc2VkID0gMDtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1MDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgbmV3UG9pbnQgaXMgaW4gdGhlIHNldCBvZiBub24gcm91dGFibGUgcG9pbnRzLFxuICAgICAgICAgICAgICAgIC8vIGRvbid0IGFkZCBpdCBhbmQgc3RvcCBwcm9jZWVkaW5nIGluIHRoaXMgZGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHNldEhhc1RoaXNQb2ludChub25Sb3V0YWJsZSwgbmV3UG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgbm90IHRoZSBlbmQgb3Igc3RhcnQgcG9pbnQsIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGlmICghKG5ld1BvaW50LnggPT09IGVuZC54ICYmIG5ld1BvaW50LnkgPT09IGVuZC55KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIShuZXdQb2ludC54ID09PSBzdGFydC54ICYmIG5ld1BvaW50LnkgPT09IHN0YXJ0LnkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBza2lwIHRoaXMgbm9kZSwgaWYgaXQgaGFzIGJlZW4gYWxyZWFkeSBjbG9zZWRcbiAgICAgICAgICAgICAgICAvLyBvciBpZiBpdCBpcyBvbiB0aGUgbGlzdCBvZiBub24gcm91dGFibGUgbm9kZXNcbiAgICAgICAgICAgICAgICBpZiAoY2xvc2VkTm9kZXMuaGFzKG5ld1BvaW50KSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgcG9zc2libGUgR1Njb3JlIGJ5IGFwcGx5aW5nIGEgcHVuaXNobWVudCBmb3IgZWFjaCBub2RlIChcImJlbmRcIikgaW4gdGhlIHBhdGhcbiAgICAgICAgICAgICAgICBsZXQgbmV3R1Njb3JlID0gd2lyZUJlbmRQdW5pc2htZW50ICsgZ1Njb3JlLmdldFdpdGhEZWZhdWx0KGN1cnJlbnROb2RlKTtcblxuICAgICAgICAgICAgICAgIGlmIChzZXRIYXNUaGlzUG9pbnQocHVuaXNoZWRCdXRSb3V0YWJsZSwgbmV3UG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBub2RlIGlzIGluIHRoZSBzZXQgb2YgcHVuaXNoZWQgbm9kZXMsIGFwcGx5IHRoZSBwdW5pc2htZW50XG4gICAgICAgICAgICAgICAgICAgIHdpcmVzQ3Jvc3NlZCsrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGFwcGx5IHRoZSBwdW5pc2htZW50IGZvciBlYWNoIHdpcmUgY3Jvc3NlZCBpbiB0aGlzIGRpcmVjdGlvblxuICAgICAgICAgICAgICAgIC8vIG5vdGU6IHdlIGFyZSBjb3VudGluZyB0aGUgd2lyZXMgY3Jvc3NlZCB3aGVuIGV4cG9ydGluZyB0aGlzIGRpcmVjdGlvbiwgbm90IHRoZSB3aXJlc1xuICAgICAgICAgICAgICAgIC8vIGNyb3NzZWQgaW4gdGhlIGZpbmFsIHBhdGgsIHRoZXJlIHdpbGwgYmUgcHJvYmFibHkgb25seSBhdCBtb3N0IG9mIHRoZXNlIG5vZGVzIGluIHRoZVxuICAgICAgICAgICAgICAgIC8vIGZpbmFsIHBhdGgsIG5vdCBtdWx0aXBsZVxuICAgICAgICAgICAgICAgIG5ld0dTY29yZSArPSB3aXJlc0Nyb3NzZWQgKiB3aXJlQ3Jvc3NQdW5pc2htZW50O1xuXG4gICAgICAgICAgICAgICAgLy8gc2tpcCB0aGlzIG5vZGUgaWYgaXQgaGFzIHdvcnN0IGVzdGltYWdlIGdzY29yZSB0aGFuIGluIHRoZSBnc2NvcmUgdGFibGVcbiAgICAgICAgICAgICAgICBpZiAobmV3R1Njb3JlID49IGdTY29yZS5nZXRXaXRoRGVmYXVsdChuZXdQb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2FtZUZyb20uc2V0KG5ld1BvaW50LCBjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgZ1Njb3JlLnNldChuZXdQb2ludCwgbmV3R1Njb3JlKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0ZTY29yZSA9IG5ld0dTY29yZSArIGRpc3RhbmNlRnVuY3Rpb24obmV3UG9pbnQsIGVuZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW9wZW5Ob2Rlcy5oYXMobmV3UG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgcG9pbnQgdG8gdGhlIGxpc3Qgb2YgcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgIGFkZE9wZW5Ob2RlKG5ld1BvaW50LCBuZXdGU2NvcmUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG1vdmUgdG8gdGhlIG5leHQgcG9pbnQgaW4gdGhlIGRpcmVjaXRvblxuICAgICAgICAgICAgICAgIG5ld1BvaW50ID0gbW92ZVBvaW50KG5ld1BvaW50LCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wZW5Ob2Rlcy5zaXplID4gbWF4Tm9kZUxpbWl0KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgYVN0YXI6IE51bWJlciBvZiBvcGVuIG5vZGVzICgke29wZW5Ob2Rlcy5zaXplfSkgZXhjZWVkZWQgdGhlIGxpbWl0IGZvciBvcGVuIG5vZGVzICgke21heE5vZGVMaW1pdH0pLmApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiB3ZSBnb3QgaGVyZSwgdGhlIHBhdGggd2FzIG5vdCBmb3VuZFxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiByZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3BlY2lmaWVkIHNldCBvZiBwb2ludHMgY29udGFpbnMgdGhlIHNwZWNpZmllZCBwb2ludCAoYW5kIHJldHVybnMgYGZhbHNlYCBvdGhlcndpc2UpXG4gKiBAcGFyYW0ge1NldH0gc2V0IHNldCBvZiBwb2ludHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludCBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWBcbiAqL1xuZnVuY3Rpb24gc2V0SGFzVGhpc1BvaW50KHNldCwgcG9pbnQpIHtcbiAgICBmb3IgKGxldCBpdGVtIG9mIHNldCkge1xuICAgICAgICBpZiAoaXRlbS54ID09PSBwb2ludC54ICYmIGl0ZW0ueSA9PT0gcG9pbnQueSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IG1vdmVzIHRoZSBwYXNzZWQgcG9pbnQgaW4gdGhlIHNwZWNpZmllZCBkaXJlY3Rpb24uIEl0IHNpbXBseSBhZGRzIG9yIHN1YnRyYWN0cyAxIGZyb20gb25lIG9mIHRoZSBjb29yZGluYXRlcyBkZXBlbmRpbmcgb24gdGhlIGRpcmVjdGlvbiBhdHRyaWJ1dGUuXG4gKiBAcGFyYW0gIHtPYmplY3R9IHBvaW50ICAgICBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWBcbiAqIEBwYXJhbSAge251bWJlcn0gZGlyZWN0aW9uIGRpcmVjdGlvbnM6XG4gKiAgICAgLSAwOiB1cFxuICogICAgIC0gMTogcmlnaHRcbiAqICAgICAtIDI6IGRvd25cbiAqICAgICAtIDM6IGxlZnRcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgIG9iamVjdCBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YFxuICovXG5mdW5jdGlvbiBtb3ZlUG9pbnQoe3gsIHl9LCBkaXJlY3Rpb24pIHtcbiAgICAvLyBtYXAgZGlyZWN0aW9uIGRvIHBvaW50IGNvb3JkaW5hdGUgbW9kaWZpY2F0aW9uXG4gICAgY29uc3QgZGlyTWFwID0ge1xuICAgICAgICAwOiAoKSA9PiB7XG4gICAgICAgICAgICB5IC09IDFcbiAgICAgICAgfSxcbiAgICAgICAgMTogKCkgPT4ge1xuICAgICAgICAgICAgeCArPSAxXG4gICAgICAgIH0sXG4gICAgICAgIDI6ICgpID0+IHtcbiAgICAgICAgICAgIHkgKz0gMVxuICAgICAgICB9LFxuICAgICAgICAzOiAoKSA9PiB7XG4gICAgICAgICAgICB4IC09IDFcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpck1hcFtkaXJlY3Rpb25dKCk7XG5cbiAgICByZXR1cm4ge3gsIHl9XG59XG5cbi8qKlxuICogaGVscGVyIGJhY2t0cmFja2luZyBmdW5jdGlvbiB1c2VkIGJ5IHRoZSBhU3RhciBhbGdvcml0aG0gdG8gY29uc3RydWN0IHRoZSBmaW5hbCBwYXRoXG4gKiBAcGFyYW0gIHtPYmplY3R9IGNhbWVGcm9tICAgIG9iamVjdCBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YFxuICogQHBhcmFtICB7T2JqZWN0fSBjdXJyZW50Tm9kZSBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWBcbiAqIEByZXR1cm4ge0FycmF5fSBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgbnVtZXJpYyBhdHRyaWJ1dGVzIGB4YCBhbmQgYHlgXG4gKi9cbmZ1bmN0aW9uIHJlY29uc3RydWN0UGF0aChjYW1lRnJvbSwgY3VycmVudE5vZGUpIHtcbiAgICBsZXQgcGF0aCA9IFtdO1xuXG4gICAgcGF0aC5wdXNoKHtcbiAgICAgICAgeDogY3VycmVudE5vZGUueCxcbiAgICAgICAgeTogY3VycmVudE5vZGUueVxuICAgIH0pXG5cbiAgICB3aGlsZSAoY2FtZUZyb20uaGFzKGN1cnJlbnROb2RlKSkge1xuICAgICAgICBjdXJyZW50Tm9kZSA9IGNhbWVGcm9tLmdldChjdXJyZW50Tm9kZSk7XG4gICAgICAgIC8vIHB1c2ggdGhlIHBvaW50IG9uIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5IGluc3RlYWQgb2YgdGhlIGVuZFxuICAgICAgICBwYXRoLnNwbGljZSgwLCAwLCB7XG4gICAgICAgICAgICB4OiBjdXJyZW50Tm9kZS54LFxuICAgICAgICAgICAgeTogY3VycmVudE5vZGUueVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiBwYXRoO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIEhlbHBlckZ1bmN0aW9uc1xuICovXG5cbmltcG9ydCBzdHJpbmdpZnkgZnJvbSBcImpzb24tc3RyaW5naWZ5LXByZXR0eS1jb21wYWN0XCI7IC8vIG5vdGU6IGltcG9ydGVkIGZyb20gYSBtb2R1bGVcblxuLyoqXG4gKiBhZGQgYSBjcm9zcyBicm93c2VyIGV2ZW50IGxpc3RlbmVyIG9uIGEgbW91c2Ugc2Nyb2xsXG4gKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgRE9NIHF1ZXJ5IG9mIHRoZSBlbGVtZW50IHRoYXQgdGhlIGxpc3RlbmVyIHdpbGwgYmUgYWRkZWQgdG9cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgIEZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgb2NjdXJzLiBUaGUgZnVuY3Rpb24gdGFrZXMgYXMgYSBwYXJhbWV0ZXIgYW4gZXZlbnQgb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkTW91c2VTY3JvbGxFdmVudExpc3RlbmVyKHF1ZXJ5LCBmdW5jKSB7XG4gICAgbGV0IE1vdXNlV2hlZWxIYW5kbGVyID0gZXZlbnQgPT4ge1xuICAgICAgICAvLyByZWRlY2xhcmUgZm9yIG9sZCBJRSBzdXBwb3J0XG4gICAgICAgIHZhciBldmVudCA9IHdpbmRvdy5ldmVudCB8fCBldmVudDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZWRlY2xhcmVcblxuICAgICAgICBldmVudC5kZWx0YSA9IE1hdGgubWF4KC0xLCBNYXRoLm1pbigxLCAoZXZlbnQud2hlZWxEZWx0YSB8fCAtZXZlbnQuZGV0YWlsKSkpO1xuXG4gICAgICAgIGZ1bmMoZXZlbnQpXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBzdmdlbGVtZW50O1xuXG4gICAgLy8gaWYgdGhlIHF1ZXJ5IGlzIGEgc2ltcGxlIERPTSBpZCBzZWxlY3Rvciwgd2UgY2FuIHVzZSBnZXRFbGVtZW50QnlJZCB3aGljaCBoYXMgYmV0dGVyIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgaWYocXVlcnkubWF0Y2goL14jXFx3KyQvKSkge1xuICAgICAgICBzdmdlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocXVlcnkuc3Vic3RyKDEpKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHN2Z2VsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHF1ZXJ5KVxuICAgIH1cblxuICAgIGlmIChzdmdlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgLy8gSUU5LCBDaHJvbWUsIFNhZmFyaSwgT3BlcmFcbiAgICAgICAgc3ZnZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V3aGVlbFwiLCBNb3VzZVdoZWVsSGFuZGxlciwgZmFsc2UpO1xuICAgICAgICAvLyBGaXJlZm94XG4gICAgICAgIHN2Z2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTU1vdXNlU2Nyb2xsXCIsIE1vdXNlV2hlZWxIYW5kbGVyLCBmYWxzZSk7XG4gICAgfSBlbHNlICB7XG4gICAgICAgIC8vIElFIDYvNy84XG4gICAgICAgIHN2Z2VsZW1lbnQuYXR0YWNoRXZlbnQoXCJvbm1vdXNld2hlZWxcIiwgTW91c2VXaGVlbEhhbmRsZXIpO1xuICAgIH1cbiAgICBzdmdlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdldmVudCcsIGUpXG4gICAgfSwgZmFsc2UpXG59XG5cbi8qKlxuICogY29udmVydCBhIGRhdGEgb2JqZWN0IHRvIEpTT04gc3RyaW5nIG9yIHRvIGEgZGF0YSBVUkkgY29udGFpbmluZyBhIEpTT04gc3RyaW5nXG4gKiBAcGFyYW0gIHtPYmplY3R9ICBkYXRhICAgICAgICAgICAgb2JqZWN0IHRoYXQgd2lsbCBiZSBzZXJpYWxpemVkIGludG8gYSBKU09OIHN0cmluZ1xuICogQHBhcmFtICB7Qm9vbGVhbn0gW3ByZXR0eT1mYWxzZV0gIGlmIGB0cnVlYCwgdGhlIGNvZGUgd2lsbCBiZSBwcm9wcmVybHkgaW5kZW50ZWQsIGVsc2UgYSBtb3JlIGNvbXBhY3Qgc3ludGF4IHdpbGwgYmUgdXNlZFxuICogQHBhcmFtICB7Qm9vbGVhbn0gW2RhdGFVcmk9ZmFsc2VdIHJldHVybiBkYXRhVXJpIGNvbnRhaW5pbmcgdGhlIEpTT04gc3RyaW5nIGluc3RlYWQgb2YgdGhlIHB1cmUgSlNPTiBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEpTT05TdHJpbmcoZGF0YSwgcHJldHR5ID0gZmFsc2UsIGRhdGFVcmkgPSBmYWxzZSkge1xuICAgIGlmKGRhdGFVcmkpIHtcbiAgICAgICAgcmV0dXJuICdkYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCwnXG4gICAgICAgICAgICArIGVuY29kZVVSSUNvbXBvbmVudChnZXRKU09OU3RyaW5nKGRhdGEsIHByZXR0eSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcmV0dHkpXG4gICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5KGRhdGEsIHttYXhMZW5ndGg6IDUwfSk7XG5cbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIH1cbn1cblxuLyoqXG4gKiByZXR1cm5zIHRoZSBNYW5oYXR0YW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgcG9pbnRzIF9hXyBhbmQgX2JfXG4gKiBAcGFyYW0gIHtPYmplY3R9IGEgb2JqZWN0IGNvbnRhaW5pbmcgbnVtZXJpYyBhdHRyaWJ1dGVzIGB4YCBhbmQgYHlgXG4gKiBAcGFyYW0gIHtPYmplY3R9IGIgb2JqZWN0IGNvbnRhaW5pbmcgbnVtZXJpYyBhdHRyaWJ1dGVzIGB4YCBhbmQgYHlgXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYW5oYXR0YW5EaXN0YW5jZShhLCBiKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKGEueCAtIGIueCkgKyBNYXRoLmFicyhhLnkgLSBiLnkpO1xufVxuIiwiLyoqIEBtb2R1bGUgTWFwV2l0aERlZmF1bHRWYWx1ZSAqL1xuLyoqXG4gKiBNYXAgdGhhdCBoYXMgYSBkZWZhdWx0IHZhbHVlIHNwZWNpZmllZCBpbiB0aGUgY29uc3RydWN0b3IuXG4gKlxuICogRm9yIHRoZSBjb21wbGV0ZSBkb2N1bWVudGF0aW9uIG9mIHRoZSBNYXAgc2VlIFtNYXAgaW4gdGhlIE1ETiB3ZWIgZG9jc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWFwKVxuICpcbiAqIFVzYWdlOlxuICogYGBgSmF2YVNjcmlwdFxuIGxldCBteU1hcCA9IG5ldyBNYXBXaXRoRGVmYXVsdFZhbHVlKEluZmluaXR5KTtcbiBjb25zdCB2YWx1ZSA9IG15TWFwLmdldFdpdGhEZWZhdWx0KGtleSlcbiBgYGBcbiAqXG4gKiBfTm90ZTogVGhpcyB2ZXJzaW9uIGlzIHdyaXR0ZW4gc3BlY2lhbGx5IGZvciBFUzYgY29tcGlsZWQgaW50byBFUzUuIEluIG5vbi1jb21waWxlZCBFUzYgaXMgdGhlIGltcGxlbWVudGF0aW9uIGZhciBtb3JlIGVsZWdhbnQ6X1xuICpcbiAqIGBgYEphdmFTY3JpcHRcbiBleHBvcnQgY2xhc3MgTWFwV2l0aERlZmF1bHRWYWx1ZSBleHRlbmRzIE1hcCB7XG4gICAgIGNvbnN0cnVjdG9yKGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAgdGhpcy5kZWZhdWx0ID0gZGVmYXVsdFZhbHVlO1xuICAgICB9XG5cbiAgICAgZ2V0KGtleSkge1xuICAgICAgICAgaWYodGhpcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgIHJldHVybiBzdXBlci5nZXQoa2V5KTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdDtcbiAgICAgICAgIH1cbiAgICAgfVxuIH1gYGBcbiAqIEBjbGFzcyBNYXBXaXRoRGVmYXVsdFZhbHVlXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIHthbnl9IGRlZmF1bHQgdmFsdWUgdGhhdCB3aWxsIGJlIHJldHVybmVkIHdoZW4gdGhlIHJlcXVlc3RlZCBrZXkgaXMgbm90IGZvdW5kIGluIHRoZSBtYXBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZGVmYXVsdFZhbHVlKSB7XG4gICAgbGV0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHthbnl9IGtleSBrZXkgb2YgYSByZXF1ZXN0ZWQgaXRlbVxuICAgICAqIEByZXR1cm4ge2FueX0gdmFsdWUgb2YgdGhlIGl0ZW0gd2l0aCB0aGUgY29ycmVzcG9uZGluZyBrZXksIG9yIGRlZmF1bHRWYWx1ZSBpZiB0aGUga2V5IGlzIG5vdCBmb3VuZCBpbiB0aGUgbWFwXG4gICAgICovXG4gICAgbWFwLmdldFdpdGhEZWZhdWx0ID0gKGtleSkgPT4ge1xuICAgICAgICByZXR1cm4gbWFwLmhhcyhrZXkpXG4gICAgICAgICAgICA/IG1hcC5nZXQoa2V5KVxuICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqIEBtb2R1bGUgcm91dGVXb3JrZXIgKi9cblxuaW1wb3J0IGZpbmRQYXRoIGZyb20gJy4vbW9kdWxlcy9maW5kUGF0aCdcblxuLyoqXG4gKiBjYWxsYmFjayB3aGVuIGEgbWVzc2FnZSBpcyBzZW50IHRvIHRoZSB3ZWIgd29ya2VyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IHdlYiB3b3JrZXIgZXZlbnQgb2JqZWN0ICh0aGUgYGRhdGFgIGl0ZW0gb2YgdGhlIGV2ZW50IG9iamVjdCBpcyBleHBlY3RlZCB0byBjb250YWluXG4gKiAgICAgICAgICAgICAgICAgICAgICAgdGhlc2UgaXRlbXM6IGB3aXJlc2AgKGFycmF5KSwgYG5vblJvdXRhYmxlTm9kZXNgIChpdGVyYWJsZSkgYW5kIGBpbmNvbnZlbmllbnROb2Rlc2AgKGl0ZXJhYmxlKSlcbiAqL1xub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgY29uc3Qge3dpcmVzLCBub25Sb3V0YWJsZU5vZGVzLCBpbmNvbnZlbmllbnROb2Rlc30gPSBldmVudC5kYXRhO1xuXG4gICAgY29uc3QgcGF0aHMgPSBmaW5kUGF0aHMod2lyZXMsIG5vblJvdXRhYmxlTm9kZXMsIGluY29udmVuaWVudE5vZGVzKTtcblxuICAgIHBvc3RNZXNzYWdlKHtwYXRoc30pO1xuICAgIGNsb3NlKCk7XG59XG5cbi8qKlxuICogZmluZCBwYXRocyBmb3IgYWxsIHRoZSBzcGVjaWZpZWQgd2lyZXNcbiAqIEBwYXJhbSAge0FycmF5fSB3aXJlcyAgICAgICAgICAgICAgYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIGF0dHJpYnV0ZXMgYGZyb21gIGFuZCBgdG9gLCBib3RoIG9mIHRoZW0gd2hpY2ggYXJlIG9iamVjdHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCB2YWx1ZXMgYHhgIGFuZCBgeWAgY29udGFpbmluZyBjb29yZGluYXRlcyBvZiB0aGUgd2lyZSBlbmRwb2ludHNcbiAqIEBwYXJhbSAge0l0ZXJhYmxlfSBub25Sb3V0YWJsZU5vZGVzICBTZXQgb3IgYXJyYXkgb2Ygbm9uIHJvdXRhYmxlIG5vZGVzXG4gKiBAcGFyYW0gIHtJdGVyYWJsZX0gaW5jb252ZW5pZW50Tm9kZXMgU2V0IG9yIGFycmF5IG9mIGluY29udmVuaWVudCBub2Rlc1xuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgICAgICAgICBhcnJheSBvZiBwYXRocywgZWFjaCBpdGVtIGlzIGFuIGFycmF5IG9mIHBvaW50cyBvZiB0aGUgcGF0aFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgcmV0dXJuZWQgYXJyYXkgY29udGFpbnMgcGF0aHMgZm9yIHRoZSB3aXJlcyB3aXRoIGNvcnJlc3BvbmRpbmcgaW5kZXhlcyBmcm9tIHRoZSBgd2lyZXNgIHBhcmFtZXRlclxuICovXG5mdW5jdGlvbiBmaW5kUGF0aHMod2lyZXMsIG5vblJvdXRhYmxlTm9kZXMsIGluY29udmVuaWVudE5vZGVzKSB7XG4gICAgbGV0IHBhdGhzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IFtmcm9tLCB0b10gb2Ygd2lyZXMpIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IGZpbmRQYXRoKGZyb20sIHRvLCBub25Sb3V0YWJsZU5vZGVzLCBpbmNvbnZlbmllbnROb2RlcylcblxuICAgICAgICBpZighcGF0aCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJwYXRoIG5vdCBmb3VuZFwiKVxuICAgICAgICAgICAgY29uc29sZS5sb2coZnJvbSwgdG8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJwYXRoIGZvdW5kXCIpXG4gICAgICAgIH1cblxuICAgICAgICBwYXRocy5wdXNoKHBhdGgpO1xuXG4gICAgICAgIC8vIGFkZCBuZXcgaW5jb252ZW5pZW50IG5vZGVzIGNyZWF0ZWQgYnkgdGhpcyBuZXcgcGF0aFxuICAgICAgICBsZXQgcHJldlBvaW50O1xuICAgICAgICBmb3IoY29uc3QgcG9pbnQgb2YgcGF0aCkge1xuICAgICAgICAgICAgaWYocHJldlBvaW50KSB7XG4gICAgICAgICAgICAgICAgaWYocG9pbnQueCA9PT0gcHJldlBvaW50LngpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaG9yaXpvbnRhbCBzZWN0aW9uIG9mIHRoZSBwYXRoXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgeSA9IE1hdGgubWluKHBvaW50LnksIHByZXZQb2ludC55KTsgeSA8PSBNYXRoLm1heChwb2ludC55LCBwcmV2UG9pbnQueSkgOyArK3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY29udmVuaWVudE5vZGVzLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogcG9pbnQueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKHBvaW50LnkgPT09IHByZXZQb2ludC55KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZlcnRpY2FsIHNlY3Rpb24gb2YgdGhlIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCB4ID0gTWF0aC5taW4ocG9pbnQueCwgcHJldlBvaW50LngpOyB4IDw9IE1hdGgubWF4KHBvaW50LngsIHByZXZQb2ludC54KSA7ICsreCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5jb252ZW5pZW50Tm9kZXMuYWRkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHBvaW50LnlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXZQb2ludCA9IHBvaW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhzO1xufVxuIl19"}