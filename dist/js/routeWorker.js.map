{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/json-stringify-pretty-compact/index.js","node_modules/libstl/Datastructures/DoublyLinkedList.js","node_modules/libstl/Datastructures/Heap.js","node_modules/libstl/Datastructures/MaxHeap.js","node_modules/libstl/Datastructures/MinHeap.js","node_modules/libstl/Datastructures/PriorityQueue.js","node_modules/libstl/Datastructures/Queue.js","node_modules/libstl/Datastructures/Stack.js","node_modules/libstl/node-module.js","src/es6/modules/findPath.js","src/es6/modules/other/helperFunctions.js","src/es6/modules/other/mapWithDefaultValue.js","src/es6/routeWorker.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;kBCGwB,Q;;AAfxB;;AACA;;;;AAEA;;;;AAAwC;;AAExC;;AAEA;;;;;;;;AAQe,SAAS,QAAT,CAAkB,KAAlB,EAAyB,GAAzB,EAA8B,WAA9B,EAA2C,mBAA3C,EAAgE;AAC3E,QAAM,qDAAN;;AAEA,QAAM,sBAAsB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","file":"routeWorker.js","sourcesContent":["(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()","function stringify (obj, options) {\n  options = options || {}\n  var indent = JSON.stringify([1], null, get(options, 'indent', 2)).slice(2, -3)\n  var addMargin = get(options, 'margins', false)\n  var maxLength = (indent === '' ? Infinity : get(options, 'maxLength', 80))\n\n  return (function _stringify (obj, currentIndent, reserved) {\n    if (obj && typeof obj.toJSON === 'function') {\n      obj = obj.toJSON()\n    }\n\n    var string = JSON.stringify(obj)\n\n    if (string === undefined) {\n      return string\n    }\n\n    var length = maxLength - currentIndent.length - reserved\n\n    if (string.length <= length) {\n      var prettified = prettify(string, addMargin)\n      if (prettified.length <= length) {\n        return prettified\n      }\n    }\n\n    if (typeof obj === 'object' && obj !== null) {\n      var nextIndent = currentIndent + indent\n      var items = []\n      var delimiters\n      var comma = function (array, index) {\n        return (index === array.length - 1 ? 0 : 1)\n      }\n\n      if (Array.isArray(obj)) {\n        for (var index = 0; index < obj.length; index++) {\n          items.push(\n            _stringify(obj[index], nextIndent, comma(obj, index)) || 'null'\n          )\n        }\n        delimiters = '[]'\n      } else {\n        Object.keys(obj).forEach(function (key, index, array) {\n          var keyPart = JSON.stringify(key) + ': '\n          var value = _stringify(obj[key], nextIndent,\n                                 keyPart.length + comma(array, index))\n          if (value !== undefined) {\n            items.push(keyPart + value)\n          }\n        })\n        delimiters = '{}'\n      }\n\n      if (items.length > 0) {\n        return [\n          delimiters[0],\n          indent + items.join(',\\n' + nextIndent),\n          delimiters[1]\n        ].join('\\n' + currentIndent)\n      }\n    }\n\n    return string\n  }(obj, '', 0))\n}\n\n// Note: This regex matches even invalid JSON strings, but since we’re\n// working on the output of `JSON.stringify` we know that only valid strings\n// are present (unless the user supplied a weird `options.indent` but in\n// that case we don’t care since the output would be invalid anyway).\nvar stringOrChar = /(\"(?:[^\\\\\"]|\\\\.)*\")|[:,\\][}{]/g\n\nfunction prettify (string, addMargin) {\n  var m = addMargin ? ' ' : ''\n  var tokens = {\n    '{': '{' + m,\n    '[': '[' + m,\n    '}': m + '}',\n    ']': m + ']',\n    ',': ', ',\n    ':': ': '\n  }\n  return string.replace(stringOrChar, function (match, string) {\n    return string ? match : tokens[match]\n  })\n}\n\nfunction get (options, name, defaultValue) {\n  return (name in options ? options[name] : defaultValue)\n}\n\nmodule.exports = stringify\n","/**\n * The DoublyLinkedList class provides the main functionality of a doubly linked list.\n *\n * @class DoublyLinkedList\n */\nvar DoublyLinkedList = (function () {\n    function DoublyLinkedList() {\n        /**\n         * Count of elements in list\n         *\n         * @property _length\n         * @type number\n         * @private\n         */\n        this._length = 0;\n        /**\n         * Iteration pointer\n         *\n         * @property _key\n         * @type number\n         * @private\n         */\n        this._key = 0;\n        /**\n         * Reference to head(first) element in list\n         *\n         * @property _head\n         * @type DoublyLinkedListNode\n         * @private\n         */\n        this._head = null;\n        /**\n         * Reference to tail(last) element in list\n         *\n         * @property _tail\n         * @type DoublyLinkedListNode\n         * @private\n         */\n        this._tail = null;\n        /**\n         * Reference to iterated element in list\n         *\n         * @property _current\n         * @type DoublyLinkedListNode\n         * @private\n         */\n        this._current = null;\n    }\n    /**\n     * Insert a new value at the specified index\n     *\n     * @method add\n     * @param index The index where the new value is to be inserted.\n     * @param value The new value for the index.\n     * @return void\n     */\n    DoublyLinkedList.prototype.add = function (index, value) {\n        if (index < 0 || index >= this._length) {\n            throw new Error(\"Out of bounds\");\n        }\n        var i = 0;\n        var current = this._head;\n        while (i < index) {\n            current = current.next;\n            i++;\n        }\n        current.value = value;\n    };\n    /**\n     * Pops a node from the end of the doubly linked list\n     *\n     * @method pop\n     * @return any  The value of the popped node.\n     */\n    DoublyLinkedList.prototype.pop = function () {\n        if (this._length === 0) {\n            throw new Error(\"Can't pop from an empty data structure\");\n        }\n        var value = this._tail.value;\n        this._tail = this._tail.prev;\n        if (this._tail) {\n            delete this._tail.next;\n            this._tail.next = null;\n        }\n        this._length--;\n        if (this._length === 0) {\n            delete this._head;\n            this._head = null;\n        }\n        return value;\n    };\n    /**\n     * Shifts a node from the beginning of the doubly linked list\n     *\n     * @method shift\n     * @return any  The value of the shifted node.\n     */\n    DoublyLinkedList.prototype.shift = function () {\n        if (this._length === 0) {\n            throw new Error(\"Can't shift from an empty data structure\");\n        }\n        var value = this._head.value;\n        this._head = this._head.next;\n        if (this._head) {\n            delete this._head.prev;\n            this._head.prev = null;\n        }\n        this._length--;\n        return value;\n    };\n    /**\n     * Pushes an element at the end of the doubly linked list\n     *\n     * @method push\n     * @param value The value to push.\n     * @return void\n     */\n    DoublyLinkedList.prototype.push = function (value) {\n        // allocate new node\n        var node = {\n            value: value,\n            prev: this._tail,\n            next: null\n        };\n        if (this._length === 0) {\n            this._head = this._tail = node;\n        }\n        else {\n            this._tail.next = node;\n            this._tail = this._tail.next;\n        }\n        this._length++;\n    };\n    /**\n     * Prepends the doubly linked list with an element\n     *\n     * @method unshift\n     * @param value The value to unshift.\n     * @return void\n     */\n    DoublyLinkedList.prototype.unshift = function (value) {\n        // allocate new node\n        var node = {\n            value: value,\n            prev: null,\n            next: this._head\n        };\n        if (this._length === 0) {\n            this._head = this._tail = node;\n        }\n        else {\n            this._head.prev = node;\n            this._head = this._head.prev;\n        }\n        this._length++;\n    };\n    /**\n     * Peeks at the node from the end of the doubly linked list\n     *\n     * @method top\n     * @return any  The value of the last node.\n     */\n    DoublyLinkedList.prototype.top = function () {\n        if (this._tail)\n            return this._tail.value;\n    };\n    /**\n     * Peeks at the node from the beginning of the doubly linked list\n     *\n     * @method bottom\n     * @return any  The value of the first node.\n     */\n    DoublyLinkedList.prototype.bottom = function () {\n        if (this._head)\n            return this._head.value;\n    };\n    /**\n     * Counts the number of elements in the doubly linked list\n     *\n     * @method count\n     * @return number the number of elements in the doubly linked list.\n     */\n    DoublyLinkedList.prototype.count = function () {\n        return this._length;\n    };\n    /**\n     * Checks whether the doubly linked list is empty\n     *\n     * @method isEmpty\n     * @return boolean whether the doubly linked list is empty.\n     */\n    DoublyLinkedList.prototype.isEmpty = function () {\n        return (this._length === 0);\n    };\n    /**\n     * Rewind iterator back to the start\n     *\n     * @method rewind\n     * @return void\n     */\n    DoublyLinkedList.prototype.rewind = function () {\n        this._key = 0;\n        this._current = this._head;\n    };\n    /**\n     * Return current list entry\n     *\n     * @method current\n     * @return any  The current node value.\n     */\n    DoublyLinkedList.prototype.current = function () {\n        if (this._current) {\n            return this._current.value;\n        }\n        return null;\n    };\n    /**\n     * Return current node index\n     *\n     * @method key\n     * @return any  The current node index.\n     */\n    DoublyLinkedList.prototype.key = function () {\n        return this._key;\n    };\n    /**\n     * Move to next entry\n     *\n     * @method next\n     * @return void\n     */\n    DoublyLinkedList.prototype.next = function () {\n        this._current = this._current.next;\n        this._key++;\n    };\n    /**\n     * Move to previous entry\n     *\n     * @method prev\n     * @return void\n     */\n    DoublyLinkedList.prototype.prev = function () {\n        this._current = this._current.prev;\n        this._key--;\n    };\n    /**\n     * Check whether the doubly linked list contains more nodes\n     *\n     * @method valid\n     * @return boolean true if the doubly linked list contains any more nodes, false otherwise.\n     */\n    DoublyLinkedList.prototype.valid = function () {\n        return (this._key >= 0 && this._key < this._length);\n    };\n    /**\n     * Export the list to array\n     *\n     * @method toArray\n     * @return Array   The exported array\n     */\n    DoublyLinkedList.prototype.toArray = function () {\n        var list = [];\n        var current = this._head;\n        while (current) {\n            list.push(current.value);\n            current = current.next;\n        }\n        return list;\n    };\n    /**\n     * Serializes the list to string\n     *\n     * @method toString\n     * @return string   The serialized string.\n     */\n    DoublyLinkedList.prototype.toString = function () {\n        return \"{\" + this.toArray().join(\"->\") + \"}\";\n    };\n    return DoublyLinkedList;\n})();\nmodule.exports = DoublyLinkedList;\n//# sourceMappingURL=DoublyLinkedList.js.map","/**\n * The Heap class provides the main functionality of a Heap.\n *\n * @class Heap\n */\nvar Heap = (function () {\n    function Heap() {\n        /**\n         * Binary tree storage array\n         *\n         * @property _tree\n         * @type Array\n         * @private\n         */\n        this._tree = [];\n        /**\n         * Heap type\n         *\n         * @property _type\n         * @type number\n         * @private\n         */\n        this._type = Heap.MAX;\n        /**\n         * Iteration pointer\n         *\n         * @property _key\n         * @type number\n         * @private\n         */\n        this._key = 0;\n    }\n    /**\n     * Get index of left child element in binary tree stored in array\n     *\n     * @method _child\n     * @param n\n     * @return number\n     * @private\n     */\n    Heap.prototype._child = function (n) {\n        return 2 * n + 1;\n    };\n    /**\n     * Get index of parent element in binary tree stored in array\n     *\n     * @method _parent\n     * @param n\n     * @return number\n     * @private\n     */\n    Heap.prototype._parent = function (n) {\n        //console.log('n=', n, Math.floor(n / 2));\n        return Math.floor(n / 2);\n    };\n    /**\n     * Swap 2 elements in binary tree\n     *\n     * @method _swap\n     * @param first\n     * @param second\n     * @private\n     */\n    Heap.prototype._swap = function (first, second) {\n        var swap = this._tree[first];\n        this._tree[first] = this._tree[second];\n        this._tree[second] = swap;\n    };\n    /**\n     * Sift elements in binary tree\n     *\n     * @method _siftUp\n     * @param i\n     * @private\n     */\n    Heap.prototype._siftUp = function (i) {\n        while (i > 0) {\n            var parent = this._parent(i);\n            if (this.compare(this._tree[i], this._tree[parent]) * this._type > 0) {\n                this._swap(i, parent);\n                i = parent;\n            }\n            else {\n                break;\n            }\n        }\n    };\n    /**\n     * Sift down elements in binary tree\n     *\n     * @method _siftDown\n     * @param i\n     * @private\n     */\n    Heap.prototype._siftDown = function (i) {\n        while (i < this._tree.length) {\n            var left = this._child(i);\n            var right = left + 1;\n            if ((left < this._tree.length) && (right < this._tree.length) &&\n                (this.compare(this._tree[i], this._tree[left]) * this._type < 0 ||\n                    this.compare(this._tree[i], this._tree[right]) * this._type < 0)) {\n                // there is 2 children and one of them must be swapped\n                // get correct element to sift down\n                var sift = left;\n                if (this.compare(this._tree[left], this._tree[right]) * this._type < 0) {\n                    sift = right;\n                }\n                this._swap(i, sift);\n                i = sift;\n            }\n            else if (left < this._tree.length &&\n                this.compare(this._tree[i], this._tree[left]) * this._type < 0) {\n                // only one child exists\n                this._swap(i, left);\n                i = left;\n            }\n            else {\n                break;\n            }\n        }\n    };\n    /**\n     * Extracts a node from top of the heap and sift up\n     *\n     * @method extract\n     * @return any The value of the extracted node.\n     */\n    Heap.prototype.extract = function () {\n        if (this._tree.length === 0) {\n            throw new Error(\"Can't extract from an empty data structure\");\n        }\n        var extracted = this._tree[0];\n        if (this._tree.length === 1) {\n            this._tree = [];\n        }\n        else {\n            this._tree[0] = this._tree.pop();\n            this._siftDown(0);\n        }\n        return extracted;\n    };\n    /**\n     * Inserts an element in the heap by sifting it up\n     *\n     * @method insert\n     * @param value The value to insert.\n     * @return void\n     */\n    Heap.prototype.insert = function (value) {\n        this._tree.push(value);\n        this._siftUp(this._tree.length - 1);\n    };\n    /**\n     * Peeks at the node from the top of the heap\n     *\n     * @method top\n     * @return any The value of the node on the top.\n     */\n    Heap.prototype.top = function () {\n        if (this._tree.length === 0) {\n            throw new Error(\"Can't peek at an empty heap\");\n        }\n        return this._tree[0];\n    };\n    /**\n     * Counts the number of elements in the heap\n     *\n     * @method count\n     * @return number the number of elements in the heap.\n     */\n    Heap.prototype.count = function () {\n        return this._tree.length;\n    };\n    /**\n     * Checks whether the heap is empty\n     *\n     * @method isEmpty\n     * @return boolean whether the heap is empty.\n     */\n    Heap.prototype.isEmpty = function () {\n        return (this._tree.length === 0);\n    };\n    /**\n     * Rewind iterator back to the start (no-op)\n     *\n     * @method rewind\n     * @return void\n     */\n    Heap.prototype.rewind = function () {\n        this._key = 0;\n    };\n    /**\n     * Return current node pointed by the iterator\n     *\n     * @method current\n     * @return any The current node value.\n     */\n    Heap.prototype.current = function () {\n        return this._tree[this._key];\n    };\n    /**\n     * Return current node index\n     *\n     * @method key\n     * @return any The current node index.\n     */\n    Heap.prototype.key = function () {\n        return this._key;\n    };\n    /**\n     * Move to the next node\n     *\n     * @method next\n     * @return void\n     */\n    Heap.prototype.next = function () {\n        this._key++;\n    };\n    /**\n     * Move to previous entry\n     *\n     * @method prev\n     * @return void\n     */\n    Heap.prototype.prev = function () {\n        this._key--;\n    };\n    /**\n     * Check whether the heap contains more nodes\n     *\n     * @method valid\n     * @return boolean true if the heap contains any more nodes, false otherwise.\n     */\n    Heap.prototype.valid = function () {\n        return (this._key >= 0 && this._key < this._tree.length);\n    };\n    /**\n     * Compare elements in order to place them correctly in the heap while sifting up.\n     *\n     * @method compare\n     * @param first The value of the first node being compared.\n     * @param second The value of the second node being compared.\n     * @return number Result of the comparison, positive integer if first is greater than second, 0 if they are equal, negative integer otherwise.\n     * Having multiple elements with the same value in a Heap is not recommended. They will end up in an arbitrary relative position.\n     */\n    Heap.prototype.compare = function (first, second) {\n        if (first > second) {\n            return 1;\n        }\n        else if (first == second) {\n            return 0;\n        }\n        else {\n            return -1;\n        }\n    };\n    /**\n     * Visually display heap tree\n     *\n     * @method _displayNode\n     * @param node\n     * @param prefix\n     * @param last\n     * @return String\n     * @private\n     */\n    Heap.prototype._displayNode = function (node, prefix, last) {\n        if (prefix === void 0) { prefix = ''; }\n        if (last === void 0) { last = true; }\n        var line = prefix;\n        // get child indexes\n        var left = this._child(node);\n        var right = left + 1;\n        if (last) {\n            line += (prefix ? '└─' : '  ');\n        }\n        else {\n            line += '├─';\n        }\n        line += this._tree[node];\n        prefix += (last ? '  ' : '│ ');\n        if (left < this._tree.length) {\n            line += '\\n' + this._displayNode(left, prefix, (this._tree[right] == undefined ? true : false));\n        }\n        if (right < this._tree.length) {\n            line += '\\n' + this._displayNode(right, prefix, true);\n        }\n        return line;\n    };\n    /**\n     * Serializes the heap to string\n     *\n     * @method toString\n     * @return string   The serialized string.\n     */\n    Heap.prototype.toString = function () {\n        // start with root and recursively goes to each node\n        return this._displayNode(0);\n    };\n    /**\n     * Serializes the heap to array\n     *\n     * @method toArray\n     * @return Array   The serialized array.\n     */\n    Heap.prototype.toArray = function () {\n        return this._tree;\n    };\n    /**\n     * Max heap flag\n     *\n     * @property MAX\n     * @type number\n     * @static\n     */\n    Heap.MAX = 1;\n    /**\n     * Min heap flag\n     *\n     * @property MIN\n     * @type number\n     * @static\n     */\n    Heap.MIN = -1;\n    return Heap;\n})();\nmodule.exports = Heap;\n//# sourceMappingURL=Heap.js.map","var __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\nvar Heap = require('./Heap');\n/**\n * The MaxHeap class provides the main functionality of a heap, keeping the maximum on the top.\n *\n * @class MaxHeap\n * @extends Heap\n */\nvar MaxHeap = (function (_super) {\n    __extends(MaxHeap, _super);\n    function MaxHeap() {\n        _super.apply(this, arguments);\n        this._type = Heap.MAX;\n    }\n    return MaxHeap;\n})(Heap);\nmodule.exports = MaxHeap;\n//# sourceMappingURL=MaxHeap.js.map","var __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\nvar Heap = require('./Heap');\n/**\n * The MinHeap class provides the main functionality of a heap, keeping the minimum on the top.\n *\n * @class MinHeap\n * @extends Heap\n */\nvar MinHeap = (function (_super) {\n    __extends(MinHeap, _super);\n    function MinHeap() {\n        _super.apply(this, arguments);\n        this._type = Heap.MIN;\n    }\n    return MinHeap;\n})(Heap);\nmodule.exports = MinHeap;\n//# sourceMappingURL=MinHeap.js.map","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Heap = require('./Heap');\n/**\n * The PriorityQueue class provides the main functionality of an prioritized queue, implemented using a max heap.\n *\n * @class PriorityQueue\n * @extends Heap\n */\nvar PriorityQueue = (function (_super) {\n    __extends(PriorityQueue, _super);\n    function PriorityQueue() {\n        _super.apply(this, arguments);\n        this._type = Heap.MAX;\n    }\n    /**\n     * Adds an element to the queue\n     *\n     * @method enqueue\n     * @param value The value to enqueue.\n     * @param priority The priority of value.\n     * @return void\n     */\n    PriorityQueue.prototype.enqueue = function (value, priority) {\n        return this.insert(new PriorityQueueNode(value, priority));\n    };\n    /**\n     * Dequeues a node from the queue\n     *\n     * @method dequeue\n     * @return any  The value of the dequeued node.\n     */\n    PriorityQueue.prototype.dequeue = function () {\n        return this.extract().value;\n    };\n    /**\n     * Peeks at the node from the top of the heap\n     *\n     * @method top\n     * @return any The value of the node on the top.\n     */\n    PriorityQueue.prototype.top = function () {\n        return _super.prototype.top.call(this).value;\n    };\n    /**\n     * Compare elements in order to place them correctly in the heap while sifting up.\n     *\n     * @method compare\n     * @param first The value of the first node being compared.\n     * @param second The value of the second node being compared.\n     * @return number Result of the comparison, positive integer if first is greater than second, 0 if they are equal, negative integer otherwise.\n     * Having multiple elements with the same value in a Heap is not recommended. They will end up in an arbitrary relative position.\n     */\n    PriorityQueue.prototype.compare = function (first, second) {\n        if (first.priority > second.priority) {\n            return 1;\n        }\n        else if (first.priority == second.priority) {\n            return 0;\n        }\n        else {\n            return -1;\n        }\n    };\n    return PriorityQueue;\n})(Heap);\n/**\n * PriorityQueue Node\n *\n * @class PriorityQueueNode\n */\nvar PriorityQueueNode = (function () {\n    /**\n     * Constructor\n     *\n     * @method constructor\n     * @param value\n     * @param priority\n     */\n    function PriorityQueueNode(value, priority) {\n        this.value = value;\n        this.priority = priority;\n    }\n    /**\n     * Serializes the node to string\n     *\n     * @method toString\n     * @return string   The serialized string.\n     */\n    PriorityQueueNode.prototype.toString = function () {\n        return this.value + \" [\" + this.priority + \"]\";\n    };\n    return PriorityQueueNode;\n})();\nmodule.exports = PriorityQueue;\n//# sourceMappingURL=PriorityQueue.js.map","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DoublyLinkedList = require('./DoublyLinkedList');\n/**\n * The Queue class provides the main functionality of a queue implemented using a doubly linked list.\n *\n * @class Queue\n * @extends DoublyLinkedList\n */\nvar Queue = (function (_super) {\n    __extends(Queue, _super);\n    function Queue() {\n        _super.apply(this, arguments);\n    }\n    /**\n     * Adds an element to the queue\n     *\n     * @method enqueue\n     * @param value The value to enqueue.\n     * @return void\n     */\n    Queue.prototype.enqueue = function (value) {\n        return this.push(value);\n    };\n    /**\n     * Dequeues a node from the queue\n     *\n     * @method dequeue\n     * @return any  The value of the dequeued node.\n     */\n    Queue.prototype.dequeue = function () {\n        return this.shift();\n    };\n    return Queue;\n})(DoublyLinkedList);\nmodule.exports = Queue;\n//# sourceMappingURL=Queue.js.map","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DoublyLinkedList = require('./DoublyLinkedList');\n/**\n * The Stack class provides the main functionality of a stack implemented using a doubly linked list.\n *\n * @class Stack\n * @extends DoublyLinkedList\n */\nvar Stack = (function (_super) {\n    __extends(Stack, _super);\n    function Stack() {\n        _super.apply(this, arguments);\n    }\n    return Stack;\n})(DoublyLinkedList);\nmodule.exports = Stack;\n//# sourceMappingURL=Stack.js.map","/**\n * STL\n * @type {{DoublyLinkedList: exports, Stack: exports, Queue: exports, Heap: exports, MaxHeap: exports, MinHeap: exports, PriorityQueue: exports}}\n */\nmodule.exports = {\n\tDoublyLinkedList: require('./Datastructures/DoublyLinkedList'),\n\tStack: require('./Datastructures/Stack'),\n\tQueue: require('./Datastructures/Queue'),\n\tHeap: require('./Datastructures/Heap'),\n\tMaxHeap: require('./Datastructures/MaxHeap'),\n\tMinHeap: require('./Datastructures/MinHeap'),\n\tPriorityQueue: require('./Datastructures/PriorityQueue')\n};","import { manhattanDistance } from './other/helperFunctions'\nimport MapWithDefaultValue from './other/mapWithDefaultValue'\n\nimport { PriorityQueue } from 'libstl'; // note: imported from a node module\n\n/** @module findPath */\n\n/**\n * Heavily modified implementation of the A* algorithm\n * @param  {Object} start object containing numeric attributes `x` and `y` that represent the first endpoint of the wire in grid pixels\n * @param  {Object} end   object containing numeric attributes `x` and `y` that represent the second endpoint of the wire in grid pixels\n * @param  {Set} nonRoutable set of non routable nodes\n * @param  {Set} punishedButRoutable set of nodes that are not optimal for routing\n * @return {Array} array of objects containing numeric attributes `x` and `y`\n */\nexport default function findPath(start, end, nonRoutable, punishedButRoutable) {\n    const distanceFunction = manhattanDistance;\n\n    const wireCrossPunishment = 1;\n    const wireBendPunishment = 1;\n\n    // number of nodes, that can be opened at once\n    // once is this limit exceeded, aStar will fail and return undefined\n    const maxNodeLimit = 100000;\n\n    let closedNodes = new Set();\n    let openNodes = new Set();\n    let openNodeQueue = new PriorityQueue();\n\n    // functions for working with open nodes:\n\n    /**\n     * add a new open node to the structure\n     * @param {Object} node   object containing numeric attributes `x` and `y` that represent the first endpoint of the wire\n     * @param {number} fscore fScore of this node\n     */\n    const addOpenNode = (node, fscore) => {\n        openNodes.add(node);\n        // flip the fscore, because PriorityQueue uses max heap\n        openNodeQueue.enqueue(node, 1 / fscore);\n    }\n\n    /**\n     * get the open node with the lowest fScore and remove it\n     * @return {Object} object containing numeric attributes `x` and `y` that represent the first endpoint of the wire\n     */\n    const getOpenNode = () => {\n        const node = openNodeQueue.dequeue();\n        openNodes.delete(node);\n        return node;\n    }\n\n    let cameFrom = new Map();\n\n    // default value: infinity\n    let gScore = new MapWithDefaultValue(Infinity);\n    gScore.set(start, 0);\n\n    let startFScore = distanceFunction(start, end);\n\n    addOpenNode(start, startFScore);\n\n    openNodes.add(start);\n    openNodeQueue.enqueue(start, 1 / startFScore);\n\n    while (openNodes.size > 0) {\n        // get the value from openNodes that has the lowest fScore\n        const currentNode = getOpenNode();\n\n        // if we reached the end point, reconstruct the path and return it\n        if (currentNode.x == end.x && currentNode.y == end.y) {\n            return reconstructPath(cameFrom, currentNode);\n        }\n\n        // add this node to the closed nodes\n        closedNodes.add(currentNode);\n\n        // the farthest points accessible without avoiding obstacles in every direction\n        // (but max 50 in each direction)\n        for (let direction = 0; direction < 4; direction++) {\n            let newPoint = movePoint(currentNode, direction);\n\n            let wiresCrossed = 0;\n\n            for (let i = 0; i < 50; i++) {\n                // if newPoint is in the set of non routable points,\n                // don't add it and stop proceeding in this direction\n                if (setHasThisPoint(nonRoutable, newPoint)) {\n                    // if this not the end or start point, break\n                    if (!(newPoint.x === end.x && newPoint.y === end.y) &&\n                        !(newPoint.x === start.x && newPoint.y === start.y)) {\n                            break;\n                    }\n                }\n\n                // skip this node, if it has been already closed\n                // or if it is on the list of non routable nodes\n                if (closedNodes.has(newPoint)) {\n                    continue;\n                }\n\n                // calculate possible GScore by applying a punishment for each node (\"bend\") in the path\n                let newGScore = wireBendPunishment + gScore.getWithDefault(currentNode);\n\n                if (setHasThisPoint(punishedButRoutable, newPoint)) {\n                    // if the node is in the set of punished nodes, apply the punishment\n                    wiresCrossed++;\n                }\n\n                // apply the punishment for each wire crossed in this direction\n                // note: we are counting the wires crossed when exporting this direction, not the wires\n                // crossed in the final path, there will be probably only at most of these nodes in the\n                // final path, not multiple\n                newGScore += wiresCrossed * wireCrossPunishment;\n\n                // skip this node if it has worst estimage gscore than in the gscore table\n                if (newGScore >= gScore.getWithDefault(newPoint)) {\n                    continue;\n                }\n\n                cameFrom.set(newPoint, currentNode);\n                gScore.set(newPoint, newGScore);\n\n                const newFScore = newGScore + distanceFunction(newPoint, end);\n\n                if (!openNodes.has(newPoint)) {\n                    // add the point to the list of points\n                    addOpenNode(newPoint, newFScore);\n                }\n\n                // move to the next point in the direciton\n                newPoint = movePoint(newPoint, direction);\n            }\n        }\n\n        if (openNodes.size > maxNodeLimit) {\n            console.log(`aStar: Number of open nodes (${openNodes.size}) exceeded the limit for open nodes (${maxNodeLimit}).`)\n            break;\n        }\n    }\n    // if we got here, the path was not found\n\n    return undefined;\n}\n\n/**\n * returns `true` if the specified set of points contains the specified point (and returns `false` otherwise)\n * @param {Set} set set of points\n * @param {Object} point object containing numeric attributes `x` and `y`\n */\nfunction setHasThisPoint(set, point) {\n    for (let item of set) {\n        if (item.x === point.x && item.y === point.y) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Helper that moves the passed point in the specified direction. It simply adds or subtracts 1 from one of the coordinates depending on the direction attribute.\n * @param  {Object} point     object containing numeric attributes `x` and `y`\n * @param  {number} direction directions:\n *     - 0: up\n *     - 1: right\n *     - 2: down\n *     - 3: left\n * @return {Object}           object containing numeric attributes `x` and `y`\n */\nfunction movePoint({x, y}, direction) {\n    // map direction do point coordinate modification\n    const dirMap = {\n        0: () => {\n            y -= 1\n        },\n        1: () => {\n            x += 1\n        },\n        2: () => {\n            y += 1\n        },\n        3: () => {\n            x -= 1\n        }\n    }\n\n    dirMap[direction]();\n\n    return {x, y}\n}\n\n/**\n * helper backtracking function used by the aStar algorithm to construct the final path\n * @param  {Object} cameFrom    object containing numeric attributes `x` and `y`\n * @param  {Object} currentNode object containing numeric attributes `x` and `y`\n * @return {Array} array of objects containing numeric attributes `x` and `y`\n */\nfunction reconstructPath(cameFrom, currentNode) {\n    let path = [];\n\n    path.push({\n        x: currentNode.x,\n        y: currentNode.y\n    })\n\n    while (cameFrom.has(currentNode)) {\n        currentNode = cameFrom.get(currentNode);\n        path.push({\n            x: currentNode.x,\n            y: currentNode.y\n        })\n    }\n\n    return path;\n}\n","\"use strict\";\n\n/**\n * @module HelperFunctions\n */\n\nimport stringify from \"json-stringify-pretty-compact\"; // note: imported from a module\n\n/**\n * add a cross browser event listener on a mouse scroll\n * @param {string} query DOM query of the element that the listener will be added to\n * @param {Function} func  Function that will be called when the event occurs. The function takes as a parameter an event object.\n */\nexport function addMouseScrollEventListener(query, func) {\n    let MouseWheelHandler = event => {\n        // redeclare for old IE support\n        var event = window.event || event; // eslint-disable-line no-redeclare\n\n        event.delta = Math.max(-1, Math.min(1, (event.wheelDelta || -event.detail)));\n\n        func(event)\n\n        return false;\n    }\n\n    let svgelement;\n\n    // if the query is a simple DOM id selector, we can use getElementById which has better backwards compatibility\n    if(query.match(/^#\\w+$/)) {\n        svgelement = document.getElementById(query.substr(1))\n    } else {\n        svgelement = document.querySelector(query)\n    }\n\n    if (svgelement.addEventListener) {\n        // IE9, Chrome, Safari, Opera\n        svgelement.addEventListener(\"mousewheel\", MouseWheelHandler, false);\n        // Firefox\n        svgelement.addEventListener(\"DOMMouseScroll\", MouseWheelHandler, false);\n    } else  {\n        // IE 6/7/8\n        svgelement.attachEvent(\"onmousewheel\", MouseWheelHandler);\n    }\n    svgelement.addEventListener('mousewheel', function(e) {\n        console.log('event', e)\n    }, false)\n}\n\n/**\n * convert a data object to JSON string or to a data URI containing a JSON string\n * @param  {Object}  data            object that will be serialized into a JSON string\n * @param  {Boolean} [pretty=false]  if `true`, the code will be proprerly indented, else a more compact syntax will be used\n * @param  {Boolean} [dataUri=false] return dataUri containing the JSON string instead of the pure JSON string\n * @return {string}\n */\nexport function getJSONString(data, pretty = false, dataUri = false) {\n    if(dataUri) {\n        return 'data:application/json;charset=utf-8,'\n            + encodeURIComponent(getJSONString(data, pretty));\n    } else {\n        switch (pretty) {\n            case true:\n                return stringify(data, {maxLength: 50});\n            case false:\n                return JSON.stringify(data);\n        }\n    }\n}\n\n/**\n * returns the Manhattan distance between the points _a_ and _b_\n * @param  {Object} a object containing numeric attributes `x` and `y`\n * @param  {Object} b object containing numeric attributes `x` and `y`\n * @return {number}\n */\nexport function manhattanDistance(a, b) {\n    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\n}\n","/** @module MapWithDefaultValue */\n/**\n * Map that has a default value specified in the constructor.\n *\n * For the complete documentation of the Map see [Map in the MDN web docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\n *\n * Usage:\n * ```JavaScript\n let myMap = new MapWithDefaultValue(Infinity);\n const value = myMap.getWithDefault(key)\n ```\n *\n * _Note: This version is written specially for ES6 compiled into ES5. In non-compiled ES6 is the implementation far more elegant:_\n *\n * ```JavaScript\n export class MapWithDefaultValue extends Map {\n     constructor(defaultValue) {\n         super();\n\n         this.default = defaultValue;\n     }\n\n     get(key) {\n         if(this.has(key)) {\n             return super.get(key);\n         } else {\n             return this.default;\n         }\n     }\n }```\n * @class MapWithDefaultValue\n * @param defaultValue {any} default value that will be returned when the requested key is not found in the map\n */\nexport default function(defaultValue) {\n    let map = new Map();\n    /**\n     * @param  {any} key key of a requested item\n     * @return {any} value of the item with the corresponding key, or defaultValue if the key is not found in the map\n     */\n    map.getWithDefault = (key) => {\n        return map.has(key)\n            ? map.get(key)\n            : defaultValue;\n    }\n    return map;\n}\n","/** @module routeWorker */\n\nimport findPath from './modules/findPath'\n\n/**\n * callback when a message is sent to the web worker\n *\n * @param {Object} event web worker event object (the `data` item of the event object is expected to contain\n *                       these items: `wires` (array), `nonRoutableNodes` (iterable) and `inconvenientNodes` (iterable))\n */\nonmessage = (event) => {\n    const {wires, nonRoutableNodes, inconvenientNodes} = event.data;\n\n    const paths = findPaths(wires, nonRoutableNodes, inconvenientNodes);\n\n    postMessage({paths});\n    close();\n}\n\n/**\n * find paths for all the specified wires\n * @param  {Array} wires              array of objects with attributes `from` and `to`, both of them which are objects\n *                                    with values `x` and `y` containing coordinates of the wire endpoints\n * @param  {Iterable} nonRoutableNodes  Set or array of non routable nodes\n * @param  {Iterable} inconvenientNodes Set or array of inconvenient nodes\n * @return {Array}                    array of paths, each item is an array of points of the path\n *                                    the returned array contains paths for the wires with corresponding indexes from the `wires` parameter\n */\nfunction findPaths(wires, nonRoutableNodes, inconvenientNodes) {\n    let paths = [];\n\n    for (const [from, to] of wires) {\n        const path = findPath(from, to, nonRoutableNodes, inconvenientNodes)\n\n        if(!path) {\n            console.log(\"path not found\")\n            console.log(from, to);\n        } else {\n            console.log(\"path found\")\n        }\n\n        paths.push(path);\n\n        // add new inconvenient nodes created by this new path\n        let prevPoint;\n        for(const point of path) {\n            if(prevPoint) {\n                if(point.x === prevPoint.x) {\n                    // horizontal section of the path\n                    for(let y = Math.min(point.y, prevPoint.y); y <= Math.max(point.y, prevPoint.y) ; ++y) {\n                        inconvenientNodes.add({\n                            x: point.x,\n                            y: y\n                        })\n                    }\n                } else if(point.y === prevPoint.y) {\n                    // vertical section of the path\n                    for(let x = Math.min(point.x, prevPoint.x); x <= Math.max(point.x, prevPoint.x) ; ++x) {\n                        inconvenientNodes.add({\n                            x: x,\n                            y: point.y\n                        })\n                    }\n                }\n            }\n\n            prevPoint = point;\n        }\n    }\n\n    return paths;\n}\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvanNvbi1zdHJpbmdpZnktcHJldHR5LWNvbXBhY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL0RvdWJseUxpbmtlZExpc3QuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL0hlYXAuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL01heEhlYXAuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL01pbkhlYXAuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL1ByaW9yaXR5UXVldWUuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL1F1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL2xpYnN0bC9EYXRhc3RydWN0dXJlcy9TdGFjay5qcyIsIm5vZGVfbW9kdWxlcy9saWJzdGwvbm9kZS1tb2R1bGUuanMiLCJzcmMvZXM2L21vZHVsZXMvZmluZFBhdGguanMiLCJzcmMvZXM2L21vZHVsZXMvb3RoZXIvaGVscGVyRnVuY3Rpb25zLmpzIiwic3JjL2VzNi9tb2R1bGVzL290aGVyL21hcFdpdGhEZWZhdWx0VmFsdWUuanMiLCJzcmMvZXM2L3JvdXRlV29ya2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O2tCQ0d3QixROztBQWZ4Qjs7QUFDQTs7OztBQUVBOzs7O0FBQXdDOztBQUV4Qzs7QUFFQTs7Ozs7Ozs7QUFRZSxTQUFTLFFBQVQsQ0FBa0IsS0FBbEIsRUFBeUIsR0FB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LCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9cmV0dXJuIGV9KSgpIiwiZnVuY3Rpb24gc3RyaW5naWZ5IChvYmosIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdmFyIGluZGVudCA9IEpTT04uc3RyaW5naWZ5KFsxXSwgbnVsbCwgZ2V0KG9wdGlvbnMsICdpbmRlbnQnLCAyKSkuc2xpY2UoMiwgLTMpXG4gIHZhciBhZGRNYXJnaW4gPSBnZXQob3B0aW9ucywgJ21hcmdpbnMnLCBmYWxzZSlcbiAgdmFyIG1heExlbmd0aCA9IChpbmRlbnQgPT09ICcnID8gSW5maW5pdHkgOiBnZXQob3B0aW9ucywgJ21heExlbmd0aCcsIDgwKSlcblxuICByZXR1cm4gKGZ1bmN0aW9uIF9zdHJpbmdpZnkgKG9iaiwgY3VycmVudEluZGVudCwgcmVzZXJ2ZWQpIHtcbiAgICBpZiAob2JqICYmIHR5cGVvZiBvYmoudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvYmogPSBvYmoudG9KU09OKClcbiAgICB9XG5cbiAgICB2YXIgc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkob2JqKVxuXG4gICAgaWYgKHN0cmluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gc3RyaW5nXG4gICAgfVxuXG4gICAgdmFyIGxlbmd0aCA9IG1heExlbmd0aCAtIGN1cnJlbnRJbmRlbnQubGVuZ3RoIC0gcmVzZXJ2ZWRcblxuICAgIGlmIChzdHJpbmcubGVuZ3RoIDw9IGxlbmd0aCkge1xuICAgICAgdmFyIHByZXR0aWZpZWQgPSBwcmV0dGlmeShzdHJpbmcsIGFkZE1hcmdpbilcbiAgICAgIGlmIChwcmV0dGlmaWVkLmxlbmd0aCA8PSBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHByZXR0aWZpZWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmV4dEluZGVudCA9IGN1cnJlbnRJbmRlbnQgKyBpbmRlbnRcbiAgICAgIHZhciBpdGVtcyA9IFtdXG4gICAgICB2YXIgZGVsaW1pdGVyc1xuICAgICAgdmFyIGNvbW1hID0gZnVuY3Rpb24gKGFycmF5LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gKGluZGV4ID09PSBhcnJheS5sZW5ndGggLSAxID8gMCA6IDEpXG4gICAgICB9XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IG9iai5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKFxuICAgICAgICAgICAgX3N0cmluZ2lmeShvYmpbaW5kZXhdLCBuZXh0SW5kZW50LCBjb21tYShvYmosIGluZGV4KSkgfHwgJ251bGwnXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGRlbGltaXRlcnMgPSAnW10nXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSwgaW5kZXgsIGFycmF5KSB7XG4gICAgICAgICAgdmFyIGtleVBhcnQgPSBKU09OLnN0cmluZ2lmeShrZXkpICsgJzogJ1xuICAgICAgICAgIHZhciB2YWx1ZSA9IF9zdHJpbmdpZnkob2JqW2tleV0sIG5leHRJbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlQYXJ0Lmxlbmd0aCArIGNvbW1hKGFycmF5LCBpbmRleCkpXG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goa2V5UGFydCArIHZhbHVlKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgZGVsaW1pdGVycyA9ICd7fSdcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBkZWxpbWl0ZXJzWzBdLFxuICAgICAgICAgIGluZGVudCArIGl0ZW1zLmpvaW4oJyxcXG4nICsgbmV4dEluZGVudCksXG4gICAgICAgICAgZGVsaW1pdGVyc1sxXVxuICAgICAgICBdLmpvaW4oJ1xcbicgKyBjdXJyZW50SW5kZW50KVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmdcbiAgfShvYmosICcnLCAwKSlcbn1cblxuLy8gTm90ZTogVGhpcyByZWdleCBtYXRjaGVzIGV2ZW4gaW52YWxpZCBKU09OIHN0cmluZ3MsIGJ1dCBzaW5jZSB3ZeKAmXJlXG4vLyB3b3JraW5nIG9uIHRoZSBvdXRwdXQgb2YgYEpTT04uc3RyaW5naWZ5YCB3ZSBrbm93IHRoYXQgb25seSB2YWxpZCBzdHJpbmdzXG4vLyBhcmUgcHJlc2VudCAodW5sZXNzIHRoZSB1c2VyIHN1cHBsaWVkIGEgd2VpcmQgYG9wdGlvbnMuaW5kZW50YCBidXQgaW5cbi8vIHRoYXQgY2FzZSB3ZSBkb27igJl0IGNhcmUgc2luY2UgdGhlIG91dHB1dCB3b3VsZCBiZSBpbnZhbGlkIGFueXdheSkuXG52YXIgc3RyaW5nT3JDaGFyID0gLyhcIig/OlteXFxcXFwiXXxcXFxcLikqXCIpfFs6LFxcXVt9e10vZ1xuXG5mdW5jdGlvbiBwcmV0dGlmeSAoc3RyaW5nLCBhZGRNYXJnaW4pIHtcbiAgdmFyIG0gPSBhZGRNYXJnaW4gPyAnICcgOiAnJ1xuICB2YXIgdG9rZW5zID0ge1xuICAgICd7JzogJ3snICsgbSxcbiAgICAnWyc6ICdbJyArIG0sXG4gICAgJ30nOiBtICsgJ30nLFxuICAgICddJzogbSArICddJyxcbiAgICAnLCc6ICcsICcsXG4gICAgJzonOiAnOiAnXG4gIH1cbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHN0cmluZ09yQ2hhciwgZnVuY3Rpb24gKG1hdGNoLCBzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nID8gbWF0Y2ggOiB0b2tlbnNbbWF0Y2hdXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGdldCAob3B0aW9ucywgbmFtZSwgZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiAobmFtZSBpbiBvcHRpb25zID8gb3B0aW9uc1tuYW1lXSA6IGRlZmF1bHRWYWx1ZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdpZnlcbiIsIi8qKlxuICogVGhlIERvdWJseUxpbmtlZExpc3QgY2xhc3MgcHJvdmlkZXMgdGhlIG1haW4gZnVuY3Rpb25hbGl0eSBvZiBhIGRvdWJseSBsaW5rZWQgbGlzdC5cbiAqXG4gKiBAY2xhc3MgRG91Ymx5TGlua2VkTGlzdFxuICovXG52YXIgRG91Ymx5TGlua2VkTGlzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRG91Ymx5TGlua2VkTGlzdCgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvdW50IG9mIGVsZW1lbnRzIGluIGxpc3RcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IF9sZW5ndGhcbiAgICAgICAgICogQHR5cGUgbnVtYmVyXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogSXRlcmF0aW9uIHBvaW50ZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IF9rZXlcbiAgICAgICAgICogQHR5cGUgbnVtYmVyXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9rZXkgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIGhlYWQoZmlyc3QpIGVsZW1lbnQgaW4gbGlzdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgX2hlYWRcbiAgICAgICAgICogQHR5cGUgRG91Ymx5TGlua2VkTGlzdE5vZGVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hlYWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIHRhaWwobGFzdCkgZWxlbWVudCBpbiBsaXN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfdGFpbFxuICAgICAgICAgKiBAdHlwZSBEb3VibHlMaW5rZWRMaXN0Tm9kZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdGFpbCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gaXRlcmF0ZWQgZWxlbWVudCBpbiBsaXN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfY3VycmVudFxuICAgICAgICAgKiBAdHlwZSBEb3VibHlMaW5rZWRMaXN0Tm9kZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydCBhIG5ldyB2YWx1ZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGFkZFxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggd2hlcmUgdGhlIG5ldyB2YWx1ZSBpcyB0byBiZSBpbnNlcnRlZC5cbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIGluZGV4LlxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk91dCBvZiBib3VuZHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIHdoaWxlIChpIDwgaW5kZXgpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudC52YWx1ZSA9IHZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUG9wcyBhIG5vZGUgZnJvbSB0aGUgZW5kIG9mIHRoZSBkb3VibHkgbGlua2VkIGxpc3RcbiAgICAgKlxuICAgICAqIEBtZXRob2QgcG9wXG4gICAgICogQHJldHVybiBhbnkgIFRoZSB2YWx1ZSBvZiB0aGUgcG9wcGVkIG5vZGUuXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwb3AgZnJvbSBhbiBlbXB0eSBkYXRhIHN0cnVjdHVyZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl90YWlsLnZhbHVlO1xuICAgICAgICB0aGlzLl90YWlsID0gdGhpcy5fdGFpbC5wcmV2O1xuICAgICAgICBpZiAodGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3RhaWwubmV4dDtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwubmV4dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGVuZ3RoLS07XG4gICAgICAgIGlmICh0aGlzLl9sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9oZWFkO1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2hpZnRzIGEgbm9kZSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRvdWJseSBsaW5rZWQgbGlzdFxuICAgICAqXG4gICAgICogQG1ldGhvZCBzaGlmdFxuICAgICAqIEByZXR1cm4gYW55ICBUaGUgdmFsdWUgb2YgdGhlIHNoaWZ0ZWQgbm9kZS5cbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgc2hpZnQgZnJvbSBhbiBlbXB0eSBkYXRhIHN0cnVjdHVyZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9oZWFkLnZhbHVlO1xuICAgICAgICB0aGlzLl9oZWFkID0gdGhpcy5faGVhZC5uZXh0O1xuICAgICAgICBpZiAodGhpcy5faGVhZCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2hlYWQucHJldjtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQucHJldiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGVuZ3RoLS07XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhbiBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIGRvdWJseSBsaW5rZWQgbGlzdFxuICAgICAqXG4gICAgICogQG1ldGhvZCBwdXNoXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBwdXNoLlxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gYWxsb2NhdGUgbmV3IG5vZGVcbiAgICAgICAgdmFyIG5vZGUgPSB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBwcmV2OiB0aGlzLl90YWlsLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5fbGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gdGhpcy5fdGFpbCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90YWlsLm5leHQgPSBub2RlO1xuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IHRoaXMuX3RhaWwubmV4dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sZW5ndGgrKztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByZXBlbmRzIHRoZSBkb3VibHkgbGlua2VkIGxpc3Qgd2l0aCBhbiBlbGVtZW50XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHVuc2hpZnRcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHVuc2hpZnQuXG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBhbGxvY2F0ZSBuZXcgbm9kZVxuICAgICAgICB2YXIgbm9kZSA9IHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHByZXY6IG51bGwsXG4gICAgICAgICAgICBuZXh0OiB0aGlzLl9oZWFkXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLl9sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSB0aGlzLl90YWlsID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQucHJldiA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gdGhpcy5faGVhZC5wcmV2O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xlbmd0aCsrO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGVla3MgYXQgdGhlIG5vZGUgZnJvbSB0aGUgZW5kIG9mIHRoZSBkb3VibHkgbGlua2VkIGxpc3RcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9wXG4gICAgICogQHJldHVybiBhbnkgIFRoZSB2YWx1ZSBvZiB0aGUgbGFzdCBub2RlLlxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLnRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RhaWwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGFpbC52YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBlZWtzIGF0IHRoZSBub2RlIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgZG91Ymx5IGxpbmtlZCBsaXN0XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGJvdHRvbVxuICAgICAqIEByZXR1cm4gYW55ICBUaGUgdmFsdWUgb2YgdGhlIGZpcnN0IG5vZGUuXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUuYm90dG9tID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5faGVhZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWFkLnZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ291bnRzIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGRvdWJseSBsaW5rZWQgbGlzdFxuICAgICAqXG4gICAgICogQG1ldGhvZCBjb3VudFxuICAgICAqIEByZXR1cm4gbnVtYmVyIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGRvdWJseSBsaW5rZWQgbGlzdC5cbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBkb3VibHkgbGlua2VkIGxpc3QgaXMgZW1wdHlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgaXNFbXB0eVxuICAgICAqIEByZXR1cm4gYm9vbGVhbiB3aGV0aGVyIHRoZSBkb3VibHkgbGlua2VkIGxpc3QgaXMgZW1wdHkuXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9sZW5ndGggPT09IDApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV3aW5kIGl0ZXJhdG9yIGJhY2sgdG8gdGhlIHN0YXJ0XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHJld2luZFxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLnJld2luZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fa2V5ID0gMDtcbiAgICAgICAgdGhpcy5fY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gY3VycmVudCBsaXN0IGVudHJ5XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGN1cnJlbnRcbiAgICAgKiBAcmV0dXJuIGFueSAgVGhlIGN1cnJlbnQgbm9kZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnQudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gY3VycmVudCBub2RlIGluZGV4XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGtleVxuICAgICAqIEByZXR1cm4gYW55ICBUaGUgY3VycmVudCBub2RlIGluZGV4LlxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLmtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1vdmUgdG8gbmV4dCBlbnRyeVxuICAgICAqXG4gICAgICogQG1ldGhvZCBuZXh0XG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudCA9IHRoaXMuX2N1cnJlbnQubmV4dDtcbiAgICAgICAgdGhpcy5fa2V5Kys7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNb3ZlIHRvIHByZXZpb3VzIGVudHJ5XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHByZXZcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fY3VycmVudC5wcmV2O1xuICAgICAgICB0aGlzLl9rZXktLTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGRvdWJseSBsaW5rZWQgbGlzdCBjb250YWlucyBtb3JlIG5vZGVzXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHZhbGlkXG4gICAgICogQHJldHVybiBib29sZWFuIHRydWUgaWYgdGhlIGRvdWJseSBsaW5rZWQgbGlzdCBjb250YWlucyBhbnkgbW9yZSBub2RlcywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLnZhbGlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2tleSA+PSAwICYmIHRoaXMuX2tleSA8IHRoaXMuX2xlbmd0aCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeHBvcnQgdGhlIGxpc3QgdG8gYXJyYXlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9BcnJheVxuICAgICAqIEByZXR1cm4gQXJyYXkgICBUaGUgZXhwb3J0ZWQgYXJyYXlcbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGlzdCA9IFtdO1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICBsaXN0LnB1c2goY3VycmVudC52YWx1ZSk7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgbGlzdCB0byBzdHJpbmdcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9TdHJpbmdcbiAgICAgKiBAcmV0dXJuIHN0cmluZyAgIFRoZSBzZXJpYWxpemVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwie1wiICsgdGhpcy50b0FycmF5KCkuam9pbihcIi0+XCIpICsgXCJ9XCI7XG4gICAgfTtcbiAgICByZXR1cm4gRG91Ymx5TGlua2VkTGlzdDtcbn0pKCk7XG5tb2R1bGUuZXhwb3J0cyA9IERvdWJseUxpbmtlZExpc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Eb3VibHlMaW5rZWRMaXN0LmpzLm1hcCIsIi8qKlxuICogVGhlIEhlYXAgY2xhc3MgcHJvdmlkZXMgdGhlIG1haW4gZnVuY3Rpb25hbGl0eSBvZiBhIEhlYXAuXG4gKlxuICogQGNsYXNzIEhlYXBcbiAqL1xudmFyIEhlYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhlYXAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCaW5hcnkgdHJlZSBzdG9yYWdlIGFycmF5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfdHJlZVxuICAgICAgICAgKiBAdHlwZSBBcnJheVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdHJlZSA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogSGVhcCB0eXBlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfdHlwZVxuICAgICAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3R5cGUgPSBIZWFwLk1BWDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0ZXJhdGlvbiBwb2ludGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfa2V5XG4gICAgICAgICAqIEB0eXBlIG51bWJlclxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fa2V5ID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGluZGV4IG9mIGxlZnQgY2hpbGQgZWxlbWVudCBpbiBiaW5hcnkgdHJlZSBzdG9yZWQgaW4gYXJyYXlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2NoaWxkXG4gICAgICogQHBhcmFtIG5cbiAgICAgKiBAcmV0dXJuIG51bWJlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUuX2NoaWxkID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIDIgKiBuICsgMTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBpbmRleCBvZiBwYXJlbnQgZWxlbWVudCBpbiBiaW5hcnkgdHJlZSBzdG9yZWQgaW4gYXJyYXlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3BhcmVudFxuICAgICAqIEBwYXJhbSBuXG4gICAgICogQHJldHVybiBudW1iZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLl9wYXJlbnQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICAvL2NvbnNvbGUubG9nKCduPScsIG4sIE1hdGguZmxvb3IobiAvIDIpKTtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobiAvIDIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3dhcCAyIGVsZW1lbnRzIGluIGJpbmFyeSB0cmVlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9zd2FwXG4gICAgICogQHBhcmFtIGZpcnN0XG4gICAgICogQHBhcmFtIHNlY29uZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUuX3N3YXAgPSBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICB2YXIgc3dhcCA9IHRoaXMuX3RyZWVbZmlyc3RdO1xuICAgICAgICB0aGlzLl90cmVlW2ZpcnN0XSA9IHRoaXMuX3RyZWVbc2Vjb25kXTtcbiAgICAgICAgdGhpcy5fdHJlZVtzZWNvbmRdID0gc3dhcDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNpZnQgZWxlbWVudHMgaW4gYmluYXJ5IHRyZWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3NpZnRVcFxuICAgICAqIEBwYXJhbSBpXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5fc2lmdFVwID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgd2hpbGUgKGkgPiAwKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50KGkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFyZSh0aGlzLl90cmVlW2ldLCB0aGlzLl90cmVlW3BhcmVudF0pICogdGhpcy5fdHlwZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zd2FwKGksIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgaSA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTaWZ0IGRvd24gZWxlbWVudHMgaW4gYmluYXJ5IHRyZWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3NpZnREb3duXG4gICAgICogQHBhcmFtIGlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLl9zaWZ0RG93biA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5fdHJlZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy5fY2hpbGQoaSk7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIGlmICgobGVmdCA8IHRoaXMuX3RyZWUubGVuZ3RoKSAmJiAocmlnaHQgPCB0aGlzLl90cmVlLmxlbmd0aCkgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5jb21wYXJlKHRoaXMuX3RyZWVbaV0sIHRoaXMuX3RyZWVbbGVmdF0pICogdGhpcy5fdHlwZSA8IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wYXJlKHRoaXMuX3RyZWVbaV0sIHRoaXMuX3RyZWVbcmlnaHRdKSAqIHRoaXMuX3R5cGUgPCAwKSkge1xuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIDIgY2hpbGRyZW4gYW5kIG9uZSBvZiB0aGVtIG11c3QgYmUgc3dhcHBlZFxuICAgICAgICAgICAgICAgIC8vIGdldCBjb3JyZWN0IGVsZW1lbnQgdG8gc2lmdCBkb3duXG4gICAgICAgICAgICAgICAgdmFyIHNpZnQgPSBsZWZ0O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhcmUodGhpcy5fdHJlZVtsZWZ0XSwgdGhpcy5fdHJlZVtyaWdodF0pICogdGhpcy5fdHlwZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2lmdCA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9zd2FwKGksIHNpZnQpO1xuICAgICAgICAgICAgICAgIGkgPSBzaWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGVmdCA8IHRoaXMuX3RyZWUubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wYXJlKHRoaXMuX3RyZWVbaV0sIHRoaXMuX3RyZWVbbGVmdF0pICogdGhpcy5fdHlwZSA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IG9uZSBjaGlsZCBleGlzdHNcbiAgICAgICAgICAgICAgICB0aGlzLl9zd2FwKGksIGxlZnQpO1xuICAgICAgICAgICAgICAgIGkgPSBsZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIGEgbm9kZSBmcm9tIHRvcCBvZiB0aGUgaGVhcCBhbmQgc2lmdCB1cFxuICAgICAqXG4gICAgICogQG1ldGhvZCBleHRyYWN0XG4gICAgICogQHJldHVybiBhbnkgVGhlIHZhbHVlIG9mIHRoZSBleHRyYWN0ZWQgbm9kZS5cbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fdHJlZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGV4dHJhY3QgZnJvbSBhbiBlbXB0eSBkYXRhIHN0cnVjdHVyZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXh0cmFjdGVkID0gdGhpcy5fdHJlZVswXTtcbiAgICAgICAgaWYgKHRoaXMuX3RyZWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLl90cmVlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90cmVlWzBdID0gdGhpcy5fdHJlZS5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuX3NpZnREb3duKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRyYWN0ZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIGVsZW1lbnQgaW4gdGhlIGhlYXAgYnkgc2lmdGluZyBpdCB1cFxuICAgICAqXG4gICAgICogQG1ldGhvZCBpbnNlcnRcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdHJlZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgdGhpcy5fc2lmdFVwKHRoaXMuX3RyZWUubGVuZ3RoIC0gMSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQZWVrcyBhdCB0aGUgbm9kZSBmcm9tIHRoZSB0b3Agb2YgdGhlIGhlYXBcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9wXG4gICAgICogQHJldHVybiBhbnkgVGhlIHZhbHVlIG9mIHRoZSBub2RlIG9uIHRoZSB0b3AuXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUudG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fdHJlZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHBlZWsgYXQgYW4gZW1wdHkgaGVhcFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdHJlZVswXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvdW50cyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBoZWFwXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGNvdW50XG4gICAgICogQHJldHVybiBudW1iZXIgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaGVhcC5cbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWUubGVuZ3RoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGhlYXAgaXMgZW1wdHlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgaXNFbXB0eVxuICAgICAqIEByZXR1cm4gYm9vbGVhbiB3aGV0aGVyIHRoZSBoZWFwIGlzIGVtcHR5LlxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fdHJlZS5sZW5ndGggPT09IDApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV3aW5kIGl0ZXJhdG9yIGJhY2sgdG8gdGhlIHN0YXJ0IChuby1vcClcbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmV3aW5kXG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUucmV3aW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9rZXkgPSAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGN1cnJlbnQgbm9kZSBwb2ludGVkIGJ5IHRoZSBpdGVyYXRvclxuICAgICAqXG4gICAgICogQG1ldGhvZCBjdXJyZW50XG4gICAgICogQHJldHVybiBhbnkgVGhlIGN1cnJlbnQgbm9kZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJlZVt0aGlzLl9rZXldO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGN1cnJlbnQgbm9kZSBpbmRleFxuICAgICAqXG4gICAgICogQG1ldGhvZCBrZXlcbiAgICAgKiBAcmV0dXJuIGFueSBUaGUgY3VycmVudCBub2RlIGluZGV4LlxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLmtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1vdmUgdG8gdGhlIG5leHQgbm9kZVxuICAgICAqXG4gICAgICogQG1ldGhvZCBuZXh0XG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fa2V5Kys7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNb3ZlIHRvIHByZXZpb3VzIGVudHJ5XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHByZXZcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9rZXktLTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGhlYXAgY29udGFpbnMgbW9yZSBub2Rlc1xuICAgICAqXG4gICAgICogQG1ldGhvZCB2YWxpZFxuICAgICAqIEByZXR1cm4gYm9vbGVhbiB0cnVlIGlmIHRoZSBoZWFwIGNvbnRhaW5zIGFueSBtb3JlIG5vZGVzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUudmFsaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fa2V5ID49IDAgJiYgdGhpcy5fa2V5IDwgdGhpcy5fdHJlZS5sZW5ndGgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcGFyZSBlbGVtZW50cyBpbiBvcmRlciB0byBwbGFjZSB0aGVtIGNvcnJlY3RseSBpbiB0aGUgaGVhcCB3aGlsZSBzaWZ0aW5nIHVwLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBjb21wYXJlXG4gICAgICogQHBhcmFtIGZpcnN0IFRoZSB2YWx1ZSBvZiB0aGUgZmlyc3Qgbm9kZSBiZWluZyBjb21wYXJlZC5cbiAgICAgKiBAcGFyYW0gc2Vjb25kIFRoZSB2YWx1ZSBvZiB0aGUgc2Vjb25kIG5vZGUgYmVpbmcgY29tcGFyZWQuXG4gICAgICogQHJldHVybiBudW1iZXIgUmVzdWx0IG9mIHRoZSBjb21wYXJpc29uLCBwb3NpdGl2ZSBpbnRlZ2VyIGlmIGZpcnN0IGlzIGdyZWF0ZXIgdGhhbiBzZWNvbmQsIDAgaWYgdGhleSBhcmUgZXF1YWwsIG5lZ2F0aXZlIGludGVnZXIgb3RoZXJ3aXNlLlxuICAgICAqIEhhdmluZyBtdWx0aXBsZSBlbGVtZW50cyB3aXRoIHRoZSBzYW1lIHZhbHVlIGluIGEgSGVhcCBpcyBub3QgcmVjb21tZW5kZWQuIFRoZXkgd2lsbCBlbmQgdXAgaW4gYW4gYXJiaXRyYXJ5IHJlbGF0aXZlIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICBpZiAoZmlyc3QgPiBzZWNvbmQpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpcnN0ID09IHNlY29uZCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFZpc3VhbGx5IGRpc3BsYXkgaGVhcCB0cmVlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9kaXNwbGF5Tm9kZVxuICAgICAqIEBwYXJhbSBub2RlXG4gICAgICogQHBhcmFtIHByZWZpeFxuICAgICAqIEBwYXJhbSBsYXN0XG4gICAgICogQHJldHVybiBTdHJpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLl9kaXNwbGF5Tm9kZSA9IGZ1bmN0aW9uIChub2RlLCBwcmVmaXgsIGxhc3QpIHtcbiAgICAgICAgaWYgKHByZWZpeCA9PT0gdm9pZCAwKSB7IHByZWZpeCA9ICcnOyB9XG4gICAgICAgIGlmIChsYXN0ID09PSB2b2lkIDApIHsgbGFzdCA9IHRydWU7IH1cbiAgICAgICAgdmFyIGxpbmUgPSBwcmVmaXg7XG4gICAgICAgIC8vIGdldCBjaGlsZCBpbmRleGVzXG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5fY2hpbGQobm9kZSk7XG4gICAgICAgIHZhciByaWdodCA9IGxlZnQgKyAxO1xuICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgbGluZSArPSAocHJlZml4ID8gJ+KUlOKUgCcgOiAnICAnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxpbmUgKz0gJ+KUnOKUgCc7XG4gICAgICAgIH1cbiAgICAgICAgbGluZSArPSB0aGlzLl90cmVlW25vZGVdO1xuICAgICAgICBwcmVmaXggKz0gKGxhc3QgPyAnICAnIDogJ+KUgiAnKTtcbiAgICAgICAgaWYgKGxlZnQgPCB0aGlzLl90cmVlLmxlbmd0aCkge1xuICAgICAgICAgICAgbGluZSArPSAnXFxuJyArIHRoaXMuX2Rpc3BsYXlOb2RlKGxlZnQsIHByZWZpeCwgKHRoaXMuX3RyZWVbcmlnaHRdID09IHVuZGVmaW5lZCA/IHRydWUgOiBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyaWdodCA8IHRoaXMuX3RyZWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBsaW5lICs9ICdcXG4nICsgdGhpcy5fZGlzcGxheU5vZGUocmlnaHQsIHByZWZpeCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBoZWFwIHRvIHN0cmluZ1xuICAgICAqXG4gICAgICogQG1ldGhvZCB0b1N0cmluZ1xuICAgICAqIEByZXR1cm4gc3RyaW5nICAgVGhlIHNlcmlhbGl6ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBzdGFydCB3aXRoIHJvb3QgYW5kIHJlY3Vyc2l2ZWx5IGdvZXMgdG8gZWFjaCBub2RlXG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwbGF5Tm9kZSgwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGhlYXAgdG8gYXJyYXlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9BcnJheVxuICAgICAqIEByZXR1cm4gQXJyYXkgICBUaGUgc2VyaWFsaXplZCBhcnJheS5cbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJlZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1heCBoZWFwIGZsYWdcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBNQVhcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgSGVhcC5NQVggPSAxO1xuICAgIC8qKlxuICAgICAqIE1pbiBoZWFwIGZsYWdcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBNSU5cbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgSGVhcC5NSU4gPSAtMTtcbiAgICByZXR1cm4gSGVhcDtcbn0pKCk7XG5tb2R1bGUuZXhwb3J0cyA9IEhlYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IZWFwLmpzLm1hcCIsInZhciBfX2V4dGVuZHMgPSB0aGlzLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlO1xuICAgIGQucHJvdG90eXBlID0gbmV3IF9fKCk7XG59O1xudmFyIEhlYXAgPSByZXF1aXJlKCcuL0hlYXAnKTtcbi8qKlxuICogVGhlIE1heEhlYXAgY2xhc3MgcHJvdmlkZXMgdGhlIG1haW4gZnVuY3Rpb25hbGl0eSBvZiBhIGhlYXAsIGtlZXBpbmcgdGhlIG1heGltdW0gb24gdGhlIHRvcC5cbiAqXG4gKiBAY2xhc3MgTWF4SGVhcFxuICogQGV4dGVuZHMgSGVhcFxuICovXG52YXIgTWF4SGVhcCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1heEhlYXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWF4SGVhcCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX3R5cGUgPSBIZWFwLk1BWDtcbiAgICB9XG4gICAgcmV0dXJuIE1heEhlYXA7XG59KShIZWFwKTtcbm1vZHVsZS5leHBvcnRzID0gTWF4SGVhcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1heEhlYXAuanMubWFwIiwidmFyIF9fZXh0ZW5kcyA9IHRoaXMuX19leHRlbmRzIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGU7XG4gICAgZC5wcm90b3R5cGUgPSBuZXcgX18oKTtcbn07XG52YXIgSGVhcCA9IHJlcXVpcmUoJy4vSGVhcCcpO1xuLyoqXG4gKiBUaGUgTWluSGVhcCBjbGFzcyBwcm92aWRlcyB0aGUgbWFpbiBmdW5jdGlvbmFsaXR5IG9mIGEgaGVhcCwga2VlcGluZyB0aGUgbWluaW11bSBvbiB0aGUgdG9wLlxuICpcbiAqIEBjbGFzcyBNaW5IZWFwXG4gKiBAZXh0ZW5kcyBIZWFwXG4gKi9cbnZhciBNaW5IZWFwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWluSGVhcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNaW5IZWFwKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fdHlwZSA9IEhlYXAuTUlOO1xuICAgIH1cbiAgICByZXR1cm4gTWluSGVhcDtcbn0pKEhlYXApO1xubW9kdWxlLmV4cG9ydHMgPSBNaW5IZWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWluSGVhcC5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBIZWFwID0gcmVxdWlyZSgnLi9IZWFwJyk7XG4vKipcbiAqIFRoZSBQcmlvcml0eVF1ZXVlIGNsYXNzIHByb3ZpZGVzIHRoZSBtYWluIGZ1bmN0aW9uYWxpdHkgb2YgYW4gcHJpb3JpdGl6ZWQgcXVldWUsIGltcGxlbWVudGVkIHVzaW5nIGEgbWF4IGhlYXAuXG4gKlxuICogQGNsYXNzIFByaW9yaXR5UXVldWVcbiAqIEBleHRlbmRzIEhlYXBcbiAqL1xudmFyIFByaW9yaXR5UXVldWUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQcmlvcml0eVF1ZXVlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByaW9yaXR5UXVldWUoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl90eXBlID0gSGVhcC5NQVg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZWxlbWVudCB0byB0aGUgcXVldWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZW5xdWV1ZVxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gZW5xdWV1ZS5cbiAgICAgKiBAcGFyYW0gcHJpb3JpdHkgVGhlIHByaW9yaXR5IG9mIHZhbHVlLlxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbiAodmFsdWUsIHByaW9yaXR5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc2VydChuZXcgUHJpb3JpdHlRdWV1ZU5vZGUodmFsdWUsIHByaW9yaXR5KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXF1ZXVlcyBhIG5vZGUgZnJvbSB0aGUgcXVldWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVxdWV1ZVxuICAgICAqIEByZXR1cm4gYW55ICBUaGUgdmFsdWUgb2YgdGhlIGRlcXVldWVkIG5vZGUuXG4gICAgICovXG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZGVxdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFjdCgpLnZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGVla3MgYXQgdGhlIG5vZGUgZnJvbSB0aGUgdG9wIG9mIHRoZSBoZWFwXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHRvcFxuICAgICAqIEByZXR1cm4gYW55IFRoZSB2YWx1ZSBvZiB0aGUgbm9kZSBvbiB0aGUgdG9wLlxuICAgICAqL1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLnRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUudG9wLmNhbGwodGhpcykudmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wYXJlIGVsZW1lbnRzIGluIG9yZGVyIHRvIHBsYWNlIHRoZW0gY29ycmVjdGx5IGluIHRoZSBoZWFwIHdoaWxlIHNpZnRpbmcgdXAuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGNvbXBhcmVcbiAgICAgKiBAcGFyYW0gZmlyc3QgVGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBub2RlIGJlaW5nIGNvbXBhcmVkLlxuICAgICAqIEBwYXJhbSBzZWNvbmQgVGhlIHZhbHVlIG9mIHRoZSBzZWNvbmQgbm9kZSBiZWluZyBjb21wYXJlZC5cbiAgICAgKiBAcmV0dXJuIG51bWJlciBSZXN1bHQgb2YgdGhlIGNvbXBhcmlzb24sIHBvc2l0aXZlIGludGVnZXIgaWYgZmlyc3QgaXMgZ3JlYXRlciB0aGFuIHNlY29uZCwgMCBpZiB0aGV5IGFyZSBlcXVhbCwgbmVnYXRpdmUgaW50ZWdlciBvdGhlcndpc2UuXG4gICAgICogSGF2aW5nIG11bHRpcGxlIGVsZW1lbnRzIHdpdGggdGhlIHNhbWUgdmFsdWUgaW4gYSBIZWFwIGlzIG5vdCByZWNvbW1lbmRlZC4gVGhleSB3aWxsIGVuZCB1cCBpbiBhbiBhcmJpdHJhcnkgcmVsYXRpdmUgcG9zaXRpb24uXG4gICAgICovXG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgIGlmIChmaXJzdC5wcmlvcml0eSA+IHNlY29uZC5wcmlvcml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmlyc3QucHJpb3JpdHkgPT0gc2Vjb25kLnByaW9yaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFByaW9yaXR5UXVldWU7XG59KShIZWFwKTtcbi8qKlxuICogUHJpb3JpdHlRdWV1ZSBOb2RlXG4gKlxuICogQGNsYXNzIFByaW9yaXR5UXVldWVOb2RlXG4gKi9cbnZhciBQcmlvcml0eVF1ZXVlTm9kZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKlxuICAgICAqIEBtZXRob2QgY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gcHJpb3JpdHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQcmlvcml0eVF1ZXVlTm9kZSh2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIG5vZGUgdG8gc3RyaW5nXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHRvU3RyaW5nXG4gICAgICogQHJldHVybiBzdHJpbmcgICBUaGUgc2VyaWFsaXplZCBzdHJpbmcuXG4gICAgICovXG4gICAgUHJpb3JpdHlRdWV1ZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSArIFwiIFtcIiArIHRoaXMucHJpb3JpdHkgKyBcIl1cIjtcbiAgICB9O1xuICAgIHJldHVybiBQcmlvcml0eVF1ZXVlTm9kZTtcbn0pKCk7XG5tb2R1bGUuZXhwb3J0cyA9IFByaW9yaXR5UXVldWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qcmlvcml0eVF1ZXVlLmpzLm1hcCIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIERvdWJseUxpbmtlZExpc3QgPSByZXF1aXJlKCcuL0RvdWJseUxpbmtlZExpc3QnKTtcbi8qKlxuICogVGhlIFF1ZXVlIGNsYXNzIHByb3ZpZGVzIHRoZSBtYWluIGZ1bmN0aW9uYWxpdHkgb2YgYSBxdWV1ZSBpbXBsZW1lbnRlZCB1c2luZyBhIGRvdWJseSBsaW5rZWQgbGlzdC5cbiAqXG4gKiBAY2xhc3MgUXVldWVcbiAqIEBleHRlbmRzIERvdWJseUxpbmtlZExpc3RcbiAqL1xudmFyIFF1ZXVlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUXVldWUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUXVldWUoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGVsZW1lbnQgdG8gdGhlIHF1ZXVlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGVucXVldWVcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGVucXVldWUuXG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgUXVldWUucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaCh2YWx1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXF1ZXVlcyBhIG5vZGUgZnJvbSB0aGUgcXVldWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVxdWV1ZVxuICAgICAqIEByZXR1cm4gYW55ICBUaGUgdmFsdWUgb2YgdGhlIGRlcXVldWVkIG5vZGUuXG4gICAgICovXG4gICAgUXVldWUucHJvdG90eXBlLmRlcXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoaWZ0KCk7XG4gICAgfTtcbiAgICByZXR1cm4gUXVldWU7XG59KShEb3VibHlMaW5rZWRMaXN0KTtcbm1vZHVsZS5leHBvcnRzID0gUXVldWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1RdWV1ZS5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBEb3VibHlMaW5rZWRMaXN0ID0gcmVxdWlyZSgnLi9Eb3VibHlMaW5rZWRMaXN0Jyk7XG4vKipcbiAqIFRoZSBTdGFjayBjbGFzcyBwcm92aWRlcyB0aGUgbWFpbiBmdW5jdGlvbmFsaXR5IG9mIGEgc3RhY2sgaW1wbGVtZW50ZWQgdXNpbmcgYSBkb3VibHkgbGlua2VkIGxpc3QuXG4gKlxuICogQGNsYXNzIFN0YWNrXG4gKiBAZXh0ZW5kcyBEb3VibHlMaW5rZWRMaXN0XG4gKi9cbnZhciBTdGFjayA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0YWNrLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN0YWNrKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0YWNrO1xufSkoRG91Ymx5TGlua2VkTGlzdCk7XG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RhY2suanMubWFwIiwiLyoqXG4gKiBTVExcbiAqIEB0eXBlIHt7RG91Ymx5TGlua2VkTGlzdDogZXhwb3J0cywgU3RhY2s6IGV4cG9ydHMsIFF1ZXVlOiBleHBvcnRzLCBIZWFwOiBleHBvcnRzLCBNYXhIZWFwOiBleHBvcnRzLCBNaW5IZWFwOiBleHBvcnRzLCBQcmlvcml0eVF1ZXVlOiBleHBvcnRzfX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG5cdERvdWJseUxpbmtlZExpc3Q6IHJlcXVpcmUoJy4vRGF0YXN0cnVjdHVyZXMvRG91Ymx5TGlua2VkTGlzdCcpLFxuXHRTdGFjazogcmVxdWlyZSgnLi9EYXRhc3RydWN0dXJlcy9TdGFjaycpLFxuXHRRdWV1ZTogcmVxdWlyZSgnLi9EYXRhc3RydWN0dXJlcy9RdWV1ZScpLFxuXHRIZWFwOiByZXF1aXJlKCcuL0RhdGFzdHJ1Y3R1cmVzL0hlYXAnKSxcblx0TWF4SGVhcDogcmVxdWlyZSgnLi9EYXRhc3RydWN0dXJlcy9NYXhIZWFwJyksXG5cdE1pbkhlYXA6IHJlcXVpcmUoJy4vRGF0YXN0cnVjdHVyZXMvTWluSGVhcCcpLFxuXHRQcmlvcml0eVF1ZXVlOiByZXF1aXJlKCcuL0RhdGFzdHJ1Y3R1cmVzL1ByaW9yaXR5UXVldWUnKVxufTsiLCJpbXBvcnQgeyBtYW5oYXR0YW5EaXN0YW5jZSB9IGZyb20gJy4vb3RoZXIvaGVscGVyRnVuY3Rpb25zJ1xuaW1wb3J0IE1hcFdpdGhEZWZhdWx0VmFsdWUgZnJvbSAnLi9vdGhlci9tYXBXaXRoRGVmYXVsdFZhbHVlJ1xuXG5pbXBvcnQgeyBQcmlvcml0eVF1ZXVlIH0gZnJvbSAnbGlic3RsJzsgLy8gbm90ZTogaW1wb3J0ZWQgZnJvbSBhIG5vZGUgbW9kdWxlXG5cbi8qKiBAbW9kdWxlIGZpbmRQYXRoICovXG5cbi8qKlxuICogSGVhdmlseSBtb2RpZmllZCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgQSogYWxnb3JpdGhtXG4gKiBAcGFyYW0gIHtPYmplY3R9IHN0YXJ0IG9iamVjdCBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YCB0aGF0IHJlcHJlc2VudCB0aGUgZmlyc3QgZW5kcG9pbnQgb2YgdGhlIHdpcmUgaW4gZ3JpZCBwaXhlbHNcbiAqIEBwYXJhbSAge09iamVjdH0gZW5kICAgb2JqZWN0IGNvbnRhaW5pbmcgbnVtZXJpYyBhdHRyaWJ1dGVzIGB4YCBhbmQgYHlgIHRoYXQgcmVwcmVzZW50IHRoZSBzZWNvbmQgZW5kcG9pbnQgb2YgdGhlIHdpcmUgaW4gZ3JpZCBwaXhlbHNcbiAqIEBwYXJhbSAge1NldH0gbm9uUm91dGFibGUgc2V0IG9mIG5vbiByb3V0YWJsZSBub2Rlc1xuICogQHBhcmFtICB7U2V0fSBwdW5pc2hlZEJ1dFJvdXRhYmxlIHNldCBvZiBub2RlcyB0aGF0IGFyZSBub3Qgb3B0aW1hbCBmb3Igcm91dGluZ1xuICogQHJldHVybiB7QXJyYXl9IGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZmluZFBhdGgoc3RhcnQsIGVuZCwgbm9uUm91dGFibGUsIHB1bmlzaGVkQnV0Um91dGFibGUpIHtcbiAgICBjb25zdCBkaXN0YW5jZUZ1bmN0aW9uID0gbWFuaGF0dGFuRGlzdGFuY2U7XG5cbiAgICBjb25zdCB3aXJlQ3Jvc3NQdW5pc2htZW50ID0gMTtcbiAgICBjb25zdCB3aXJlQmVuZFB1bmlzaG1lbnQgPSAxO1xuXG4gICAgLy8gbnVtYmVyIG9mIG5vZGVzLCB0aGF0IGNhbiBiZSBvcGVuZWQgYXQgb25jZVxuICAgIC8vIG9uY2UgaXMgdGhpcyBsaW1pdCBleGNlZWRlZCwgYVN0YXIgd2lsbCBmYWlsIGFuZCByZXR1cm4gdW5kZWZpbmVkXG4gICAgY29uc3QgbWF4Tm9kZUxpbWl0ID0gMTAwMDAwO1xuXG4gICAgbGV0IGNsb3NlZE5vZGVzID0gbmV3IFNldCgpO1xuICAgIGxldCBvcGVuTm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgbGV0IG9wZW5Ob2RlUXVldWUgPSBuZXcgUHJpb3JpdHlRdWV1ZSgpO1xuXG4gICAgLy8gZnVuY3Rpb25zIGZvciB3b3JraW5nIHdpdGggb3BlbiBub2RlczpcblxuICAgIC8qKlxuICAgICAqIGFkZCBhIG5ldyBvcGVuIG5vZGUgdG8gdGhlIHN0cnVjdHVyZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlICAgb2JqZWN0IGNvbnRhaW5pbmcgbnVtZXJpYyBhdHRyaWJ1dGVzIGB4YCBhbmQgYHlgIHRoYXQgcmVwcmVzZW50IHRoZSBmaXJzdCBlbmRwb2ludCBvZiB0aGUgd2lyZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmc2NvcmUgZlNjb3JlIG9mIHRoaXMgbm9kZVxuICAgICAqL1xuICAgIGNvbnN0IGFkZE9wZW5Ob2RlID0gKG5vZGUsIGZzY29yZSkgPT4ge1xuICAgICAgICBvcGVuTm9kZXMuYWRkKG5vZGUpO1xuICAgICAgICAvLyBmbGlwIHRoZSBmc2NvcmUsIGJlY2F1c2UgUHJpb3JpdHlRdWV1ZSB1c2VzIG1heCBoZWFwXG4gICAgICAgIG9wZW5Ob2RlUXVldWUuZW5xdWV1ZShub2RlLCAxIC8gZnNjb3JlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIG9wZW4gbm9kZSB3aXRoIHRoZSBsb3dlc3QgZlNjb3JlIGFuZCByZW1vdmUgaXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YCB0aGF0IHJlcHJlc2VudCB0aGUgZmlyc3QgZW5kcG9pbnQgb2YgdGhlIHdpcmVcbiAgICAgKi9cbiAgICBjb25zdCBnZXRPcGVuTm9kZSA9ICgpID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG9wZW5Ob2RlUXVldWUuZGVxdWV1ZSgpO1xuICAgICAgICBvcGVuTm9kZXMuZGVsZXRlKG5vZGUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICBsZXQgY2FtZUZyb20gPSBuZXcgTWFwKCk7XG5cbiAgICAvLyBkZWZhdWx0IHZhbHVlOiBpbmZpbml0eVxuICAgIGxldCBnU2NvcmUgPSBuZXcgTWFwV2l0aERlZmF1bHRWYWx1ZShJbmZpbml0eSk7XG4gICAgZ1Njb3JlLnNldChzdGFydCwgMCk7XG5cbiAgICBsZXQgc3RhcnRGU2NvcmUgPSBkaXN0YW5jZUZ1bmN0aW9uKHN0YXJ0LCBlbmQpO1xuXG4gICAgYWRkT3Blbk5vZGUoc3RhcnQsIHN0YXJ0RlNjb3JlKTtcblxuICAgIG9wZW5Ob2Rlcy5hZGQoc3RhcnQpO1xuICAgIG9wZW5Ob2RlUXVldWUuZW5xdWV1ZShzdGFydCwgMSAvIHN0YXJ0RlNjb3JlKTtcblxuICAgIHdoaWxlIChvcGVuTm9kZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgLy8gZ2V0IHRoZSB2YWx1ZSBmcm9tIG9wZW5Ob2RlcyB0aGF0IGhhcyB0aGUgbG93ZXN0IGZTY29yZVxuICAgICAgICBjb25zdCBjdXJyZW50Tm9kZSA9IGdldE9wZW5Ob2RlKCk7XG5cbiAgICAgICAgLy8gaWYgd2UgcmVhY2hlZCB0aGUgZW5kIHBvaW50LCByZWNvbnN0cnVjdCB0aGUgcGF0aCBhbmQgcmV0dXJuIGl0XG4gICAgICAgIGlmIChjdXJyZW50Tm9kZS54ID09IGVuZC54ICYmIGN1cnJlbnROb2RlLnkgPT0gZW5kLnkpIHtcbiAgICAgICAgICAgIHJldHVybiByZWNvbnN0cnVjdFBhdGgoY2FtZUZyb20sIGN1cnJlbnROb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB0aGlzIG5vZGUgdG8gdGhlIGNsb3NlZCBub2Rlc1xuICAgICAgICBjbG9zZWROb2Rlcy5hZGQoY3VycmVudE5vZGUpO1xuXG4gICAgICAgIC8vIHRoZSBmYXJ0aGVzdCBwb2ludHMgYWNjZXNzaWJsZSB3aXRob3V0IGF2b2lkaW5nIG9ic3RhY2xlcyBpbiBldmVyeSBkaXJlY3Rpb25cbiAgICAgICAgLy8gKGJ1dCBtYXggNTAgaW4gZWFjaCBkaXJlY3Rpb24pXG4gICAgICAgIGZvciAobGV0IGRpcmVjdGlvbiA9IDA7IGRpcmVjdGlvbiA8IDQ7IGRpcmVjdGlvbisrKSB7XG4gICAgICAgICAgICBsZXQgbmV3UG9pbnQgPSBtb3ZlUG9pbnQoY3VycmVudE5vZGUsIGRpcmVjdGlvbik7XG5cbiAgICAgICAgICAgIGxldCB3aXJlc0Nyb3NzZWQgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDUwOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBuZXdQb2ludCBpcyBpbiB0aGUgc2V0IG9mIG5vbiByb3V0YWJsZSBwb2ludHMsXG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgYWRkIGl0IGFuZCBzdG9wIHByb2NlZWRpbmcgaW4gdGhpcyBkaXJlY3Rpb25cbiAgICAgICAgICAgICAgICBpZiAoc2V0SGFzVGhpc1BvaW50KG5vblJvdXRhYmxlLCBuZXdQb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBub3QgdGhlIGVuZCBvciBzdGFydCBwb2ludCwgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobmV3UG9pbnQueCA9PT0gZW5kLnggJiYgbmV3UG9pbnQueSA9PT0gZW5kLnkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhKG5ld1BvaW50LnggPT09IHN0YXJ0LnggJiYgbmV3UG9pbnQueSA9PT0gc3RhcnQueSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHNraXAgdGhpcyBub2RlLCBpZiBpdCBoYXMgYmVlbiBhbHJlYWR5IGNsb3NlZFxuICAgICAgICAgICAgICAgIC8vIG9yIGlmIGl0IGlzIG9uIHRoZSBsaXN0IG9mIG5vbiByb3V0YWJsZSBub2Rlc1xuICAgICAgICAgICAgICAgIGlmIChjbG9zZWROb2Rlcy5oYXMobmV3UG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBwb3NzaWJsZSBHU2NvcmUgYnkgYXBwbHlpbmcgYSBwdW5pc2htZW50IGZvciBlYWNoIG5vZGUgKFwiYmVuZFwiKSBpbiB0aGUgcGF0aFxuICAgICAgICAgICAgICAgIGxldCBuZXdHU2NvcmUgPSB3aXJlQmVuZFB1bmlzaG1lbnQgKyBnU2NvcmUuZ2V0V2l0aERlZmF1bHQoY3VycmVudE5vZGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNldEhhc1RoaXNQb2ludChwdW5pc2hlZEJ1dFJvdXRhYmxlLCBuZXdQb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIG5vZGUgaXMgaW4gdGhlIHNldCBvZiBwdW5pc2hlZCBub2RlcywgYXBwbHkgdGhlIHB1bmlzaG1lbnRcbiAgICAgICAgICAgICAgICAgICAgd2lyZXNDcm9zc2VkKys7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYXBwbHkgdGhlIHB1bmlzaG1lbnQgZm9yIGVhY2ggd2lyZSBjcm9zc2VkIGluIHRoaXMgZGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgLy8gbm90ZTogd2UgYXJlIGNvdW50aW5nIHRoZSB3aXJlcyBjcm9zc2VkIHdoZW4gZXhwb3J0aW5nIHRoaXMgZGlyZWN0aW9uLCBub3QgdGhlIHdpcmVzXG4gICAgICAgICAgICAgICAgLy8gY3Jvc3NlZCBpbiB0aGUgZmluYWwgcGF0aCwgdGhlcmUgd2lsbCBiZSBwcm9iYWJseSBvbmx5IGF0IG1vc3Qgb2YgdGhlc2Ugbm9kZXMgaW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gZmluYWwgcGF0aCwgbm90IG11bHRpcGxlXG4gICAgICAgICAgICAgICAgbmV3R1Njb3JlICs9IHdpcmVzQ3Jvc3NlZCAqIHdpcmVDcm9zc1B1bmlzaG1lbnQ7XG5cbiAgICAgICAgICAgICAgICAvLyBza2lwIHRoaXMgbm9kZSBpZiBpdCBoYXMgd29yc3QgZXN0aW1hZ2UgZ3Njb3JlIHRoYW4gaW4gdGhlIGdzY29yZSB0YWJsZVxuICAgICAgICAgICAgICAgIGlmIChuZXdHU2NvcmUgPj0gZ1Njb3JlLmdldFdpdGhEZWZhdWx0KG5ld1BvaW50KSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjYW1lRnJvbS5zZXQobmV3UG9pbnQsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgICAgICBnU2NvcmUuc2V0KG5ld1BvaW50LCBuZXdHU2NvcmUpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RlNjb3JlID0gbmV3R1Njb3JlICsgZGlzdGFuY2VGdW5jdGlvbihuZXdQb2ludCwgZW5kKTtcblxuICAgICAgICAgICAgICAgIGlmICghb3Blbk5vZGVzLmhhcyhuZXdQb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBwb2ludCB0byB0aGUgbGlzdCBvZiBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgYWRkT3Blbk5vZGUobmV3UG9pbnQsIG5ld0ZTY29yZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0byB0aGUgbmV4dCBwb2ludCBpbiB0aGUgZGlyZWNpdG9uXG4gICAgICAgICAgICAgICAgbmV3UG9pbnQgPSBtb3ZlUG9pbnQobmV3UG9pbnQsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3Blbk5vZGVzLnNpemUgPiBtYXhOb2RlTGltaXQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBhU3RhcjogTnVtYmVyIG9mIG9wZW4gbm9kZXMgKCR7b3Blbk5vZGVzLnNpemV9KSBleGNlZWRlZCB0aGUgbGltaXQgZm9yIG9wZW4gbm9kZXMgKCR7bWF4Tm9kZUxpbWl0fSkuYClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGlmIHdlIGdvdCBoZXJlLCB0aGUgcGF0aCB3YXMgbm90IGZvdW5kXG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIHJldHVybnMgYHRydWVgIGlmIHRoZSBzcGVjaWZpZWQgc2V0IG9mIHBvaW50cyBjb250YWlucyB0aGUgc3BlY2lmaWVkIHBvaW50IChhbmQgcmV0dXJucyBgZmFsc2VgIG90aGVyd2lzZSlcbiAqIEBwYXJhbSB7U2V0fSBzZXQgc2V0IG9mIHBvaW50c1xuICogQHBhcmFtIHtPYmplY3R9IHBvaW50IG9iamVjdCBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YFxuICovXG5mdW5jdGlvbiBzZXRIYXNUaGlzUG9pbnQoc2V0LCBwb2ludCkge1xuICAgIGZvciAobGV0IGl0ZW0gb2Ygc2V0KSB7XG4gICAgICAgIGlmIChpdGVtLnggPT09IHBvaW50LnggJiYgaXRlbS55ID09PSBwb2ludC55KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgbW92ZXMgdGhlIHBhc3NlZCBwb2ludCBpbiB0aGUgc3BlY2lmaWVkIGRpcmVjdGlvbi4gSXQgc2ltcGx5IGFkZHMgb3Igc3VidHJhY3RzIDEgZnJvbSBvbmUgb2YgdGhlIGNvb3JkaW5hdGVzIGRlcGVuZGluZyBvbiB0aGUgZGlyZWN0aW9uIGF0dHJpYnV0ZS5cbiAqIEBwYXJhbSAge09iamVjdH0gcG9pbnQgICAgIG9iamVjdCBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YFxuICogQHBhcmFtICB7bnVtYmVyfSBkaXJlY3Rpb24gZGlyZWN0aW9uczpcbiAqICAgICAtIDA6IHVwXG4gKiAgICAgLSAxOiByaWdodFxuICogICAgIC0gMjogZG93blxuICogICAgIC0gMzogbGVmdFxuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgb2JqZWN0IGNvbnRhaW5pbmcgbnVtZXJpYyBhdHRyaWJ1dGVzIGB4YCBhbmQgYHlgXG4gKi9cbmZ1bmN0aW9uIG1vdmVQb2ludCh7eCwgeX0sIGRpcmVjdGlvbikge1xuICAgIC8vIG1hcCBkaXJlY3Rpb24gZG8gcG9pbnQgY29vcmRpbmF0ZSBtb2RpZmljYXRpb25cbiAgICBjb25zdCBkaXJNYXAgPSB7XG4gICAgICAgIDA6ICgpID0+IHtcbiAgICAgICAgICAgIHkgLT0gMVxuICAgICAgICB9LFxuICAgICAgICAxOiAoKSA9PiB7XG4gICAgICAgICAgICB4ICs9IDFcbiAgICAgICAgfSxcbiAgICAgICAgMjogKCkgPT4ge1xuICAgICAgICAgICAgeSArPSAxXG4gICAgICAgIH0sXG4gICAgICAgIDM6ICgpID0+IHtcbiAgICAgICAgICAgIHggLT0gMVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlyTWFwW2RpcmVjdGlvbl0oKTtcblxuICAgIHJldHVybiB7eCwgeX1cbn1cblxuLyoqXG4gKiBoZWxwZXIgYmFja3RyYWNraW5nIGZ1bmN0aW9uIHVzZWQgYnkgdGhlIGFTdGFyIGFsZ29yaXRobSB0byBjb25zdHJ1Y3QgdGhlIGZpbmFsIHBhdGhcbiAqIEBwYXJhbSAge09iamVjdH0gY2FtZUZyb20gICAgb2JqZWN0IGNvbnRhaW5pbmcgbnVtZXJpYyBhdHRyaWJ1dGVzIGB4YCBhbmQgYHlgXG4gKiBAcGFyYW0gIHtPYmplY3R9IGN1cnJlbnROb2RlIG9iamVjdCBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YFxuICogQHJldHVybiB7QXJyYXl9IGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWBcbiAqL1xuZnVuY3Rpb24gcmVjb25zdHJ1Y3RQYXRoKGNhbWVGcm9tLCBjdXJyZW50Tm9kZSkge1xuICAgIGxldCBwYXRoID0gW107XG5cbiAgICBwYXRoLnB1c2goe1xuICAgICAgICB4OiBjdXJyZW50Tm9kZS54LFxuICAgICAgICB5OiBjdXJyZW50Tm9kZS55XG4gICAgfSlcblxuICAgIHdoaWxlIChjYW1lRnJvbS5oYXMoY3VycmVudE5vZGUpKSB7XG4gICAgICAgIGN1cnJlbnROb2RlID0gY2FtZUZyb20uZ2V0KGN1cnJlbnROb2RlKTtcbiAgICAgICAgcGF0aC5wdXNoKHtcbiAgICAgICAgICAgIHg6IGN1cnJlbnROb2RlLngsXG4gICAgICAgICAgICB5OiBjdXJyZW50Tm9kZS55XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGg7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBAbW9kdWxlIEhlbHBlckZ1bmN0aW9uc1xuICovXG5cbmltcG9ydCBzdHJpbmdpZnkgZnJvbSBcImpzb24tc3RyaW5naWZ5LXByZXR0eS1jb21wYWN0XCI7IC8vIG5vdGU6IGltcG9ydGVkIGZyb20gYSBtb2R1bGVcblxuLyoqXG4gKiBhZGQgYSBjcm9zcyBicm93c2VyIGV2ZW50IGxpc3RlbmVyIG9uIGEgbW91c2Ugc2Nyb2xsXG4gKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgRE9NIHF1ZXJ5IG9mIHRoZSBlbGVtZW50IHRoYXQgdGhlIGxpc3RlbmVyIHdpbGwgYmUgYWRkZWQgdG9cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgIEZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgb2NjdXJzLiBUaGUgZnVuY3Rpb24gdGFrZXMgYXMgYSBwYXJhbWV0ZXIgYW4gZXZlbnQgb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkTW91c2VTY3JvbGxFdmVudExpc3RlbmVyKHF1ZXJ5LCBmdW5jKSB7XG4gICAgbGV0IE1vdXNlV2hlZWxIYW5kbGVyID0gZXZlbnQgPT4ge1xuICAgICAgICAvLyByZWRlY2xhcmUgZm9yIG9sZCBJRSBzdXBwb3J0XG4gICAgICAgIHZhciBldmVudCA9IHdpbmRvdy5ldmVudCB8fCBldmVudDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZWRlY2xhcmVcblxuICAgICAgICBldmVudC5kZWx0YSA9IE1hdGgubWF4KC0xLCBNYXRoLm1pbigxLCAoZXZlbnQud2hlZWxEZWx0YSB8fCAtZXZlbnQuZGV0YWlsKSkpO1xuXG4gICAgICAgIGZ1bmMoZXZlbnQpXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBzdmdlbGVtZW50O1xuXG4gICAgLy8gaWYgdGhlIHF1ZXJ5IGlzIGEgc2ltcGxlIERPTSBpZCBzZWxlY3Rvciwgd2UgY2FuIHVzZSBnZXRFbGVtZW50QnlJZCB3aGljaCBoYXMgYmV0dGVyIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgaWYocXVlcnkubWF0Y2goL14jXFx3KyQvKSkge1xuICAgICAgICBzdmdlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocXVlcnkuc3Vic3RyKDEpKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHN2Z2VsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHF1ZXJ5KVxuICAgIH1cblxuICAgIGlmIChzdmdlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgLy8gSUU5LCBDaHJvbWUsIFNhZmFyaSwgT3BlcmFcbiAgICAgICAgc3ZnZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V3aGVlbFwiLCBNb3VzZVdoZWVsSGFuZGxlciwgZmFsc2UpO1xuICAgICAgICAvLyBGaXJlZm94XG4gICAgICAgIHN2Z2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTU1vdXNlU2Nyb2xsXCIsIE1vdXNlV2hlZWxIYW5kbGVyLCBmYWxzZSk7XG4gICAgfSBlbHNlICB7XG4gICAgICAgIC8vIElFIDYvNy84XG4gICAgICAgIHN2Z2VsZW1lbnQuYXR0YWNoRXZlbnQoXCJvbm1vdXNld2hlZWxcIiwgTW91c2VXaGVlbEhhbmRsZXIpO1xuICAgIH1cbiAgICBzdmdlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdldmVudCcsIGUpXG4gICAgfSwgZmFsc2UpXG59XG5cbi8qKlxuICogY29udmVydCBhIGRhdGEgb2JqZWN0IHRvIEpTT04gc3RyaW5nIG9yIHRvIGEgZGF0YSBVUkkgY29udGFpbmluZyBhIEpTT04gc3RyaW5nXG4gKiBAcGFyYW0gIHtPYmplY3R9ICBkYXRhICAgICAgICAgICAgb2JqZWN0IHRoYXQgd2lsbCBiZSBzZXJpYWxpemVkIGludG8gYSBKU09OIHN0cmluZ1xuICogQHBhcmFtICB7Qm9vbGVhbn0gW3ByZXR0eT1mYWxzZV0gIGlmIGB0cnVlYCwgdGhlIGNvZGUgd2lsbCBiZSBwcm9wcmVybHkgaW5kZW50ZWQsIGVsc2UgYSBtb3JlIGNvbXBhY3Qgc3ludGF4IHdpbGwgYmUgdXNlZFxuICogQHBhcmFtICB7Qm9vbGVhbn0gW2RhdGFVcmk9ZmFsc2VdIHJldHVybiBkYXRhVXJpIGNvbnRhaW5pbmcgdGhlIEpTT04gc3RyaW5nIGluc3RlYWQgb2YgdGhlIHB1cmUgSlNPTiBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEpTT05TdHJpbmcoZGF0YSwgcHJldHR5ID0gZmFsc2UsIGRhdGFVcmkgPSBmYWxzZSkge1xuICAgIGlmKGRhdGFVcmkpIHtcbiAgICAgICAgcmV0dXJuICdkYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCwnXG4gICAgICAgICAgICArIGVuY29kZVVSSUNvbXBvbmVudChnZXRKU09OU3RyaW5nKGRhdGEsIHByZXR0eSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAocHJldHR5KSB7XG4gICAgICAgICAgICBjYXNlIHRydWU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShkYXRhLCB7bWF4TGVuZ3RoOiA1MH0pO1xuICAgICAgICAgICAgY2FzZSBmYWxzZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogcmV0dXJucyB0aGUgTWFuaGF0dGFuIGRpc3RhbmNlIGJldHdlZW4gdGhlIHBvaW50cyBfYV8gYW5kIF9iX1xuICogQHBhcmFtICB7T2JqZWN0fSBhIG9iamVjdCBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YFxuICogQHBhcmFtICB7T2JqZWN0fSBiIG9iamVjdCBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFuaGF0dGFuRGlzdGFuY2UoYSwgYikge1xuICAgIHJldHVybiBNYXRoLmFicyhhLnggLSBiLngpICsgTWF0aC5hYnMoYS55IC0gYi55KTtcbn1cbiIsIi8qKiBAbW9kdWxlIE1hcFdpdGhEZWZhdWx0VmFsdWUgKi9cbi8qKlxuICogTWFwIHRoYXQgaGFzIGEgZGVmYXVsdCB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICpcbiAqIEZvciB0aGUgY29tcGxldGUgZG9jdW1lbnRhdGlvbiBvZiB0aGUgTWFwIHNlZSBbTWFwIGluIHRoZSBNRE4gd2ViIGRvY3NdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hcClcbiAqXG4gKiBVc2FnZTpcbiAqIGBgYEphdmFTY3JpcHRcbiBsZXQgbXlNYXAgPSBuZXcgTWFwV2l0aERlZmF1bHRWYWx1ZShJbmZpbml0eSk7XG4gY29uc3QgdmFsdWUgPSBteU1hcC5nZXRXaXRoRGVmYXVsdChrZXkpXG4gYGBgXG4gKlxuICogX05vdGU6IFRoaXMgdmVyc2lvbiBpcyB3cml0dGVuIHNwZWNpYWxseSBmb3IgRVM2IGNvbXBpbGVkIGludG8gRVM1LiBJbiBub24tY29tcGlsZWQgRVM2IGlzIHRoZSBpbXBsZW1lbnRhdGlvbiBmYXIgbW9yZSBlbGVnYW50Ol9cbiAqXG4gKiBgYGBKYXZhU2NyaXB0XG4gZXhwb3J0IGNsYXNzIE1hcFdpdGhEZWZhdWx0VmFsdWUgZXh0ZW5kcyBNYXAge1xuICAgICBjb25zdHJ1Y3RvcihkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgIHRoaXMuZGVmYXVsdCA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgfVxuXG4gICAgIGdldChrZXkpIHtcbiAgICAgICAgIGlmKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICByZXR1cm4gc3VwZXIuZ2V0KGtleSk7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHQ7XG4gICAgICAgICB9XG4gICAgIH1cbiB9YGBgXG4gKiBAY2xhc3MgTWFwV2l0aERlZmF1bHRWYWx1ZVxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSB7YW55fSBkZWZhdWx0IHZhbHVlIHRoYXQgd2lsbCBiZSByZXR1cm5lZCB3aGVuIHRoZSByZXF1ZXN0ZWQga2V5IGlzIG5vdCBmb3VuZCBpbiB0aGUgbWFwXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGRlZmF1bHRWYWx1ZSkge1xuICAgIGxldCBtYXAgPSBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7YW55fSBrZXkga2V5IG9mIGEgcmVxdWVzdGVkIGl0ZW1cbiAgICAgKiBAcmV0dXJuIHthbnl9IHZhbHVlIG9mIHRoZSBpdGVtIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcga2V5LCBvciBkZWZhdWx0VmFsdWUgaWYgdGhlIGtleSBpcyBub3QgZm91bmQgaW4gdGhlIG1hcFxuICAgICAqL1xuICAgIG1hcC5nZXRXaXRoRGVmYXVsdCA9IChrZXkpID0+IHtcbiAgICAgICAgcmV0dXJuIG1hcC5oYXMoa2V5KVxuICAgICAgICAgICAgPyBtYXAuZ2V0KGtleSlcbiAgICAgICAgICAgIDogZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xufVxuIiwiLyoqIEBtb2R1bGUgcm91dGVXb3JrZXIgKi9cblxuaW1wb3J0IGZpbmRQYXRoIGZyb20gJy4vbW9kdWxlcy9maW5kUGF0aCdcblxuLyoqXG4gKiBjYWxsYmFjayB3aGVuIGEgbWVzc2FnZSBpcyBzZW50IHRvIHRoZSB3ZWIgd29ya2VyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IHdlYiB3b3JrZXIgZXZlbnQgb2JqZWN0ICh0aGUgYGRhdGFgIGl0ZW0gb2YgdGhlIGV2ZW50IG9iamVjdCBpcyBleHBlY3RlZCB0byBjb250YWluXG4gKiAgICAgICAgICAgICAgICAgICAgICAgdGhlc2UgaXRlbXM6IGB3aXJlc2AgKGFycmF5KSwgYG5vblJvdXRhYmxlTm9kZXNgIChpdGVyYWJsZSkgYW5kIGBpbmNvbnZlbmllbnROb2Rlc2AgKGl0ZXJhYmxlKSlcbiAqL1xub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgY29uc3Qge3dpcmVzLCBub25Sb3V0YWJsZU5vZGVzLCBpbmNvbnZlbmllbnROb2Rlc30gPSBldmVudC5kYXRhO1xuXG4gICAgY29uc3QgcGF0aHMgPSBmaW5kUGF0aHMod2lyZXMsIG5vblJvdXRhYmxlTm9kZXMsIGluY29udmVuaWVudE5vZGVzKTtcblxuICAgIHBvc3RNZXNzYWdlKHtwYXRoc30pO1xuICAgIGNsb3NlKCk7XG59XG5cbi8qKlxuICogZmluZCBwYXRocyBmb3IgYWxsIHRoZSBzcGVjaWZpZWQgd2lyZXNcbiAqIEBwYXJhbSAge0FycmF5fSB3aXJlcyAgICAgICAgICAgICAgYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIGF0dHJpYnV0ZXMgYGZyb21gIGFuZCBgdG9gLCBib3RoIG9mIHRoZW0gd2hpY2ggYXJlIG9iamVjdHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCB2YWx1ZXMgYHhgIGFuZCBgeWAgY29udGFpbmluZyBjb29yZGluYXRlcyBvZiB0aGUgd2lyZSBlbmRwb2ludHNcbiAqIEBwYXJhbSAge0l0ZXJhYmxlfSBub25Sb3V0YWJsZU5vZGVzICBTZXQgb3IgYXJyYXkgb2Ygbm9uIHJvdXRhYmxlIG5vZGVzXG4gKiBAcGFyYW0gIHtJdGVyYWJsZX0gaW5jb252ZW5pZW50Tm9kZXMgU2V0IG9yIGFycmF5IG9mIGluY29udmVuaWVudCBub2Rlc1xuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgICAgICAgICBhcnJheSBvZiBwYXRocywgZWFjaCBpdGVtIGlzIGFuIGFycmF5IG9mIHBvaW50cyBvZiB0aGUgcGF0aFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgcmV0dXJuZWQgYXJyYXkgY29udGFpbnMgcGF0aHMgZm9yIHRoZSB3aXJlcyB3aXRoIGNvcnJlc3BvbmRpbmcgaW5kZXhlcyBmcm9tIHRoZSBgd2lyZXNgIHBhcmFtZXRlclxuICovXG5mdW5jdGlvbiBmaW5kUGF0aHMod2lyZXMsIG5vblJvdXRhYmxlTm9kZXMsIGluY29udmVuaWVudE5vZGVzKSB7XG4gICAgbGV0IHBhdGhzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IFtmcm9tLCB0b10gb2Ygd2lyZXMpIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IGZpbmRQYXRoKGZyb20sIHRvLCBub25Sb3V0YWJsZU5vZGVzLCBpbmNvbnZlbmllbnROb2RlcylcblxuICAgICAgICBpZighcGF0aCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJwYXRoIG5vdCBmb3VuZFwiKVxuICAgICAgICAgICAgY29uc29sZS5sb2coZnJvbSwgdG8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJwYXRoIGZvdW5kXCIpXG4gICAgICAgIH1cblxuICAgICAgICBwYXRocy5wdXNoKHBhdGgpO1xuXG4gICAgICAgIC8vIGFkZCBuZXcgaW5jb252ZW5pZW50IG5vZGVzIGNyZWF0ZWQgYnkgdGhpcyBuZXcgcGF0aFxuICAgICAgICBsZXQgcHJldlBvaW50O1xuICAgICAgICBmb3IoY29uc3QgcG9pbnQgb2YgcGF0aCkge1xuICAgICAgICAgICAgaWYocHJldlBvaW50KSB7XG4gICAgICAgICAgICAgICAgaWYocG9pbnQueCA9PT0gcHJldlBvaW50LngpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaG9yaXpvbnRhbCBzZWN0aW9uIG9mIHRoZSBwYXRoXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgeSA9IE1hdGgubWluKHBvaW50LnksIHByZXZQb2ludC55KTsgeSA8PSBNYXRoLm1heChwb2ludC55LCBwcmV2UG9pbnQueSkgOyArK3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY29udmVuaWVudE5vZGVzLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogcG9pbnQueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKHBvaW50LnkgPT09IHByZXZQb2ludC55KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZlcnRpY2FsIHNlY3Rpb24gb2YgdGhlIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCB4ID0gTWF0aC5taW4ocG9pbnQueCwgcHJldlBvaW50LngpOyB4IDw9IE1hdGgubWF4KHBvaW50LngsIHByZXZQb2ludC54KSA7ICsreCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5jb252ZW5pZW50Tm9kZXMuYWRkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHBvaW50LnlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXZQb2ludCA9IHBvaW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhzO1xufVxuIl19"}