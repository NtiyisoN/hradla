{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/json-stringify-pretty-compact/index.js","node_modules/libstl/Datastructures/DoublyLinkedList.js","node_modules/libstl/Datastructures/Heap.js","node_modules/libstl/Datastructures/MaxHeap.js","node_modules/libstl/Datastructures/MinHeap.js","node_modules/libstl/Datastructures/PriorityQueue.js","node_modules/libstl/Datastructures/Queue.js","node_modules/libstl/Datastructures/Stack.js","node_modules/libstl/node-module.js","src/es6/modules/findPath.js","src/es6/modules/other/helperFunctions.js","src/es6/modules/other/mapWithDefaultValue.js","src/es6/routeWorker.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;kBCGwB,Q;;AAfxB;;AACA;;;;AAEA;;;;AAAwC;;AAExC;;AAEA;;;;;;;;AAQe,SAAS,QAAT,CAAkB,KAAlB,EAAyB,GAAzB,EAA8B,WAA9B,EAA2C,mBAA3C,EAAgE;AAC3E,QAAM,mBAAmB,kCAAzB;;AAEA,QAA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","file":"routeWorker.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","function stringify (obj, options) {\n  options = options || {}\n  var indent = JSON.stringify([1], null, get(options, 'indent', 2)).slice(2, -3)\n  var addMargin = get(options, 'margins', false)\n  var maxLength = (indent === '' ? Infinity : get(options, 'maxLength', 80))\n\n  return (function _stringify (obj, currentIndent, reserved) {\n    if (obj && typeof obj.toJSON === 'function') {\n      obj = obj.toJSON()\n    }\n\n    var string = JSON.stringify(obj)\n\n    if (string === undefined) {\n      return string\n    }\n\n    var length = maxLength - currentIndent.length - reserved\n\n    if (string.length <= length) {\n      var prettified = prettify(string, addMargin)\n      if (prettified.length <= length) {\n        return prettified\n      }\n    }\n\n    if (typeof obj === 'object' && obj !== null) {\n      var nextIndent = currentIndent + indent\n      var items = []\n      var delimiters\n      var comma = function (array, index) {\n        return (index === array.length - 1 ? 0 : 1)\n      }\n\n      if (Array.isArray(obj)) {\n        for (var index = 0; index < obj.length; index++) {\n          items.push(\n            _stringify(obj[index], nextIndent, comma(obj, index)) || 'null'\n          )\n        }\n        delimiters = '[]'\n      } else {\n        Object.keys(obj).forEach(function (key, index, array) {\n          var keyPart = JSON.stringify(key) + ': '\n          var value = _stringify(obj[key], nextIndent,\n                                 keyPart.length + comma(array, index))\n          if (value !== undefined) {\n            items.push(keyPart + value)\n          }\n        })\n        delimiters = '{}'\n      }\n\n      if (items.length > 0) {\n        return [\n          delimiters[0],\n          indent + items.join(',\\n' + nextIndent),\n          delimiters[1]\n        ].join('\\n' + currentIndent)\n      }\n    }\n\n    return string\n  }(obj, '', 0))\n}\n\n// Note: This regex matches even invalid JSON strings, but since we’re\n// working on the output of `JSON.stringify` we know that only valid strings\n// are present (unless the user supplied a weird `options.indent` but in\n// that case we don’t care since the output would be invalid anyway).\nvar stringOrChar = /(\"(?:[^\\\\\"]|\\\\.)*\")|[:,\\][}{]/g\n\nfunction prettify (string, addMargin) {\n  var m = addMargin ? ' ' : ''\n  var tokens = {\n    '{': '{' + m,\n    '[': '[' + m,\n    '}': m + '}',\n    ']': m + ']',\n    ',': ', ',\n    ':': ': '\n  }\n  return string.replace(stringOrChar, function (match, string) {\n    return string ? match : tokens[match]\n  })\n}\n\nfunction get (options, name, defaultValue) {\n  return (name in options ? options[name] : defaultValue)\n}\n\nmodule.exports = stringify\n","/**\n * The DoublyLinkedList class provides the main functionality of a doubly linked list.\n *\n * @class DoublyLinkedList\n */\nvar DoublyLinkedList = (function () {\n    function DoublyLinkedList() {\n        /**\n         * Count of elements in list\n         *\n         * @property _length\n         * @type number\n         * @private\n         */\n        this._length = 0;\n        /**\n         * Iteration pointer\n         *\n         * @property _key\n         * @type number\n         * @private\n         */\n        this._key = 0;\n        /**\n         * Reference to head(first) element in list\n         *\n         * @property _head\n         * @type DoublyLinkedListNode\n         * @private\n         */\n        this._head = null;\n        /**\n         * Reference to tail(last) element in list\n         *\n         * @property _tail\n         * @type DoublyLinkedListNode\n         * @private\n         */\n        this._tail = null;\n        /**\n         * Reference to iterated element in list\n         *\n         * @property _current\n         * @type DoublyLinkedListNode\n         * @private\n         */\n        this._current = null;\n    }\n    /**\n     * Insert a new value at the specified index\n     *\n     * @method add\n     * @param index The index where the new value is to be inserted.\n     * @param value The new value for the index.\n     * @return void\n     */\n    DoublyLinkedList.prototype.add = function (index, value) {\n        if (index < 0 || index >= this._length) {\n            throw new Error(\"Out of bounds\");\n        }\n        var i = 0;\n        var current = this._head;\n        while (i < index) {\n            current = current.next;\n            i++;\n        }\n        current.value = value;\n    };\n    /**\n     * Pops a node from the end of the doubly linked list\n     *\n     * @method pop\n     * @return any  The value of the popped node.\n     */\n    DoublyLinkedList.prototype.pop = function () {\n        if (this._length === 0) {\n            throw new Error(\"Can't pop from an empty data structure\");\n        }\n        var value = this._tail.value;\n        this._tail = this._tail.prev;\n        if (this._tail) {\n            delete this._tail.next;\n            this._tail.next = null;\n        }\n        this._length--;\n        if (this._length === 0) {\n            delete this._head;\n            this._head = null;\n        }\n        return value;\n    };\n    /**\n     * Shifts a node from the beginning of the doubly linked list\n     *\n     * @method shift\n     * @return any  The value of the shifted node.\n     */\n    DoublyLinkedList.prototype.shift = function () {\n        if (this._length === 0) {\n            throw new Error(\"Can't shift from an empty data structure\");\n        }\n        var value = this._head.value;\n        this._head = this._head.next;\n        if (this._head) {\n            delete this._head.prev;\n            this._head.prev = null;\n        }\n        this._length--;\n        return value;\n    };\n    /**\n     * Pushes an element at the end of the doubly linked list\n     *\n     * @method push\n     * @param value The value to push.\n     * @return void\n     */\n    DoublyLinkedList.prototype.push = function (value) {\n        // allocate new node\n        var node = {\n            value: value,\n            prev: this._tail,\n            next: null\n        };\n        if (this._length === 0) {\n            this._head = this._tail = node;\n        }\n        else {\n            this._tail.next = node;\n            this._tail = this._tail.next;\n        }\n        this._length++;\n    };\n    /**\n     * Prepends the doubly linked list with an element\n     *\n     * @method unshift\n     * @param value The value to unshift.\n     * @return void\n     */\n    DoublyLinkedList.prototype.unshift = function (value) {\n        // allocate new node\n        var node = {\n            value: value,\n            prev: null,\n            next: this._head\n        };\n        if (this._length === 0) {\n            this._head = this._tail = node;\n        }\n        else {\n            this._head.prev = node;\n            this._head = this._head.prev;\n        }\n        this._length++;\n    };\n    /**\n     * Peeks at the node from the end of the doubly linked list\n     *\n     * @method top\n     * @return any  The value of the last node.\n     */\n    DoublyLinkedList.prototype.top = function () {\n        if (this._tail)\n            return this._tail.value;\n    };\n    /**\n     * Peeks at the node from the beginning of the doubly linked list\n     *\n     * @method bottom\n     * @return any  The value of the first node.\n     */\n    DoublyLinkedList.prototype.bottom = function () {\n        if (this._head)\n            return this._head.value;\n    };\n    /**\n     * Counts the number of elements in the doubly linked list\n     *\n     * @method count\n     * @return number the number of elements in the doubly linked list.\n     */\n    DoublyLinkedList.prototype.count = function () {\n        return this._length;\n    };\n    /**\n     * Checks whether the doubly linked list is empty\n     *\n     * @method isEmpty\n     * @return boolean whether the doubly linked list is empty.\n     */\n    DoublyLinkedList.prototype.isEmpty = function () {\n        return (this._length === 0);\n    };\n    /**\n     * Rewind iterator back to the start\n     *\n     * @method rewind\n     * @return void\n     */\n    DoublyLinkedList.prototype.rewind = function () {\n        this._key = 0;\n        this._current = this._head;\n    };\n    /**\n     * Return current list entry\n     *\n     * @method current\n     * @return any  The current node value.\n     */\n    DoublyLinkedList.prototype.current = function () {\n        if (this._current) {\n            return this._current.value;\n        }\n        return null;\n    };\n    /**\n     * Return current node index\n     *\n     * @method key\n     * @return any  The current node index.\n     */\n    DoublyLinkedList.prototype.key = function () {\n        return this._key;\n    };\n    /**\n     * Move to next entry\n     *\n     * @method next\n     * @return void\n     */\n    DoublyLinkedList.prototype.next = function () {\n        this._current = this._current.next;\n        this._key++;\n    };\n    /**\n     * Move to previous entry\n     *\n     * @method prev\n     * @return void\n     */\n    DoublyLinkedList.prototype.prev = function () {\n        this._current = this._current.prev;\n        this._key--;\n    };\n    /**\n     * Check whether the doubly linked list contains more nodes\n     *\n     * @method valid\n     * @return boolean true if the doubly linked list contains any more nodes, false otherwise.\n     */\n    DoublyLinkedList.prototype.valid = function () {\n        return (this._key >= 0 && this._key < this._length);\n    };\n    /**\n     * Export the list to array\n     *\n     * @method toArray\n     * @return Array   The exported array\n     */\n    DoublyLinkedList.prototype.toArray = function () {\n        var list = [];\n        var current = this._head;\n        while (current) {\n            list.push(current.value);\n            current = current.next;\n        }\n        return list;\n    };\n    /**\n     * Serializes the list to string\n     *\n     * @method toString\n     * @return string   The serialized string.\n     */\n    DoublyLinkedList.prototype.toString = function () {\n        return \"{\" + this.toArray().join(\"->\") + \"}\";\n    };\n    return DoublyLinkedList;\n})();\nmodule.exports = DoublyLinkedList;\n//# sourceMappingURL=DoublyLinkedList.js.map","/**\n * The Heap class provides the main functionality of a Heap.\n *\n * @class Heap\n */\nvar Heap = (function () {\n    function Heap() {\n        /**\n         * Binary tree storage array\n         *\n         * @property _tree\n         * @type Array\n         * @private\n         */\n        this._tree = [];\n        /**\n         * Heap type\n         *\n         * @property _type\n         * @type number\n         * @private\n         */\n        this._type = Heap.MAX;\n        /**\n         * Iteration pointer\n         *\n         * @property _key\n         * @type number\n         * @private\n         */\n        this._key = 0;\n    }\n    /**\n     * Get index of left child element in binary tree stored in array\n     *\n     * @method _child\n     * @param n\n     * @return number\n     * @private\n     */\n    Heap.prototype._child = function (n) {\n        return 2 * n + 1;\n    };\n    /**\n     * Get index of parent element in binary tree stored in array\n     *\n     * @method _parent\n     * @param n\n     * @return number\n     * @private\n     */\n    Heap.prototype._parent = function (n) {\n        //console.log('n=', n, Math.floor(n / 2));\n        return Math.floor(n / 2);\n    };\n    /**\n     * Swap 2 elements in binary tree\n     *\n     * @method _swap\n     * @param first\n     * @param second\n     * @private\n     */\n    Heap.prototype._swap = function (first, second) {\n        var swap = this._tree[first];\n        this._tree[first] = this._tree[second];\n        this._tree[second] = swap;\n    };\n    /**\n     * Sift elements in binary tree\n     *\n     * @method _siftUp\n     * @param i\n     * @private\n     */\n    Heap.prototype._siftUp = function (i) {\n        while (i > 0) {\n            var parent = this._parent(i);\n            if (this.compare(this._tree[i], this._tree[parent]) * this._type > 0) {\n                this._swap(i, parent);\n                i = parent;\n            }\n            else {\n                break;\n            }\n        }\n    };\n    /**\n     * Sift down elements in binary tree\n     *\n     * @method _siftDown\n     * @param i\n     * @private\n     */\n    Heap.prototype._siftDown = function (i) {\n        while (i < this._tree.length) {\n            var left = this._child(i);\n            var right = left + 1;\n            if ((left < this._tree.length) && (right < this._tree.length) &&\n                (this.compare(this._tree[i], this._tree[left]) * this._type < 0 ||\n                    this.compare(this._tree[i], this._tree[right]) * this._type < 0)) {\n                // there is 2 children and one of them must be swapped\n                // get correct element to sift down\n                var sift = left;\n                if (this.compare(this._tree[left], this._tree[right]) * this._type < 0) {\n                    sift = right;\n                }\n                this._swap(i, sift);\n                i = sift;\n            }\n            else if (left < this._tree.length &&\n                this.compare(this._tree[i], this._tree[left]) * this._type < 0) {\n                // only one child exists\n                this._swap(i, left);\n                i = left;\n            }\n            else {\n                break;\n            }\n        }\n    };\n    /**\n     * Extracts a node from top of the heap and sift up\n     *\n     * @method extract\n     * @return any The value of the extracted node.\n     */\n    Heap.prototype.extract = function () {\n        if (this._tree.length === 0) {\n            throw new Error(\"Can't extract from an empty data structure\");\n        }\n        var extracted = this._tree[0];\n        if (this._tree.length === 1) {\n            this._tree = [];\n        }\n        else {\n            this._tree[0] = this._tree.pop();\n            this._siftDown(0);\n        }\n        return extracted;\n    };\n    /**\n     * Inserts an element in the heap by sifting it up\n     *\n     * @method insert\n     * @param value The value to insert.\n     * @return void\n     */\n    Heap.prototype.insert = function (value) {\n        this._tree.push(value);\n        this._siftUp(this._tree.length - 1);\n    };\n    /**\n     * Peeks at the node from the top of the heap\n     *\n     * @method top\n     * @return any The value of the node on the top.\n     */\n    Heap.prototype.top = function () {\n        if (this._tree.length === 0) {\n            throw new Error(\"Can't peek at an empty heap\");\n        }\n        return this._tree[0];\n    };\n    /**\n     * Counts the number of elements in the heap\n     *\n     * @method count\n     * @return number the number of elements in the heap.\n     */\n    Heap.prototype.count = function () {\n        return this._tree.length;\n    };\n    /**\n     * Checks whether the heap is empty\n     *\n     * @method isEmpty\n     * @return boolean whether the heap is empty.\n     */\n    Heap.prototype.isEmpty = function () {\n        return (this._tree.length === 0);\n    };\n    /**\n     * Rewind iterator back to the start (no-op)\n     *\n     * @method rewind\n     * @return void\n     */\n    Heap.prototype.rewind = function () {\n        this._key = 0;\n    };\n    /**\n     * Return current node pointed by the iterator\n     *\n     * @method current\n     * @return any The current node value.\n     */\n    Heap.prototype.current = function () {\n        return this._tree[this._key];\n    };\n    /**\n     * Return current node index\n     *\n     * @method key\n     * @return any The current node index.\n     */\n    Heap.prototype.key = function () {\n        return this._key;\n    };\n    /**\n     * Move to the next node\n     *\n     * @method next\n     * @return void\n     */\n    Heap.prototype.next = function () {\n        this._key++;\n    };\n    /**\n     * Move to previous entry\n     *\n     * @method prev\n     * @return void\n     */\n    Heap.prototype.prev = function () {\n        this._key--;\n    };\n    /**\n     * Check whether the heap contains more nodes\n     *\n     * @method valid\n     * @return boolean true if the heap contains any more nodes, false otherwise.\n     */\n    Heap.prototype.valid = function () {\n        return (this._key >= 0 && this._key < this._tree.length);\n    };\n    /**\n     * Compare elements in order to place them correctly in the heap while sifting up.\n     *\n     * @method compare\n     * @param first The value of the first node being compared.\n     * @param second The value of the second node being compared.\n     * @return number Result of the comparison, positive integer if first is greater than second, 0 if they are equal, negative integer otherwise.\n     * Having multiple elements with the same value in a Heap is not recommended. They will end up in an arbitrary relative position.\n     */\n    Heap.prototype.compare = function (first, second) {\n        if (first > second) {\n            return 1;\n        }\n        else if (first == second) {\n            return 0;\n        }\n        else {\n            return -1;\n        }\n    };\n    /**\n     * Visually display heap tree\n     *\n     * @method _displayNode\n     * @param node\n     * @param prefix\n     * @param last\n     * @return String\n     * @private\n     */\n    Heap.prototype._displayNode = function (node, prefix, last) {\n        if (prefix === void 0) { prefix = ''; }\n        if (last === void 0) { last = true; }\n        var line = prefix;\n        // get child indexes\n        var left = this._child(node);\n        var right = left + 1;\n        if (last) {\n            line += (prefix ? '└─' : '  ');\n        }\n        else {\n            line += '├─';\n        }\n        line += this._tree[node];\n        prefix += (last ? '  ' : '│ ');\n        if (left < this._tree.length) {\n            line += '\\n' + this._displayNode(left, prefix, (this._tree[right] == undefined ? true : false));\n        }\n        if (right < this._tree.length) {\n            line += '\\n' + this._displayNode(right, prefix, true);\n        }\n        return line;\n    };\n    /**\n     * Serializes the heap to string\n     *\n     * @method toString\n     * @return string   The serialized string.\n     */\n    Heap.prototype.toString = function () {\n        // start with root and recursively goes to each node\n        return this._displayNode(0);\n    };\n    /**\n     * Serializes the heap to array\n     *\n     * @method toArray\n     * @return Array   The serialized array.\n     */\n    Heap.prototype.toArray = function () {\n        return this._tree;\n    };\n    /**\n     * Max heap flag\n     *\n     * @property MAX\n     * @type number\n     * @static\n     */\n    Heap.MAX = 1;\n    /**\n     * Min heap flag\n     *\n     * @property MIN\n     * @type number\n     * @static\n     */\n    Heap.MIN = -1;\n    return Heap;\n})();\nmodule.exports = Heap;\n//# sourceMappingURL=Heap.js.map","var __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\nvar Heap = require('./Heap');\n/**\n * The MaxHeap class provides the main functionality of a heap, keeping the maximum on the top.\n *\n * @class MaxHeap\n * @extends Heap\n */\nvar MaxHeap = (function (_super) {\n    __extends(MaxHeap, _super);\n    function MaxHeap() {\n        _super.apply(this, arguments);\n        this._type = Heap.MAX;\n    }\n    return MaxHeap;\n})(Heap);\nmodule.exports = MaxHeap;\n//# sourceMappingURL=MaxHeap.js.map","var __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\nvar Heap = require('./Heap');\n/**\n * The MinHeap class provides the main functionality of a heap, keeping the minimum on the top.\n *\n * @class MinHeap\n * @extends Heap\n */\nvar MinHeap = (function (_super) {\n    __extends(MinHeap, _super);\n    function MinHeap() {\n        _super.apply(this, arguments);\n        this._type = Heap.MIN;\n    }\n    return MinHeap;\n})(Heap);\nmodule.exports = MinHeap;\n//# sourceMappingURL=MinHeap.js.map","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Heap = require('./Heap');\n/**\n * The PriorityQueue class provides the main functionality of an prioritized queue, implemented using a max heap.\n *\n * @class PriorityQueue\n * @extends Heap\n */\nvar PriorityQueue = (function (_super) {\n    __extends(PriorityQueue, _super);\n    function PriorityQueue() {\n        _super.apply(this, arguments);\n        this._type = Heap.MAX;\n    }\n    /**\n     * Adds an element to the queue\n     *\n     * @method enqueue\n     * @param value The value to enqueue.\n     * @param priority The priority of value.\n     * @return void\n     */\n    PriorityQueue.prototype.enqueue = function (value, priority) {\n        return this.insert(new PriorityQueueNode(value, priority));\n    };\n    /**\n     * Dequeues a node from the queue\n     *\n     * @method dequeue\n     * @return any  The value of the dequeued node.\n     */\n    PriorityQueue.prototype.dequeue = function () {\n        return this.extract().value;\n    };\n    /**\n     * Peeks at the node from the top of the heap\n     *\n     * @method top\n     * @return any The value of the node on the top.\n     */\n    PriorityQueue.prototype.top = function () {\n        return _super.prototype.top.call(this).value;\n    };\n    /**\n     * Compare elements in order to place them correctly in the heap while sifting up.\n     *\n     * @method compare\n     * @param first The value of the first node being compared.\n     * @param second The value of the second node being compared.\n     * @return number Result of the comparison, positive integer if first is greater than second, 0 if they are equal, negative integer otherwise.\n     * Having multiple elements with the same value in a Heap is not recommended. They will end up in an arbitrary relative position.\n     */\n    PriorityQueue.prototype.compare = function (first, second) {\n        if (first.priority > second.priority) {\n            return 1;\n        }\n        else if (first.priority == second.priority) {\n            return 0;\n        }\n        else {\n            return -1;\n        }\n    };\n    return PriorityQueue;\n})(Heap);\n/**\n * PriorityQueue Node\n *\n * @class PriorityQueueNode\n */\nvar PriorityQueueNode = (function () {\n    /**\n     * Constructor\n     *\n     * @method constructor\n     * @param value\n     * @param priority\n     */\n    function PriorityQueueNode(value, priority) {\n        this.value = value;\n        this.priority = priority;\n    }\n    /**\n     * Serializes the node to string\n     *\n     * @method toString\n     * @return string   The serialized string.\n     */\n    PriorityQueueNode.prototype.toString = function () {\n        return this.value + \" [\" + this.priority + \"]\";\n    };\n    return PriorityQueueNode;\n})();\nmodule.exports = PriorityQueue;\n//# sourceMappingURL=PriorityQueue.js.map","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DoublyLinkedList = require('./DoublyLinkedList');\n/**\n * The Queue class provides the main functionality of a queue implemented using a doubly linked list.\n *\n * @class Queue\n * @extends DoublyLinkedList\n */\nvar Queue = (function (_super) {\n    __extends(Queue, _super);\n    function Queue() {\n        _super.apply(this, arguments);\n    }\n    /**\n     * Adds an element to the queue\n     *\n     * @method enqueue\n     * @param value The value to enqueue.\n     * @return void\n     */\n    Queue.prototype.enqueue = function (value) {\n        return this.push(value);\n    };\n    /**\n     * Dequeues a node from the queue\n     *\n     * @method dequeue\n     * @return any  The value of the dequeued node.\n     */\n    Queue.prototype.dequeue = function () {\n        return this.shift();\n    };\n    return Queue;\n})(DoublyLinkedList);\nmodule.exports = Queue;\n//# sourceMappingURL=Queue.js.map","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DoublyLinkedList = require('./DoublyLinkedList');\n/**\n * The Stack class provides the main functionality of a stack implemented using a doubly linked list.\n *\n * @class Stack\n * @extends DoublyLinkedList\n */\nvar Stack = (function (_super) {\n    __extends(Stack, _super);\n    function Stack() {\n        _super.apply(this, arguments);\n    }\n    return Stack;\n})(DoublyLinkedList);\nmodule.exports = Stack;\n//# sourceMappingURL=Stack.js.map","/**\n * STL\n * @type {{DoublyLinkedList: exports, Stack: exports, Queue: exports, Heap: exports, MaxHeap: exports, MinHeap: exports, PriorityQueue: exports}}\n */\nmodule.exports = {\n\tDoublyLinkedList: require('./Datastructures/DoublyLinkedList'),\n\tStack: require('./Datastructures/Stack'),\n\tQueue: require('./Datastructures/Queue'),\n\tHeap: require('./Datastructures/Heap'),\n\tMaxHeap: require('./Datastructures/MaxHeap'),\n\tMinHeap: require('./Datastructures/MinHeap'),\n\tPriorityQueue: require('./Datastructures/PriorityQueue')\n};","import { manhattanDistance } from './other/helperFunctions';\nimport MapWithDefaultValue from './other/mapWithDefaultValue';\n\nimport { PriorityQueue } from 'libstl'; // note: imported from a node module\n\n/** @module findPath */\n\n/**\n * Heavily modified implementation of the A* algorithm\n * @param  {Object} start object containing numeric attributes `x` and `y` that represent the first endpoint of the wire in grid pixels\n * @param  {Object} end   object containing numeric attributes `x` and `y` that represent the second endpoint of the wire in grid pixels\n * @param  {Set} nonRoutable set of non routable nodes\n * @param  {Set} punishedButRoutable set of nodes that are not optimal for routing\n * @return {Array} array of objects containing numeric attributes `x` and `y`\n */\nexport default function findPath(start, end, nonRoutable, punishedButRoutable) {\n    const distanceFunction = manhattanDistance;\n\n    const wireCrossPunishment = 1;\n    const wireBendPunishment = 1;\n\n    // number of nodes, that can be opened at once\n    // once is this limit exceeded, aStar will fail and return undefined\n    const maxNodeLimit = 100000;\n\n    let closedNodes = new Set();\n    let openNodes = new Set();\n    let openNodeQueue = new PriorityQueue();\n\n    // functions for working with open nodes:\n\n    /**\n     * add a new open node to the structure\n     * @param {Object} node   object containing numeric attributes `x` and `y` that represent the first endpoint of the wire\n     * @param {number} fscore fScore of this node\n     */\n    const addOpenNode = (node, fscore) => {\n        openNodes.add(node);\n        // flip the fscore, because PriorityQueue uses max heap\n        openNodeQueue.enqueue(node, 1 / fscore);\n    };\n\n    /**\n     * get the open node with the lowest fScore and remove it\n     * @return {Object} object containing numeric attributes `x` and `y` that represent the first endpoint of the wire\n     */\n    const getOpenNode = () => {\n        const node = openNodeQueue.dequeue();\n        openNodes.delete(node);\n        return node;\n    };\n\n    let cameFrom = new Map();\n\n    // default value: infinity\n    let gScore = new MapWithDefaultValue(Infinity);\n    gScore.set(start, 0);\n\n    let startFScore = distanceFunction(start, end);\n\n    addOpenNode(start, startFScore);\n\n    openNodes.add(start);\n    openNodeQueue.enqueue(start, 1 / startFScore);\n\n    while (openNodes.size > 0) {\n        // get the value from openNodes that has the lowest fScore\n        const currentNode = getOpenNode();\n\n        // if we reached the end point, reconstruct the path and return it\n        if (currentNode.x == end.x && currentNode.y == end.y) {\n            return reconstructPath(cameFrom, currentNode);\n        }\n\n        // add this node to the closed nodes\n        closedNodes.add(currentNode);\n\n        // the farthest points accessible without avoiding obstacles in every direction\n        // (but max 50 in each direction)\n        for (let direction = 0; direction < 4; direction++) {\n            let newPoint = movePoint(currentNode, direction);\n\n            let wiresCrossed = 0;\n\n            for (let i = 0; i < 50; i++) {\n                // if newPoint is in the set of non routable points,\n                // don't add it and stop proceeding in this direction\n                if (setHasThisPoint(nonRoutable, newPoint)) {\n                    // if this not the end or start point, break\n                    if (\n                        !(newPoint.x === end.x && newPoint.y === end.y) &&\n                        !(newPoint.x === start.x && newPoint.y === start.y)\n                    ) {\n                        break;\n                    }\n                }\n\n                // skip this node, if it has been already closed\n                // or if it is on the list of non routable nodes\n                if (closedNodes.has(newPoint)) {\n                    continue;\n                }\n\n                // calculate possible GScore by applying a punishment for each node (\"bend\") in the path\n                let newGScore = wireBendPunishment + gScore.getWithDefault(currentNode);\n\n                if (setHasThisPoint(punishedButRoutable, newPoint)) {\n                    // if the node is in the set of punished nodes, apply the punishment\n                    wiresCrossed++;\n                }\n\n                // apply the punishment for each wire crossed in this direction\n                // note: we are counting the wires crossed when exporting this direction, not the wires\n                // crossed in the final path, there will be probably only at most of these nodes in the\n                // final path, not multiple\n                newGScore += wiresCrossed * wireCrossPunishment;\n\n                // skip this node if it has worst estimage gscore than in the gscore table\n                if (newGScore >= gScore.getWithDefault(newPoint)) {\n                    continue;\n                }\n\n                cameFrom.set(newPoint, currentNode);\n                gScore.set(newPoint, newGScore);\n\n                const newFScore = newGScore + distanceFunction(newPoint, end);\n\n                if (!openNodes.has(newPoint)) {\n                    // add the point to the list of points\n                    addOpenNode(newPoint, newFScore);\n                }\n\n                // move to the next point in the direciton\n                newPoint = movePoint(newPoint, direction);\n            }\n        }\n\n        if (openNodes.size > maxNodeLimit) {\n            console.log(\n                `aStar: Number of open nodes (${\n                    openNodes.size\n                }) exceeded the limit for open nodes (${maxNodeLimit}).`\n            );\n            break;\n        }\n    }\n    // if we got here, the path was not found\n\n    return undefined;\n}\n\n/**\n * returns `true` if the specified set of points contains the specified point (and returns `false` otherwise)\n * @param {Set} set set of points\n * @param {Object} point object containing numeric attributes `x` and `y`\n */\nfunction setHasThisPoint(set, point) {\n    for (let item of set) {\n        if (item.x === point.x && item.y === point.y) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Helper that moves the passed point in the specified direction. It simply adds or subtracts 1 from one of the coordinates depending on the direction attribute.\n * @param  {Object} point     object containing numeric attributes `x` and `y`\n * @param  {number} direction directions:\n *     - 0: up\n *     - 1: right\n *     - 2: down\n *     - 3: left\n * @return {Object}           object containing numeric attributes `x` and `y`\n */\nfunction movePoint({ x, y }, direction) {\n    // map direction do point coordinate modification\n    const dirMap = {\n        0: () => {\n            y -= 1;\n        },\n        1: () => {\n            x += 1;\n        },\n        2: () => {\n            y += 1;\n        },\n        3: () => {\n            x -= 1;\n        }\n    };\n\n    dirMap[direction]();\n\n    return { x, y };\n}\n\n/**\n * helper backtracking function used by the aStar algorithm to construct the final path\n * @param  {Object} cameFrom    object containing numeric attributes `x` and `y`\n * @param  {Object} currentNode object containing numeric attributes `x` and `y`\n * @return {Array} array of objects containing numeric attributes `x` and `y`\n */\nfunction reconstructPath(cameFrom, currentNode) {\n    let path = [];\n\n    path.push({\n        x: currentNode.x,\n        y: currentNode.y\n    });\n\n    while (cameFrom.has(currentNode)) {\n        currentNode = cameFrom.get(currentNode);\n        path.push({\n            x: currentNode.x,\n            y: currentNode.y\n        });\n    }\n\n    return path;\n}\n","/**\n * @module HelperFunctions\n */\n\nimport stringify from 'json-stringify-pretty-compact'; // note: imported from a module\n\n/**\n * add a cross browser event listener on a mouse scroll\n * @param {string} query DOM query of the element that the listener will be added to\n * @param {Function} func  Function that will be called when the event occurs. The function takes as a parameter an event object.\n */\nexport function addMouseScrollEventListener(query, func) {\n    let MouseWheelHandler = event => {\n        // redeclare for old IE support\n        var event = window.event || event; // eslint-disable-line no-redeclare\n\n        event.delta = Math.max(-1, Math.min(1, event.wheelDelta || -event.detail));\n\n        func(event);\n\n        return false;\n    };\n\n    let svgelement;\n\n    // if the query is a simple DOM id selector, we can use getElementById which has better backwards compatibility\n    if (query.match(/^#\\w+$/)) {\n        svgelement = document.getElementById(query.substr(1));\n    } else {\n        svgelement = document.querySelector(query);\n    }\n\n    if (svgelement.addEventListener) {\n        // IE9, Chrome, Safari, Opera\n        svgelement.addEventListener('mousewheel', MouseWheelHandler, false);\n        // Firefox\n        svgelement.addEventListener('DOMMouseScroll', MouseWheelHandler, false);\n    } else {\n        // IE 6/7/8\n        svgelement.attachEvent('onmousewheel', MouseWheelHandler);\n    }\n    svgelement.addEventListener(\n        'mousewheel',\n        function(e) {\n            console.log('event', e);\n        },\n        false\n    );\n}\n\n/**\n * convert a data object to JSON string or to a data URI containing a JSON string\n * @param  {Object}  data            object that will be serialized into a JSON string\n * @param  {Boolean} [pretty=false]  if `true`, the code will be proprerly indented, else a more compact syntax will be used\n * @param  {Boolean} [dataUri=false] return dataUri containing the JSON string instead of the pure JSON string\n * @return {string}\n */\nexport function getJSONString(data, pretty = false, dataUri = false) {\n    if (dataUri) {\n        return (\n            'data:application/json;charset=utf-8,' + encodeURIComponent(getJSONString(data, pretty))\n        );\n    } else {\n        if (pretty) return stringify(data, { maxLength: 50 });\n\n        return JSON.stringify(data);\n    }\n}\n\n/**\n * returns the Manhattan distance between the points _a_ and _b_\n * @param  {Object} a object containing numeric attributes `x` and `y`\n * @param  {Object} b object containing numeric attributes `x` and `y`\n * @return {number}\n */\nexport function manhattanDistance(a, b) {\n    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\n}\n","/** @module MapWithDefaultValue */\n/**\n * Map that has a default value specified in the constructor.\n *\n * For the complete documentation of the Map see [Map in the MDN web docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\n *\n * Usage:\n * ```JavaScript\n let myMap = new MapWithDefaultValue(Infinity);\n const value = myMap.getWithDefault(key)\n ```\n *\n * _Note: This version is written specially for ES6 compiled into ES5. In non-compiled ES6 is the implementation far more elegant:_\n *\n * ```JavaScript\n export class MapWithDefaultValue extends Map {\n     constructor(defaultValue) {\n         super();\n\n         this.default = defaultValue;\n     }\n\n     get(key) {\n         if(this.has(key)) {\n             return super.get(key);\n         } else {\n             return this.default;\n         }\n     }\n }```\n * @class MapWithDefaultValue\n * @param defaultValue {any} default value that will be returned when the requested key is not found in the map\n */\nexport default function(defaultValue) {\n    let map = new Map();\n    /**\n     * @param  {any} key key of a requested item\n     * @return {any} value of the item with the corresponding key, or defaultValue if the key is not found in the map\n     */\n    map.getWithDefault = key => {\n        return map.has(key) ? map.get(key) : defaultValue;\n    };\n    return map;\n}\n","'use strict';\n\n/** @module routeWorker */\n\nimport findPath from './modules/findPath';\n\n/**\n * callback when a message is sent to the web worker\n *\n * @param {Object} event web worker event object (the `data` item of the event object is expected to contain\n *                       these items: `wires` (array), `nonRoutableNodes` (iterable) and `inconvenientNodes` (iterable))\n */\nonmessage = event => {\n    const { wires, nonRoutableNodes, inconvenientNodes } = event.data;\n\n    const paths = findPaths(wires, nonRoutableNodes, inconvenientNodes);\n\n    postMessage({ paths });\n    close();\n};\n\n/**\n * find paths for all the specified wires\n * @param  {Array} wires              array of objects with attributes `from` and `to`, both of them which are objects\n *                                    with values `x` and `y` containing coordinates of the wire endpoints\n * @param  {Iterable} nonRoutableNodes  Set or array of non routable nodes\n * @param  {Iterable} inconvenientNodes Set or array of inconvenient nodes\n * @return {Array}                    array of paths, each item is an array of points of the path\n *                                    the returned array contains paths for the wires with corresponding indexes from the `wires` parameter\n */\nfunction findPaths(wires, nonRoutableNodes, inconvenientNodes) {\n    let paths = [];\n\n    for (const [from, to] of wires) {\n        const path = findPath(from, to, nonRoutableNodes, inconvenientNodes);\n\n        if (!path) {\n            console.log('path not found');\n            console.log(from, to);\n        } else {\n            console.log('path found');\n        }\n\n        paths.push(path);\n\n        // add new inconvenient nodes created by this new path\n        let prevPoint;\n        for (const point of path) {\n            if (prevPoint) {\n                if (point.x === prevPoint.x) {\n                    // horizontal section of the path\n                    for (\n                        let y = Math.min(point.y, prevPoint.y);\n                        y <= Math.max(point.y, prevPoint.y);\n                        ++y\n                    ) {\n                        inconvenientNodes.add({\n                            x: point.x,\n                            y: y\n                        });\n                    }\n                } else if (point.y === prevPoint.y) {\n                    // vertical section of the path\n                    for (\n                        let x = Math.min(point.x, prevPoint.x);\n                        x <= Math.max(point.x, prevPoint.x);\n                        ++x\n                    ) {\n                        inconvenientNodes.add({\n                            x: x,\n                            y: point.y\n                        });\n                    }\n                }\n            }\n\n            prevPoint = point;\n        }\n    }\n\n    return paths;\n}\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvanNvbi1zdHJpbmdpZnktcHJldHR5LWNvbXBhY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL0RvdWJseUxpbmtlZExpc3QuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL0hlYXAuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL01heEhlYXAuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL01pbkhlYXAuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL1ByaW9yaXR5UXVldWUuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL1F1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL2xpYnN0bC9EYXRhc3RydWN0dXJlcy9TdGFjay5qcyIsIm5vZGVfbW9kdWxlcy9saWJzdGwvbm9kZS1tb2R1bGUuanMiLCJzcmMvZXM2L21vZHVsZXMvZmluZFBhdGguanMiLCJzcmMvZXM2L21vZHVsZXMvb3RoZXIvaGVscGVyRnVuY3Rpb25zLmpzIiwic3JjL2VzNi9tb2R1bGVzL290aGVyL21hcFdpdGhEZWZhdWx0VmFsdWUuanMiLCJzcmMvZXM2L3JvdXRlV29ya2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O2tCQ0d3QixROztBQWZ4Qjs7QUFDQTs7OztBQUVBOzs7O0FBQXdDOztBQUV4Qzs7QUFFQTs7Ozs7Ozs7QUFRZSxTQUFTLFFBQVQsQ0FBa0IsS0FBbEIsRUFBeUIsR0FB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ZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiZnVuY3Rpb24gc3RyaW5naWZ5IChvYmosIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdmFyIGluZGVudCA9IEpTT04uc3RyaW5naWZ5KFsxXSwgbnVsbCwgZ2V0KG9wdGlvbnMsICdpbmRlbnQnLCAyKSkuc2xpY2UoMiwgLTMpXG4gIHZhciBhZGRNYXJnaW4gPSBnZXQob3B0aW9ucywgJ21hcmdpbnMnLCBmYWxzZSlcbiAgdmFyIG1heExlbmd0aCA9IChpbmRlbnQgPT09ICcnID8gSW5maW5pdHkgOiBnZXQob3B0aW9ucywgJ21heExlbmd0aCcsIDgwKSlcblxuICByZXR1cm4gKGZ1bmN0aW9uIF9zdHJpbmdpZnkgKG9iaiwgY3VycmVudEluZGVudCwgcmVzZXJ2ZWQpIHtcbiAgICBpZiAob2JqICYmIHR5cGVvZiBvYmoudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvYmogPSBvYmoudG9KU09OKClcbiAgICB9XG5cbiAgICB2YXIgc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkob2JqKVxuXG4gICAgaWYgKHN0cmluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gc3RyaW5nXG4gICAgfVxuXG4gICAgdmFyIGxlbmd0aCA9IG1heExlbmd0aCAtIGN1cnJlbnRJbmRlbnQubGVuZ3RoIC0gcmVzZXJ2ZWRcblxuICAgIGlmIChzdHJpbmcubGVuZ3RoIDw9IGxlbmd0aCkge1xuICAgICAgdmFyIHByZXR0aWZpZWQgPSBwcmV0dGlmeShzdHJpbmcsIGFkZE1hcmdpbilcbiAgICAgIGlmIChwcmV0dGlmaWVkLmxlbmd0aCA8PSBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHByZXR0aWZpZWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmV4dEluZGVudCA9IGN1cnJlbnRJbmRlbnQgKyBpbmRlbnRcbiAgICAgIHZhciBpdGVtcyA9IFtdXG4gICAgICB2YXIgZGVsaW1pdGVyc1xuICAgICAgdmFyIGNvbW1hID0gZnVuY3Rpb24gKGFycmF5LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gKGluZGV4ID09PSBhcnJheS5sZW5ndGggLSAxID8gMCA6IDEpXG4gICAgICB9XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IG9iai5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKFxuICAgICAgICAgICAgX3N0cmluZ2lmeShvYmpbaW5kZXhdLCBuZXh0SW5kZW50LCBjb21tYShvYmosIGluZGV4KSkgfHwgJ251bGwnXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGRlbGltaXRlcnMgPSAnW10nXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSwgaW5kZXgsIGFycmF5KSB7XG4gICAgICAgICAgdmFyIGtleVBhcnQgPSBKU09OLnN0cmluZ2lmeShrZXkpICsgJzogJ1xuICAgICAgICAgIHZhciB2YWx1ZSA9IF9zdHJpbmdpZnkob2JqW2tleV0sIG5leHRJbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlQYXJ0Lmxlbmd0aCArIGNvbW1hKGFycmF5LCBpbmRleCkpXG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goa2V5UGFydCArIHZhbHVlKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgZGVsaW1pdGVycyA9ICd7fSdcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBkZWxpbWl0ZXJzWzBdLFxuICAgICAgICAgIGluZGVudCArIGl0ZW1zLmpvaW4oJyxcXG4nICsgbmV4dEluZGVudCksXG4gICAgICAgICAgZGVsaW1pdGVyc1sxXVxuICAgICAgICBdLmpvaW4oJ1xcbicgKyBjdXJyZW50SW5kZW50KVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmdcbiAgfShvYmosICcnLCAwKSlcbn1cblxuLy8gTm90ZTogVGhpcyByZWdleCBtYXRjaGVzIGV2ZW4gaW52YWxpZCBKU09OIHN0cmluZ3MsIGJ1dCBzaW5jZSB3ZeKAmXJlXG4vLyB3b3JraW5nIG9uIHRoZSBvdXRwdXQgb2YgYEpTT04uc3RyaW5naWZ5YCB3ZSBrbm93IHRoYXQgb25seSB2YWxpZCBzdHJpbmdzXG4vLyBhcmUgcHJlc2VudCAodW5sZXNzIHRoZSB1c2VyIHN1cHBsaWVkIGEgd2VpcmQgYG9wdGlvbnMuaW5kZW50YCBidXQgaW5cbi8vIHRoYXQgY2FzZSB3ZSBkb27igJl0IGNhcmUgc2luY2UgdGhlIG91dHB1dCB3b3VsZCBiZSBpbnZhbGlkIGFueXdheSkuXG52YXIgc3RyaW5nT3JDaGFyID0gLyhcIig/OlteXFxcXFwiXXxcXFxcLikqXCIpfFs6LFxcXVt9e10vZ1xuXG5mdW5jdGlvbiBwcmV0dGlmeSAoc3RyaW5nLCBhZGRNYXJnaW4pIHtcbiAgdmFyIG0gPSBhZGRNYXJnaW4gPyAnICcgOiAnJ1xuICB2YXIgdG9rZW5zID0ge1xuICAgICd7JzogJ3snICsgbSxcbiAgICAnWyc6ICdbJyArIG0sXG4gICAgJ30nOiBtICsgJ30nLFxuICAgICddJzogbSArICddJyxcbiAgICAnLCc6ICcsICcsXG4gICAgJzonOiAnOiAnXG4gIH1cbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHN0cmluZ09yQ2hhciwgZnVuY3Rpb24gKG1hdGNoLCBzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nID8gbWF0Y2ggOiB0b2tlbnNbbWF0Y2hdXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGdldCAob3B0aW9ucywgbmFtZSwgZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiAobmFtZSBpbiBvcHRpb25zID8gb3B0aW9uc1tuYW1lXSA6IGRlZmF1bHRWYWx1ZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdpZnlcbiIsIi8qKlxuICogVGhlIERvdWJseUxpbmtlZExpc3QgY2xhc3MgcHJvdmlkZXMgdGhlIG1haW4gZnVuY3Rpb25hbGl0eSBvZiBhIGRvdWJseSBsaW5rZWQgbGlzdC5cbiAqXG4gKiBAY2xhc3MgRG91Ymx5TGlua2VkTGlzdFxuICovXG52YXIgRG91Ymx5TGlua2VkTGlzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRG91Ymx5TGlua2VkTGlzdCgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvdW50IG9mIGVsZW1lbnRzIGluIGxpc3RcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IF9sZW5ndGhcbiAgICAgICAgICogQHR5cGUgbnVtYmVyXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogSXRlcmF0aW9uIHBvaW50ZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IF9rZXlcbiAgICAgICAgICogQHR5cGUgbnVtYmVyXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9rZXkgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIGhlYWQoZmlyc3QpIGVsZW1lbnQgaW4gbGlzdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgX2hlYWRcbiAgICAgICAgICogQHR5cGUgRG91Ymx5TGlua2VkTGlzdE5vZGVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hlYWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIHRhaWwobGFzdCkgZWxlbWVudCBpbiBsaXN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfdGFpbFxuICAgICAgICAgKiBAdHlwZSBEb3VibHlMaW5rZWRMaXN0Tm9kZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdGFpbCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gaXRlcmF0ZWQgZWxlbWVudCBpbiBsaXN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfY3VycmVudFxuICAgICAgICAgKiBAdHlwZSBEb3VibHlMaW5rZWRMaXN0Tm9kZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydCBhIG5ldyB2YWx1ZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGFkZFxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggd2hlcmUgdGhlIG5ldyB2YWx1ZSBpcyB0byBiZSBpbnNlcnRlZC5cbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIGluZGV4LlxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk91dCBvZiBib3VuZHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIHdoaWxlIChpIDwgaW5kZXgpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudC52YWx1ZSA9IHZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUG9wcyBhIG5vZGUgZnJvbSB0aGUgZW5kIG9mIHRoZSBkb3VibHkgbGlua2VkIGxpc3RcbiAgICAgKlxuICAgICAqIEBtZXRob2QgcG9wXG4gICAgICogQHJldHVybiBhbnkgIFRoZSB2YWx1ZSBvZiB0aGUgcG9wcGVkIG5vZGUuXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwb3AgZnJvbSBhbiBlbXB0eSBkYXRhIHN0cnVjdHVyZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl90YWlsLnZhbHVlO1xuICAgICAgICB0aGlzLl90YWlsID0gdGhpcy5fdGFpbC5wcmV2O1xuICAgICAgICBpZiAodGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3RhaWwubmV4dDtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwubmV4dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGVuZ3RoLS07XG4gICAgICAgIGlmICh0aGlzLl9sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9oZWFkO1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2hpZnRzIGEgbm9kZSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRvdWJseSBsaW5rZWQgbGlzdFxuICAgICAqXG4gICAgICogQG1ldGhvZCBzaGlmdFxuICAgICAqIEByZXR1cm4gYW55ICBUaGUgdmFsdWUgb2YgdGhlIHNoaWZ0ZWQgbm9kZS5cbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgc2hpZnQgZnJvbSBhbiBlbXB0eSBkYXRhIHN0cnVjdHVyZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9oZWFkLnZhbHVlO1xuICAgICAgICB0aGlzLl9oZWFkID0gdGhpcy5faGVhZC5uZXh0O1xuICAgICAgICBpZiAodGhpcy5faGVhZCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2hlYWQucHJldjtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQucHJldiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGVuZ3RoLS07XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhbiBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIGRvdWJseSBsaW5rZWQgbGlzdFxuICAgICAqXG4gICAgICogQG1ldGhvZCBwdXNoXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBwdXNoLlxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gYWxsb2NhdGUgbmV3IG5vZGVcbiAgICAgICAgdmFyIG5vZGUgPSB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBwcmV2OiB0aGlzLl90YWlsLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5fbGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gdGhpcy5fdGFpbCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90YWlsLm5leHQgPSBub2RlO1xuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IHRoaXMuX3RhaWwubmV4dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sZW5ndGgrKztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByZXBlbmRzIHRoZSBkb3VibHkgbGlua2VkIGxpc3Qgd2l0aCBhbiBlbGVtZW50XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHVuc2hpZnRcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHVuc2hpZnQuXG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBhbGxvY2F0ZSBuZXcgbm9kZVxuICAgICAgICB2YXIgbm9kZSA9IHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHByZXY6IG51bGwsXG4gICAgICAgICAgICBuZXh0OiB0aGlzLl9oZWFkXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLl9sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSB0aGlzLl90YWlsID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQucHJldiA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gdGhpcy5faGVhZC5wcmV2O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xlbmd0aCsrO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGVla3MgYXQgdGhlIG5vZGUgZnJvbSB0aGUgZW5kIG9mIHRoZSBkb3VibHkgbGlua2VkIGxpc3RcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9wXG4gICAgICogQHJldHVybiBhbnkgIFRoZSB2YWx1ZSBvZiB0aGUgbGFzdCBub2RlLlxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLnRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RhaWwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGFpbC52YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBlZWtzIGF0IHRoZSBub2RlIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgZG91Ymx5IGxpbmtlZCBsaXN0XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGJvdHRvbVxuICAgICAqIEByZXR1cm4gYW55ICBUaGUgdmFsdWUgb2YgdGhlIGZpcnN0IG5vZGUuXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUuYm90dG9tID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5faGVhZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWFkLnZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ291bnRzIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGRvdWJseSBsaW5rZWQgbGlzdFxuICAgICAqXG4gICAgICogQG1ldGhvZCBjb3VudFxuICAgICAqIEByZXR1cm4gbnVtYmVyIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGRvdWJseSBsaW5rZWQgbGlzdC5cbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBkb3VibHkgbGlua2VkIGxpc3QgaXMgZW1wdHlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgaXNFbXB0eVxuICAgICAqIEByZXR1cm4gYm9vbGVhbiB3aGV0aGVyIHRoZSBkb3VibHkgbGlua2VkIGxpc3QgaXMgZW1wdHkuXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9sZW5ndGggPT09IDApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV3aW5kIGl0ZXJhdG9yIGJhY2sgdG8gdGhlIHN0YXJ0XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHJld2luZFxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLnJld2luZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fa2V5ID0gMDtcbiAgICAgICAgdGhpcy5fY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gY3VycmVudCBsaXN0IGVudHJ5XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGN1cnJlbnRcbiAgICAgKiBAcmV0dXJuIGFueSAgVGhlIGN1cnJlbnQgbm9kZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnQudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gY3VycmVudCBub2RlIGluZGV4XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGtleVxuICAgICAqIEByZXR1cm4gYW55ICBUaGUgY3VycmVudCBub2RlIGluZGV4LlxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLmtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1vdmUgdG8gbmV4dCBlbnRyeVxuICAgICAqXG4gICAgICogQG1ldGhvZCBuZXh0XG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudCA9IHRoaXMuX2N1cnJlbnQubmV4dDtcbiAgICAgICAgdGhpcy5fa2V5Kys7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNb3ZlIHRvIHByZXZpb3VzIGVudHJ5XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHByZXZcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fY3VycmVudC5wcmV2O1xuICAgICAgICB0aGlzLl9rZXktLTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGRvdWJseSBsaW5rZWQgbGlzdCBjb250YWlucyBtb3JlIG5vZGVzXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHZhbGlkXG4gICAgICogQHJldHVybiBib29sZWFuIHRydWUgaWYgdGhlIGRvdWJseSBsaW5rZWQgbGlzdCBjb250YWlucyBhbnkgbW9yZSBub2RlcywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLnZhbGlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2tleSA+PSAwICYmIHRoaXMuX2tleSA8IHRoaXMuX2xlbmd0aCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeHBvcnQgdGhlIGxpc3QgdG8gYXJyYXlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9BcnJheVxuICAgICAqIEByZXR1cm4gQXJyYXkgICBUaGUgZXhwb3J0ZWQgYXJyYXlcbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGlzdCA9IFtdO1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICBsaXN0LnB1c2goY3VycmVudC52YWx1ZSk7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgbGlzdCB0byBzdHJpbmdcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9TdHJpbmdcbiAgICAgKiBAcmV0dXJuIHN0cmluZyAgIFRoZSBzZXJpYWxpemVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwie1wiICsgdGhpcy50b0FycmF5KCkuam9pbihcIi0+XCIpICsgXCJ9XCI7XG4gICAgfTtcbiAgICByZXR1cm4gRG91Ymx5TGlua2VkTGlzdDtcbn0pKCk7XG5tb2R1bGUuZXhwb3J0cyA9IERvdWJseUxpbmtlZExpc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Eb3VibHlMaW5rZWRMaXN0LmpzLm1hcCIsIi8qKlxuICogVGhlIEhlYXAgY2xhc3MgcHJvdmlkZXMgdGhlIG1haW4gZnVuY3Rpb25hbGl0eSBvZiBhIEhlYXAuXG4gKlxuICogQGNsYXNzIEhlYXBcbiAqL1xudmFyIEhlYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhlYXAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCaW5hcnkgdHJlZSBzdG9yYWdlIGFycmF5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfdHJlZVxuICAgICAgICAgKiBAdHlwZSBBcnJheVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdHJlZSA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogSGVhcCB0eXBlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfdHlwZVxuICAgICAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3R5cGUgPSBIZWFwLk1BWDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0ZXJhdGlvbiBwb2ludGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfa2V5XG4gICAgICAgICAqIEB0eXBlIG51bWJlclxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fa2V5ID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGluZGV4IG9mIGxlZnQgY2hpbGQgZWxlbWVudCBpbiBiaW5hcnkgdHJlZSBzdG9yZWQgaW4gYXJyYXlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2NoaWxkXG4gICAgICogQHBhcmFtIG5cbiAgICAgKiBAcmV0dXJuIG51bWJlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUuX2NoaWxkID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIDIgKiBuICsgMTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBpbmRleCBvZiBwYXJlbnQgZWxlbWVudCBpbiBiaW5hcnkgdHJlZSBzdG9yZWQgaW4gYXJyYXlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3BhcmVudFxuICAgICAqIEBwYXJhbSBuXG4gICAgICogQHJldHVybiBudW1iZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLl9wYXJlbnQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICAvL2NvbnNvbGUubG9nKCduPScsIG4sIE1hdGguZmxvb3IobiAvIDIpKTtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobiAvIDIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3dhcCAyIGVsZW1lbnRzIGluIGJpbmFyeSB0cmVlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9zd2FwXG4gICAgICogQHBhcmFtIGZpcnN0XG4gICAgICogQHBhcmFtIHNlY29uZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUuX3N3YXAgPSBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICB2YXIgc3dhcCA9IHRoaXMuX3RyZWVbZmlyc3RdO1xuICAgICAgICB0aGlzLl90cmVlW2ZpcnN0XSA9IHRoaXMuX3RyZWVbc2Vjb25kXTtcbiAgICAgICAgdGhpcy5fdHJlZVtzZWNvbmRdID0gc3dhcDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNpZnQgZWxlbWVudHMgaW4gYmluYXJ5IHRyZWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3NpZnRVcFxuICAgICAqIEBwYXJhbSBpXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5fc2lmdFVwID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgd2hpbGUgKGkgPiAwKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50KGkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFyZSh0aGlzLl90cmVlW2ldLCB0aGlzLl90cmVlW3BhcmVudF0pICogdGhpcy5fdHlwZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zd2FwKGksIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgaSA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTaWZ0IGRvd24gZWxlbWVudHMgaW4gYmluYXJ5IHRyZWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3NpZnREb3duXG4gICAgICogQHBhcmFtIGlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLl9zaWZ0RG93biA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5fdHJlZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy5fY2hpbGQoaSk7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIGlmICgobGVmdCA8IHRoaXMuX3RyZWUubGVuZ3RoKSAmJiAocmlnaHQgPCB0aGlzLl90cmVlLmxlbmd0aCkgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5jb21wYXJlKHRoaXMuX3RyZWVbaV0sIHRoaXMuX3RyZWVbbGVmdF0pICogdGhpcy5fdHlwZSA8IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wYXJlKHRoaXMuX3RyZWVbaV0sIHRoaXMuX3RyZWVbcmlnaHRdKSAqIHRoaXMuX3R5cGUgPCAwKSkge1xuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIDIgY2hpbGRyZW4gYW5kIG9uZSBvZiB0aGVtIG11c3QgYmUgc3dhcHBlZFxuICAgICAgICAgICAgICAgIC8vIGdldCBjb3JyZWN0IGVsZW1lbnQgdG8gc2lmdCBkb3duXG4gICAgICAgICAgICAgICAgdmFyIHNpZnQgPSBsZWZ0O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhcmUodGhpcy5fdHJlZVtsZWZ0XSwgdGhpcy5fdHJlZVtyaWdodF0pICogdGhpcy5fdHlwZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2lmdCA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9zd2FwKGksIHNpZnQpO1xuICAgICAgICAgICAgICAgIGkgPSBzaWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGVmdCA8IHRoaXMuX3RyZWUubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wYXJlKHRoaXMuX3RyZWVbaV0sIHRoaXMuX3RyZWVbbGVmdF0pICogdGhpcy5fdHlwZSA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IG9uZSBjaGlsZCBleGlzdHNcbiAgICAgICAgICAgICAgICB0aGlzLl9zd2FwKGksIGxlZnQpO1xuICAgICAgICAgICAgICAgIGkgPSBsZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIGEgbm9kZSBmcm9tIHRvcCBvZiB0aGUgaGVhcCBhbmQgc2lmdCB1cFxuICAgICAqXG4gICAgICogQG1ldGhvZCBleHRyYWN0XG4gICAgICogQHJldHVybiBhbnkgVGhlIHZhbHVlIG9mIHRoZSBleHRyYWN0ZWQgbm9kZS5cbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fdHJlZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGV4dHJhY3QgZnJvbSBhbiBlbXB0eSBkYXRhIHN0cnVjdHVyZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXh0cmFjdGVkID0gdGhpcy5fdHJlZVswXTtcbiAgICAgICAgaWYgKHRoaXMuX3RyZWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLl90cmVlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90cmVlWzBdID0gdGhpcy5fdHJlZS5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuX3NpZnREb3duKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRyYWN0ZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIGVsZW1lbnQgaW4gdGhlIGhlYXAgYnkgc2lmdGluZyBpdCB1cFxuICAgICAqXG4gICAgICogQG1ldGhvZCBpbnNlcnRcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdHJlZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgdGhpcy5fc2lmdFVwKHRoaXMuX3RyZWUubGVuZ3RoIC0gMSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQZWVrcyBhdCB0aGUgbm9kZSBmcm9tIHRoZSB0b3Agb2YgdGhlIGhlYXBcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9wXG4gICAgICogQHJldHVybiBhbnkgVGhlIHZhbHVlIG9mIHRoZSBub2RlIG9uIHRoZSB0b3AuXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUudG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fdHJlZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHBlZWsgYXQgYW4gZW1wdHkgaGVhcFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdHJlZVswXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvdW50cyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBoZWFwXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGNvdW50XG4gICAgICogQHJldHVybiBudW1iZXIgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaGVhcC5cbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWUubGVuZ3RoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGhlYXAgaXMgZW1wdHlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgaXNFbXB0eVxuICAgICAqIEByZXR1cm4gYm9vbGVhbiB3aGV0aGVyIHRoZSBoZWFwIGlzIGVtcHR5LlxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fdHJlZS5sZW5ndGggPT09IDApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV3aW5kIGl0ZXJhdG9yIGJhY2sgdG8gdGhlIHN0YXJ0IChuby1vcClcbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmV3aW5kXG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUucmV3aW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9rZXkgPSAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGN1cnJlbnQgbm9kZSBwb2ludGVkIGJ5IHRoZSBpdGVyYXRvclxuICAgICAqXG4gICAgICogQG1ldGhvZCBjdXJyZW50XG4gICAgICogQHJldHVybiBhbnkgVGhlIGN1cnJlbnQgbm9kZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJlZVt0aGlzLl9rZXldO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGN1cnJlbnQgbm9kZSBpbmRleFxuICAgICAqXG4gICAgICogQG1ldGhvZCBrZXlcbiAgICAgKiBAcmV0dXJuIGFueSBUaGUgY3VycmVudCBub2RlIGluZGV4LlxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLmtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1vdmUgdG8gdGhlIG5leHQgbm9kZVxuICAgICAqXG4gICAgICogQG1ldGhvZCBuZXh0XG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fa2V5Kys7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNb3ZlIHRvIHByZXZpb3VzIGVudHJ5XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHByZXZcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9rZXktLTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGhlYXAgY29udGFpbnMgbW9yZSBub2Rlc1xuICAgICAqXG4gICAgICogQG1ldGhvZCB2YWxpZFxuICAgICAqIEByZXR1cm4gYm9vbGVhbiB0cnVlIGlmIHRoZSBoZWFwIGNvbnRhaW5zIGFueSBtb3JlIG5vZGVzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUudmFsaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fa2V5ID49IDAgJiYgdGhpcy5fa2V5IDwgdGhpcy5fdHJlZS5sZW5ndGgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcGFyZSBlbGVtZW50cyBpbiBvcmRlciB0byBwbGFjZSB0aGVtIGNvcnJlY3RseSBpbiB0aGUgaGVhcCB3aGlsZSBzaWZ0aW5nIHVwLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBjb21wYXJlXG4gICAgICogQHBhcmFtIGZpcnN0IFRoZSB2YWx1ZSBvZiB0aGUgZmlyc3Qgbm9kZSBiZWluZyBjb21wYXJlZC5cbiAgICAgKiBAcGFyYW0gc2Vjb25kIFRoZSB2YWx1ZSBvZiB0aGUgc2Vjb25kIG5vZGUgYmVpbmcgY29tcGFyZWQuXG4gICAgICogQHJldHVybiBudW1iZXIgUmVzdWx0IG9mIHRoZSBjb21wYXJpc29uLCBwb3NpdGl2ZSBpbnRlZ2VyIGlmIGZpcnN0IGlzIGdyZWF0ZXIgdGhhbiBzZWNvbmQsIDAgaWYgdGhleSBhcmUgZXF1YWwsIG5lZ2F0aXZlIGludGVnZXIgb3RoZXJ3aXNlLlxuICAgICAqIEhhdmluZyBtdWx0aXBsZSBlbGVtZW50cyB3aXRoIHRoZSBzYW1lIHZhbHVlIGluIGEgSGVhcCBpcyBub3QgcmVjb21tZW5kZWQuIFRoZXkgd2lsbCBlbmQgdXAgaW4gYW4gYXJiaXRyYXJ5IHJlbGF0aXZlIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICBpZiAoZmlyc3QgPiBzZWNvbmQpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpcnN0ID09IHNlY29uZCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFZpc3VhbGx5IGRpc3BsYXkgaGVhcCB0cmVlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9kaXNwbGF5Tm9kZVxuICAgICAqIEBwYXJhbSBub2RlXG4gICAgICogQHBhcmFtIHByZWZpeFxuICAgICAqIEBwYXJhbSBsYXN0XG4gICAgICogQHJldHVybiBTdHJpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLl9kaXNwbGF5Tm9kZSA9IGZ1bmN0aW9uIChub2RlLCBwcmVmaXgsIGxhc3QpIHtcbiAgICAgICAgaWYgKHByZWZpeCA9PT0gdm9pZCAwKSB7IHByZWZpeCA9ICcnOyB9XG4gICAgICAgIGlmIChsYXN0ID09PSB2b2lkIDApIHsgbGFzdCA9IHRydWU7IH1cbiAgICAgICAgdmFyIGxpbmUgPSBwcmVmaXg7XG4gICAgICAgIC8vIGdldCBjaGlsZCBpbmRleGVzXG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5fY2hpbGQobm9kZSk7XG4gICAgICAgIHZhciByaWdodCA9IGxlZnQgKyAxO1xuICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgbGluZSArPSAocHJlZml4ID8gJ+KUlOKUgCcgOiAnICAnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxpbmUgKz0gJ+KUnOKUgCc7XG4gICAgICAgIH1cbiAgICAgICAgbGluZSArPSB0aGlzLl90cmVlW25vZGVdO1xuICAgICAgICBwcmVmaXggKz0gKGxhc3QgPyAnICAnIDogJ+KUgiAnKTtcbiAgICAgICAgaWYgKGxlZnQgPCB0aGlzLl90cmVlLmxlbmd0aCkge1xuICAgICAgICAgICAgbGluZSArPSAnXFxuJyArIHRoaXMuX2Rpc3BsYXlOb2RlKGxlZnQsIHByZWZpeCwgKHRoaXMuX3RyZWVbcmlnaHRdID09IHVuZGVmaW5lZCA/IHRydWUgOiBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyaWdodCA8IHRoaXMuX3RyZWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBsaW5lICs9ICdcXG4nICsgdGhpcy5fZGlzcGxheU5vZGUocmlnaHQsIHByZWZpeCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBoZWFwIHRvIHN0cmluZ1xuICAgICAqXG4gICAgICogQG1ldGhvZCB0b1N0cmluZ1xuICAgICAqIEByZXR1cm4gc3RyaW5nICAgVGhlIHNlcmlhbGl6ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBzdGFydCB3aXRoIHJvb3QgYW5kIHJlY3Vyc2l2ZWx5IGdvZXMgdG8gZWFjaCBub2RlXG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwbGF5Tm9kZSgwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGhlYXAgdG8gYXJyYXlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9BcnJheVxuICAgICAqIEByZXR1cm4gQXJyYXkgICBUaGUgc2VyaWFsaXplZCBhcnJheS5cbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJlZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1heCBoZWFwIGZsYWdcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBNQVhcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgSGVhcC5NQVggPSAxO1xuICAgIC8qKlxuICAgICAqIE1pbiBoZWFwIGZsYWdcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBNSU5cbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgSGVhcC5NSU4gPSAtMTtcbiAgICByZXR1cm4gSGVhcDtcbn0pKCk7XG5tb2R1bGUuZXhwb3J0cyA9IEhlYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IZWFwLmpzLm1hcCIsInZhciBfX2V4dGVuZHMgPSB0aGlzLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlO1xuICAgIGQucHJvdG90eXBlID0gbmV3IF9fKCk7XG59O1xudmFyIEhlYXAgPSByZXF1aXJlKCcuL0hlYXAnKTtcbi8qKlxuICogVGhlIE1heEhlYXAgY2xhc3MgcHJvdmlkZXMgdGhlIG1haW4gZnVuY3Rpb25hbGl0eSBvZiBhIGhlYXAsIGtlZXBpbmcgdGhlIG1heGltdW0gb24gdGhlIHRvcC5cbiAqXG4gKiBAY2xhc3MgTWF4SGVhcFxuICogQGV4dGVuZHMgSGVhcFxuICovXG52YXIgTWF4SGVhcCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1heEhlYXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWF4SGVhcCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX3R5cGUgPSBIZWFwLk1BWDtcbiAgICB9XG4gICAgcmV0dXJuIE1heEhlYXA7XG59KShIZWFwKTtcbm1vZHVsZS5leHBvcnRzID0gTWF4SGVhcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1heEhlYXAuanMubWFwIiwidmFyIF9fZXh0ZW5kcyA9IHRoaXMuX19leHRlbmRzIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGU7XG4gICAgZC5wcm90b3R5cGUgPSBuZXcgX18oKTtcbn07XG52YXIgSGVhcCA9IHJlcXVpcmUoJy4vSGVhcCcpO1xuLyoqXG4gKiBUaGUgTWluSGVhcCBjbGFzcyBwcm92aWRlcyB0aGUgbWFpbiBmdW5jdGlvbmFsaXR5IG9mIGEgaGVhcCwga2VlcGluZyB0aGUgbWluaW11bSBvbiB0aGUgdG9wLlxuICpcbiAqIEBjbGFzcyBNaW5IZWFwXG4gKiBAZXh0ZW5kcyBIZWFwXG4gKi9cbnZhciBNaW5IZWFwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWluSGVhcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNaW5IZWFwKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fdHlwZSA9IEhlYXAuTUlOO1xuICAgIH1cbiAgICByZXR1cm4gTWluSGVhcDtcbn0pKEhlYXApO1xubW9kdWxlLmV4cG9ydHMgPSBNaW5IZWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWluSGVhcC5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBIZWFwID0gcmVxdWlyZSgnLi9IZWFwJyk7XG4vKipcbiAqIFRoZSBQcmlvcml0eVF1ZXVlIGNsYXNzIHByb3ZpZGVzIHRoZSBtYWluIGZ1bmN0aW9uYWxpdHkgb2YgYW4gcHJpb3JpdGl6ZWQgcXVldWUsIGltcGxlbWVudGVkIHVzaW5nIGEgbWF4IGhlYXAuXG4gKlxuICogQGNsYXNzIFByaW9yaXR5UXVldWVcbiAqIEBleHRlbmRzIEhlYXBcbiAqL1xudmFyIFByaW9yaXR5UXVldWUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQcmlvcml0eVF1ZXVlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByaW9yaXR5UXVldWUoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl90eXBlID0gSGVhcC5NQVg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZWxlbWVudCB0byB0aGUgcXVldWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZW5xdWV1ZVxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gZW5xdWV1ZS5cbiAgICAgKiBAcGFyYW0gcHJpb3JpdHkgVGhlIHByaW9yaXR5IG9mIHZhbHVlLlxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbiAodmFsdWUsIHByaW9yaXR5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc2VydChuZXcgUHJpb3JpdHlRdWV1ZU5vZGUodmFsdWUsIHByaW9yaXR5KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXF1ZXVlcyBhIG5vZGUgZnJvbSB0aGUgcXVldWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVxdWV1ZVxuICAgICAqIEByZXR1cm4gYW55ICBUaGUgdmFsdWUgb2YgdGhlIGRlcXVldWVkIG5vZGUuXG4gICAgICovXG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZGVxdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFjdCgpLnZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGVla3MgYXQgdGhlIG5vZGUgZnJvbSB0aGUgdG9wIG9mIHRoZSBoZWFwXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHRvcFxuICAgICAqIEByZXR1cm4gYW55IFRoZSB2YWx1ZSBvZiB0aGUgbm9kZSBvbiB0aGUgdG9wLlxuICAgICAqL1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLnRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUudG9wLmNhbGwodGhpcykudmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wYXJlIGVsZW1lbnRzIGluIG9yZGVyIHRvIHBsYWNlIHRoZW0gY29ycmVjdGx5IGluIHRoZSBoZWFwIHdoaWxlIHNpZnRpbmcgdXAuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGNvbXBhcmVcbiAgICAgKiBAcGFyYW0gZmlyc3QgVGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBub2RlIGJlaW5nIGNvbXBhcmVkLlxuICAgICAqIEBwYXJhbSBzZWNvbmQgVGhlIHZhbHVlIG9mIHRoZSBzZWNvbmQgbm9kZSBiZWluZyBjb21wYXJlZC5cbiAgICAgKiBAcmV0dXJuIG51bWJlciBSZXN1bHQgb2YgdGhlIGNvbXBhcmlzb24sIHBvc2l0aXZlIGludGVnZXIgaWYgZmlyc3QgaXMgZ3JlYXRlciB0aGFuIHNlY29uZCwgMCBpZiB0aGV5IGFyZSBlcXVhbCwgbmVnYXRpdmUgaW50ZWdlciBvdGhlcndpc2UuXG4gICAgICogSGF2aW5nIG11bHRpcGxlIGVsZW1lbnRzIHdpdGggdGhlIHNhbWUgdmFsdWUgaW4gYSBIZWFwIGlzIG5vdCByZWNvbW1lbmRlZC4gVGhleSB3aWxsIGVuZCB1cCBpbiBhbiBhcmJpdHJhcnkgcmVsYXRpdmUgcG9zaXRpb24uXG4gICAgICovXG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgIGlmIChmaXJzdC5wcmlvcml0eSA+IHNlY29uZC5wcmlvcml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmlyc3QucHJpb3JpdHkgPT0gc2Vjb25kLnByaW9yaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFByaW9yaXR5UXVldWU7XG59KShIZWFwKTtcbi8qKlxuICogUHJpb3JpdHlRdWV1ZSBOb2RlXG4gKlxuICogQGNsYXNzIFByaW9yaXR5UXVldWVOb2RlXG4gKi9cbnZhciBQcmlvcml0eVF1ZXVlTm9kZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKlxuICAgICAqIEBtZXRob2QgY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gcHJpb3JpdHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQcmlvcml0eVF1ZXVlTm9kZSh2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIG5vZGUgdG8gc3RyaW5nXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHRvU3RyaW5nXG4gICAgICogQHJldHVybiBzdHJpbmcgICBUaGUgc2VyaWFsaXplZCBzdHJpbmcuXG4gICAgICovXG4gICAgUHJpb3JpdHlRdWV1ZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSArIFwiIFtcIiArIHRoaXMucHJpb3JpdHkgKyBcIl1cIjtcbiAgICB9O1xuICAgIHJldHVybiBQcmlvcml0eVF1ZXVlTm9kZTtcbn0pKCk7XG5tb2R1bGUuZXhwb3J0cyA9IFByaW9yaXR5UXVldWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qcmlvcml0eVF1ZXVlLmpzLm1hcCIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIERvdWJseUxpbmtlZExpc3QgPSByZXF1aXJlKCcuL0RvdWJseUxpbmtlZExpc3QnKTtcbi8qKlxuICogVGhlIFF1ZXVlIGNsYXNzIHByb3ZpZGVzIHRoZSBtYWluIGZ1bmN0aW9uYWxpdHkgb2YgYSBxdWV1ZSBpbXBsZW1lbnRlZCB1c2luZyBhIGRvdWJseSBsaW5rZWQgbGlzdC5cbiAqXG4gKiBAY2xhc3MgUXVldWVcbiAqIEBleHRlbmRzIERvdWJseUxpbmtlZExpc3RcbiAqL1xudmFyIFF1ZXVlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUXVldWUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUXVldWUoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGVsZW1lbnQgdG8gdGhlIHF1ZXVlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGVucXVldWVcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGVucXVldWUuXG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgUXVldWUucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaCh2YWx1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXF1ZXVlcyBhIG5vZGUgZnJvbSB0aGUgcXVldWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVxdWV1ZVxuICAgICAqIEByZXR1cm4gYW55ICBUaGUgdmFsdWUgb2YgdGhlIGRlcXVldWVkIG5vZGUuXG4gICAgICovXG4gICAgUXVldWUucHJvdG90eXBlLmRlcXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoaWZ0KCk7XG4gICAgfTtcbiAgICByZXR1cm4gUXVldWU7XG59KShEb3VibHlMaW5rZWRMaXN0KTtcbm1vZHVsZS5leHBvcnRzID0gUXVldWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1RdWV1ZS5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBEb3VibHlMaW5rZWRMaXN0ID0gcmVxdWlyZSgnLi9Eb3VibHlMaW5rZWRMaXN0Jyk7XG4vKipcbiAqIFRoZSBTdGFjayBjbGFzcyBwcm92aWRlcyB0aGUgbWFpbiBmdW5jdGlvbmFsaXR5IG9mIGEgc3RhY2sgaW1wbGVtZW50ZWQgdXNpbmcgYSBkb3VibHkgbGlua2VkIGxpc3QuXG4gKlxuICogQGNsYXNzIFN0YWNrXG4gKiBAZXh0ZW5kcyBEb3VibHlMaW5rZWRMaXN0XG4gKi9cbnZhciBTdGFjayA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0YWNrLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN0YWNrKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0YWNrO1xufSkoRG91Ymx5TGlua2VkTGlzdCk7XG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RhY2suanMubWFwIiwiLyoqXG4gKiBTVExcbiAqIEB0eXBlIHt7RG91Ymx5TGlua2VkTGlzdDogZXhwb3J0cywgU3RhY2s6IGV4cG9ydHMsIFF1ZXVlOiBleHBvcnRzLCBIZWFwOiBleHBvcnRzLCBNYXhIZWFwOiBleHBvcnRzLCBNaW5IZWFwOiBleHBvcnRzLCBQcmlvcml0eVF1ZXVlOiBleHBvcnRzfX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG5cdERvdWJseUxpbmtlZExpc3Q6IHJlcXVpcmUoJy4vRGF0YXN0cnVjdHVyZXMvRG91Ymx5TGlua2VkTGlzdCcpLFxuXHRTdGFjazogcmVxdWlyZSgnLi9EYXRhc3RydWN0dXJlcy9TdGFjaycpLFxuXHRRdWV1ZTogcmVxdWlyZSgnLi9EYXRhc3RydWN0dXJlcy9RdWV1ZScpLFxuXHRIZWFwOiByZXF1aXJlKCcuL0RhdGFzdHJ1Y3R1cmVzL0hlYXAnKSxcblx0TWF4SGVhcDogcmVxdWlyZSgnLi9EYXRhc3RydWN0dXJlcy9NYXhIZWFwJyksXG5cdE1pbkhlYXA6IHJlcXVpcmUoJy4vRGF0YXN0cnVjdHVyZXMvTWluSGVhcCcpLFxuXHRQcmlvcml0eVF1ZXVlOiByZXF1aXJlKCcuL0RhdGFzdHJ1Y3R1cmVzL1ByaW9yaXR5UXVldWUnKVxufTsiLCJpbXBvcnQgeyBtYW5oYXR0YW5EaXN0YW5jZSB9IGZyb20gJy4vb3RoZXIvaGVscGVyRnVuY3Rpb25zJztcbmltcG9ydCBNYXBXaXRoRGVmYXVsdFZhbHVlIGZyb20gJy4vb3RoZXIvbWFwV2l0aERlZmF1bHRWYWx1ZSc7XG5cbmltcG9ydCB7IFByaW9yaXR5UXVldWUgfSBmcm9tICdsaWJzdGwnOyAvLyBub3RlOiBpbXBvcnRlZCBmcm9tIGEgbm9kZSBtb2R1bGVcblxuLyoqIEBtb2R1bGUgZmluZFBhdGggKi9cblxuLyoqXG4gKiBIZWF2aWx5IG1vZGlmaWVkIGltcGxlbWVudGF0aW9uIG9mIHRoZSBBKiBhbGdvcml0aG1cbiAqIEBwYXJhbSAge09iamVjdH0gc3RhcnQgb2JqZWN0IGNvbnRhaW5pbmcgbnVtZXJpYyBhdHRyaWJ1dGVzIGB4YCBhbmQgYHlgIHRoYXQgcmVwcmVzZW50IHRoZSBmaXJzdCBlbmRwb2ludCBvZiB0aGUgd2lyZSBpbiBncmlkIHBpeGVsc1xuICogQHBhcmFtICB7T2JqZWN0fSBlbmQgICBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWAgdGhhdCByZXByZXNlbnQgdGhlIHNlY29uZCBlbmRwb2ludCBvZiB0aGUgd2lyZSBpbiBncmlkIHBpeGVsc1xuICogQHBhcmFtICB7U2V0fSBub25Sb3V0YWJsZSBzZXQgb2Ygbm9uIHJvdXRhYmxlIG5vZGVzXG4gKiBAcGFyYW0gIHtTZXR9IHB1bmlzaGVkQnV0Um91dGFibGUgc2V0IG9mIG5vZGVzIHRoYXQgYXJlIG5vdCBvcHRpbWFsIGZvciByb3V0aW5nXG4gKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmaW5kUGF0aChzdGFydCwgZW5kLCBub25Sb3V0YWJsZSwgcHVuaXNoZWRCdXRSb3V0YWJsZSkge1xuICAgIGNvbnN0IGRpc3RhbmNlRnVuY3Rpb24gPSBtYW5oYXR0YW5EaXN0YW5jZTtcblxuICAgIGNvbnN0IHdpcmVDcm9zc1B1bmlzaG1lbnQgPSAxO1xuICAgIGNvbnN0IHdpcmVCZW5kUHVuaXNobWVudCA9IDE7XG5cbiAgICAvLyBudW1iZXIgb2Ygbm9kZXMsIHRoYXQgY2FuIGJlIG9wZW5lZCBhdCBvbmNlXG4gICAgLy8gb25jZSBpcyB0aGlzIGxpbWl0IGV4Y2VlZGVkLCBhU3RhciB3aWxsIGZhaWwgYW5kIHJldHVybiB1bmRlZmluZWRcbiAgICBjb25zdCBtYXhOb2RlTGltaXQgPSAxMDAwMDA7XG5cbiAgICBsZXQgY2xvc2VkTm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgbGV0IG9wZW5Ob2RlcyA9IG5ldyBTZXQoKTtcbiAgICBsZXQgb3Blbk5vZGVRdWV1ZSA9IG5ldyBQcmlvcml0eVF1ZXVlKCk7XG5cbiAgICAvLyBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBvcGVuIG5vZGVzOlxuXG4gICAgLyoqXG4gICAgICogYWRkIGEgbmV3IG9wZW4gbm9kZSB0byB0aGUgc3RydWN0dXJlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgICBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWAgdGhhdCByZXByZXNlbnQgdGhlIGZpcnN0IGVuZHBvaW50IG9mIHRoZSB3aXJlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZzY29yZSBmU2NvcmUgb2YgdGhpcyBub2RlXG4gICAgICovXG4gICAgY29uc3QgYWRkT3Blbk5vZGUgPSAobm9kZSwgZnNjb3JlKSA9PiB7XG4gICAgICAgIG9wZW5Ob2Rlcy5hZGQobm9kZSk7XG4gICAgICAgIC8vIGZsaXAgdGhlIGZzY29yZSwgYmVjYXVzZSBQcmlvcml0eVF1ZXVlIHVzZXMgbWF4IGhlYXBcbiAgICAgICAgb3Blbk5vZGVRdWV1ZS5lbnF1ZXVlKG5vZGUsIDEgLyBmc2NvcmUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIG9wZW4gbm9kZSB3aXRoIHRoZSBsb3dlc3QgZlNjb3JlIGFuZCByZW1vdmUgaXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YCB0aGF0IHJlcHJlc2VudCB0aGUgZmlyc3QgZW5kcG9pbnQgb2YgdGhlIHdpcmVcbiAgICAgKi9cbiAgICBjb25zdCBnZXRPcGVuTm9kZSA9ICgpID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG9wZW5Ob2RlUXVldWUuZGVxdWV1ZSgpO1xuICAgICAgICBvcGVuTm9kZXMuZGVsZXRlKG5vZGUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuXG4gICAgbGV0IGNhbWVGcm9tID0gbmV3IE1hcCgpO1xuXG4gICAgLy8gZGVmYXVsdCB2YWx1ZTogaW5maW5pdHlcbiAgICBsZXQgZ1Njb3JlID0gbmV3IE1hcFdpdGhEZWZhdWx0VmFsdWUoSW5maW5pdHkpO1xuICAgIGdTY29yZS5zZXQoc3RhcnQsIDApO1xuXG4gICAgbGV0IHN0YXJ0RlNjb3JlID0gZGlzdGFuY2VGdW5jdGlvbihzdGFydCwgZW5kKTtcblxuICAgIGFkZE9wZW5Ob2RlKHN0YXJ0LCBzdGFydEZTY29yZSk7XG5cbiAgICBvcGVuTm9kZXMuYWRkKHN0YXJ0KTtcbiAgICBvcGVuTm9kZVF1ZXVlLmVucXVldWUoc3RhcnQsIDEgLyBzdGFydEZTY29yZSk7XG5cbiAgICB3aGlsZSAob3Blbk5vZGVzLnNpemUgPiAwKSB7XG4gICAgICAgIC8vIGdldCB0aGUgdmFsdWUgZnJvbSBvcGVuTm9kZXMgdGhhdCBoYXMgdGhlIGxvd2VzdCBmU2NvcmVcbiAgICAgICAgY29uc3QgY3VycmVudE5vZGUgPSBnZXRPcGVuTm9kZSgpO1xuXG4gICAgICAgIC8vIGlmIHdlIHJlYWNoZWQgdGhlIGVuZCBwb2ludCwgcmVjb25zdHJ1Y3QgdGhlIHBhdGggYW5kIHJldHVybiBpdFxuICAgICAgICBpZiAoY3VycmVudE5vZGUueCA9PSBlbmQueCAmJiBjdXJyZW50Tm9kZS55ID09IGVuZC55KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjb25zdHJ1Y3RQYXRoKGNhbWVGcm9tLCBjdXJyZW50Tm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgdGhpcyBub2RlIHRvIHRoZSBjbG9zZWQgbm9kZXNcbiAgICAgICAgY2xvc2VkTm9kZXMuYWRkKGN1cnJlbnROb2RlKTtcblxuICAgICAgICAvLyB0aGUgZmFydGhlc3QgcG9pbnRzIGFjY2Vzc2libGUgd2l0aG91dCBhdm9pZGluZyBvYnN0YWNsZXMgaW4gZXZlcnkgZGlyZWN0aW9uXG4gICAgICAgIC8vIChidXQgbWF4IDUwIGluIGVhY2ggZGlyZWN0aW9uKVxuICAgICAgICBmb3IgKGxldCBkaXJlY3Rpb24gPSAwOyBkaXJlY3Rpb24gPCA0OyBkaXJlY3Rpb24rKykge1xuICAgICAgICAgICAgbGV0IG5ld1BvaW50ID0gbW92ZVBvaW50KGN1cnJlbnROb2RlLCBkaXJlY3Rpb24pO1xuXG4gICAgICAgICAgICBsZXQgd2lyZXNDcm9zc2VkID0gMDtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1MDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgbmV3UG9pbnQgaXMgaW4gdGhlIHNldCBvZiBub24gcm91dGFibGUgcG9pbnRzLFxuICAgICAgICAgICAgICAgIC8vIGRvbid0IGFkZCBpdCBhbmQgc3RvcCBwcm9jZWVkaW5nIGluIHRoaXMgZGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHNldEhhc1RoaXNQb2ludChub25Sb3V0YWJsZSwgbmV3UG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgbm90IHRoZSBlbmQgb3Igc3RhcnQgcG9pbnQsIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICEobmV3UG9pbnQueCA9PT0gZW5kLnggJiYgbmV3UG9pbnQueSA9PT0gZW5kLnkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhKG5ld1BvaW50LnggPT09IHN0YXJ0LnggJiYgbmV3UG9pbnQueSA9PT0gc3RhcnQueSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHNraXAgdGhpcyBub2RlLCBpZiBpdCBoYXMgYmVlbiBhbHJlYWR5IGNsb3NlZFxuICAgICAgICAgICAgICAgIC8vIG9yIGlmIGl0IGlzIG9uIHRoZSBsaXN0IG9mIG5vbiByb3V0YWJsZSBub2Rlc1xuICAgICAgICAgICAgICAgIGlmIChjbG9zZWROb2Rlcy5oYXMobmV3UG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBwb3NzaWJsZSBHU2NvcmUgYnkgYXBwbHlpbmcgYSBwdW5pc2htZW50IGZvciBlYWNoIG5vZGUgKFwiYmVuZFwiKSBpbiB0aGUgcGF0aFxuICAgICAgICAgICAgICAgIGxldCBuZXdHU2NvcmUgPSB3aXJlQmVuZFB1bmlzaG1lbnQgKyBnU2NvcmUuZ2V0V2l0aERlZmF1bHQoY3VycmVudE5vZGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNldEhhc1RoaXNQb2ludChwdW5pc2hlZEJ1dFJvdXRhYmxlLCBuZXdQb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIG5vZGUgaXMgaW4gdGhlIHNldCBvZiBwdW5pc2hlZCBub2RlcywgYXBwbHkgdGhlIHB1bmlzaG1lbnRcbiAgICAgICAgICAgICAgICAgICAgd2lyZXNDcm9zc2VkKys7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYXBwbHkgdGhlIHB1bmlzaG1lbnQgZm9yIGVhY2ggd2lyZSBjcm9zc2VkIGluIHRoaXMgZGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgLy8gbm90ZTogd2UgYXJlIGNvdW50aW5nIHRoZSB3aXJlcyBjcm9zc2VkIHdoZW4gZXhwb3J0aW5nIHRoaXMgZGlyZWN0aW9uLCBub3QgdGhlIHdpcmVzXG4gICAgICAgICAgICAgICAgLy8gY3Jvc3NlZCBpbiB0aGUgZmluYWwgcGF0aCwgdGhlcmUgd2lsbCBiZSBwcm9iYWJseSBvbmx5IGF0IG1vc3Qgb2YgdGhlc2Ugbm9kZXMgaW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gZmluYWwgcGF0aCwgbm90IG11bHRpcGxlXG4gICAgICAgICAgICAgICAgbmV3R1Njb3JlICs9IHdpcmVzQ3Jvc3NlZCAqIHdpcmVDcm9zc1B1bmlzaG1lbnQ7XG5cbiAgICAgICAgICAgICAgICAvLyBza2lwIHRoaXMgbm9kZSBpZiBpdCBoYXMgd29yc3QgZXN0aW1hZ2UgZ3Njb3JlIHRoYW4gaW4gdGhlIGdzY29yZSB0YWJsZVxuICAgICAgICAgICAgICAgIGlmIChuZXdHU2NvcmUgPj0gZ1Njb3JlLmdldFdpdGhEZWZhdWx0KG5ld1BvaW50KSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjYW1lRnJvbS5zZXQobmV3UG9pbnQsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgICAgICBnU2NvcmUuc2V0KG5ld1BvaW50LCBuZXdHU2NvcmUpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RlNjb3JlID0gbmV3R1Njb3JlICsgZGlzdGFuY2VGdW5jdGlvbihuZXdQb2ludCwgZW5kKTtcblxuICAgICAgICAgICAgICAgIGlmICghb3Blbk5vZGVzLmhhcyhuZXdQb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBwb2ludCB0byB0aGUgbGlzdCBvZiBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgYWRkT3Blbk5vZGUobmV3UG9pbnQsIG5ld0ZTY29yZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0byB0aGUgbmV4dCBwb2ludCBpbiB0aGUgZGlyZWNpdG9uXG4gICAgICAgICAgICAgICAgbmV3UG9pbnQgPSBtb3ZlUG9pbnQobmV3UG9pbnQsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3Blbk5vZGVzLnNpemUgPiBtYXhOb2RlTGltaXQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIGBhU3RhcjogTnVtYmVyIG9mIG9wZW4gbm9kZXMgKCR7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5Ob2Rlcy5zaXplXG4gICAgICAgICAgICAgICAgfSkgZXhjZWVkZWQgdGhlIGxpbWl0IGZvciBvcGVuIG5vZGVzICgke21heE5vZGVMaW1pdH0pLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiB3ZSBnb3QgaGVyZSwgdGhlIHBhdGggd2FzIG5vdCBmb3VuZFxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiByZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3BlY2lmaWVkIHNldCBvZiBwb2ludHMgY29udGFpbnMgdGhlIHNwZWNpZmllZCBwb2ludCAoYW5kIHJldHVybnMgYGZhbHNlYCBvdGhlcndpc2UpXG4gKiBAcGFyYW0ge1NldH0gc2V0IHNldCBvZiBwb2ludHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludCBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWBcbiAqL1xuZnVuY3Rpb24gc2V0SGFzVGhpc1BvaW50KHNldCwgcG9pbnQpIHtcbiAgICBmb3IgKGxldCBpdGVtIG9mIHNldCkge1xuICAgICAgICBpZiAoaXRlbS54ID09PSBwb2ludC54ICYmIGl0ZW0ueSA9PT0gcG9pbnQueSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IG1vdmVzIHRoZSBwYXNzZWQgcG9pbnQgaW4gdGhlIHNwZWNpZmllZCBkaXJlY3Rpb24uIEl0IHNpbXBseSBhZGRzIG9yIHN1YnRyYWN0cyAxIGZyb20gb25lIG9mIHRoZSBjb29yZGluYXRlcyBkZXBlbmRpbmcgb24gdGhlIGRpcmVjdGlvbiBhdHRyaWJ1dGUuXG4gKiBAcGFyYW0gIHtPYmplY3R9IHBvaW50ICAgICBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWBcbiAqIEBwYXJhbSAge251bWJlcn0gZGlyZWN0aW9uIGRpcmVjdGlvbnM6XG4gKiAgICAgLSAwOiB1cFxuICogICAgIC0gMTogcmlnaHRcbiAqICAgICAtIDI6IGRvd25cbiAqICAgICAtIDM6IGxlZnRcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgIG9iamVjdCBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YFxuICovXG5mdW5jdGlvbiBtb3ZlUG9pbnQoeyB4LCB5IH0sIGRpcmVjdGlvbikge1xuICAgIC8vIG1hcCBkaXJlY3Rpb24gZG8gcG9pbnQgY29vcmRpbmF0ZSBtb2RpZmljYXRpb25cbiAgICBjb25zdCBkaXJNYXAgPSB7XG4gICAgICAgIDA6ICgpID0+IHtcbiAgICAgICAgICAgIHkgLT0gMTtcbiAgICAgICAgfSxcbiAgICAgICAgMTogKCkgPT4ge1xuICAgICAgICAgICAgeCArPSAxO1xuICAgICAgICB9LFxuICAgICAgICAyOiAoKSA9PiB7XG4gICAgICAgICAgICB5ICs9IDE7XG4gICAgICAgIH0sXG4gICAgICAgIDM6ICgpID0+IHtcbiAgICAgICAgICAgIHggLT0gMTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBkaXJNYXBbZGlyZWN0aW9uXSgpO1xuXG4gICAgcmV0dXJuIHsgeCwgeSB9O1xufVxuXG4vKipcbiAqIGhlbHBlciBiYWNrdHJhY2tpbmcgZnVuY3Rpb24gdXNlZCBieSB0aGUgYVN0YXIgYWxnb3JpdGhtIHRvIGNvbnN0cnVjdCB0aGUgZmluYWwgcGF0aFxuICogQHBhcmFtICB7T2JqZWN0fSBjYW1lRnJvbSAgICBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWBcbiAqIEBwYXJhbSAge09iamVjdH0gY3VycmVudE5vZGUgb2JqZWN0IGNvbnRhaW5pbmcgbnVtZXJpYyBhdHRyaWJ1dGVzIGB4YCBhbmQgYHlgXG4gKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YFxuICovXG5mdW5jdGlvbiByZWNvbnN0cnVjdFBhdGgoY2FtZUZyb20sIGN1cnJlbnROb2RlKSB7XG4gICAgbGV0IHBhdGggPSBbXTtcblxuICAgIHBhdGgucHVzaCh7XG4gICAgICAgIHg6IGN1cnJlbnROb2RlLngsXG4gICAgICAgIHk6IGN1cnJlbnROb2RlLnlcbiAgICB9KTtcblxuICAgIHdoaWxlIChjYW1lRnJvbS5oYXMoY3VycmVudE5vZGUpKSB7XG4gICAgICAgIGN1cnJlbnROb2RlID0gY2FtZUZyb20uZ2V0KGN1cnJlbnROb2RlKTtcbiAgICAgICAgcGF0aC5wdXNoKHtcbiAgICAgICAgICAgIHg6IGN1cnJlbnROb2RlLngsXG4gICAgICAgICAgICB5OiBjdXJyZW50Tm9kZS55XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIEhlbHBlckZ1bmN0aW9uc1xuICovXG5cbmltcG9ydCBzdHJpbmdpZnkgZnJvbSAnanNvbi1zdHJpbmdpZnktcHJldHR5LWNvbXBhY3QnOyAvLyBub3RlOiBpbXBvcnRlZCBmcm9tIGEgbW9kdWxlXG5cbi8qKlxuICogYWRkIGEgY3Jvc3MgYnJvd3NlciBldmVudCBsaXN0ZW5lciBvbiBhIG1vdXNlIHNjcm9sbFxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IERPTSBxdWVyeSBvZiB0aGUgZWxlbWVudCB0aGF0IHRoZSBsaXN0ZW5lciB3aWxsIGJlIGFkZGVkIHRvXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jICBGdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IG9jY3Vycy4gVGhlIGZ1bmN0aW9uIHRha2VzIGFzIGEgcGFyYW1ldGVyIGFuIGV2ZW50IG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZE1vdXNlU2Nyb2xsRXZlbnRMaXN0ZW5lcihxdWVyeSwgZnVuYykge1xuICAgIGxldCBNb3VzZVdoZWVsSGFuZGxlciA9IGV2ZW50ID0+IHtcbiAgICAgICAgLy8gcmVkZWNsYXJlIGZvciBvbGQgSUUgc3VwcG9ydFxuICAgICAgICB2YXIgZXZlbnQgPSB3aW5kb3cuZXZlbnQgfHwgZXZlbnQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVkZWNsYXJlXG5cbiAgICAgICAgZXZlbnQuZGVsdGEgPSBNYXRoLm1heCgtMSwgTWF0aC5taW4oMSwgZXZlbnQud2hlZWxEZWx0YSB8fCAtZXZlbnQuZGV0YWlsKSk7XG5cbiAgICAgICAgZnVuYyhldmVudCk7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBsZXQgc3ZnZWxlbWVudDtcblxuICAgIC8vIGlmIHRoZSBxdWVyeSBpcyBhIHNpbXBsZSBET00gaWQgc2VsZWN0b3IsIHdlIGNhbiB1c2UgZ2V0RWxlbWVudEJ5SWQgd2hpY2ggaGFzIGJldHRlciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgIGlmIChxdWVyeS5tYXRjaCgvXiNcXHcrJC8pKSB7XG4gICAgICAgIHN2Z2VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChxdWVyeS5zdWJzdHIoMSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN2Z2VsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHF1ZXJ5KTtcbiAgICB9XG5cbiAgICBpZiAoc3ZnZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIC8vIElFOSwgQ2hyb21lLCBTYWZhcmksIE9wZXJhXG4gICAgICAgIHN2Z2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIE1vdXNlV2hlZWxIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIC8vIEZpcmVmb3hcbiAgICAgICAgc3ZnZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIE1vdXNlV2hlZWxIYW5kbGVyLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSUUgNi83LzhcbiAgICAgICAgc3ZnZWxlbWVudC5hdHRhY2hFdmVudCgnb25tb3VzZXdoZWVsJywgTW91c2VXaGVlbEhhbmRsZXIpO1xuICAgIH1cbiAgICBzdmdlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICdtb3VzZXdoZWVsJyxcbiAgICAgICAgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2V2ZW50JywgZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZhbHNlXG4gICAgKTtcbn1cblxuLyoqXG4gKiBjb252ZXJ0IGEgZGF0YSBvYmplY3QgdG8gSlNPTiBzdHJpbmcgb3IgdG8gYSBkYXRhIFVSSSBjb250YWluaW5nIGEgSlNPTiBzdHJpbmdcbiAqIEBwYXJhbSAge09iamVjdH0gIGRhdGEgICAgICAgICAgICBvYmplY3QgdGhhdCB3aWxsIGJlIHNlcmlhbGl6ZWQgaW50byBhIEpTT04gc3RyaW5nXG4gKiBAcGFyYW0gIHtCb29sZWFufSBbcHJldHR5PWZhbHNlXSAgaWYgYHRydWVgLCB0aGUgY29kZSB3aWxsIGJlIHByb3ByZXJseSBpbmRlbnRlZCwgZWxzZSBhIG1vcmUgY29tcGFjdCBzeW50YXggd2lsbCBiZSB1c2VkXG4gKiBAcGFyYW0gIHtCb29sZWFufSBbZGF0YVVyaT1mYWxzZV0gcmV0dXJuIGRhdGFVcmkgY29udGFpbmluZyB0aGUgSlNPTiBzdHJpbmcgaW5zdGVhZCBvZiB0aGUgcHVyZSBKU09OIHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SlNPTlN0cmluZyhkYXRhLCBwcmV0dHkgPSBmYWxzZSwgZGF0YVVyaSA9IGZhbHNlKSB7XG4gICAgaWYgKGRhdGFVcmkpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICdkYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCwnICsgZW5jb2RlVVJJQ29tcG9uZW50KGdldEpTT05TdHJpbmcoZGF0YSwgcHJldHR5KSlcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJldHR5KSByZXR1cm4gc3RyaW5naWZ5KGRhdGEsIHsgbWF4TGVuZ3RoOiA1MCB9KTtcblxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgfVxufVxuXG4vKipcbiAqIHJldHVybnMgdGhlIE1hbmhhdHRhbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBwb2ludHMgX2FfIGFuZCBfYl9cbiAqIEBwYXJhbSAge09iamVjdH0gYSBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWBcbiAqIEBwYXJhbSAge09iamVjdH0gYiBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWBcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hbmhhdHRhbkRpc3RhbmNlKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoYS54IC0gYi54KSArIE1hdGguYWJzKGEueSAtIGIueSk7XG59XG4iLCIvKiogQG1vZHVsZSBNYXBXaXRoRGVmYXVsdFZhbHVlICovXG4vKipcbiAqIE1hcCB0aGF0IGhhcyBhIGRlZmF1bHQgdmFsdWUgc3BlY2lmaWVkIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBGb3IgdGhlIGNvbXBsZXRlIGRvY3VtZW50YXRpb24gb2YgdGhlIE1hcCBzZWUgW01hcCBpbiB0aGUgTUROIHdlYiBkb2NzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXApXG4gKlxuICogVXNhZ2U6XG4gKiBgYGBKYXZhU2NyaXB0XG4gbGV0IG15TWFwID0gbmV3IE1hcFdpdGhEZWZhdWx0VmFsdWUoSW5maW5pdHkpO1xuIGNvbnN0IHZhbHVlID0gbXlNYXAuZ2V0V2l0aERlZmF1bHQoa2V5KVxuIGBgYFxuICpcbiAqIF9Ob3RlOiBUaGlzIHZlcnNpb24gaXMgd3JpdHRlbiBzcGVjaWFsbHkgZm9yIEVTNiBjb21waWxlZCBpbnRvIEVTNS4gSW4gbm9uLWNvbXBpbGVkIEVTNiBpcyB0aGUgaW1wbGVtZW50YXRpb24gZmFyIG1vcmUgZWxlZ2FudDpfXG4gKlxuICogYGBgSmF2YVNjcmlwdFxuIGV4cG9ydCBjbGFzcyBNYXBXaXRoRGVmYXVsdFZhbHVlIGV4dGVuZHMgTWFwIHtcbiAgICAgY29uc3RydWN0b3IoZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgICB0aGlzLmRlZmF1bHQgPSBkZWZhdWx0VmFsdWU7XG4gICAgIH1cblxuICAgICBnZXQoa2V5KSB7XG4gICAgICAgICBpZih0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmdldChrZXkpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0O1xuICAgICAgICAgfVxuICAgICB9XG4gfWBgYFxuICogQGNsYXNzIE1hcFdpdGhEZWZhdWx0VmFsdWVcbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUge2FueX0gZGVmYXVsdCB2YWx1ZSB0aGF0IHdpbGwgYmUgcmV0dXJuZWQgd2hlbiB0aGUgcmVxdWVzdGVkIGtleSBpcyBub3QgZm91bmQgaW4gdGhlIG1hcFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkZWZhdWx0VmFsdWUpIHtcbiAgICBsZXQgbWFwID0gbmV3IE1hcCgpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge2FueX0ga2V5IGtleSBvZiBhIHJlcXVlc3RlZCBpdGVtXG4gICAgICogQHJldHVybiB7YW55fSB2YWx1ZSBvZiB0aGUgaXRlbSB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGtleSwgb3IgZGVmYXVsdFZhbHVlIGlmIHRoZSBrZXkgaXMgbm90IGZvdW5kIGluIHRoZSBtYXBcbiAgICAgKi9cbiAgICBtYXAuZ2V0V2l0aERlZmF1bHQgPSBrZXkgPT4ge1xuICAgICAgICByZXR1cm4gbWFwLmhhcyhrZXkpID8gbWFwLmdldChrZXkpIDogZGVmYXVsdFZhbHVlO1xuICAgIH07XG4gICAgcmV0dXJuIG1hcDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEBtb2R1bGUgcm91dGVXb3JrZXIgKi9cblxuaW1wb3J0IGZpbmRQYXRoIGZyb20gJy4vbW9kdWxlcy9maW5kUGF0aCc7XG5cbi8qKlxuICogY2FsbGJhY2sgd2hlbiBhIG1lc3NhZ2UgaXMgc2VudCB0byB0aGUgd2ViIHdvcmtlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB3ZWIgd29ya2VyIGV2ZW50IG9iamVjdCAodGhlIGBkYXRhYCBpdGVtIG9mIHRoZSBldmVudCBvYmplY3QgaXMgZXhwZWN0ZWQgdG8gY29udGFpblxuICogICAgICAgICAgICAgICAgICAgICAgIHRoZXNlIGl0ZW1zOiBgd2lyZXNgIChhcnJheSksIGBub25Sb3V0YWJsZU5vZGVzYCAoaXRlcmFibGUpIGFuZCBgaW5jb252ZW5pZW50Tm9kZXNgIChpdGVyYWJsZSkpXG4gKi9cbm9ubWVzc2FnZSA9IGV2ZW50ID0+IHtcbiAgICBjb25zdCB7IHdpcmVzLCBub25Sb3V0YWJsZU5vZGVzLCBpbmNvbnZlbmllbnROb2RlcyB9ID0gZXZlbnQuZGF0YTtcblxuICAgIGNvbnN0IHBhdGhzID0gZmluZFBhdGhzKHdpcmVzLCBub25Sb3V0YWJsZU5vZGVzLCBpbmNvbnZlbmllbnROb2Rlcyk7XG5cbiAgICBwb3N0TWVzc2FnZSh7IHBhdGhzIH0pO1xuICAgIGNsb3NlKCk7XG59O1xuXG4vKipcbiAqIGZpbmQgcGF0aHMgZm9yIGFsbCB0aGUgc3BlY2lmaWVkIHdpcmVzXG4gKiBAcGFyYW0gIHtBcnJheX0gd2lyZXMgICAgICAgICAgICAgIGFycmF5IG9mIG9iamVjdHMgd2l0aCBhdHRyaWJ1dGVzIGBmcm9tYCBhbmQgYHRvYCwgYm90aCBvZiB0aGVtIHdoaWNoIGFyZSBvYmplY3RzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggdmFsdWVzIGB4YCBhbmQgYHlgIGNvbnRhaW5pbmcgY29vcmRpbmF0ZXMgb2YgdGhlIHdpcmUgZW5kcG9pbnRzXG4gKiBAcGFyYW0gIHtJdGVyYWJsZX0gbm9uUm91dGFibGVOb2RlcyAgU2V0IG9yIGFycmF5IG9mIG5vbiByb3V0YWJsZSBub2Rlc1xuICogQHBhcmFtICB7SXRlcmFibGV9IGluY29udmVuaWVudE5vZGVzIFNldCBvciBhcnJheSBvZiBpbmNvbnZlbmllbnQgbm9kZXNcbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICAgICAgICAgYXJyYXkgb2YgcGF0aHMsIGVhY2ggaXRlbSBpcyBhbiBhcnJheSBvZiBwb2ludHMgb2YgdGhlIHBhdGhcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHJldHVybmVkIGFycmF5IGNvbnRhaW5zIHBhdGhzIGZvciB0aGUgd2lyZXMgd2l0aCBjb3JyZXNwb25kaW5nIGluZGV4ZXMgZnJvbSB0aGUgYHdpcmVzYCBwYXJhbWV0ZXJcbiAqL1xuZnVuY3Rpb24gZmluZFBhdGhzKHdpcmVzLCBub25Sb3V0YWJsZU5vZGVzLCBpbmNvbnZlbmllbnROb2Rlcykge1xuICAgIGxldCBwYXRocyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBbZnJvbSwgdG9dIG9mIHdpcmVzKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBmaW5kUGF0aChmcm9tLCB0bywgbm9uUm91dGFibGVOb2RlcywgaW5jb252ZW5pZW50Tm9kZXMpO1xuXG4gICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ3BhdGggbm90IGZvdW5kJyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhmcm9tLCB0byk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygncGF0aCBmb3VuZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aHMucHVzaChwYXRoKTtcblxuICAgICAgICAvLyBhZGQgbmV3IGluY29udmVuaWVudCBub2RlcyBjcmVhdGVkIGJ5IHRoaXMgbmV3IHBhdGhcbiAgICAgICAgbGV0IHByZXZQb2ludDtcbiAgICAgICAgZm9yIChjb25zdCBwb2ludCBvZiBwYXRoKSB7XG4gICAgICAgICAgICBpZiAocHJldlBvaW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvaW50LnggPT09IHByZXZQb2ludC54KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhvcml6b250YWwgc2VjdGlvbiBvZiB0aGUgcGF0aFxuICAgICAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHkgPSBNYXRoLm1pbihwb2ludC55LCBwcmV2UG9pbnQueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5IDw9IE1hdGgubWF4KHBvaW50LnksIHByZXZQb2ludC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICsreVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY29udmVuaWVudE5vZGVzLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogcG9pbnQueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocG9pbnQueSA9PT0gcHJldlBvaW50LnkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmVydGljYWwgc2VjdGlvbiBvZiB0aGUgcGF0aFxuICAgICAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHggPSBNYXRoLm1pbihwb2ludC54LCBwcmV2UG9pbnQueCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4IDw9IE1hdGgubWF4KHBvaW50LngsIHByZXZQb2ludC54KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICsreFxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY29udmVuaWVudE5vZGVzLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBwb2ludC55XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJldlBvaW50ID0gcG9pbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aHM7XG59XG4iXX0="}