{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/json-stringify-pretty-compact/index.js","node_modules/libstl/Datastructures/DoublyLinkedList.js","node_modules/libstl/Datastructures/Heap.js","node_modules/libstl/Datastructures/MaxHeap.js","node_modules/libstl/Datastructures/MinHeap.js","node_modules/libstl/Datastructures/PriorityQueue.js","node_modules/libstl/Datastructures/Queue.js","node_modules/libstl/Datastructures/Stack.js","node_modules/libstl/node-module.js","src/es6/findPath.js","src/es6/helperFunctions.js","src/es6/mapWithDefaultValue.js","src/es6/routeWorker.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;kBCGwB,Q;;AAfxB;;AACA;;;;AAEA;;;;AAAwC;;AAExC;;AAEA;;;;;;;;AAQe,SAAS,QAAT,CAAkB,KAAlB,EAAyB,GAAzB,EAA8B,WAA9B,EAA2C,mBAA3C,EAAgE;;AAE3E,QAAM,qDAAN;;AAEA,QAAM,sBAAs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","file":"routeWorker.js","sourcesContent":["(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()","function stringify (obj, options) {\n  options = options || {}\n  var indent = JSON.stringify([1], null, get(options, 'indent', 2)).slice(2, -3)\n  var addMargin = get(options, 'margins', false)\n  var maxLength = (indent === '' ? Infinity : get(options, 'maxLength', 80))\n\n  return (function _stringify (obj, currentIndent, reserved) {\n    if (obj && typeof obj.toJSON === 'function') {\n      obj = obj.toJSON()\n    }\n\n    var string = JSON.stringify(obj)\n\n    if (string === undefined) {\n      return string\n    }\n\n    var length = maxLength - currentIndent.length - reserved\n\n    if (string.length <= length) {\n      var prettified = prettify(string, addMargin)\n      if (prettified.length <= length) {\n        return prettified\n      }\n    }\n\n    if (typeof obj === 'object' && obj !== null) {\n      var nextIndent = currentIndent + indent\n      var items = []\n      var delimiters\n      var comma = function (array, index) {\n        return (index === array.length - 1 ? 0 : 1)\n      }\n\n      if (Array.isArray(obj)) {\n        for (var index = 0; index < obj.length; index++) {\n          items.push(\n            _stringify(obj[index], nextIndent, comma(obj, index)) || 'null'\n          )\n        }\n        delimiters = '[]'\n      } else {\n        Object.keys(obj).forEach(function (key, index, array) {\n          var keyPart = JSON.stringify(key) + ': '\n          var value = _stringify(obj[key], nextIndent,\n                                 keyPart.length + comma(array, index))\n          if (value !== undefined) {\n            items.push(keyPart + value)\n          }\n        })\n        delimiters = '{}'\n      }\n\n      if (items.length > 0) {\n        return [\n          delimiters[0],\n          indent + items.join(',\\n' + nextIndent),\n          delimiters[1]\n        ].join('\\n' + currentIndent)\n      }\n    }\n\n    return string\n  }(obj, '', 0))\n}\n\n// Note: This regex matches even invalid JSON strings, but since we’re\n// working on the output of `JSON.stringify` we know that only valid strings\n// are present (unless the user supplied a weird `options.indent` but in\n// that case we don’t care since the output would be invalid anyway).\nvar stringOrChar = /(\"(?:[^\\\\\"]|\\\\.)*\")|[:,\\][}{]/g\n\nfunction prettify (string, addMargin) {\n  var m = addMargin ? ' ' : ''\n  var tokens = {\n    '{': '{' + m,\n    '[': '[' + m,\n    '}': m + '}',\n    ']': m + ']',\n    ',': ', ',\n    ':': ': '\n  }\n  return string.replace(stringOrChar, function (match, string) {\n    return string ? match : tokens[match]\n  })\n}\n\nfunction get (options, name, defaultValue) {\n  return (name in options ? options[name] : defaultValue)\n}\n\nmodule.exports = stringify\n","/**\n * The DoublyLinkedList class provides the main functionality of a doubly linked list.\n *\n * @class DoublyLinkedList\n */\nvar DoublyLinkedList = (function () {\n    function DoublyLinkedList() {\n        /**\n         * Count of elements in list\n         *\n         * @property _length\n         * @type number\n         * @private\n         */\n        this._length = 0;\n        /**\n         * Iteration pointer\n         *\n         * @property _key\n         * @type number\n         * @private\n         */\n        this._key = 0;\n        /**\n         * Reference to head(first) element in list\n         *\n         * @property _head\n         * @type DoublyLinkedListNode\n         * @private\n         */\n        this._head = null;\n        /**\n         * Reference to tail(last) element in list\n         *\n         * @property _tail\n         * @type DoublyLinkedListNode\n         * @private\n         */\n        this._tail = null;\n        /**\n         * Reference to iterated element in list\n         *\n         * @property _current\n         * @type DoublyLinkedListNode\n         * @private\n         */\n        this._current = null;\n    }\n    /**\n     * Insert a new value at the specified index\n     *\n     * @method add\n     * @param index The index where the new value is to be inserted.\n     * @param value The new value for the index.\n     * @return void\n     */\n    DoublyLinkedList.prototype.add = function (index, value) {\n        if (index < 0 || index >= this._length) {\n            throw new Error(\"Out of bounds\");\n        }\n        var i = 0;\n        var current = this._head;\n        while (i < index) {\n            current = current.next;\n            i++;\n        }\n        current.value = value;\n    };\n    /**\n     * Pops a node from the end of the doubly linked list\n     *\n     * @method pop\n     * @return any  The value of the popped node.\n     */\n    DoublyLinkedList.prototype.pop = function () {\n        if (this._length === 0) {\n            throw new Error(\"Can't pop from an empty data structure\");\n        }\n        var value = this._tail.value;\n        this._tail = this._tail.prev;\n        if (this._tail) {\n            delete this._tail.next;\n            this._tail.next = null;\n        }\n        this._length--;\n        if (this._length === 0) {\n            delete this._head;\n            this._head = null;\n        }\n        return value;\n    };\n    /**\n     * Shifts a node from the beginning of the doubly linked list\n     *\n     * @method shift\n     * @return any  The value of the shifted node.\n     */\n    DoublyLinkedList.prototype.shift = function () {\n        if (this._length === 0) {\n            throw new Error(\"Can't shift from an empty data structure\");\n        }\n        var value = this._head.value;\n        this._head = this._head.next;\n        if (this._head) {\n            delete this._head.prev;\n            this._head.prev = null;\n        }\n        this._length--;\n        return value;\n    };\n    /**\n     * Pushes an element at the end of the doubly linked list\n     *\n     * @method push\n     * @param value The value to push.\n     * @return void\n     */\n    DoublyLinkedList.prototype.push = function (value) {\n        // allocate new node\n        var node = {\n            value: value,\n            prev: this._tail,\n            next: null\n        };\n        if (this._length === 0) {\n            this._head = this._tail = node;\n        }\n        else {\n            this._tail.next = node;\n            this._tail = this._tail.next;\n        }\n        this._length++;\n    };\n    /**\n     * Prepends the doubly linked list with an element\n     *\n     * @method unshift\n     * @param value The value to unshift.\n     * @return void\n     */\n    DoublyLinkedList.prototype.unshift = function (value) {\n        // allocate new node\n        var node = {\n            value: value,\n            prev: null,\n            next: this._head\n        };\n        if (this._length === 0) {\n            this._head = this._tail = node;\n        }\n        else {\n            this._head.prev = node;\n            this._head = this._head.prev;\n        }\n        this._length++;\n    };\n    /**\n     * Peeks at the node from the end of the doubly linked list\n     *\n     * @method top\n     * @return any  The value of the last node.\n     */\n    DoublyLinkedList.prototype.top = function () {\n        if (this._tail)\n            return this._tail.value;\n    };\n    /**\n     * Peeks at the node from the beginning of the doubly linked list\n     *\n     * @method bottom\n     * @return any  The value of the first node.\n     */\n    DoublyLinkedList.prototype.bottom = function () {\n        if (this._head)\n            return this._head.value;\n    };\n    /**\n     * Counts the number of elements in the doubly linked list\n     *\n     * @method count\n     * @return number the number of elements in the doubly linked list.\n     */\n    DoublyLinkedList.prototype.count = function () {\n        return this._length;\n    };\n    /**\n     * Checks whether the doubly linked list is empty\n     *\n     * @method isEmpty\n     * @return boolean whether the doubly linked list is empty.\n     */\n    DoublyLinkedList.prototype.isEmpty = function () {\n        return (this._length === 0);\n    };\n    /**\n     * Rewind iterator back to the start\n     *\n     * @method rewind\n     * @return void\n     */\n    DoublyLinkedList.prototype.rewind = function () {\n        this._key = 0;\n        this._current = this._head;\n    };\n    /**\n     * Return current list entry\n     *\n     * @method current\n     * @return any  The current node value.\n     */\n    DoublyLinkedList.prototype.current = function () {\n        if (this._current) {\n            return this._current.value;\n        }\n        return null;\n    };\n    /**\n     * Return current node index\n     *\n     * @method key\n     * @return any  The current node index.\n     */\n    DoublyLinkedList.prototype.key = function () {\n        return this._key;\n    };\n    /**\n     * Move to next entry\n     *\n     * @method next\n     * @return void\n     */\n    DoublyLinkedList.prototype.next = function () {\n        this._current = this._current.next;\n        this._key++;\n    };\n    /**\n     * Move to previous entry\n     *\n     * @method prev\n     * @return void\n     */\n    DoublyLinkedList.prototype.prev = function () {\n        this._current = this._current.prev;\n        this._key--;\n    };\n    /**\n     * Check whether the doubly linked list contains more nodes\n     *\n     * @method valid\n     * @return boolean true if the doubly linked list contains any more nodes, false otherwise.\n     */\n    DoublyLinkedList.prototype.valid = function () {\n        return (this._key >= 0 && this._key < this._length);\n    };\n    /**\n     * Export the list to array\n     *\n     * @method toArray\n     * @return Array   The exported array\n     */\n    DoublyLinkedList.prototype.toArray = function () {\n        var list = [];\n        var current = this._head;\n        while (current) {\n            list.push(current.value);\n            current = current.next;\n        }\n        return list;\n    };\n    /**\n     * Serializes the list to string\n     *\n     * @method toString\n     * @return string   The serialized string.\n     */\n    DoublyLinkedList.prototype.toString = function () {\n        return \"{\" + this.toArray().join(\"->\") + \"}\";\n    };\n    return DoublyLinkedList;\n})();\nmodule.exports = DoublyLinkedList;\n//# sourceMappingURL=DoublyLinkedList.js.map","/**\n * The Heap class provides the main functionality of a Heap.\n *\n * @class Heap\n */\nvar Heap = (function () {\n    function Heap() {\n        /**\n         * Binary tree storage array\n         *\n         * @property _tree\n         * @type Array\n         * @private\n         */\n        this._tree = [];\n        /**\n         * Heap type\n         *\n         * @property _type\n         * @type number\n         * @private\n         */\n        this._type = Heap.MAX;\n        /**\n         * Iteration pointer\n         *\n         * @property _key\n         * @type number\n         * @private\n         */\n        this._key = 0;\n    }\n    /**\n     * Get index of left child element in binary tree stored in array\n     *\n     * @method _child\n     * @param n\n     * @return number\n     * @private\n     */\n    Heap.prototype._child = function (n) {\n        return 2 * n + 1;\n    };\n    /**\n     * Get index of parent element in binary tree stored in array\n     *\n     * @method _parent\n     * @param n\n     * @return number\n     * @private\n     */\n    Heap.prototype._parent = function (n) {\n        //console.log('n=', n, Math.floor(n / 2));\n        return Math.floor(n / 2);\n    };\n    /**\n     * Swap 2 elements in binary tree\n     *\n     * @method _swap\n     * @param first\n     * @param second\n     * @private\n     */\n    Heap.prototype._swap = function (first, second) {\n        var swap = this._tree[first];\n        this._tree[first] = this._tree[second];\n        this._tree[second] = swap;\n    };\n    /**\n     * Sift elements in binary tree\n     *\n     * @method _siftUp\n     * @param i\n     * @private\n     */\n    Heap.prototype._siftUp = function (i) {\n        while (i > 0) {\n            var parent = this._parent(i);\n            if (this.compare(this._tree[i], this._tree[parent]) * this._type > 0) {\n                this._swap(i, parent);\n                i = parent;\n            }\n            else {\n                break;\n            }\n        }\n    };\n    /**\n     * Sift down elements in binary tree\n     *\n     * @method _siftDown\n     * @param i\n     * @private\n     */\n    Heap.prototype._siftDown = function (i) {\n        while (i < this._tree.length) {\n            var left = this._child(i);\n            var right = left + 1;\n            if ((left < this._tree.length) && (right < this._tree.length) &&\n                (this.compare(this._tree[i], this._tree[left]) * this._type < 0 ||\n                    this.compare(this._tree[i], this._tree[right]) * this._type < 0)) {\n                // there is 2 children and one of them must be swapped\n                // get correct element to sift down\n                var sift = left;\n                if (this.compare(this._tree[left], this._tree[right]) * this._type < 0) {\n                    sift = right;\n                }\n                this._swap(i, sift);\n                i = sift;\n            }\n            else if (left < this._tree.length &&\n                this.compare(this._tree[i], this._tree[left]) * this._type < 0) {\n                // only one child exists\n                this._swap(i, left);\n                i = left;\n            }\n            else {\n                break;\n            }\n        }\n    };\n    /**\n     * Extracts a node from top of the heap and sift up\n     *\n     * @method extract\n     * @return any The value of the extracted node.\n     */\n    Heap.prototype.extract = function () {\n        if (this._tree.length === 0) {\n            throw new Error(\"Can't extract from an empty data structure\");\n        }\n        var extracted = this._tree[0];\n        if (this._tree.length === 1) {\n            this._tree = [];\n        }\n        else {\n            this._tree[0] = this._tree.pop();\n            this._siftDown(0);\n        }\n        return extracted;\n    };\n    /**\n     * Inserts an element in the heap by sifting it up\n     *\n     * @method insert\n     * @param value The value to insert.\n     * @return void\n     */\n    Heap.prototype.insert = function (value) {\n        this._tree.push(value);\n        this._siftUp(this._tree.length - 1);\n    };\n    /**\n     * Peeks at the node from the top of the heap\n     *\n     * @method top\n     * @return any The value of the node on the top.\n     */\n    Heap.prototype.top = function () {\n        if (this._tree.length === 0) {\n            throw new Error(\"Can't peek at an empty heap\");\n        }\n        return this._tree[0];\n    };\n    /**\n     * Counts the number of elements in the heap\n     *\n     * @method count\n     * @return number the number of elements in the heap.\n     */\n    Heap.prototype.count = function () {\n        return this._tree.length;\n    };\n    /**\n     * Checks whether the heap is empty\n     *\n     * @method isEmpty\n     * @return boolean whether the heap is empty.\n     */\n    Heap.prototype.isEmpty = function () {\n        return (this._tree.length === 0);\n    };\n    /**\n     * Rewind iterator back to the start (no-op)\n     *\n     * @method rewind\n     * @return void\n     */\n    Heap.prototype.rewind = function () {\n        this._key = 0;\n    };\n    /**\n     * Return current node pointed by the iterator\n     *\n     * @method current\n     * @return any The current node value.\n     */\n    Heap.prototype.current = function () {\n        return this._tree[this._key];\n    };\n    /**\n     * Return current node index\n     *\n     * @method key\n     * @return any The current node index.\n     */\n    Heap.prototype.key = function () {\n        return this._key;\n    };\n    /**\n     * Move to the next node\n     *\n     * @method next\n     * @return void\n     */\n    Heap.prototype.next = function () {\n        this._key++;\n    };\n    /**\n     * Move to previous entry\n     *\n     * @method prev\n     * @return void\n     */\n    Heap.prototype.prev = function () {\n        this._key--;\n    };\n    /**\n     * Check whether the heap contains more nodes\n     *\n     * @method valid\n     * @return boolean true if the heap contains any more nodes, false otherwise.\n     */\n    Heap.prototype.valid = function () {\n        return (this._key >= 0 && this._key < this._tree.length);\n    };\n    /**\n     * Compare elements in order to place them correctly in the heap while sifting up.\n     *\n     * @method compare\n     * @param first The value of the first node being compared.\n     * @param second The value of the second node being compared.\n     * @return number Result of the comparison, positive integer if first is greater than second, 0 if they are equal, negative integer otherwise.\n     * Having multiple elements with the same value in a Heap is not recommended. They will end up in an arbitrary relative position.\n     */\n    Heap.prototype.compare = function (first, second) {\n        if (first > second) {\n            return 1;\n        }\n        else if (first == second) {\n            return 0;\n        }\n        else {\n            return -1;\n        }\n    };\n    /**\n     * Visually display heap tree\n     *\n     * @method _displayNode\n     * @param node\n     * @param prefix\n     * @param last\n     * @return String\n     * @private\n     */\n    Heap.prototype._displayNode = function (node, prefix, last) {\n        if (prefix === void 0) { prefix = ''; }\n        if (last === void 0) { last = true; }\n        var line = prefix;\n        // get child indexes\n        var left = this._child(node);\n        var right = left + 1;\n        if (last) {\n            line += (prefix ? '└─' : '  ');\n        }\n        else {\n            line += '├─';\n        }\n        line += this._tree[node];\n        prefix += (last ? '  ' : '│ ');\n        if (left < this._tree.length) {\n            line += '\\n' + this._displayNode(left, prefix, (this._tree[right] == undefined ? true : false));\n        }\n        if (right < this._tree.length) {\n            line += '\\n' + this._displayNode(right, prefix, true);\n        }\n        return line;\n    };\n    /**\n     * Serializes the heap to string\n     *\n     * @method toString\n     * @return string   The serialized string.\n     */\n    Heap.prototype.toString = function () {\n        // start with root and recursively goes to each node\n        return this._displayNode(0);\n    };\n    /**\n     * Serializes the heap to array\n     *\n     * @method toArray\n     * @return Array   The serialized array.\n     */\n    Heap.prototype.toArray = function () {\n        return this._tree;\n    };\n    /**\n     * Max heap flag\n     *\n     * @property MAX\n     * @type number\n     * @static\n     */\n    Heap.MAX = 1;\n    /**\n     * Min heap flag\n     *\n     * @property MIN\n     * @type number\n     * @static\n     */\n    Heap.MIN = -1;\n    return Heap;\n})();\nmodule.exports = Heap;\n//# sourceMappingURL=Heap.js.map","var __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\nvar Heap = require('./Heap');\n/**\n * The MaxHeap class provides the main functionality of a heap, keeping the maximum on the top.\n *\n * @class MaxHeap\n * @extends Heap\n */\nvar MaxHeap = (function (_super) {\n    __extends(MaxHeap, _super);\n    function MaxHeap() {\n        _super.apply(this, arguments);\n        this._type = Heap.MAX;\n    }\n    return MaxHeap;\n})(Heap);\nmodule.exports = MaxHeap;\n//# sourceMappingURL=MaxHeap.js.map","var __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\nvar Heap = require('./Heap');\n/**\n * The MinHeap class provides the main functionality of a heap, keeping the minimum on the top.\n *\n * @class MinHeap\n * @extends Heap\n */\nvar MinHeap = (function (_super) {\n    __extends(MinHeap, _super);\n    function MinHeap() {\n        _super.apply(this, arguments);\n        this._type = Heap.MIN;\n    }\n    return MinHeap;\n})(Heap);\nmodule.exports = MinHeap;\n//# sourceMappingURL=MinHeap.js.map","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Heap = require('./Heap');\n/**\n * The PriorityQueue class provides the main functionality of an prioritized queue, implemented using a max heap.\n *\n * @class PriorityQueue\n * @extends Heap\n */\nvar PriorityQueue = (function (_super) {\n    __extends(PriorityQueue, _super);\n    function PriorityQueue() {\n        _super.apply(this, arguments);\n        this._type = Heap.MAX;\n    }\n    /**\n     * Adds an element to the queue\n     *\n     * @method enqueue\n     * @param value The value to enqueue.\n     * @param priority The priority of value.\n     * @return void\n     */\n    PriorityQueue.prototype.enqueue = function (value, priority) {\n        return this.insert(new PriorityQueueNode(value, priority));\n    };\n    /**\n     * Dequeues a node from the queue\n     *\n     * @method dequeue\n     * @return any  The value of the dequeued node.\n     */\n    PriorityQueue.prototype.dequeue = function () {\n        return this.extract().value;\n    };\n    /**\n     * Peeks at the node from the top of the heap\n     *\n     * @method top\n     * @return any The value of the node on the top.\n     */\n    PriorityQueue.prototype.top = function () {\n        return _super.prototype.top.call(this).value;\n    };\n    /**\n     * Compare elements in order to place them correctly in the heap while sifting up.\n     *\n     * @method compare\n     * @param first The value of the first node being compared.\n     * @param second The value of the second node being compared.\n     * @return number Result of the comparison, positive integer if first is greater than second, 0 if they are equal, negative integer otherwise.\n     * Having multiple elements with the same value in a Heap is not recommended. They will end up in an arbitrary relative position.\n     */\n    PriorityQueue.prototype.compare = function (first, second) {\n        if (first.priority > second.priority) {\n            return 1;\n        }\n        else if (first.priority == second.priority) {\n            return 0;\n        }\n        else {\n            return -1;\n        }\n    };\n    return PriorityQueue;\n})(Heap);\n/**\n * PriorityQueue Node\n *\n * @class PriorityQueueNode\n */\nvar PriorityQueueNode = (function () {\n    /**\n     * Constructor\n     *\n     * @method constructor\n     * @param value\n     * @param priority\n     */\n    function PriorityQueueNode(value, priority) {\n        this.value = value;\n        this.priority = priority;\n    }\n    /**\n     * Serializes the node to string\n     *\n     * @method toString\n     * @return string   The serialized string.\n     */\n    PriorityQueueNode.prototype.toString = function () {\n        return this.value + \" [\" + this.priority + \"]\";\n    };\n    return PriorityQueueNode;\n})();\nmodule.exports = PriorityQueue;\n//# sourceMappingURL=PriorityQueue.js.map","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DoublyLinkedList = require('./DoublyLinkedList');\n/**\n * The Queue class provides the main functionality of a queue implemented using a doubly linked list.\n *\n * @class Queue\n * @extends DoublyLinkedList\n */\nvar Queue = (function (_super) {\n    __extends(Queue, _super);\n    function Queue() {\n        _super.apply(this, arguments);\n    }\n    /**\n     * Adds an element to the queue\n     *\n     * @method enqueue\n     * @param value The value to enqueue.\n     * @return void\n     */\n    Queue.prototype.enqueue = function (value) {\n        return this.push(value);\n    };\n    /**\n     * Dequeues a node from the queue\n     *\n     * @method dequeue\n     * @return any  The value of the dequeued node.\n     */\n    Queue.prototype.dequeue = function () {\n        return this.shift();\n    };\n    return Queue;\n})(DoublyLinkedList);\nmodule.exports = Queue;\n//# sourceMappingURL=Queue.js.map","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DoublyLinkedList = require('./DoublyLinkedList');\n/**\n * The Stack class provides the main functionality of a stack implemented using a doubly linked list.\n *\n * @class Stack\n * @extends DoublyLinkedList\n */\nvar Stack = (function (_super) {\n    __extends(Stack, _super);\n    function Stack() {\n        _super.apply(this, arguments);\n    }\n    return Stack;\n})(DoublyLinkedList);\nmodule.exports = Stack;\n//# sourceMappingURL=Stack.js.map","/**\n * STL\n * @type {{DoublyLinkedList: exports, Stack: exports, Queue: exports, Heap: exports, MaxHeap: exports, MinHeap: exports, PriorityQueue: exports}}\n */\nmodule.exports = {\n\tDoublyLinkedList: require('./Datastructures/DoublyLinkedList'),\n\tStack: require('./Datastructures/Stack'),\n\tQueue: require('./Datastructures/Queue'),\n\tHeap: require('./Datastructures/Heap'),\n\tMaxHeap: require('./Datastructures/MaxHeap'),\n\tMinHeap: require('./Datastructures/MinHeap'),\n\tPriorityQueue: require('./Datastructures/PriorityQueue')\n};","import {manhattanDistance} from './helperFunctions'\nimport MapWithDefaultValue from './mapWithDefaultValue'\n\nimport { PriorityQueue } from 'libstl'; // note: imported from a node module\n\n/** @module findPath */\n\n/**\n * Heavily modified implementation of the A* algorithm\n * @param  {Object} start object containing numeric attributes `x` and `y` that represent the first endpoint of the wire in grid pixels\n * @param  {Object} end   object containing numeric attributes `x` and `y` that represent the second endpoint of the wire in grid pixels\n * @param  {Set} nonRoutable set of non routable nodes\n * @param  {Set} punishedButRoutable set of nodes that are not optimal for routing\n * @return {Array} array of objects containing numeric attributes `x` and `y`\n */\nexport default function findPath(start, end, nonRoutable, punishedButRoutable) {\n\n    const distanceFunction = manhattanDistance;\n\n    const wireCrossPunishment = 1;\n    const wireBendPunishment = 1;\n\n    // number of nodes, that can be opened at once\n    // once is this limit exceeded, aStar will fail and return undefined\n    const maxNodeLimit = 100000;\n\n    let closedNodes = new Set();\n    let openNodes = new Set();\n    let openNodeQueue = new PriorityQueue();\n\n    // functions for working with open nodes:\n\n    /**\n     * add a new open node to the structure\n     * @param {Object} node   object containing numeric attributes `x` and `y` that represent the first endpoint of the wire\n     * @param {number} fscore fScore of this node\n     */\n    const addOpenNode = (node, fscore) => {\n        openNodes.add(node);\n        // flip the fscore, because PriorityQueue uses max heap\n        openNodeQueue.enqueue(node, 1 / fscore);\n    }\n\n    /**\n     * get the open node with the lowest fScore and remove it\n     * @return {Object} object containing numeric attributes `x` and `y` that represent the first endpoint of the wire\n     */\n    const getOpenNode = () => {\n        const node = openNodeQueue.dequeue();\n        openNodes.delete(node);\n        return node;\n    }\n\n    let cameFrom = new Map();\n\n    // default value: infinity\n    let gScore = new MapWithDefaultValue(Infinity);\n    gScore.set(start, 0);\n\n    let startFScore = distanceFunction(start, end);\n\n    addOpenNode(start, startFScore);\n\n    openNodes.add(start);\n    openNodeQueue.enqueue(start, 1 / startFScore);\n\n    while (openNodes.size > 0) {\n        // get the value from openNodes that has the lowest fScore\n        const currentNode = getOpenNode();\n\n        // if we reached the end point, reconstruct the path and return it\n        if (currentNode.x == end.x && currentNode.y == end.y) {\n            return reconstructPath(cameFrom, currentNode);\n        }\n\n        // add this node to the closed nodes\n        closedNodes.add(currentNode);\n\n        // the farthest points accessible without avoiding obstacles in every direction\n        // (but max 50 in each direction)\n        for (let direction = 0; direction < 4; direction++) {\n            let newPoint = movePoint(currentNode, direction);\n\n            let wiresCrossed = 0;\n\n            for (let i = 0; i < 50; i++) {\n                // if newPoint is in the set of non routable points,\n                // don't add it and stop proceeding in this direction\n                if (setHasThisPoint(nonRoutable, newPoint)) {\n                    // if this not the end point, break\n                    if (newPoint.x !== end.x || newPoint.y !== end.y) {\n                        break;\n                    }\n                }\n\n                // skip this node, if it has been already closed\n                // or if it is on the list of non routable nodes\n                if (closedNodes.has(newPoint)) {\n                    continue;\n                }\n\n                // calculate possible GScore by applying a punishment for each node (\"bend\") in the path\n                let newGScore = wireBendPunishment + gScore.getWithDefault(currentNode);\n\n                if (setHasThisPoint(punishedButRoutable, newPoint)) {\n                    // if the node is in the set of punished nodes, apply the punishment\n                    wiresCrossed++;\n                }\n\n                // apply the punishment for each wire crossed in this direction\n                // note: we are counting the wires crossed when exporting this direction, not the wires\n                // crossed in the final path, there will be probably only at most of these nodes in the\n                // final path, not multiple\n                newGScore += wiresCrossed * wireCrossPunishment;\n\n                // skip this node if it has worst estimage gscore than in the gscore table\n                if (newGScore >= gScore.getWithDefault(newPoint)) {\n                    continue;\n                }\n\n                cameFrom.set(newPoint, currentNode);\n                gScore.set(newPoint, newGScore);\n\n                const newFScore = newGScore + distanceFunction(newPoint, end);\n\n                if (!openNodes.has(newPoint)) {\n                    // add the point to the list of points\n                    addOpenNode(newPoint, newFScore);\n                }\n\n                // move to the next point in the direciton\n                newPoint = movePoint(newPoint, direction);\n            }\n        }\n\n        if (openNodes.size > maxNodeLimit) {\n            console.log(`aStar: Number of open nodes (${openNodes.size}) exceeded the limit for open nodes (${maxNodeLimit}).`)\n            break;\n        }\n    }\n    // if we got here, the path was not found\n\n    return undefined;\n}\n\n/**\n * returns `true` if the specified set of points contains the specified point (and returns `false` otherwise)\n * @param {Set} set set of points\n * @param {Object} point object containing numeric attributes `x` and `y`\n */\nfunction setHasThisPoint(set, point) {\n    for (let item of set) {\n        if (item.x === point.x && item.y === point.y) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Helper that moves the passed point in the specified direction. It simply adds or subtracts 1 from one of the coordinates depending on the direction attribute.\n * @param  {Object} point     object containing numeric attributes `x` and `y`\n * @param  {number} direction directions:\n *     - 0: up\n *     - 1: right\n *     - 2: down\n *     - 3: left\n * @return {Object}           object containing numeric attributes `x` and `y`\n */\nfunction movePoint(point, direction) {\n    switch (direction) {\n        case 0: // up\n            return {\n                x: point.x,\n                y: point.y - 1\n            };\n        case 1: // right\n            return {\n                x: point.x + 1,\n                y: point.y\n            };\n        case 2: // down\n            return {\n                x: point.x,\n                y: point.y + 1\n            };\n        case 3: // left\n            return {\n                x: point.x - 1,\n                y: point.y\n            };\n    }\n}\n\n/**\n * helper backtracking function used by the aStar algorithm to construct the final path\n * @param  {Object} cameFrom    object containing numeric attributes `x` and `y`\n * @param  {Object} currentNode object containing numeric attributes `x` and `y`\n * @return {Array} array of objects containing numeric attributes `x` and `y`\n */\nfunction reconstructPath(cameFrom, currentNode) {\n    let path = [];\n\n    path.push({\n        x: currentNode.x,\n        y: currentNode.y\n    })\n\n    while (cameFrom.has(currentNode)) {\n        currentNode = cameFrom.get(currentNode);\n        path.push({\n            x: currentNode.x,\n            y: currentNode.y\n        })\n    }\n\n    return path;\n}\n","\"use strict\";\n\n/**\n * @module HelperFunctions\n */\n\nimport stringify from \"json-stringify-pretty-compact\"; // note: imported from a module\n\n/**\n * add a cross browser event listener on a mouse scroll\n * @param {string} query DOM query of the element that the listener will be added to\n * @param {Function} func  Function that will be called when the event occurs. The function takes as a parameter an event object.\n */\nexport function addMouseScrollEventListener(query, func) {\n    let MouseWheelHandler = event => {\n        // redeclare for old IE support\n        var event = window.event || event; // eslint-disable-line no-redeclare\n\n        event.delta = Math.max(-1, Math.min(1, (event.wheelDelta || -event.detail)));\n\n        func(event)\n\n        return false;\n    }\n\n    let svgelement;\n\n    // if the query is a simple DOM id selector, we can use getElementById which has better backwards compatibility\n    if(query.match(/^#\\w+$/)) {\n        svgelement = document.getElementById(query.substr(1))\n    } else {\n        svgelement = document.querySelector(query)\n    }\n\n    if (svgelement.addEventListener) {\n        // IE9, Chrome, Safari, Opera\n        svgelement.addEventListener(\"mousewheel\", MouseWheelHandler, false);\n        // Firefox\n        svgelement.addEventListener(\"DOMMouseScroll\", MouseWheelHandler, false);\n    } else  {\n        // IE 6/7/8\n        svgelement.attachEvent(\"onmousewheel\", MouseWheelHandler);\n    }\n    svgelement.addEventListener('mousewheel', function(e) {\n        console.log('event', e)\n    }, false)\n}\n\n/**\n * convert a data object to JSON string or to a data URI containing a JSON string\n * @param  {Object}  data            object that will be serialized into a JSON string\n * @param  {Boolean} [pretty=false]  if `true`, the code will be proprerly indented, else a more compact syntax will be used\n * @param  {Boolean} [dataUri=false] return dataUri containing the JSON string instead of the pure JSON string\n * @return {string}\n */\nexport function getJSONString(data, pretty = false, dataUri = false) {\n    if(dataUri) {\n        return 'data:application/json;charset=utf-8,'\n            + encodeURIComponent(getJSONString(data, pretty));\n    } else {\n        switch (pretty) {\n            case true:\n                return stringify(data, {maxLength: 50});\n            case false:\n                return JSON.stringify(data);\n        }\n    }\n}\n\n/**\n * returns the Manhattan distance between the points _a_ and _b_\n * @param  {Object} a object containing numeric attributes `x` and `y`\n * @param  {Object} b object containing numeric attributes `x` and `y`\n * @return {number}\n */\nexport function manhattanDistance(a, b) {\n    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\n}\n","/** @module MapWithDefaultValue */\n/**\n * Map that has a default value specified in the constructor.\n *\n * For the complete documentation of the Map see [Map in the MDN web docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\n *\n * Usage:\n * ```JavaScript\n let myMap = new MapWithDefaultValue(Infinity);\n const value = myMap.getWithDefault(key)\n ```\n *\n * _Note: This version is written specially for ES6 compiled into ES5. In non-compiled ES6 is the implementation far more elegant:_\n *\n * ```JavaScript\n export class MapWithDefaultValue extends Map {\n     constructor(defaultValue) {\n         super();\n\n         this.default = defaultValue;\n     }\n\n     get(key) {\n         if(this.has(key)) {\n             return super.get(key);\n         } else {\n             return this.default;\n         }\n     }\n }```\n * @class MapWithDefaultValue\n * @param defaultValue {any} default value that will be returned when the requested key is not found in the map\n */\nexport default function(defaultValue) {\n    let map = new Map();\n    /**\n     * @param  {any} key key of a requested item\n     * @return {any} value of the item with the corresponding key, or defaultValue if the key is not found in the map\n     */\n    map.getWithDefault = (key) => {\n        return map.has(key)\n            ? map.get(key)\n            : defaultValue;\n    }\n    return map;\n}\n","/** @module routeWorker */\n\nimport findPath from './findPath'\n\n/**\n * callback when a message is sent to the web worker\n *\n * @param {Object} event web worker event object (the `data` item of the event object is expected to contain\n *                       these items: `wires` (array), `nonRoutableNodes` (iterable) and `inconvenientNodes` (iterable))\n */\nonmessage = (event) => {\n    const {wires, nonRoutableNodes, inconvenientNodes} = event.data;\n\n    const paths = findPaths(wires, nonRoutableNodes, inconvenientNodes);\n\n    postMessage({paths});\n    close();\n}\n\n/**\n * find paths for all the specified wires\n * @param  {Array} wires              array of objects with attributes `from` and `to`, both of them which are objects\n *                                    with values `x` and `y` containing coordinates of the wire endpoints\n * @param  {Iterable} nonRoutableNodes  Set or array of non routable nodes\n * @param  {Iterable} inconvenientNodes Set or array of inconvenient nodes\n * @return {Array}                    array of paths, each item is an array of points of the path\n *                                    the returned array contains paths for the wires with corresponding indexes from the `wires` parameter\n */\nfunction findPaths(wires, nonRoutableNodes, inconvenientNodes) {\n    let paths = [];\n\n    for (const [from, to] of wires) {\n        const path = findPath(from, to, nonRoutableNodes, inconvenientNodes)\n\n        paths.push(path);\n\n        // add new inconvenient nodes created by this new path\n        let prevPoint;\n        for(const point of path) {\n            if(prevPoint) {\n                if(point.x === prevPoint.x) {\n                    // horizontal section of the path\n                    for(let y = Math.min(point.y, prevPoint.y); y <= Math.max(point.y, prevPoint.y) ; ++y) {\n                        inconvenientNodes.add({\n                            x: point.x,\n                            y: y\n                        })\n                    }\n                } else if(point.y === prevPoint.y) {\n                    // vertical section of the path\n                    for(let x = Math.min(point.x, prevPoint.x); x <= Math.max(point.x, prevPoint.x) ; ++x) {\n                        inconvenientNodes.add({\n                            x: x,\n                            y: point.y\n                        })\n                    }\n                }\n            }\n\n            prevPoint = point;\n        }\n    }\n\n    return paths;\n}\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvanNvbi1zdHJpbmdpZnktcHJldHR5LWNvbXBhY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL0RvdWJseUxpbmtlZExpc3QuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL0hlYXAuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL01heEhlYXAuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL01pbkhlYXAuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL1ByaW9yaXR5UXVldWUuanMiLCJub2RlX21vZHVsZXMvbGlic3RsL0RhdGFzdHJ1Y3R1cmVzL1F1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL2xpYnN0bC9EYXRhc3RydWN0dXJlcy9TdGFjay5qcyIsIm5vZGVfbW9kdWxlcy9saWJzdGwvbm9kZS1tb2R1bGUuanMiLCJzcmMvZXM2L2ZpbmRQYXRoLmpzIiwic3JjL2VzNi9oZWxwZXJGdW5jdGlvbnMuanMiLCJzcmMvZXM2L21hcFdpdGhEZWZhdWx0VmFsdWUuanMiLCJzcmMvZXM2L3JvdXRlV29ya2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O2tCQ0d3QixROztBQWZ4Qjs7QUFDQTs7OztBQUVBOzs7O0FBQXdDOztBQUV4Qzs7QUFFQTs7Ozs7Ozs7QUFRZSxTQUFTLFFBQVQsQ0FBa0IsS0FBbEIsRUFBeUIsR0FBekIsRUFBOEIsV0FBOUIsRUFBMkMsbUJBQTNDLEVBQWdFOztB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QUFDQSxpQ0FBSSxJQUFJLElBQUksS0FBSyxHQUFMLENBQVMsTUFBTSxDQUFmLEVBQWtCLFVBQVUsQ0FBNUIsQ0FBWixFQUE0QyxLQUFLLEtBQUssR0FBTCxDQUFTLE1BQU0sQ0FBZixFQUFrQixVQUFVLENBQTVCLENBQWpELEVBQWtGLEVBQUUsQ0FBcEYsRUFBdUY7QUFDbkYsa0RBQWtCLEdBQWxCLENBQXNCO0FBQ2xCLHVDQUFHLE1BQU0sQ0FEUztBQUVsQix1Q0FBRztBQUZlLGlDQUF0QjtBQUlIO0FBQ0oseUJBUkQsTUFRTyxJQUFHLE1BQU0sQ0FBTixLQUFZLFVBQVUsQ0FBekIsRUFBNEI7QUFDL0I7QUFDQSxpQ0FBSSxJQUFJLElBQUksS0FBSyxHQUFMLENBQVMsTUFBTSxDQUFmLEVBQWtCLFVBQVUsQ0FBNUIsQ0FBWixFQUE0QyxLQUFLLEtBQUssR0FBTCxDQUFTLE1BQU0sQ0FBZixFQUFrQixVQUFVLENBQTVCLENBQWpELEVBQWtGLEVBQUUsQ0FBcEYsRUFBdUY7QUFDbkYsa0RBQWtCLEdBQWxCLENBQXNCO0FBQ2xCLHVDQUFHLENBRGU7QUFFbEIsdUNBQUcsTUFBTTtBQUZTLGlDQUF0QjtBQUlIO0FBQ0o7QUFDSjs7QUFFRCxnQ0FBWSxLQUFaO0FBQ0g7QUE3QjJCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUE4Qi9CO0FBakMwRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQW1DM0QsV0FBTyxLQUFQO0FBQ0giLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfXJldHVybiBlfSkoKSIsImZ1bmN0aW9uIHN0cmluZ2lmeSAob2JqLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHZhciBpbmRlbnQgPSBKU09OLnN0cmluZ2lmeShbMV0sIG51bGwsIGdldChvcHRpb25zLCAnaW5kZW50JywgMikpLnNsaWNlKDIsIC0zKVxuICB2YXIgYWRkTWFyZ2luID0gZ2V0KG9wdGlvbnMsICdtYXJnaW5zJywgZmFsc2UpXG4gIHZhciBtYXhMZW5ndGggPSAoaW5kZW50ID09PSAnJyA/IEluZmluaXR5IDogZ2V0KG9wdGlvbnMsICdtYXhMZW5ndGgnLCA4MCkpXG5cbiAgcmV0dXJuIChmdW5jdGlvbiBfc3RyaW5naWZ5IChvYmosIGN1cnJlbnRJbmRlbnQsIHJlc2VydmVkKSB7XG4gICAgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb2JqID0gb2JqLnRvSlNPTigpXG4gICAgfVxuXG4gICAgdmFyIHN0cmluZyA9IEpTT04uc3RyaW5naWZ5KG9iailcblxuICAgIGlmIChzdHJpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHN0cmluZ1xuICAgIH1cblxuICAgIHZhciBsZW5ndGggPSBtYXhMZW5ndGggLSBjdXJyZW50SW5kZW50Lmxlbmd0aCAtIHJlc2VydmVkXG5cbiAgICBpZiAoc3RyaW5nLmxlbmd0aCA8PSBsZW5ndGgpIHtcbiAgICAgIHZhciBwcmV0dGlmaWVkID0gcHJldHRpZnkoc3RyaW5nLCBhZGRNYXJnaW4pXG4gICAgICBpZiAocHJldHRpZmllZC5sZW5ndGggPD0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBwcmV0dGlmaWVkXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkge1xuICAgICAgdmFyIG5leHRJbmRlbnQgPSBjdXJyZW50SW5kZW50ICsgaW5kZW50XG4gICAgICB2YXIgaXRlbXMgPSBbXVxuICAgICAgdmFyIGRlbGltaXRlcnNcbiAgICAgIHZhciBjb21tYSA9IGZ1bmN0aW9uIChhcnJheSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIChpbmRleCA9PT0gYXJyYXkubGVuZ3RoIC0gMSA/IDAgOiAxKVxuICAgICAgfVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBvYmoubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgaXRlbXMucHVzaChcbiAgICAgICAgICAgIF9zdHJpbmdpZnkob2JqW2luZGV4XSwgbmV4dEluZGVudCwgY29tbWEob2JqLCBpbmRleCkpIHx8ICdudWxsJ1xuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICBkZWxpbWl0ZXJzID0gJ1tdJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIGluZGV4LCBhcnJheSkge1xuICAgICAgICAgIHZhciBrZXlQYXJ0ID0gSlNPTi5zdHJpbmdpZnkoa2V5KSArICc6ICdcbiAgICAgICAgICB2YXIgdmFsdWUgPSBfc3RyaW5naWZ5KG9ialtrZXldLCBuZXh0SW5kZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5UGFydC5sZW5ndGggKyBjb21tYShhcnJheSwgaW5kZXgpKVxuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKGtleVBhcnQgKyB2YWx1ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIGRlbGltaXRlcnMgPSAne30nXG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgZGVsaW1pdGVyc1swXSxcbiAgICAgICAgICBpbmRlbnQgKyBpdGVtcy5qb2luKCcsXFxuJyArIG5leHRJbmRlbnQpLFxuICAgICAgICAgIGRlbGltaXRlcnNbMV1cbiAgICAgICAgXS5qb2luKCdcXG4nICsgY3VycmVudEluZGVudClcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5nXG4gIH0ob2JqLCAnJywgMCkpXG59XG5cbi8vIE5vdGU6IFRoaXMgcmVnZXggbWF0Y2hlcyBldmVuIGludmFsaWQgSlNPTiBzdHJpbmdzLCBidXQgc2luY2Ugd2XigJlyZVxuLy8gd29ya2luZyBvbiB0aGUgb3V0cHV0IG9mIGBKU09OLnN0cmluZ2lmeWAgd2Uga25vdyB0aGF0IG9ubHkgdmFsaWQgc3RyaW5nc1xuLy8gYXJlIHByZXNlbnQgKHVubGVzcyB0aGUgdXNlciBzdXBwbGllZCBhIHdlaXJkIGBvcHRpb25zLmluZGVudGAgYnV0IGluXG4vLyB0aGF0IGNhc2Ugd2UgZG9u4oCZdCBjYXJlIHNpbmNlIHRoZSBvdXRwdXQgd291bGQgYmUgaW52YWxpZCBhbnl3YXkpLlxudmFyIHN0cmluZ09yQ2hhciA9IC8oXCIoPzpbXlxcXFxcIl18XFxcXC4pKlwiKXxbOixcXF1bfXtdL2dcblxuZnVuY3Rpb24gcHJldHRpZnkgKHN0cmluZywgYWRkTWFyZ2luKSB7XG4gIHZhciBtID0gYWRkTWFyZ2luID8gJyAnIDogJydcbiAgdmFyIHRva2VucyA9IHtcbiAgICAneyc6ICd7JyArIG0sXG4gICAgJ1snOiAnWycgKyBtLFxuICAgICd9JzogbSArICd9JyxcbiAgICAnXSc6IG0gKyAnXScsXG4gICAgJywnOiAnLCAnLFxuICAgICc6JzogJzogJ1xuICB9XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShzdHJpbmdPckNoYXIsIGZ1bmN0aW9uIChtYXRjaCwgc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZyA/IG1hdGNoIDogdG9rZW5zW21hdGNoXVxuICB9KVxufVxuXG5mdW5jdGlvbiBnZXQgKG9wdGlvbnMsIG5hbWUsIGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4gKG5hbWUgaW4gb3B0aW9ucyA/IG9wdGlvbnNbbmFtZV0gOiBkZWZhdWx0VmFsdWUpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5naWZ5XG4iLCIvKipcbiAqIFRoZSBEb3VibHlMaW5rZWRMaXN0IGNsYXNzIHByb3ZpZGVzIHRoZSBtYWluIGZ1bmN0aW9uYWxpdHkgb2YgYSBkb3VibHkgbGlua2VkIGxpc3QuXG4gKlxuICogQGNsYXNzIERvdWJseUxpbmtlZExpc3RcbiAqL1xudmFyIERvdWJseUxpbmtlZExpc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERvdWJseUxpbmtlZExpc3QoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb3VudCBvZiBlbGVtZW50cyBpbiBsaXN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfbGVuZ3RoXG4gICAgICAgICAqIEB0eXBlIG51bWJlclxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0ZXJhdGlvbiBwb2ludGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfa2V5XG4gICAgICAgICAqIEB0eXBlIG51bWJlclxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fa2V5ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byBoZWFkKGZpcnN0KSBlbGVtZW50IGluIGxpc3RcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IF9oZWFkXG4gICAgICAgICAqIEB0eXBlIERvdWJseUxpbmtlZExpc3ROb2RlXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9oZWFkID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byB0YWlsKGxhc3QpIGVsZW1lbnQgaW4gbGlzdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgX3RhaWxcbiAgICAgICAgICogQHR5cGUgRG91Ymx5TGlua2VkTGlzdE5vZGVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RhaWwgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIGl0ZXJhdGVkIGVsZW1lbnQgaW4gbGlzdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgX2N1cnJlbnRcbiAgICAgICAgICogQHR5cGUgRG91Ymx5TGlua2VkTGlzdE5vZGVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2N1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgYSBuZXcgdmFsdWUgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxuICAgICAqXG4gICAgICogQG1ldGhvZCBhZGRcbiAgICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IHdoZXJlIHRoZSBuZXcgdmFsdWUgaXMgdG8gYmUgaW5zZXJ0ZWQuXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBuZXcgdmFsdWUgZm9yIHRoZSBpbmRleC5cbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPdXQgb2YgYm91bmRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgICAgICB3aGlsZSAoaSA8IGluZGV4KSB7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQudmFsdWUgPSB2YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBvcHMgYSBub2RlIGZyb20gdGhlIGVuZCBvZiB0aGUgZG91Ymx5IGxpbmtlZCBsaXN0XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHBvcFxuICAgICAqIEByZXR1cm4gYW55ICBUaGUgdmFsdWUgb2YgdGhlIHBvcHBlZCBub2RlLlxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcG9wIGZyb20gYW4gZW1wdHkgZGF0YSBzdHJ1Y3R1cmVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fdGFpbC52YWx1ZTtcbiAgICAgICAgdGhpcy5fdGFpbCA9IHRoaXMuX3RhaWwucHJldjtcbiAgICAgICAgaWYgKHRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl90YWlsLm5leHQ7XG4gICAgICAgICAgICB0aGlzLl90YWlsLm5leHQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xlbmd0aC0tO1xuICAgICAgICBpZiAodGhpcy5fbGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5faGVhZDtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNoaWZ0cyBhIG5vZGUgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkb3VibHkgbGlua2VkIGxpc3RcbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2hpZnRcbiAgICAgKiBAcmV0dXJuIGFueSAgVGhlIHZhbHVlIG9mIHRoZSBzaGlmdGVkIG5vZGUuXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHNoaWZ0IGZyb20gYW4gZW1wdHkgZGF0YSBzdHJ1Y3R1cmVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5faGVhZC52YWx1ZTtcbiAgICAgICAgdGhpcy5faGVhZCA9IHRoaXMuX2hlYWQubmV4dDtcbiAgICAgICAgaWYgKHRoaXMuX2hlYWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9oZWFkLnByZXY7XG4gICAgICAgICAgICB0aGlzLl9oZWFkLnByZXYgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xlbmd0aC0tO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYW4gZWxlbWVudCBhdCB0aGUgZW5kIG9mIHRoZSBkb3VibHkgbGlua2VkIGxpc3RcbiAgICAgKlxuICAgICAqIEBtZXRob2QgcHVzaFxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHVzaC5cbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIGFsbG9jYXRlIG5ldyBub2RlXG4gICAgICAgIHZhciBub2RlID0ge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgcHJldjogdGhpcy5fdGFpbCxcbiAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuX2xlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IHRoaXMuX3RhaWwgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdGFpbC5uZXh0ID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwgPSB0aGlzLl90YWlsLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGVuZ3RoKys7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcmVwZW5kcyB0aGUgZG91Ymx5IGxpbmtlZCBsaXN0IHdpdGggYW4gZWxlbWVudFxuICAgICAqXG4gICAgICogQG1ldGhvZCB1bnNoaWZ0XG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byB1bnNoaWZ0LlxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gYWxsb2NhdGUgbmV3IG5vZGVcbiAgICAgICAgdmFyIG5vZGUgPSB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBwcmV2OiBudWxsLFxuICAgICAgICAgICAgbmV4dDogdGhpcy5faGVhZFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5fbGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gdGhpcy5fdGFpbCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkLnByZXYgPSBub2RlO1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IHRoaXMuX2hlYWQucHJldjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sZW5ndGgrKztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBlZWtzIGF0IHRoZSBub2RlIGZyb20gdGhlIGVuZCBvZiB0aGUgZG91Ymx5IGxpbmtlZCBsaXN0XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHRvcFxuICAgICAqIEByZXR1cm4gYW55ICBUaGUgdmFsdWUgb2YgdGhlIGxhc3Qgbm9kZS5cbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS50b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl90YWlsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RhaWwudmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQZWVrcyBhdCB0aGUgbm9kZSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRvdWJseSBsaW5rZWQgbGlzdFxuICAgICAqXG4gICAgICogQG1ldGhvZCBib3R0b21cbiAgICAgKiBAcmV0dXJuIGFueSAgVGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBub2RlLlxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLmJvdHRvbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hlYWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGVhZC52YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvdW50cyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBkb3VibHkgbGlua2VkIGxpc3RcbiAgICAgKlxuICAgICAqIEBtZXRob2QgY291bnRcbiAgICAgKiBAcmV0dXJuIG51bWJlciB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBkb3VibHkgbGlua2VkIGxpc3QuXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZG91Ymx5IGxpbmtlZCBsaXN0IGlzIGVtcHR5XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGlzRW1wdHlcbiAgICAgKiBAcmV0dXJuIGJvb2xlYW4gd2hldGhlciB0aGUgZG91Ymx5IGxpbmtlZCBsaXN0IGlzIGVtcHR5LlxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fbGVuZ3RoID09PSAwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJld2luZCBpdGVyYXRvciBiYWNrIHRvIHRoZSBzdGFydFxuICAgICAqXG4gICAgICogQG1ldGhvZCByZXdpbmRcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5yZXdpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2tleSA9IDA7XG4gICAgICAgIHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGN1cnJlbnQgbGlzdCBlbnRyeVxuICAgICAqXG4gICAgICogQG1ldGhvZCBjdXJyZW50XG4gICAgICogQHJldHVybiBhbnkgIFRoZSBjdXJyZW50IG5vZGUgdmFsdWUuXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGN1cnJlbnQgbm9kZSBpbmRleFxuICAgICAqXG4gICAgICogQG1ldGhvZCBrZXlcbiAgICAgKiBAcmV0dXJuIGFueSAgVGhlIGN1cnJlbnQgbm9kZSBpbmRleC5cbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5rZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNb3ZlIHRvIG5leHQgZW50cnlcbiAgICAgKlxuICAgICAqIEBtZXRob2QgbmV4dFxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIERvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9jdXJyZW50Lm5leHQ7XG4gICAgICAgIHRoaXMuX2tleSsrO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTW92ZSB0byBwcmV2aW91cyBlbnRyeVxuICAgICAqXG4gICAgICogQG1ldGhvZCBwcmV2XG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudCA9IHRoaXMuX2N1cnJlbnQucHJldjtcbiAgICAgICAgdGhpcy5fa2V5LS07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBkb3VibHkgbGlua2VkIGxpc3QgY29udGFpbnMgbW9yZSBub2Rlc1xuICAgICAqXG4gICAgICogQG1ldGhvZCB2YWxpZFxuICAgICAqIEByZXR1cm4gYm9vbGVhbiB0cnVlIGlmIHRoZSBkb3VibHkgbGlua2VkIGxpc3QgY29udGFpbnMgYW55IG1vcmUgbm9kZXMsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBEb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS52YWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9rZXkgPj0gMCAmJiB0aGlzLl9rZXkgPCB0aGlzLl9sZW5ndGgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRXhwb3J0IHRoZSBsaXN0IHRvIGFycmF5XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHRvQXJyYXlcbiAgICAgKiBAcmV0dXJuIEFycmF5ICAgVGhlIGV4cG9ydGVkIGFycmF5XG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBbXTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgbGlzdC5wdXNoKGN1cnJlbnQudmFsdWUpO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGxpc3QgdG8gc3RyaW5nXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHRvU3RyaW5nXG4gICAgICogQHJldHVybiBzdHJpbmcgICBUaGUgc2VyaWFsaXplZCBzdHJpbmcuXG4gICAgICovXG4gICAgRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIntcIiArIHRoaXMudG9BcnJheSgpLmpvaW4oXCItPlwiKSArIFwifVwiO1xuICAgIH07XG4gICAgcmV0dXJuIERvdWJseUxpbmtlZExpc3Q7XG59KSgpO1xubW9kdWxlLmV4cG9ydHMgPSBEb3VibHlMaW5rZWRMaXN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RG91Ymx5TGlua2VkTGlzdC5qcy5tYXAiLCIvKipcbiAqIFRoZSBIZWFwIGNsYXNzIHByb3ZpZGVzIHRoZSBtYWluIGZ1bmN0aW9uYWxpdHkgb2YgYSBIZWFwLlxuICpcbiAqIEBjbGFzcyBIZWFwXG4gKi9cbnZhciBIZWFwID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIZWFwKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQmluYXJ5IHRyZWUgc3RvcmFnZSBhcnJheVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgX3RyZWVcbiAgICAgICAgICogQHR5cGUgQXJyYXlcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RyZWUgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhlYXAgdHlwZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgX3R5cGVcbiAgICAgICAgICogQHR5cGUgbnVtYmVyXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90eXBlID0gSGVhcC5NQVg7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdGVyYXRpb24gcG9pbnRlclxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvcGVydHkgX2tleVxuICAgICAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2tleSA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBpbmRleCBvZiBsZWZ0IGNoaWxkIGVsZW1lbnQgaW4gYmluYXJ5IHRyZWUgc3RvcmVkIGluIGFycmF5XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9jaGlsZFxuICAgICAqIEBwYXJhbSBuXG4gICAgICogQHJldHVybiBudW1iZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLl9jaGlsZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiAyICogbiArIDE7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgaW5kZXggb2YgcGFyZW50IGVsZW1lbnQgaW4gYmluYXJ5IHRyZWUgc3RvcmVkIGluIGFycmF5XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9wYXJlbnRcbiAgICAgKiBAcGFyYW0gblxuICAgICAqIEByZXR1cm4gbnVtYmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5fcGFyZW50ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnbj0nLCBuLCBNYXRoLmZsb29yKG4gLyAyKSk7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKG4gLyAyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN3YXAgMiBlbGVtZW50cyBpbiBiaW5hcnkgdHJlZVxuICAgICAqXG4gICAgICogQG1ldGhvZCBfc3dhcFxuICAgICAqIEBwYXJhbSBmaXJzdFxuICAgICAqIEBwYXJhbSBzZWNvbmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLl9zd2FwID0gZnVuY3Rpb24gKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgdmFyIHN3YXAgPSB0aGlzLl90cmVlW2ZpcnN0XTtcbiAgICAgICAgdGhpcy5fdHJlZVtmaXJzdF0gPSB0aGlzLl90cmVlW3NlY29uZF07XG4gICAgICAgIHRoaXMuX3RyZWVbc2Vjb25kXSA9IHN3YXA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTaWZ0IGVsZW1lbnRzIGluIGJpbmFyeSB0cmVlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9zaWZ0VXBcbiAgICAgKiBAcGFyYW0gaVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUuX3NpZnRVcCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHdoaWxlIChpID4gMCkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudChpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhcmUodGhpcy5fdHJlZVtpXSwgdGhpcy5fdHJlZVtwYXJlbnRdKSAqIHRoaXMuX3R5cGUgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3dhcChpLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgIGkgPSBwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2lmdCBkb3duIGVsZW1lbnRzIGluIGJpbmFyeSB0cmVlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9zaWZ0RG93blxuICAgICAqIEBwYXJhbSBpXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5fc2lmdERvd24gPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICB3aGlsZSAoaSA8IHRoaXMuX3RyZWUubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IHRoaXMuX2NoaWxkKGkpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gbGVmdCArIDE7XG4gICAgICAgICAgICBpZiAoKGxlZnQgPCB0aGlzLl90cmVlLmxlbmd0aCkgJiYgKHJpZ2h0IDwgdGhpcy5fdHJlZS5sZW5ndGgpICYmXG4gICAgICAgICAgICAgICAgKHRoaXMuY29tcGFyZSh0aGlzLl90cmVlW2ldLCB0aGlzLl90cmVlW2xlZnRdKSAqIHRoaXMuX3R5cGUgPCAwIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGFyZSh0aGlzLl90cmVlW2ldLCB0aGlzLl90cmVlW3JpZ2h0XSkgKiB0aGlzLl90eXBlIDwgMCkpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyAyIGNoaWxkcmVuIGFuZCBvbmUgb2YgdGhlbSBtdXN0IGJlIHN3YXBwZWRcbiAgICAgICAgICAgICAgICAvLyBnZXQgY29ycmVjdCBlbGVtZW50IHRvIHNpZnQgZG93blxuICAgICAgICAgICAgICAgIHZhciBzaWZ0ID0gbGVmdDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb21wYXJlKHRoaXMuX3RyZWVbbGVmdF0sIHRoaXMuX3RyZWVbcmlnaHRdKSAqIHRoaXMuX3R5cGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZnQgPSByaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fc3dhcChpLCBzaWZ0KTtcbiAgICAgICAgICAgICAgICBpID0gc2lmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxlZnQgPCB0aGlzLl90cmVlLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuY29tcGFyZSh0aGlzLl90cmVlW2ldLCB0aGlzLl90cmVlW2xlZnRdKSAqIHRoaXMuX3R5cGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBvbmUgY2hpbGQgZXhpc3RzXG4gICAgICAgICAgICAgICAgdGhpcy5fc3dhcChpLCBsZWZ0KTtcbiAgICAgICAgICAgICAgICBpID0gbGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyBhIG5vZGUgZnJvbSB0b3Agb2YgdGhlIGhlYXAgYW5kIHNpZnQgdXBcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZXh0cmFjdFxuICAgICAqIEByZXR1cm4gYW55IFRoZSB2YWx1ZSBvZiB0aGUgZXh0cmFjdGVkIG5vZGUuXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUuZXh0cmFjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyZWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBleHRyYWN0IGZyb20gYW4gZW1wdHkgZGF0YSBzdHJ1Y3R1cmVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV4dHJhY3RlZCA9IHRoaXMuX3RyZWVbMF07XG4gICAgICAgIGlmICh0aGlzLl90cmVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5fdHJlZSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdHJlZVswXSA9IHRoaXMuX3RyZWUucG9wKCk7XG4gICAgICAgICAgICB0aGlzLl9zaWZ0RG93bigwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXh0cmFjdGVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiBlbGVtZW50IGluIHRoZSBoZWFwIGJ5IHNpZnRpbmcgaXQgdXBcbiAgICAgKlxuICAgICAqIEBtZXRob2QgaW5zZXJ0XG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3RyZWUucHVzaCh2YWx1ZSk7XG4gICAgICAgIHRoaXMuX3NpZnRVcCh0aGlzLl90cmVlLmxlbmd0aCAtIDEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGVla3MgYXQgdGhlIG5vZGUgZnJvbSB0aGUgdG9wIG9mIHRoZSBoZWFwXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHRvcFxuICAgICAqIEByZXR1cm4gYW55IFRoZSB2YWx1ZSBvZiB0aGUgbm9kZSBvbiB0aGUgdG9wLlxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLnRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyZWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwZWVrIGF0IGFuIGVtcHR5IGhlYXBcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWVbMF07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb3VudHMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaGVhcFxuICAgICAqXG4gICAgICogQG1ldGhvZCBjb3VudFxuICAgICAqIEByZXR1cm4gbnVtYmVyIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGhlYXAuXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmVlLmxlbmd0aDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBoZWFwIGlzIGVtcHR5XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGlzRW1wdHlcbiAgICAgKiBAcmV0dXJuIGJvb2xlYW4gd2hldGhlciB0aGUgaGVhcCBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX3RyZWUubGVuZ3RoID09PSAwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJld2luZCBpdGVyYXRvciBiYWNrIHRvIHRoZSBzdGFydCAobm8tb3ApXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHJld2luZFxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLnJld2luZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fa2V5ID0gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBjdXJyZW50IG5vZGUgcG9pbnRlZCBieSB0aGUgaXRlcmF0b3JcbiAgICAgKlxuICAgICAqIEBtZXRob2QgY3VycmVudFxuICAgICAqIEByZXR1cm4gYW55IFRoZSBjdXJyZW50IG5vZGUgdmFsdWUuXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWVbdGhpcy5fa2V5XTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBjdXJyZW50IG5vZGUgaW5kZXhcbiAgICAgKlxuICAgICAqIEBtZXRob2Qga2V5XG4gICAgICogQHJldHVybiBhbnkgVGhlIGN1cnJlbnQgbm9kZSBpbmRleC5cbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5rZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNb3ZlIHRvIHRoZSBuZXh0IG5vZGVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgbmV4dFxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2tleSsrO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTW92ZSB0byBwcmV2aW91cyBlbnRyeVxuICAgICAqXG4gICAgICogQG1ldGhvZCBwcmV2XG4gICAgICogQHJldHVybiB2b2lkXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fa2V5LS07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBoZWFwIGNvbnRhaW5zIG1vcmUgbm9kZXNcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdmFsaWRcbiAgICAgKiBAcmV0dXJuIGJvb2xlYW4gdHJ1ZSBpZiB0aGUgaGVhcCBjb250YWlucyBhbnkgbW9yZSBub2RlcywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIEhlYXAucHJvdG90eXBlLnZhbGlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2tleSA+PSAwICYmIHRoaXMuX2tleSA8IHRoaXMuX3RyZWUubGVuZ3RoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXBhcmUgZWxlbWVudHMgaW4gb3JkZXIgdG8gcGxhY2UgdGhlbSBjb3JyZWN0bHkgaW4gdGhlIGhlYXAgd2hpbGUgc2lmdGluZyB1cC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgY29tcGFyZVxuICAgICAqIEBwYXJhbSBmaXJzdCBUaGUgdmFsdWUgb2YgdGhlIGZpcnN0IG5vZGUgYmVpbmcgY29tcGFyZWQuXG4gICAgICogQHBhcmFtIHNlY29uZCBUaGUgdmFsdWUgb2YgdGhlIHNlY29uZCBub2RlIGJlaW5nIGNvbXBhcmVkLlxuICAgICAqIEByZXR1cm4gbnVtYmVyIFJlc3VsdCBvZiB0aGUgY29tcGFyaXNvbiwgcG9zaXRpdmUgaW50ZWdlciBpZiBmaXJzdCBpcyBncmVhdGVyIHRoYW4gc2Vjb25kLCAwIGlmIHRoZXkgYXJlIGVxdWFsLCBuZWdhdGl2ZSBpbnRlZ2VyIG90aGVyd2lzZS5cbiAgICAgKiBIYXZpbmcgbXVsdGlwbGUgZWxlbWVudHMgd2l0aCB0aGUgc2FtZSB2YWx1ZSBpbiBhIEhlYXAgaXMgbm90IHJlY29tbWVuZGVkLiBUaGV5IHdpbGwgZW5kIHVwIGluIGFuIGFyYml0cmFyeSByZWxhdGl2ZSBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgaWYgKGZpcnN0ID4gc2Vjb25kKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaXJzdCA9PSBzZWNvbmQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBWaXN1YWxseSBkaXNwbGF5IGhlYXAgdHJlZVxuICAgICAqXG4gICAgICogQG1ldGhvZCBfZGlzcGxheU5vZGVcbiAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAqIEBwYXJhbSBwcmVmaXhcbiAgICAgKiBAcGFyYW0gbGFzdFxuICAgICAqIEByZXR1cm4gU3RyaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS5fZGlzcGxheU5vZGUgPSBmdW5jdGlvbiAobm9kZSwgcHJlZml4LCBsYXN0KSB7XG4gICAgICAgIGlmIChwcmVmaXggPT09IHZvaWQgMCkgeyBwcmVmaXggPSAnJzsgfVxuICAgICAgICBpZiAobGFzdCA9PT0gdm9pZCAwKSB7IGxhc3QgPSB0cnVlOyB9XG4gICAgICAgIHZhciBsaW5lID0gcHJlZml4O1xuICAgICAgICAvLyBnZXQgY2hpbGQgaW5kZXhlc1xuICAgICAgICB2YXIgbGVmdCA9IHRoaXMuX2NoaWxkKG5vZGUpO1xuICAgICAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgMTtcbiAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgIGxpbmUgKz0gKHByZWZpeCA/ICfilJTilIAnIDogJyAgJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsaW5lICs9ICfilJzilIAnO1xuICAgICAgICB9XG4gICAgICAgIGxpbmUgKz0gdGhpcy5fdHJlZVtub2RlXTtcbiAgICAgICAgcHJlZml4ICs9IChsYXN0ID8gJyAgJyA6ICfilIIgJyk7XG4gICAgICAgIGlmIChsZWZ0IDwgdGhpcy5fdHJlZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxpbmUgKz0gJ1xcbicgKyB0aGlzLl9kaXNwbGF5Tm9kZShsZWZ0LCBwcmVmaXgsICh0aGlzLl90cmVlW3JpZ2h0XSA9PSB1bmRlZmluZWQgPyB0cnVlIDogZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmlnaHQgPCB0aGlzLl90cmVlLmxlbmd0aCkge1xuICAgICAgICAgICAgbGluZSArPSAnXFxuJyArIHRoaXMuX2Rpc3BsYXlOb2RlKHJpZ2h0LCBwcmVmaXgsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgaGVhcCB0byBzdHJpbmdcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9TdHJpbmdcbiAgICAgKiBAcmV0dXJuIHN0cmluZyAgIFRoZSBzZXJpYWxpemVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBIZWFwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gc3RhcnQgd2l0aCByb290IGFuZCByZWN1cnNpdmVseSBnb2VzIHRvIGVhY2ggbm9kZVxuICAgICAgICByZXR1cm4gdGhpcy5fZGlzcGxheU5vZGUoMCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBoZWFwIHRvIGFycmF5XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHRvQXJyYXlcbiAgICAgKiBAcmV0dXJuIEFycmF5ICAgVGhlIHNlcmlhbGl6ZWQgYXJyYXkuXG4gICAgICovXG4gICAgSGVhcC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNYXggaGVhcCBmbGFnXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgTUFYXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIEhlYXAuTUFYID0gMTtcbiAgICAvKipcbiAgICAgKiBNaW4gaGVhcCBmbGFnXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgTUlOXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIEhlYXAuTUlOID0gLTE7XG4gICAgcmV0dXJuIEhlYXA7XG59KSgpO1xubW9kdWxlLmV4cG9ydHMgPSBIZWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SGVhcC5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gdGhpcy5fX2V4dGVuZHMgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZTtcbiAgICBkLnByb3RvdHlwZSA9IG5ldyBfXygpO1xufTtcbnZhciBIZWFwID0gcmVxdWlyZSgnLi9IZWFwJyk7XG4vKipcbiAqIFRoZSBNYXhIZWFwIGNsYXNzIHByb3ZpZGVzIHRoZSBtYWluIGZ1bmN0aW9uYWxpdHkgb2YgYSBoZWFwLCBrZWVwaW5nIHRoZSBtYXhpbXVtIG9uIHRoZSB0b3AuXG4gKlxuICogQGNsYXNzIE1heEhlYXBcbiAqIEBleHRlbmRzIEhlYXBcbiAqL1xudmFyIE1heEhlYXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXhIZWFwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1heEhlYXAoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl90eXBlID0gSGVhcC5NQVg7XG4gICAgfVxuICAgIHJldHVybiBNYXhIZWFwO1xufSkoSGVhcCk7XG5tb2R1bGUuZXhwb3J0cyA9IE1heEhlYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXhIZWFwLmpzLm1hcCIsInZhciBfX2V4dGVuZHMgPSB0aGlzLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlO1xuICAgIGQucHJvdG90eXBlID0gbmV3IF9fKCk7XG59O1xudmFyIEhlYXAgPSByZXF1aXJlKCcuL0hlYXAnKTtcbi8qKlxuICogVGhlIE1pbkhlYXAgY2xhc3MgcHJvdmlkZXMgdGhlIG1haW4gZnVuY3Rpb25hbGl0eSBvZiBhIGhlYXAsIGtlZXBpbmcgdGhlIG1pbmltdW0gb24gdGhlIHRvcC5cbiAqXG4gKiBAY2xhc3MgTWluSGVhcFxuICogQGV4dGVuZHMgSGVhcFxuICovXG52YXIgTWluSGVhcCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1pbkhlYXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWluSGVhcCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX3R5cGUgPSBIZWFwLk1JTjtcbiAgICB9XG4gICAgcmV0dXJuIE1pbkhlYXA7XG59KShIZWFwKTtcbm1vZHVsZS5leHBvcnRzID0gTWluSGVhcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1pbkhlYXAuanMubWFwIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgSGVhcCA9IHJlcXVpcmUoJy4vSGVhcCcpO1xuLyoqXG4gKiBUaGUgUHJpb3JpdHlRdWV1ZSBjbGFzcyBwcm92aWRlcyB0aGUgbWFpbiBmdW5jdGlvbmFsaXR5IG9mIGFuIHByaW9yaXRpemVkIHF1ZXVlLCBpbXBsZW1lbnRlZCB1c2luZyBhIG1heCBoZWFwLlxuICpcbiAqIEBjbGFzcyBQcmlvcml0eVF1ZXVlXG4gKiBAZXh0ZW5kcyBIZWFwXG4gKi9cbnZhciBQcmlvcml0eVF1ZXVlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUHJpb3JpdHlRdWV1ZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQcmlvcml0eVF1ZXVlKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fdHlwZSA9IEhlYXAuTUFYO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGVsZW1lbnQgdG8gdGhlIHF1ZXVlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGVucXVldWVcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGVucXVldWUuXG4gICAgICogQHBhcmFtIHByaW9yaXR5IFRoZSBwcmlvcml0eSBvZiB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24gKHZhbHVlLCBwcmlvcml0eSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnNlcnQobmV3IFByaW9yaXR5UXVldWVOb2RlKHZhbHVlLCBwcmlvcml0eSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVxdWV1ZXMgYSBub2RlIGZyb20gdGhlIHF1ZXVlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRlcXVldWVcbiAgICAgKiBAcmV0dXJuIGFueSAgVGhlIHZhbHVlIG9mIHRoZSBkZXF1ZXVlZCBub2RlLlxuICAgICAqL1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLmRlcXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dHJhY3QoKS52YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBlZWtzIGF0IHRoZSBub2RlIGZyb20gdGhlIHRvcCBvZiB0aGUgaGVhcFxuICAgICAqXG4gICAgICogQG1ldGhvZCB0b3BcbiAgICAgKiBAcmV0dXJuIGFueSBUaGUgdmFsdWUgb2YgdGhlIG5vZGUgb24gdGhlIHRvcC5cbiAgICAgKi9cbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS50b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnRvcC5jYWxsKHRoaXMpLnZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcGFyZSBlbGVtZW50cyBpbiBvcmRlciB0byBwbGFjZSB0aGVtIGNvcnJlY3RseSBpbiB0aGUgaGVhcCB3aGlsZSBzaWZ0aW5nIHVwLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBjb21wYXJlXG4gICAgICogQHBhcmFtIGZpcnN0IFRoZSB2YWx1ZSBvZiB0aGUgZmlyc3Qgbm9kZSBiZWluZyBjb21wYXJlZC5cbiAgICAgKiBAcGFyYW0gc2Vjb25kIFRoZSB2YWx1ZSBvZiB0aGUgc2Vjb25kIG5vZGUgYmVpbmcgY29tcGFyZWQuXG4gICAgICogQHJldHVybiBudW1iZXIgUmVzdWx0IG9mIHRoZSBjb21wYXJpc29uLCBwb3NpdGl2ZSBpbnRlZ2VyIGlmIGZpcnN0IGlzIGdyZWF0ZXIgdGhhbiBzZWNvbmQsIDAgaWYgdGhleSBhcmUgZXF1YWwsIG5lZ2F0aXZlIGludGVnZXIgb3RoZXJ3aXNlLlxuICAgICAqIEhhdmluZyBtdWx0aXBsZSBlbGVtZW50cyB3aXRoIHRoZSBzYW1lIHZhbHVlIGluIGEgSGVhcCBpcyBub3QgcmVjb21tZW5kZWQuIFRoZXkgd2lsbCBlbmQgdXAgaW4gYW4gYXJiaXRyYXJ5IHJlbGF0aXZlIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICBpZiAoZmlyc3QucHJpb3JpdHkgPiBzZWNvbmQucHJpb3JpdHkpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpcnN0LnByaW9yaXR5ID09IHNlY29uZC5wcmlvcml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBQcmlvcml0eVF1ZXVlO1xufSkoSGVhcCk7XG4vKipcbiAqIFByaW9yaXR5UXVldWUgTm9kZVxuICpcbiAqIEBjbGFzcyBQcmlvcml0eVF1ZXVlTm9kZVxuICovXG52YXIgUHJpb3JpdHlRdWV1ZU5vZGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHBhcmFtIHByaW9yaXR5XG4gICAgICovXG4gICAgZnVuY3Rpb24gUHJpb3JpdHlRdWV1ZU5vZGUodmFsdWUsIHByaW9yaXR5KSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IHByaW9yaXR5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBub2RlIHRvIHN0cmluZ1xuICAgICAqXG4gICAgICogQG1ldGhvZCB0b1N0cmluZ1xuICAgICAqIEByZXR1cm4gc3RyaW5nICAgVGhlIHNlcmlhbGl6ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIFByaW9yaXR5UXVldWVOb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgKyBcIiBbXCIgKyB0aGlzLnByaW9yaXR5ICsgXCJdXCI7XG4gICAgfTtcbiAgICByZXR1cm4gUHJpb3JpdHlRdWV1ZU5vZGU7XG59KSgpO1xubW9kdWxlLmV4cG9ydHMgPSBQcmlvcml0eVF1ZXVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJpb3JpdHlRdWV1ZS5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBEb3VibHlMaW5rZWRMaXN0ID0gcmVxdWlyZSgnLi9Eb3VibHlMaW5rZWRMaXN0Jyk7XG4vKipcbiAqIFRoZSBRdWV1ZSBjbGFzcyBwcm92aWRlcyB0aGUgbWFpbiBmdW5jdGlvbmFsaXR5IG9mIGEgcXVldWUgaW1wbGVtZW50ZWQgdXNpbmcgYSBkb3VibHkgbGlua2VkIGxpc3QuXG4gKlxuICogQGNsYXNzIFF1ZXVlXG4gKiBAZXh0ZW5kcyBEb3VibHlMaW5rZWRMaXN0XG4gKi9cbnZhciBRdWV1ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFF1ZXVlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFF1ZXVlKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBlbGVtZW50IHRvIHRoZSBxdWV1ZVxuICAgICAqXG4gICAgICogQG1ldGhvZCBlbnF1ZXVlXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBlbnF1ZXVlLlxuICAgICAqIEByZXR1cm4gdm9pZFxuICAgICAqL1xuICAgIFF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1c2godmFsdWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVxdWV1ZXMgYSBub2RlIGZyb20gdGhlIHF1ZXVlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRlcXVldWVcbiAgICAgKiBAcmV0dXJuIGFueSAgVGhlIHZhbHVlIG9mIHRoZSBkZXF1ZXVlZCBub2RlLlxuICAgICAqL1xuICAgIFF1ZXVlLnByb3RvdHlwZS5kZXF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGlmdCgpO1xuICAgIH07XG4gICAgcmV0dXJuIFF1ZXVlO1xufSkoRG91Ymx5TGlua2VkTGlzdCk7XG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UXVldWUuanMubWFwIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgRG91Ymx5TGlua2VkTGlzdCA9IHJlcXVpcmUoJy4vRG91Ymx5TGlua2VkTGlzdCcpO1xuLyoqXG4gKiBUaGUgU3RhY2sgY2xhc3MgcHJvdmlkZXMgdGhlIG1haW4gZnVuY3Rpb25hbGl0eSBvZiBhIHN0YWNrIGltcGxlbWVudGVkIHVzaW5nIGEgZG91Ymx5IGxpbmtlZCBsaXN0LlxuICpcbiAqIEBjbGFzcyBTdGFja1xuICogQGV4dGVuZHMgRG91Ymx5TGlua2VkTGlzdFxuICovXG52YXIgU3RhY2sgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdGFjaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdGFjaygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBTdGFjaztcbn0pKERvdWJseUxpbmtlZExpc3QpO1xubW9kdWxlLmV4cG9ydHMgPSBTdGFjaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0YWNrLmpzLm1hcCIsIi8qKlxuICogU1RMXG4gKiBAdHlwZSB7e0RvdWJseUxpbmtlZExpc3Q6IGV4cG9ydHMsIFN0YWNrOiBleHBvcnRzLCBRdWV1ZTogZXhwb3J0cywgSGVhcDogZXhwb3J0cywgTWF4SGVhcDogZXhwb3J0cywgTWluSGVhcDogZXhwb3J0cywgUHJpb3JpdHlRdWV1ZTogZXhwb3J0c319XG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuXHREb3VibHlMaW5rZWRMaXN0OiByZXF1aXJlKCcuL0RhdGFzdHJ1Y3R1cmVzL0RvdWJseUxpbmtlZExpc3QnKSxcblx0U3RhY2s6IHJlcXVpcmUoJy4vRGF0YXN0cnVjdHVyZXMvU3RhY2snKSxcblx0UXVldWU6IHJlcXVpcmUoJy4vRGF0YXN0cnVjdHVyZXMvUXVldWUnKSxcblx0SGVhcDogcmVxdWlyZSgnLi9EYXRhc3RydWN0dXJlcy9IZWFwJyksXG5cdE1heEhlYXA6IHJlcXVpcmUoJy4vRGF0YXN0cnVjdHVyZXMvTWF4SGVhcCcpLFxuXHRNaW5IZWFwOiByZXF1aXJlKCcuL0RhdGFzdHJ1Y3R1cmVzL01pbkhlYXAnKSxcblx0UHJpb3JpdHlRdWV1ZTogcmVxdWlyZSgnLi9EYXRhc3RydWN0dXJlcy9Qcmlvcml0eVF1ZXVlJylcbn07IiwiaW1wb3J0IHttYW5oYXR0YW5EaXN0YW5jZX0gZnJvbSAnLi9oZWxwZXJGdW5jdGlvbnMnXG5pbXBvcnQgTWFwV2l0aERlZmF1bHRWYWx1ZSBmcm9tICcuL21hcFdpdGhEZWZhdWx0VmFsdWUnXG5cbmltcG9ydCB7IFByaW9yaXR5UXVldWUgfSBmcm9tICdsaWJzdGwnOyAvLyBub3RlOiBpbXBvcnRlZCBmcm9tIGEgbm9kZSBtb2R1bGVcblxuLyoqIEBtb2R1bGUgZmluZFBhdGggKi9cblxuLyoqXG4gKiBIZWF2aWx5IG1vZGlmaWVkIGltcGxlbWVudGF0aW9uIG9mIHRoZSBBKiBhbGdvcml0aG1cbiAqIEBwYXJhbSAge09iamVjdH0gc3RhcnQgb2JqZWN0IGNvbnRhaW5pbmcgbnVtZXJpYyBhdHRyaWJ1dGVzIGB4YCBhbmQgYHlgIHRoYXQgcmVwcmVzZW50IHRoZSBmaXJzdCBlbmRwb2ludCBvZiB0aGUgd2lyZSBpbiBncmlkIHBpeGVsc1xuICogQHBhcmFtICB7T2JqZWN0fSBlbmQgICBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWAgdGhhdCByZXByZXNlbnQgdGhlIHNlY29uZCBlbmRwb2ludCBvZiB0aGUgd2lyZSBpbiBncmlkIHBpeGVsc1xuICogQHBhcmFtICB7U2V0fSBub25Sb3V0YWJsZSBzZXQgb2Ygbm9uIHJvdXRhYmxlIG5vZGVzXG4gKiBAcGFyYW0gIHtTZXR9IHB1bmlzaGVkQnV0Um91dGFibGUgc2V0IG9mIG5vZGVzIHRoYXQgYXJlIG5vdCBvcHRpbWFsIGZvciByb3V0aW5nXG4gKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmaW5kUGF0aChzdGFydCwgZW5kLCBub25Sb3V0YWJsZSwgcHVuaXNoZWRCdXRSb3V0YWJsZSkge1xuXG4gICAgY29uc3QgZGlzdGFuY2VGdW5jdGlvbiA9IG1hbmhhdHRhbkRpc3RhbmNlO1xuXG4gICAgY29uc3Qgd2lyZUNyb3NzUHVuaXNobWVudCA9IDE7XG4gICAgY29uc3Qgd2lyZUJlbmRQdW5pc2htZW50ID0gMTtcblxuICAgIC8vIG51bWJlciBvZiBub2RlcywgdGhhdCBjYW4gYmUgb3BlbmVkIGF0IG9uY2VcbiAgICAvLyBvbmNlIGlzIHRoaXMgbGltaXQgZXhjZWVkZWQsIGFTdGFyIHdpbGwgZmFpbCBhbmQgcmV0dXJuIHVuZGVmaW5lZFxuICAgIGNvbnN0IG1heE5vZGVMaW1pdCA9IDEwMDAwMDtcblxuICAgIGxldCBjbG9zZWROb2RlcyA9IG5ldyBTZXQoKTtcbiAgICBsZXQgb3Blbk5vZGVzID0gbmV3IFNldCgpO1xuICAgIGxldCBvcGVuTm9kZVF1ZXVlID0gbmV3IFByaW9yaXR5UXVldWUoKTtcblxuICAgIC8vIGZ1bmN0aW9ucyBmb3Igd29ya2luZyB3aXRoIG9wZW4gbm9kZXM6XG5cbiAgICAvKipcbiAgICAgKiBhZGQgYSBuZXcgb3BlbiBub2RlIHRvIHRoZSBzdHJ1Y3R1cmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSAgIG9iamVjdCBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YCB0aGF0IHJlcHJlc2VudCB0aGUgZmlyc3QgZW5kcG9pbnQgb2YgdGhlIHdpcmVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZnNjb3JlIGZTY29yZSBvZiB0aGlzIG5vZGVcbiAgICAgKi9cbiAgICBjb25zdCBhZGRPcGVuTm9kZSA9IChub2RlLCBmc2NvcmUpID0+IHtcbiAgICAgICAgb3Blbk5vZGVzLmFkZChub2RlKTtcbiAgICAgICAgLy8gZmxpcCB0aGUgZnNjb3JlLCBiZWNhdXNlIFByaW9yaXR5UXVldWUgdXNlcyBtYXggaGVhcFxuICAgICAgICBvcGVuTm9kZVF1ZXVlLmVucXVldWUobm9kZSwgMSAvIGZzY29yZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBvcGVuIG5vZGUgd2l0aCB0aGUgbG93ZXN0IGZTY29yZSBhbmQgcmVtb3ZlIGl0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWAgdGhhdCByZXByZXNlbnQgdGhlIGZpcnN0IGVuZHBvaW50IG9mIHRoZSB3aXJlXG4gICAgICovXG4gICAgY29uc3QgZ2V0T3Blbk5vZGUgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBvcGVuTm9kZVF1ZXVlLmRlcXVldWUoKTtcbiAgICAgICAgb3Blbk5vZGVzLmRlbGV0ZShub2RlKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgbGV0IGNhbWVGcm9tID0gbmV3IE1hcCgpO1xuXG4gICAgLy8gZGVmYXVsdCB2YWx1ZTogaW5maW5pdHlcbiAgICBsZXQgZ1Njb3JlID0gbmV3IE1hcFdpdGhEZWZhdWx0VmFsdWUoSW5maW5pdHkpO1xuICAgIGdTY29yZS5zZXQoc3RhcnQsIDApO1xuXG4gICAgbGV0IHN0YXJ0RlNjb3JlID0gZGlzdGFuY2VGdW5jdGlvbihzdGFydCwgZW5kKTtcblxuICAgIGFkZE9wZW5Ob2RlKHN0YXJ0LCBzdGFydEZTY29yZSk7XG5cbiAgICBvcGVuTm9kZXMuYWRkKHN0YXJ0KTtcbiAgICBvcGVuTm9kZVF1ZXVlLmVucXVldWUoc3RhcnQsIDEgLyBzdGFydEZTY29yZSk7XG5cbiAgICB3aGlsZSAob3Blbk5vZGVzLnNpemUgPiAwKSB7XG4gICAgICAgIC8vIGdldCB0aGUgdmFsdWUgZnJvbSBvcGVuTm9kZXMgdGhhdCBoYXMgdGhlIGxvd2VzdCBmU2NvcmVcbiAgICAgICAgY29uc3QgY3VycmVudE5vZGUgPSBnZXRPcGVuTm9kZSgpO1xuXG4gICAgICAgIC8vIGlmIHdlIHJlYWNoZWQgdGhlIGVuZCBwb2ludCwgcmVjb25zdHJ1Y3QgdGhlIHBhdGggYW5kIHJldHVybiBpdFxuICAgICAgICBpZiAoY3VycmVudE5vZGUueCA9PSBlbmQueCAmJiBjdXJyZW50Tm9kZS55ID09IGVuZC55KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjb25zdHJ1Y3RQYXRoKGNhbWVGcm9tLCBjdXJyZW50Tm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgdGhpcyBub2RlIHRvIHRoZSBjbG9zZWQgbm9kZXNcbiAgICAgICAgY2xvc2VkTm9kZXMuYWRkKGN1cnJlbnROb2RlKTtcblxuICAgICAgICAvLyB0aGUgZmFydGhlc3QgcG9pbnRzIGFjY2Vzc2libGUgd2l0aG91dCBhdm9pZGluZyBvYnN0YWNsZXMgaW4gZXZlcnkgZGlyZWN0aW9uXG4gICAgICAgIC8vIChidXQgbWF4IDUwIGluIGVhY2ggZGlyZWN0aW9uKVxuICAgICAgICBmb3IgKGxldCBkaXJlY3Rpb24gPSAwOyBkaXJlY3Rpb24gPCA0OyBkaXJlY3Rpb24rKykge1xuICAgICAgICAgICAgbGV0IG5ld1BvaW50ID0gbW92ZVBvaW50KGN1cnJlbnROb2RlLCBkaXJlY3Rpb24pO1xuXG4gICAgICAgICAgICBsZXQgd2lyZXNDcm9zc2VkID0gMDtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1MDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgbmV3UG9pbnQgaXMgaW4gdGhlIHNldCBvZiBub24gcm91dGFibGUgcG9pbnRzLFxuICAgICAgICAgICAgICAgIC8vIGRvbid0IGFkZCBpdCBhbmQgc3RvcCBwcm9jZWVkaW5nIGluIHRoaXMgZGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHNldEhhc1RoaXNQb2ludChub25Sb3V0YWJsZSwgbmV3UG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgbm90IHRoZSBlbmQgcG9pbnQsIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdQb2ludC54ICE9PSBlbmQueCB8fCBuZXdQb2ludC55ICE9PSBlbmQueSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBza2lwIHRoaXMgbm9kZSwgaWYgaXQgaGFzIGJlZW4gYWxyZWFkeSBjbG9zZWRcbiAgICAgICAgICAgICAgICAvLyBvciBpZiBpdCBpcyBvbiB0aGUgbGlzdCBvZiBub24gcm91dGFibGUgbm9kZXNcbiAgICAgICAgICAgICAgICBpZiAoY2xvc2VkTm9kZXMuaGFzKG5ld1BvaW50KSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgcG9zc2libGUgR1Njb3JlIGJ5IGFwcGx5aW5nIGEgcHVuaXNobWVudCBmb3IgZWFjaCBub2RlIChcImJlbmRcIikgaW4gdGhlIHBhdGhcbiAgICAgICAgICAgICAgICBsZXQgbmV3R1Njb3JlID0gd2lyZUJlbmRQdW5pc2htZW50ICsgZ1Njb3JlLmdldFdpdGhEZWZhdWx0KGN1cnJlbnROb2RlKTtcblxuICAgICAgICAgICAgICAgIGlmIChzZXRIYXNUaGlzUG9pbnQocHVuaXNoZWRCdXRSb3V0YWJsZSwgbmV3UG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBub2RlIGlzIGluIHRoZSBzZXQgb2YgcHVuaXNoZWQgbm9kZXMsIGFwcGx5IHRoZSBwdW5pc2htZW50XG4gICAgICAgICAgICAgICAgICAgIHdpcmVzQ3Jvc3NlZCsrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGFwcGx5IHRoZSBwdW5pc2htZW50IGZvciBlYWNoIHdpcmUgY3Jvc3NlZCBpbiB0aGlzIGRpcmVjdGlvblxuICAgICAgICAgICAgICAgIC8vIG5vdGU6IHdlIGFyZSBjb3VudGluZyB0aGUgd2lyZXMgY3Jvc3NlZCB3aGVuIGV4cG9ydGluZyB0aGlzIGRpcmVjdGlvbiwgbm90IHRoZSB3aXJlc1xuICAgICAgICAgICAgICAgIC8vIGNyb3NzZWQgaW4gdGhlIGZpbmFsIHBhdGgsIHRoZXJlIHdpbGwgYmUgcHJvYmFibHkgb25seSBhdCBtb3N0IG9mIHRoZXNlIG5vZGVzIGluIHRoZVxuICAgICAgICAgICAgICAgIC8vIGZpbmFsIHBhdGgsIG5vdCBtdWx0aXBsZVxuICAgICAgICAgICAgICAgIG5ld0dTY29yZSArPSB3aXJlc0Nyb3NzZWQgKiB3aXJlQ3Jvc3NQdW5pc2htZW50O1xuXG4gICAgICAgICAgICAgICAgLy8gc2tpcCB0aGlzIG5vZGUgaWYgaXQgaGFzIHdvcnN0IGVzdGltYWdlIGdzY29yZSB0aGFuIGluIHRoZSBnc2NvcmUgdGFibGVcbiAgICAgICAgICAgICAgICBpZiAobmV3R1Njb3JlID49IGdTY29yZS5nZXRXaXRoRGVmYXVsdChuZXdQb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2FtZUZyb20uc2V0KG5ld1BvaW50LCBjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgZ1Njb3JlLnNldChuZXdQb2ludCwgbmV3R1Njb3JlKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0ZTY29yZSA9IG5ld0dTY29yZSArIGRpc3RhbmNlRnVuY3Rpb24obmV3UG9pbnQsIGVuZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW9wZW5Ob2Rlcy5oYXMobmV3UG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgcG9pbnQgdG8gdGhlIGxpc3Qgb2YgcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgIGFkZE9wZW5Ob2RlKG5ld1BvaW50LCBuZXdGU2NvcmUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG1vdmUgdG8gdGhlIG5leHQgcG9pbnQgaW4gdGhlIGRpcmVjaXRvblxuICAgICAgICAgICAgICAgIG5ld1BvaW50ID0gbW92ZVBvaW50KG5ld1BvaW50LCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wZW5Ob2Rlcy5zaXplID4gbWF4Tm9kZUxpbWl0KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgYVN0YXI6IE51bWJlciBvZiBvcGVuIG5vZGVzICgke29wZW5Ob2Rlcy5zaXplfSkgZXhjZWVkZWQgdGhlIGxpbWl0IGZvciBvcGVuIG5vZGVzICgke21heE5vZGVMaW1pdH0pLmApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiB3ZSBnb3QgaGVyZSwgdGhlIHBhdGggd2FzIG5vdCBmb3VuZFxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiByZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3BlY2lmaWVkIHNldCBvZiBwb2ludHMgY29udGFpbnMgdGhlIHNwZWNpZmllZCBwb2ludCAoYW5kIHJldHVybnMgYGZhbHNlYCBvdGhlcndpc2UpXG4gKiBAcGFyYW0ge1NldH0gc2V0IHNldCBvZiBwb2ludHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludCBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWBcbiAqL1xuZnVuY3Rpb24gc2V0SGFzVGhpc1BvaW50KHNldCwgcG9pbnQpIHtcbiAgICBmb3IgKGxldCBpdGVtIG9mIHNldCkge1xuICAgICAgICBpZiAoaXRlbS54ID09PSBwb2ludC54ICYmIGl0ZW0ueSA9PT0gcG9pbnQueSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IG1vdmVzIHRoZSBwYXNzZWQgcG9pbnQgaW4gdGhlIHNwZWNpZmllZCBkaXJlY3Rpb24uIEl0IHNpbXBseSBhZGRzIG9yIHN1YnRyYWN0cyAxIGZyb20gb25lIG9mIHRoZSBjb29yZGluYXRlcyBkZXBlbmRpbmcgb24gdGhlIGRpcmVjdGlvbiBhdHRyaWJ1dGUuXG4gKiBAcGFyYW0gIHtPYmplY3R9IHBvaW50ICAgICBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWBcbiAqIEBwYXJhbSAge251bWJlcn0gZGlyZWN0aW9uIGRpcmVjdGlvbnM6XG4gKiAgICAgLSAwOiB1cFxuICogICAgIC0gMTogcmlnaHRcbiAqICAgICAtIDI6IGRvd25cbiAqICAgICAtIDM6IGxlZnRcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgIG9iamVjdCBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YFxuICovXG5mdW5jdGlvbiBtb3ZlUG9pbnQocG9pbnQsIGRpcmVjdGlvbikge1xuICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgIGNhc2UgMDogLy8gdXBcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogcG9pbnQueCxcbiAgICAgICAgICAgICAgICB5OiBwb2ludC55IC0gMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAxOiAvLyByaWdodFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBwb2ludC54ICsgMSxcbiAgICAgICAgICAgICAgICB5OiBwb2ludC55XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDI6IC8vIGRvd25cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogcG9pbnQueCxcbiAgICAgICAgICAgICAgICB5OiBwb2ludC55ICsgMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAzOiAvLyBsZWZ0XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IHBvaW50LnggLSAxLFxuICAgICAgICAgICAgICAgIHk6IHBvaW50LnlcbiAgICAgICAgICAgIH07XG4gICAgfVxufVxuXG4vKipcbiAqIGhlbHBlciBiYWNrdHJhY2tpbmcgZnVuY3Rpb24gdXNlZCBieSB0aGUgYVN0YXIgYWxnb3JpdGhtIHRvIGNvbnN0cnVjdCB0aGUgZmluYWwgcGF0aFxuICogQHBhcmFtICB7T2JqZWN0fSBjYW1lRnJvbSAgICBvYmplY3QgY29udGFpbmluZyBudW1lcmljIGF0dHJpYnV0ZXMgYHhgIGFuZCBgeWBcbiAqIEBwYXJhbSAge09iamVjdH0gY3VycmVudE5vZGUgb2JqZWN0IGNvbnRhaW5pbmcgbnVtZXJpYyBhdHRyaWJ1dGVzIGB4YCBhbmQgYHlgXG4gKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIG51bWVyaWMgYXR0cmlidXRlcyBgeGAgYW5kIGB5YFxuICovXG5mdW5jdGlvbiByZWNvbnN0cnVjdFBhdGgoY2FtZUZyb20sIGN1cnJlbnROb2RlKSB7XG4gICAgbGV0IHBhdGggPSBbXTtcblxuICAgIHBhdGgucHVzaCh7XG4gICAgICAgIHg6IGN1cnJlbnROb2RlLngsXG4gICAgICAgIHk6IGN1cnJlbnROb2RlLnlcbiAgICB9KVxuXG4gICAgd2hpbGUgKGNhbWVGcm9tLmhhcyhjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgY3VycmVudE5vZGUgPSBjYW1lRnJvbS5nZXQoY3VycmVudE5vZGUpO1xuICAgICAgICBwYXRoLnB1c2goe1xuICAgICAgICAgICAgeDogY3VycmVudE5vZGUueCxcbiAgICAgICAgICAgIHk6IGN1cnJlbnROb2RlLnlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aDtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIEBtb2R1bGUgSGVscGVyRnVuY3Rpb25zXG4gKi9cblxuaW1wb3J0IHN0cmluZ2lmeSBmcm9tIFwianNvbi1zdHJpbmdpZnktcHJldHR5LWNvbXBhY3RcIjsgLy8gbm90ZTogaW1wb3J0ZWQgZnJvbSBhIG1vZHVsZVxuXG4vKipcbiAqIGFkZCBhIGNyb3NzIGJyb3dzZXIgZXZlbnQgbGlzdGVuZXIgb24gYSBtb3VzZSBzY3JvbGxcbiAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSBET00gcXVlcnkgb2YgdGhlIGVsZW1lbnQgdGhhdCB0aGUgbGlzdGVuZXIgd2lsbCBiZSBhZGRlZCB0b1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAgRnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBldmVudCBvY2N1cnMuIFRoZSBmdW5jdGlvbiB0YWtlcyBhcyBhIHBhcmFtZXRlciBhbiBldmVudCBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRNb3VzZVNjcm9sbEV2ZW50TGlzdGVuZXIocXVlcnksIGZ1bmMpIHtcbiAgICBsZXQgTW91c2VXaGVlbEhhbmRsZXIgPSBldmVudCA9PiB7XG4gICAgICAgIC8vIHJlZGVjbGFyZSBmb3Igb2xkIElFIHN1cHBvcnRcbiAgICAgICAgdmFyIGV2ZW50ID0gd2luZG93LmV2ZW50IHx8IGV2ZW50OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlZGVjbGFyZVxuXG4gICAgICAgIGV2ZW50LmRlbHRhID0gTWF0aC5tYXgoLTEsIE1hdGgubWluKDEsIChldmVudC53aGVlbERlbHRhIHx8IC1ldmVudC5kZXRhaWwpKSk7XG5cbiAgICAgICAgZnVuYyhldmVudClcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHN2Z2VsZW1lbnQ7XG5cbiAgICAvLyBpZiB0aGUgcXVlcnkgaXMgYSBzaW1wbGUgRE9NIGlkIHNlbGVjdG9yLCB3ZSBjYW4gdXNlIGdldEVsZW1lbnRCeUlkIHdoaWNoIGhhcyBiZXR0ZXIgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICBpZihxdWVyeS5tYXRjaCgvXiNcXHcrJC8pKSB7XG4gICAgICAgIHN2Z2VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChxdWVyeS5zdWJzdHIoMSkpXG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3ZnZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocXVlcnkpXG4gICAgfVxuXG4gICAgaWYgKHN2Z2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAvLyBJRTksIENocm9tZSwgU2FmYXJpLCBPcGVyYVxuICAgICAgICBzdmdlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXdoZWVsXCIsIE1vdXNlV2hlZWxIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIC8vIEZpcmVmb3hcbiAgICAgICAgc3ZnZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NTW91c2VTY3JvbGxcIiwgTW91c2VXaGVlbEhhbmRsZXIsIGZhbHNlKTtcbiAgICB9IGVsc2UgIHtcbiAgICAgICAgLy8gSUUgNi83LzhcbiAgICAgICAgc3ZnZWxlbWVudC5hdHRhY2hFdmVudChcIm9ubW91c2V3aGVlbFwiLCBNb3VzZVdoZWVsSGFuZGxlcik7XG4gICAgfVxuICAgIHN2Z2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ2V2ZW50JywgZSlcbiAgICB9LCBmYWxzZSlcbn1cblxuLyoqXG4gKiBjb252ZXJ0IGEgZGF0YSBvYmplY3QgdG8gSlNPTiBzdHJpbmcgb3IgdG8gYSBkYXRhIFVSSSBjb250YWluaW5nIGEgSlNPTiBzdHJpbmdcbiAqIEBwYXJhbSAge09iamVjdH0gIGRhdGEgICAgICAgICAgICBvYmplY3QgdGhhdCB3aWxsIGJlIHNlcmlhbGl6ZWQgaW50byBhIEpTT04gc3RyaW5nXG4gKiBAcGFyYW0gIHtCb29sZWFufSBbcHJldHR5PWZhbHNlXSAgaWYgYHRydWVgLCB0aGUgY29kZSB3aWxsIGJlIHByb3ByZXJseSBpbmRlbnRlZCwgZWxzZSBhIG1vcmUgY29tcGFjdCBzeW50YXggd2lsbCBiZSB1c2VkXG4gKiBAcGFyYW0gIHtCb29sZWFufSBbZGF0YVVyaT1mYWxzZV0gcmV0dXJuIGRhdGFVcmkgY29udGFpbmluZyB0aGUgSlNPTiBzdHJpbmcgaW5zdGVhZCBvZiB0aGUgcHVyZSBKU09OIHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SlNPTlN0cmluZyhkYXRhLCBwcmV0dHkgPSBmYWxzZSwgZGF0YVVyaSA9IGZhbHNlKSB7XG4gICAgaWYoZGF0YVVyaSkge1xuICAgICAgICByZXR1cm4gJ2RhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04LCdcbiAgICAgICAgICAgICsgZW5jb2RlVVJJQ29tcG9uZW50KGdldEpTT05TdHJpbmcoZGF0YSwgcHJldHR5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoIChwcmV0dHkpIHtcbiAgICAgICAgICAgIGNhc2UgdHJ1ZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5KGRhdGEsIHttYXhMZW5ndGg6IDUwfSk7XG4gICAgICAgICAgICBjYXNlIGZhbHNlOlxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiByZXR1cm5zIHRoZSBNYW5oYXR0YW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgcG9pbnRzIF9hXyBhbmQgX2JfXG4gKiBAcGFyYW0gIHtPYmplY3R9IGEgb2JqZWN0IGNvbnRhaW5pbmcgbnVtZXJpYyBhdHRyaWJ1dGVzIGB4YCBhbmQgYHlgXG4gKiBAcGFyYW0gIHtPYmplY3R9IGIgb2JqZWN0IGNvbnRhaW5pbmcgbnVtZXJpYyBhdHRyaWJ1dGVzIGB4YCBhbmQgYHlgXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYW5oYXR0YW5EaXN0YW5jZShhLCBiKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKGEueCAtIGIueCkgKyBNYXRoLmFicyhhLnkgLSBiLnkpO1xufVxuIiwiLyoqIEBtb2R1bGUgTWFwV2l0aERlZmF1bHRWYWx1ZSAqL1xuLyoqXG4gKiBNYXAgdGhhdCBoYXMgYSBkZWZhdWx0IHZhbHVlIHNwZWNpZmllZCBpbiB0aGUgY29uc3RydWN0b3IuXG4gKlxuICogRm9yIHRoZSBjb21wbGV0ZSBkb2N1bWVudGF0aW9uIG9mIHRoZSBNYXAgc2VlIFtNYXAgaW4gdGhlIE1ETiB3ZWIgZG9jc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWFwKVxuICpcbiAqIFVzYWdlOlxuICogYGBgSmF2YVNjcmlwdFxuIGxldCBteU1hcCA9IG5ldyBNYXBXaXRoRGVmYXVsdFZhbHVlKEluZmluaXR5KTtcbiBjb25zdCB2YWx1ZSA9IG15TWFwLmdldFdpdGhEZWZhdWx0KGtleSlcbiBgYGBcbiAqXG4gKiBfTm90ZTogVGhpcyB2ZXJzaW9uIGlzIHdyaXR0ZW4gc3BlY2lhbGx5IGZvciBFUzYgY29tcGlsZWQgaW50byBFUzUuIEluIG5vbi1jb21waWxlZCBFUzYgaXMgdGhlIGltcGxlbWVudGF0aW9uIGZhciBtb3JlIGVsZWdhbnQ6X1xuICpcbiAqIGBgYEphdmFTY3JpcHRcbiBleHBvcnQgY2xhc3MgTWFwV2l0aERlZmF1bHRWYWx1ZSBleHRlbmRzIE1hcCB7XG4gICAgIGNvbnN0cnVjdG9yKGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAgdGhpcy5kZWZhdWx0ID0gZGVmYXVsdFZhbHVlO1xuICAgICB9XG5cbiAgICAgZ2V0KGtleSkge1xuICAgICAgICAgaWYodGhpcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgIHJldHVybiBzdXBlci5nZXQoa2V5KTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdDtcbiAgICAgICAgIH1cbiAgICAgfVxuIH1gYGBcbiAqIEBjbGFzcyBNYXBXaXRoRGVmYXVsdFZhbHVlXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIHthbnl9IGRlZmF1bHQgdmFsdWUgdGhhdCB3aWxsIGJlIHJldHVybmVkIHdoZW4gdGhlIHJlcXVlc3RlZCBrZXkgaXMgbm90IGZvdW5kIGluIHRoZSBtYXBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZGVmYXVsdFZhbHVlKSB7XG4gICAgbGV0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHthbnl9IGtleSBrZXkgb2YgYSByZXF1ZXN0ZWQgaXRlbVxuICAgICAqIEByZXR1cm4ge2FueX0gdmFsdWUgb2YgdGhlIGl0ZW0gd2l0aCB0aGUgY29ycmVzcG9uZGluZyBrZXksIG9yIGRlZmF1bHRWYWx1ZSBpZiB0aGUga2V5IGlzIG5vdCBmb3VuZCBpbiB0aGUgbWFwXG4gICAgICovXG4gICAgbWFwLmdldFdpdGhEZWZhdWx0ID0gKGtleSkgPT4ge1xuICAgICAgICByZXR1cm4gbWFwLmhhcyhrZXkpXG4gICAgICAgICAgICA/IG1hcC5nZXQoa2V5KVxuICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG59XG4iLCIvKiogQG1vZHVsZSByb3V0ZVdvcmtlciAqL1xuXG5pbXBvcnQgZmluZFBhdGggZnJvbSAnLi9maW5kUGF0aCdcblxuLyoqXG4gKiBjYWxsYmFjayB3aGVuIGEgbWVzc2FnZSBpcyBzZW50IHRvIHRoZSB3ZWIgd29ya2VyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IHdlYiB3b3JrZXIgZXZlbnQgb2JqZWN0ICh0aGUgYGRhdGFgIGl0ZW0gb2YgdGhlIGV2ZW50IG9iamVjdCBpcyBleHBlY3RlZCB0byBjb250YWluXG4gKiAgICAgICAgICAgICAgICAgICAgICAgdGhlc2UgaXRlbXM6IGB3aXJlc2AgKGFycmF5KSwgYG5vblJvdXRhYmxlTm9kZXNgIChpdGVyYWJsZSkgYW5kIGBpbmNvbnZlbmllbnROb2Rlc2AgKGl0ZXJhYmxlKSlcbiAqL1xub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgY29uc3Qge3dpcmVzLCBub25Sb3V0YWJsZU5vZGVzLCBpbmNvbnZlbmllbnROb2Rlc30gPSBldmVudC5kYXRhO1xuXG4gICAgY29uc3QgcGF0aHMgPSBmaW5kUGF0aHMod2lyZXMsIG5vblJvdXRhYmxlTm9kZXMsIGluY29udmVuaWVudE5vZGVzKTtcblxuICAgIHBvc3RNZXNzYWdlKHtwYXRoc30pO1xuICAgIGNsb3NlKCk7XG59XG5cbi8qKlxuICogZmluZCBwYXRocyBmb3IgYWxsIHRoZSBzcGVjaWZpZWQgd2lyZXNcbiAqIEBwYXJhbSAge0FycmF5fSB3aXJlcyAgICAgICAgICAgICAgYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIGF0dHJpYnV0ZXMgYGZyb21gIGFuZCBgdG9gLCBib3RoIG9mIHRoZW0gd2hpY2ggYXJlIG9iamVjdHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCB2YWx1ZXMgYHhgIGFuZCBgeWAgY29udGFpbmluZyBjb29yZGluYXRlcyBvZiB0aGUgd2lyZSBlbmRwb2ludHNcbiAqIEBwYXJhbSAge0l0ZXJhYmxlfSBub25Sb3V0YWJsZU5vZGVzICBTZXQgb3IgYXJyYXkgb2Ygbm9uIHJvdXRhYmxlIG5vZGVzXG4gKiBAcGFyYW0gIHtJdGVyYWJsZX0gaW5jb252ZW5pZW50Tm9kZXMgU2V0IG9yIGFycmF5IG9mIGluY29udmVuaWVudCBub2Rlc1xuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgICAgICAgICBhcnJheSBvZiBwYXRocywgZWFjaCBpdGVtIGlzIGFuIGFycmF5IG9mIHBvaW50cyBvZiB0aGUgcGF0aFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgcmV0dXJuZWQgYXJyYXkgY29udGFpbnMgcGF0aHMgZm9yIHRoZSB3aXJlcyB3aXRoIGNvcnJlc3BvbmRpbmcgaW5kZXhlcyBmcm9tIHRoZSBgd2lyZXNgIHBhcmFtZXRlclxuICovXG5mdW5jdGlvbiBmaW5kUGF0aHMod2lyZXMsIG5vblJvdXRhYmxlTm9kZXMsIGluY29udmVuaWVudE5vZGVzKSB7XG4gICAgbGV0IHBhdGhzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IFtmcm9tLCB0b10gb2Ygd2lyZXMpIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IGZpbmRQYXRoKGZyb20sIHRvLCBub25Sb3V0YWJsZU5vZGVzLCBpbmNvbnZlbmllbnROb2RlcylcblxuICAgICAgICBwYXRocy5wdXNoKHBhdGgpO1xuXG4gICAgICAgIC8vIGFkZCBuZXcgaW5jb252ZW5pZW50IG5vZGVzIGNyZWF0ZWQgYnkgdGhpcyBuZXcgcGF0aFxuICAgICAgICBsZXQgcHJldlBvaW50O1xuICAgICAgICBmb3IoY29uc3QgcG9pbnQgb2YgcGF0aCkge1xuICAgICAgICAgICAgaWYocHJldlBvaW50KSB7XG4gICAgICAgICAgICAgICAgaWYocG9pbnQueCA9PT0gcHJldlBvaW50LngpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaG9yaXpvbnRhbCBzZWN0aW9uIG9mIHRoZSBwYXRoXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgeSA9IE1hdGgubWluKHBvaW50LnksIHByZXZQb2ludC55KTsgeSA8PSBNYXRoLm1heChwb2ludC55LCBwcmV2UG9pbnQueSkgOyArK3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY29udmVuaWVudE5vZGVzLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogcG9pbnQueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKHBvaW50LnkgPT09IHByZXZQb2ludC55KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZlcnRpY2FsIHNlY3Rpb24gb2YgdGhlIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCB4ID0gTWF0aC5taW4ocG9pbnQueCwgcHJldlBvaW50LngpOyB4IDw9IE1hdGgubWF4KHBvaW50LngsIHByZXZQb2ludC54KSA7ICsreCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5jb252ZW5pZW50Tm9kZXMuYWRkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHBvaW50LnlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXZQb2ludCA9IHBvaW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhzO1xufVxuIl19"}